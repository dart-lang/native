// Test preamble text

import Foundation

@objc public class AlignmentOptionsWrapper: NSObject {
  var wrappedInstance: AlignmentOptions

  @objc static public var alignAllEdgesInward: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignAllEdgesInward)
    }
  }

  @objc static public var alignAllEdgesNearest: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignAllEdgesNearest)
    }
  }

  @objc static public var alignAllEdgesOutward: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignAllEdgesOutward)
    }
  }

  @objc static public var alignHeightInward: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignHeightInward)
    }
  }

  @objc static public var alignHeightNearest: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignHeightNearest)
    }
  }

  @objc static public var alignHeightOutward: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignHeightOutward)
    }
  }

  @objc static public var alignMaxXInward: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignMaxXInward)
    }
  }

  @objc static public var alignMaxXNearest: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignMaxXNearest)
    }
  }

  @objc static public var alignMaxXOutward: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignMaxXOutward)
    }
  }

  @objc static public var alignMaxYInward: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignMaxYInward)
    }
  }

  @objc static public var alignMaxYNearest: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignMaxYNearest)
    }
  }

  @objc static public var alignMaxYOutward: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignMaxYOutward)
    }
  }

  @objc static public var alignMinXInward: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignMinXInward)
    }
  }

  @objc static public var alignMinXNearest: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignMinXNearest)
    }
  }

  @objc static public var alignMinXOutward: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignMinXOutward)
    }
  }

  @objc static public var alignMinYInward: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignMinYInward)
    }
  }

  @objc static public var alignMinYNearest: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignMinYNearest)
    }
  }

  @objc static public var alignMinYOutward: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignMinYOutward)
    }
  }

  @objc static public var alignRectFlipped: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignRectFlipped)
    }
  }

  @objc static public var alignWidthInward: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignWidthInward)
    }
  }

  @objc static public var alignWidthNearest: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignWidthNearest)
    }
  }

  @objc static public var alignWidthOutward: AlignmentOptionsWrapper {
    get {
      AlignmentOptionsWrapper(AlignmentOptions.alignWidthOutward)
    }
  }

  @objc public var isEmpty: Bool {
    get {
      wrappedInstance.isEmpty
    }
  }

  init(_ wrappedInstance: AlignmentOptions) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = AlignmentOptions()
  }

}

@objc public class NSBinarySearchingOptionsWrapper: NSObject {
  var wrappedInstance: NSBinarySearchingOptions

  @objc static public var firstEqual: NSBinarySearchingOptionsWrapper {
    get {
      NSBinarySearchingOptionsWrapper(NSBinarySearchingOptions.firstEqual)
    }
  }

  @objc static public var insertionIndex: NSBinarySearchingOptionsWrapper {
    get {
      NSBinarySearchingOptionsWrapper(NSBinarySearchingOptions.insertionIndex)
    }
  }

  @objc static public var lastEqual: NSBinarySearchingOptionsWrapper {
    get {
      NSBinarySearchingOptionsWrapper(NSBinarySearchingOptions.lastEqual)
    }
  }

  @objc public var isEmpty: Bool {
    get {
      wrappedInstance.isEmpty
    }
  }

  init(_ wrappedInstance: NSBinarySearchingOptions) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSBinarySearchingOptions()
  }

}

@objc public class NSEnumerationOptionsWrapper: NSObject {
  var wrappedInstance: NSEnumerationOptions

  @objc static public var concurrent: NSEnumerationOptionsWrapper {
    get {
      NSEnumerationOptionsWrapper(NSEnumerationOptions.concurrent)
    }
  }

  @objc static public var reverse: NSEnumerationOptionsWrapper {
    get {
      NSEnumerationOptionsWrapper(NSEnumerationOptions.reverse)
    }
  }

  @objc public var isEmpty: Bool {
    get {
      wrappedInstance.isEmpty
    }
  }

  init(_ wrappedInstance: NSEnumerationOptions) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSEnumerationOptions()
  }

}

@available(macOS, introduced: 12.0)
@objc public class InlinePresentationIntentWrapper: NSObject {
  var wrappedInstance: InlinePresentationIntent

  @available(macOS, introduced: 12.0)
  @objc static public var blockHTML: InlinePresentationIntentWrapper {
    get {
      InlinePresentationIntentWrapper(InlinePresentationIntent.blockHTML)
    }
  }

  @available(macOS, introduced: 12.0)
  @objc static public var code: InlinePresentationIntentWrapper {
    get {
      InlinePresentationIntentWrapper(InlinePresentationIntent.code)
    }
  }

  @available(macOS, introduced: 12.0)
  @objc static public var emphasized: InlinePresentationIntentWrapper {
    get {
      InlinePresentationIntentWrapper(InlinePresentationIntent.emphasized)
    }
  }

  @available(macOS, introduced: 12.0)
  @objc static public var inlineHTML: InlinePresentationIntentWrapper {
    get {
      InlinePresentationIntentWrapper(InlinePresentationIntent.inlineHTML)
    }
  }

  @available(macOS, introduced: 12.0)
  @objc static public var lineBreak: InlinePresentationIntentWrapper {
    get {
      InlinePresentationIntentWrapper(InlinePresentationIntent.lineBreak)
    }
  }

  @available(macOS, introduced: 12.0)
  @objc static public var softBreak: InlinePresentationIntentWrapper {
    get {
      InlinePresentationIntentWrapper(InlinePresentationIntent.softBreak)
    }
  }

  @available(macOS, introduced: 12.0)
  @objc static public var strikethrough: InlinePresentationIntentWrapper {
    get {
      InlinePresentationIntentWrapper(InlinePresentationIntent.strikethrough)
    }
  }

  @available(macOS, introduced: 12.0)
  @objc static public var stronglyEmphasized: InlinePresentationIntentWrapper {
    get {
      InlinePresentationIntentWrapper(InlinePresentationIntent.stronglyEmphasized)
    }
  }

  @objc public var isEmpty: Bool {
    get {
      wrappedInstance.isEmpty
    }
  }

  init(_ wrappedInstance: InlinePresentationIntent) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = InlinePresentationIntent()
  }

}

@available(macOS, introduced: 10.13)
@objc public class NSItemProviderFileOptionsWrapper: NSObject {
  var wrappedInstance: NSItemProviderFileOptions

  @available(macOS, introduced: 10.13)
  @objc static public var openInPlace: NSItemProviderFileOptionsWrapper {
    get {
      NSItemProviderFileOptionsWrapper(NSItemProviderFileOptions.openInPlace)
    }
  }

  @objc public var isEmpty: Bool {
    get {
      wrappedInstance.isEmpty
    }
  }

  init(_ wrappedInstance: NSItemProviderFileOptions) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.13)
  @objc init(rawValue: Int) {
    wrappedInstance = NSItemProviderFileOptions(rawValue: rawValue)
  }

  @objc override init() {
    wrappedInstance = NSItemProviderFileOptions()
  }

}

@objc public class NSKeyValueObservingOptionsWrapper: NSObject {
  var wrappedInstance: NSKeyValueObservingOptions

  @available(macOS, introduced: 10.5)
  @objc static public var initial: NSKeyValueObservingOptionsWrapper {
    get {
      NSKeyValueObservingOptionsWrapper(NSKeyValueObservingOptions.initial)
    }
  }

  @objc static public var new: NSKeyValueObservingOptionsWrapper {
    get {
      NSKeyValueObservingOptionsWrapper(NSKeyValueObservingOptions.new)
    }
  }

  @objc static public var old: NSKeyValueObservingOptionsWrapper {
    get {
      NSKeyValueObservingOptionsWrapper(NSKeyValueObservingOptions.old)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var prior: NSKeyValueObservingOptionsWrapper {
    get {
      NSKeyValueObservingOptionsWrapper(NSKeyValueObservingOptions.prior)
    }
  }

  @objc public var isEmpty: Bool {
    get {
      wrappedInstance.isEmpty
    }
  }

  init(_ wrappedInstance: NSKeyValueObservingOptions) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSKeyValueObservingOptions()
  }

}

@available(macOS, introduced: 10.15)
@objc public class NSOrderedCollectionDifferenceCalculationOptionsWrapper: NSObject {
  var wrappedInstance: NSOrderedCollectionDifferenceCalculationOptions

  @available(macOS, introduced: 10.15)
  @objc static public var inferMoves: NSOrderedCollectionDifferenceCalculationOptionsWrapper {
    get {
      NSOrderedCollectionDifferenceCalculationOptionsWrapper(NSOrderedCollectionDifferenceCalculationOptions.inferMoves)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var omitInsertedObjects: NSOrderedCollectionDifferenceCalculationOptionsWrapper {
    get {
      NSOrderedCollectionDifferenceCalculationOptionsWrapper(NSOrderedCollectionDifferenceCalculationOptions.omitInsertedObjects)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var omitRemovedObjects: NSOrderedCollectionDifferenceCalculationOptionsWrapper {
    get {
      NSOrderedCollectionDifferenceCalculationOptionsWrapper(NSOrderedCollectionDifferenceCalculationOptions.omitRemovedObjects)
    }
  }

  @objc public var isEmpty: Bool {
    get {
      wrappedInstance.isEmpty
    }
  }

  init(_ wrappedInstance: NSOrderedCollectionDifferenceCalculationOptions) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSOrderedCollectionDifferenceCalculationOptions()
  }

}

@objc public class NSSortOptionsWrapper: NSObject {
  var wrappedInstance: NSSortOptions

  @objc static public var concurrent: NSSortOptionsWrapper {
    get {
      NSSortOptionsWrapper(NSSortOptions.concurrent)
    }
  }

  @objc static public var stable: NSSortOptionsWrapper {
    get {
      NSSortOptionsWrapper(NSSortOptions.stable)
    }
  }

  @objc public var isEmpty: Bool {
    get {
      wrappedInstance.isEmpty
    }
  }

  init(_ wrappedInstance: NSSortOptions) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSSortOptions()
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class NSKeyValueObservationWrapper: NSObject {
  var wrappedInstance: NSKeyValueObservation

  init(_ wrappedInstance: NSKeyValueObservation) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSEdgeInsetsWrapper: NSObject {
  var wrappedInstance: NSEdgeInsets

  @objc public var bottom: Double {
    get {
      wrappedInstance.bottom
    }
    set {
      wrappedInstance.bottom = newValue
    }
  }

  @objc public var left: Double {
    get {
      wrappedInstance.left
    }
    set {
      wrappedInstance.left = newValue
    }
  }

  @objc public var right: Double {
    get {
      wrappedInstance.right
    }
    set {
      wrappedInstance.right = newValue
    }
  }

  @objc public var top: Double {
    get {
      wrappedInstance.top
    }
    set {
      wrappedInstance.top = newValue
    }
  }

  init(_ wrappedInstance: NSEdgeInsets) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(top: Double, left: Double, bottom: Double, right: Double) {
    wrappedInstance = NSEdgeInsets(top: top, left: left, bottom: bottom, right: right)
  }

  @objc override init() {
    wrappedInstance = NSEdgeInsets()
  }

}

@objc public class NSAffineTransformStructWrapper: NSObject {
  var wrappedInstance: NSAffineTransformStruct

  @objc public var m11: Double {
    get {
      wrappedInstance.m11
    }
    set {
      wrappedInstance.m11 = newValue
    }
  }

  @objc public var m12: Double {
    get {
      wrappedInstance.m12
    }
    set {
      wrappedInstance.m12 = newValue
    }
  }

  @objc public var m21: Double {
    get {
      wrappedInstance.m21
    }
    set {
      wrappedInstance.m21 = newValue
    }
  }

  @objc public var m22: Double {
    get {
      wrappedInstance.m22
    }
    set {
      wrappedInstance.m22 = newValue
    }
  }

  @objc public var tX: Double {
    get {
      wrappedInstance.tX
    }
    set {
      wrappedInstance.tX = newValue
    }
  }

  @objc public var tY: Double {
    get {
      wrappedInstance.tY
    }
    set {
      wrappedInstance.tY = newValue
    }
  }

  init(_ wrappedInstance: NSAffineTransformStruct) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(m11: Double, m12: Double, m21: Double, m22: Double, tX: Double, tY: Double) {
    wrappedInstance = NSAffineTransformStruct(m11: m11, m12: m12, m21: m21, m22: m22, tX: tX, tY: tY)
  }

  @objc override init() {
    wrappedInstance = NSAffineTransformStruct()
  }

}

@objc public class DecimalWrapper: NSObject {
  var wrappedInstance: Decimal

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isInfinite: Bool {
    get {
      wrappedInstance.isInfinite
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isCanonical: Bool {
    get {
      wrappedInstance.isCanonical
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isSignMinus: Bool {
    get {
      wrappedInstance.isSignMinus
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isSignaling: Bool {
    get {
      wrappedInstance.isSignaling
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isSubnormal: Bool {
    get {
      wrappedInstance.isSubnormal
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var significand: DecimalWrapper {
    get {
      DecimalWrapper(wrappedInstance.significand)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isSignalingNaN: Bool {
    get {
      wrappedInstance.isSignalingNaN
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var leastFiniteMagnitude: DecimalWrapper {
    get {
      DecimalWrapper(Decimal.leastFiniteMagnitude)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var leastNormalMagnitude: DecimalWrapper {
    get {
      DecimalWrapper(Decimal.leastNormalMagnitude)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var leastNonzeroMagnitude: DecimalWrapper {
    get {
      DecimalWrapper(Decimal.leastNonzeroMagnitude)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var greatestFiniteMagnitude: DecimalWrapper {
    get {
      DecimalWrapper(Decimal.greatestFiniteMagnitude)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var pi: DecimalWrapper {
    get {
      DecimalWrapper(Decimal.pi)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var nan: DecimalWrapper {
    get {
      DecimalWrapper(Decimal.nan)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var ulp: DecimalWrapper {
    get {
      DecimalWrapper(wrappedInstance.ulp)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isNaN: Bool {
    get {
      wrappedInstance.isNaN
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var radix: Int {
    get {
      Decimal.radix
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isZero: Bool {
    get {
      wrappedInstance.isZero
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var nextUp: DecimalWrapper {
    get {
      DecimalWrapper(wrappedInstance.nextUp)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var exponent: Int {
    get {
      wrappedInstance.exponent
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isFinite: Bool {
    get {
      wrappedInstance.isFinite
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isNormal: Bool {
    get {
      wrappedInstance.isNormal
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var nextDown: DecimalWrapper {
    get {
      DecimalWrapper(wrappedInstance.nextDown)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var quietNaN: DecimalWrapper {
    get {
      DecimalWrapper(Decimal.quietNaN)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var magnitude: DecimalWrapper {
    get {
      DecimalWrapper(wrappedInstance.magnitude)
    }
  }

  init(_ wrappedInstance: Decimal) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(floatLiteral value: Double) {
    wrappedInstance = Decimal(floatLiteral: value)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(integerLiteral value: Int) {
    wrappedInstance = Decimal(integerLiteral: value)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(signOf: DecimalWrapper, magnitudeOf magnitude: DecimalWrapper) {
    wrappedInstance = Decimal(signOf: signOf.wrappedInstance, magnitudeOf: magnitude.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(_ value: Double) {
    wrappedInstance = Decimal(value)
  }

  @objc override init() {
    wrappedInstance = Decimal()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func isTotallyOrdered(belowOrEqualTo other: DecimalWrapper) -> Bool {
    return wrappedInstance.isTotallyOrdered(belowOrEqualTo: other.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func isLessThanOrEqualTo(_ other: DecimalWrapper) -> Bool {
    return wrappedInstance.isLessThanOrEqualTo(other.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func isLess(than other: DecimalWrapper) -> Bool {
    return wrappedInstance.isLess(than: other.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func isEqual(to other: DecimalWrapper) -> Bool {
    return wrappedInstance.isEqual(to: other.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func advanced(by n: DecimalWrapper) -> DecimalWrapper {
    let result = wrappedInstance.advanced(by: n.wrappedInstance)
    return DecimalWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func distance(to other: DecimalWrapper) -> DecimalWrapper {
    let result = wrappedInstance.distance(to: other.wrappedInstance)
    return DecimalWrapper(result)
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func formatted() -> String {
    return wrappedInstance.formatted()
  }

  @objc public func negate() {
    return wrappedInstance.negate()
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class FormatStyleWrapper: NSObject {
    var wrappedInstance: Decimal.FormatStyle

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var number: DecimalWrapper.FormatStyleWrapper {
      get {
        FormatStyleWrapper(Decimal.FormatStyle.number)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var number: DecimalWrapper.FormatStyleWrapper {
      get {
        FormatStyleWrapper(Decimal.FormatStyle.number)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var attributed: FormatStyleWrapper.AttributedWrapper {
      get {
        AttributedWrapper(wrappedInstance.attributed)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var parseStrategy: DecimalWrapper.ParseStrategyWrapper {
      get {
        ParseStrategyWrapper(wrappedInstance.parseStrategy)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper {
      get {
        LocaleWrapper(wrappedInstance.locale)
      }
      set {
        wrappedInstance.locale = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: Decimal.FormatStyle) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func scale(_ multiplicand: Double) -> DecimalWrapper.FormatStyleWrapper {
      let result = wrappedInstance.scale(multiplicand)
      return FormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func format(_ value: DecimalWrapper) -> String {
      return wrappedInstance.format(value.wrappedInstance)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> DecimalWrapper.FormatStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return FormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class AttributedWrapper: NSObject {
      var wrappedInstance: FormatStyle.Attributed

      init(_ wrappedInstance: FormatStyle.Attributed) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func format(_ value: DecimalWrapper) -> AttributedStringWrapper {
        let result = wrappedInstance.format(value.wrappedInstance)
        return AttributedStringWrapper(result)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func locale(_ locale: LocaleWrapper) -> FormatStyleWrapper.AttributedWrapper {
        let result = wrappedInstance.locale(locale.wrappedInstance)
        return AttributedWrapper(result)
      }

    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class PercentWrapper: NSObject {
      var wrappedInstance: FormatStyle.Percent

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var percent: FormatStyleWrapper.PercentWrapper {
        get {
          PercentWrapper(FormatStyle.Percent.percent)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var percent: FormatStyleWrapper.PercentWrapper {
        get {
          PercentWrapper(FormatStyle.Percent.percent)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public var attributed: FormatStyleWrapper.AttributedWrapper {
        get {
          AttributedWrapper(wrappedInstance.attributed)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public var parseStrategy: DecimalWrapper.ParseStrategyWrapper {
        get {
          ParseStrategyWrapper(wrappedInstance.parseStrategy)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public var locale: LocaleWrapper {
        get {
          LocaleWrapper(wrappedInstance.locale)
        }
        set {
          wrappedInstance.locale = newValue.wrappedInstance
        }
      }

      init(_ wrappedInstance: FormatStyle.Percent) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func scale(_ multiplicand: Double) -> FormatStyleWrapper.PercentWrapper {
        let result = wrappedInstance.scale(multiplicand)
        return PercentWrapper(result)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func format(_ value: DecimalWrapper) -> String {
        return wrappedInstance.format(value.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func locale(_ locale: LocaleWrapper) -> FormatStyleWrapper.PercentWrapper {
        let result = wrappedInstance.locale(locale.wrappedInstance)
        return PercentWrapper(result)
      }

    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class CurrencyWrapper: NSObject {
      var wrappedInstance: FormatStyle.Currency

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public var attributed: FormatStyleWrapper.AttributedWrapper {
        get {
          AttributedWrapper(wrappedInstance.attributed)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public var currencyCode: String {
        get {
          wrappedInstance.currencyCode
        }
        set {
          wrappedInstance.currencyCode = newValue
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public var parseStrategy: DecimalWrapper.ParseStrategyWrapper {
        get {
          ParseStrategyWrapper(wrappedInstance.parseStrategy)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public var locale: LocaleWrapper {
        get {
          LocaleWrapper(wrappedInstance.locale)
        }
        set {
          wrappedInstance.locale = newValue.wrappedInstance
        }
      }

      init(_ wrappedInstance: FormatStyle.Currency) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func scale(_ multiplicand: Double) -> FormatStyleWrapper.CurrencyWrapper {
        let result = wrappedInstance.scale(multiplicand)
        return CurrencyWrapper(result)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func format(_ value: DecimalWrapper) -> String {
        return wrappedInstance.format(value.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func locale(_ locale: LocaleWrapper) -> FormatStyleWrapper.CurrencyWrapper {
        let result = wrappedInstance.locale(locale.wrappedInstance)
        return CurrencyWrapper(result)
      }

    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class ParseStrategyWrapper: NSObject {
    var wrappedInstance: Decimal.ParseStrategy

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var lenient: Bool {
      get {
        wrappedInstance.lenient
      }
      set {
        wrappedInstance.lenient = newValue
      }
    }

    init(_ wrappedInstance: Decimal.ParseStrategy) {
      self.wrappedInstance = wrappedInstance
    }

  }

}

@objc public class NSFastEnumerationStateWrapper: NSObject {
  var wrappedInstance: NSFastEnumerationState

  init(_ wrappedInstance: NSFastEnumerationState) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSFastEnumerationState()
  }

}

@objc public class NSHashEnumeratorWrapper: NSObject {
  var wrappedInstance: NSHashEnumerator

  init(_ wrappedInstance: NSHashEnumerator) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSHashEnumerator()
  }

}

@objc public class NSHashTableCallBacksWrapper: NSObject {
  var wrappedInstance: NSHashTableCallBacks

  init(_ wrappedInstance: NSHashTableCallBacks) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSHashTableCallBacks()
  }

}

@objc public class NSMapEnumeratorWrapper: NSObject {
  var wrappedInstance: NSMapEnumerator

  init(_ wrappedInstance: NSMapEnumerator) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSMapEnumerator()
  }

}

@objc public class NSMapTableKeyCallBacksWrapper: NSObject {
  var wrappedInstance: NSMapTableKeyCallBacks

  init(_ wrappedInstance: NSMapTableKeyCallBacks) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSMapTableKeyCallBacks()
  }

}

@objc public class NSMapTableValueCallBacksWrapper: NSObject {
  var wrappedInstance: NSMapTableValueCallBacks

  init(_ wrappedInstance: NSMapTableValueCallBacks) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSMapTableValueCallBacks()
  }

}

@objc public class OperatingSystemVersionWrapper: NSObject {
  var wrappedInstance: OperatingSystemVersion

  @objc public var majorVersion: Int {
    get {
      wrappedInstance.majorVersion
    }
    set {
      wrappedInstance.majorVersion = newValue
    }
  }

  @objc public var minorVersion: Int {
    get {
      wrappedInstance.minorVersion
    }
    set {
      wrappedInstance.minorVersion = newValue
    }
  }

  @objc public var patchVersion: Int {
    get {
      wrappedInstance.patchVersion
    }
    set {
      wrappedInstance.patchVersion = newValue
    }
  }

  init(_ wrappedInstance: OperatingSystemVersion) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(majorVersion: Int, minorVersion: Int, patchVersion: Int) {
    wrappedInstance = OperatingSystemVersion(majorVersion: majorVersion, minorVersion: minorVersion, patchVersion: patchVersion)
  }

  @objc override init() {
    wrappedInstance = OperatingSystemVersion()
  }

}

@objc public class NSSwappedDoubleWrapper: NSObject {
  var wrappedInstance: NSSwappedDouble

  init(_ wrappedInstance: NSSwappedDouble) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSSwappedDouble()
  }

}

@objc public class NSSwappedFloatWrapper: NSObject {
  var wrappedInstance: NSSwappedFloat

  init(_ wrappedInstance: NSSwappedFloat) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSSwappedFloat()
  }

}

@objc public class NSAttributedStringFormattingContextKeyWrapper: NSObject {
  var wrappedInstance: NSAttributedStringFormattingContextKey

  @available(macOS, introduced: 14.0)
  @objc static public var inflectionConceptsKey: NSAttributedStringFormattingContextKeyWrapper {
    get {
      NSAttributedStringFormattingContextKeyWrapper(NSAttributedStringFormattingContextKey.inflectionConceptsKey)
    }
  }

  init(_ wrappedInstance: NSAttributedStringFormattingContextKey) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = NSAttributedStringFormattingContextKey(rawValue: rawValue)
  }

  @objc init(_ rawValue: String) {
    wrappedInstance = NSAttributedStringFormattingContextKey(rawValue)
  }

}

@objc public class NSExceptionNameWrapper: NSObject {
  var wrappedInstance: NSExceptionName

  @objc static public var characterConversionException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.characterConversionException)
    }
  }

  @objc static public var decimalNumberDivideByZeroException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.decimalNumberDivideByZeroException)
    }
  }

  @objc static public var decimalNumberExactnessException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.decimalNumberExactnessException)
    }
  }

  @objc static public var decimalNumberOverflowException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.decimalNumberOverflowException)
    }
  }

  @objc static public var decimalNumberUnderflowException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.decimalNumberUnderflowException)
    }
  }

  @objc static public var destinationInvalidException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.destinationInvalidException)
    }
  }

  @objc static public var fileHandleOperationException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.fileHandleOperationException)
    }
  }

  @objc static public var genericException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.genericException)
    }
  }

  @objc static public var inconsistentArchiveException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.inconsistentArchiveException)
    }
  }

  @objc static public var internalInconsistencyException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.internalInconsistencyException)
    }
  }

  @objc static public var invalidArchiveOperationException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.invalidArchiveOperationException)
    }
  }

  @objc static public var invalidArgumentException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.invalidArgumentException)
    }
  }

  @objc static public var invalidReceivePortException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.invalidReceivePortException)
    }
  }

  @objc static public var invalidSendPortException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.invalidSendPortException)
    }
  }

  @objc static public var invalidUnarchiveOperationException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.invalidUnarchiveOperationException)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var invocationOperationCancelledException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.invocationOperationCancelledException)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var invocationOperationVoidResultException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.invocationOperationVoidResultException)
    }
  }

  @objc static public var mallocException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.mallocException)
    }
  }

  @objc static public var objectInaccessibleException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.objectInaccessibleException)
    }
  }

  @objc static public var objectNotAvailableException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.objectNotAvailableException)
    }
  }

  @objc static public var oldStyleException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.oldStyleException)
    }
  }

  @objc static public var parseErrorException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.parseErrorException)
    }
  }

  @objc static public var portReceiveException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.portReceiveException)
    }
  }

  @objc static public var portSendException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.portSendException)
    }
  }

  @objc static public var portTimeoutException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.portTimeoutException)
    }
  }

  @objc static public var rangeException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.rangeException)
    }
  }

  @objc static public var undefinedKeyException: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(NSExceptionName.undefinedKeyException)
    }
  }

  init(_ wrappedInstance: NSExceptionName) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = NSExceptionName(rawValue: rawValue)
  }

  @objc init(_ rawValue: String) {
    wrappedInstance = NSExceptionName(rawValue)
  }

}

@objc public class FileAttributeKeyWrapper: NSObject {
  var wrappedInstance: FileAttributeKey

  @objc static public var appendOnly: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.appendOnly)
    }
  }

  @objc static public var busy: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.busy)
    }
  }

  @objc static public var creationDate: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.creationDate)
    }
  }

  @objc static public var deviceIdentifier: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.deviceIdentifier)
    }
  }

  @objc static public var extensionHidden: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.extensionHidden)
    }
  }

  @objc static public var groupOwnerAccountID: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.groupOwnerAccountID)
    }
  }

  @objc static public var groupOwnerAccountName: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.groupOwnerAccountName)
    }
  }

  @objc static public var hfsCreatorCode: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.hfsCreatorCode)
    }
  }

  @objc static public var hfsTypeCode: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.hfsTypeCode)
    }
  }

  @objc static public var immutable: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.immutable)
    }
  }

  @objc static public var modificationDate: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.modificationDate)
    }
  }

  @objc static public var ownerAccountID: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.ownerAccountID)
    }
  }

  @objc static public var ownerAccountName: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.ownerAccountName)
    }
  }

  @objc static public var posixPermissions: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.posixPermissions)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var protectionKey: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.protectionKey)
    }
  }

  @objc static public var referenceCount: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.referenceCount)
    }
  }

  @objc static public var size: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.size)
    }
  }

  @objc static public var systemFileNumber: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.systemFileNumber)
    }
  }

  @objc static public var systemFreeNodes: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.systemFreeNodes)
    }
  }

  @objc static public var systemFreeSize: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.systemFreeSize)
    }
  }

  @objc static public var systemNodes: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.systemNodes)
    }
  }

  @objc static public var systemNumber: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.systemNumber)
    }
  }

  @objc static public var systemSize: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.systemSize)
    }
  }

  @objc static public var type: FileAttributeKeyWrapper {
    get {
      FileAttributeKeyWrapper(FileAttributeKey.type)
    }
  }

  init(_ wrappedInstance: FileAttributeKey) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = FileAttributeKey(rawValue: rawValue)
  }

  @objc init(_ rawValue: String) {
    wrappedInstance = FileAttributeKey(rawValue)
  }

}

@objc public class FileAttributeTypeWrapper: NSObject {
  var wrappedInstance: FileAttributeType

  @objc static public var typeBlockSpecial: FileAttributeTypeWrapper {
    get {
      FileAttributeTypeWrapper(FileAttributeType.typeBlockSpecial)
    }
  }

  @objc static public var typeCharacterSpecial: FileAttributeTypeWrapper {
    get {
      FileAttributeTypeWrapper(FileAttributeType.typeCharacterSpecial)
    }
  }

  @objc static public var typeDirectory: FileAttributeTypeWrapper {
    get {
      FileAttributeTypeWrapper(FileAttributeType.typeDirectory)
    }
  }

  @objc static public var typeRegular: FileAttributeTypeWrapper {
    get {
      FileAttributeTypeWrapper(FileAttributeType.typeRegular)
    }
  }

  @objc static public var typeSocket: FileAttributeTypeWrapper {
    get {
      FileAttributeTypeWrapper(FileAttributeType.typeSocket)
    }
  }

  @objc static public var typeSymbolicLink: FileAttributeTypeWrapper {
    get {
      FileAttributeTypeWrapper(FileAttributeType.typeSymbolicLink)
    }
  }

  @objc static public var typeUnknown: FileAttributeTypeWrapper {
    get {
      FileAttributeTypeWrapper(FileAttributeType.typeUnknown)
    }
  }

  init(_ wrappedInstance: FileAttributeType) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = FileAttributeType(rawValue: rawValue)
  }

}

@objc public class FileProtectionTypeWrapper: NSObject {
  var wrappedInstance: FileProtectionType

  @available(macOS, introduced: 10.6)
  @objc static public var complete: FileProtectionTypeWrapper {
    get {
      FileProtectionTypeWrapper(FileProtectionType.complete)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var completeUnlessOpen: FileProtectionTypeWrapper {
    get {
      FileProtectionTypeWrapper(FileProtectionType.completeUnlessOpen)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var completeUntilFirstUserAuthentication: FileProtectionTypeWrapper {
    get {
      FileProtectionTypeWrapper(FileProtectionType.completeUntilFirstUserAuthentication)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var none: FileProtectionTypeWrapper {
    get {
      FileProtectionTypeWrapper(FileProtectionType.none)
    }
  }

  init(_ wrappedInstance: FileProtectionType) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = FileProtectionType(rawValue: rawValue)
  }

}

@objc public class NSFileProviderServiceNameWrapper: NSObject {
  var wrappedInstance: NSFileProviderServiceName

  init(_ wrappedInstance: NSFileProviderServiceName) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = NSFileProviderServiceName(rawValue: rawValue)
  }

  @objc init(_ rawValue: String) {
    wrappedInstance = NSFileProviderServiceName(rawValue)
  }

}

@objc public class HTTPCookiePropertyKeyWrapper: NSObject {
  var wrappedInstance: HTTPCookiePropertyKey

  @available(macOS, introduced: 10.2)
  @objc static public var comment: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.comment)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var commentURL: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.commentURL)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var discard: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.discard)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var domain: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.domain)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var expires: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.expires)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var maximumAge: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.maximumAge)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var name: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.name)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var originURL: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.originURL)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var path: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.path)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var port: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.port)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var sameSitePolicy: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.sameSitePolicy)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var secure: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.secure)
    }
  }

  @available(macOS, introduced: 15.2)
  @objc static public var setByJavaScript: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.setByJavaScript)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var value: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.value)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var version: HTTPCookiePropertyKeyWrapper {
    get {
      HTTPCookiePropertyKeyWrapper(HTTPCookiePropertyKey.version)
    }
  }

  init(_ wrappedInstance: HTTPCookiePropertyKey) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = HTTPCookiePropertyKey(rawValue: rawValue)
  }

  @objc init(_ rawValue: String) {
    wrappedInstance = HTTPCookiePropertyKey(rawValue)
  }

}

@objc public class HTTPCookieStringPolicyWrapper: NSObject {
  var wrappedInstance: HTTPCookieStringPolicy

  @available(macOS, introduced: 10.15)
  @objc static public var sameSiteLax: HTTPCookieStringPolicyWrapper {
    get {
      HTTPCookieStringPolicyWrapper(HTTPCookieStringPolicy.sameSiteLax)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var sameSiteStrict: HTTPCookieStringPolicyWrapper {
    get {
      HTTPCookieStringPolicyWrapper(HTTPCookieStringPolicy.sameSiteStrict)
    }
  }

  init(_ wrappedInstance: HTTPCookieStringPolicy) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = HTTPCookieStringPolicy(rawValue: rawValue)
  }

}

@objc public class NSKeyValueChangeKeyWrapper: NSObject {
  var wrappedInstance: NSKeyValueChangeKey

  @objc static public var indexesKey: NSKeyValueChangeKeyWrapper {
    get {
      NSKeyValueChangeKeyWrapper(NSKeyValueChangeKey.indexesKey)
    }
  }

  @objc static public var kindKey: NSKeyValueChangeKeyWrapper {
    get {
      NSKeyValueChangeKeyWrapper(NSKeyValueChangeKey.kindKey)
    }
  }

  @objc static public var newKey: NSKeyValueChangeKeyWrapper {
    get {
      NSKeyValueChangeKeyWrapper(NSKeyValueChangeKey.newKey)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var notificationIsPriorKey: NSKeyValueChangeKeyWrapper {
    get {
      NSKeyValueChangeKeyWrapper(NSKeyValueChangeKey.notificationIsPriorKey)
    }
  }

  @objc static public var oldKey: NSKeyValueChangeKeyWrapper {
    get {
      NSKeyValueChangeKeyWrapper(NSKeyValueChangeKey.oldKey)
    }
  }

  init(_ wrappedInstance: NSKeyValueChangeKey) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = NSKeyValueChangeKey(rawValue: rawValue)
  }

}

@objc public class NSKeyValueOperatorWrapper: NSObject {
  var wrappedInstance: NSKeyValueOperator

  @objc static public var averageKeyValueOperator: NSKeyValueOperatorWrapper {
    get {
      NSKeyValueOperatorWrapper(NSKeyValueOperator.averageKeyValueOperator)
    }
  }

  @objc static public var countKeyValueOperator: NSKeyValueOperatorWrapper {
    get {
      NSKeyValueOperatorWrapper(NSKeyValueOperator.countKeyValueOperator)
    }
  }

  @objc static public var distinctUnionOfArraysKeyValueOperator: NSKeyValueOperatorWrapper {
    get {
      NSKeyValueOperatorWrapper(NSKeyValueOperator.distinctUnionOfArraysKeyValueOperator)
    }
  }

  @objc static public var distinctUnionOfObjectsKeyValueOperator: NSKeyValueOperatorWrapper {
    get {
      NSKeyValueOperatorWrapper(NSKeyValueOperator.distinctUnionOfObjectsKeyValueOperator)
    }
  }

  @objc static public var distinctUnionOfSetsKeyValueOperator: NSKeyValueOperatorWrapper {
    get {
      NSKeyValueOperatorWrapper(NSKeyValueOperator.distinctUnionOfSetsKeyValueOperator)
    }
  }

  @objc static public var maximumKeyValueOperator: NSKeyValueOperatorWrapper {
    get {
      NSKeyValueOperatorWrapper(NSKeyValueOperator.maximumKeyValueOperator)
    }
  }

  @objc static public var minimumKeyValueOperator: NSKeyValueOperatorWrapper {
    get {
      NSKeyValueOperatorWrapper(NSKeyValueOperator.minimumKeyValueOperator)
    }
  }

  @objc static public var sumKeyValueOperator: NSKeyValueOperatorWrapper {
    get {
      NSKeyValueOperatorWrapper(NSKeyValueOperator.sumKeyValueOperator)
    }
  }

  @objc static public var unionOfArraysKeyValueOperator: NSKeyValueOperatorWrapper {
    get {
      NSKeyValueOperatorWrapper(NSKeyValueOperator.unionOfArraysKeyValueOperator)
    }
  }

  @objc static public var unionOfObjectsKeyValueOperator: NSKeyValueOperatorWrapper {
    get {
      NSKeyValueOperatorWrapper(NSKeyValueOperator.unionOfObjectsKeyValueOperator)
    }
  }

  @objc static public var unionOfSetsKeyValueOperator: NSKeyValueOperatorWrapper {
    get {
      NSKeyValueOperatorWrapper(NSKeyValueOperator.unionOfSetsKeyValueOperator)
    }
  }

  init(_ wrappedInstance: NSKeyValueOperator) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = NSKeyValueOperator(rawValue: rawValue)
  }

}

@objc public class NSLinguisticTagWrapper: NSObject {
  var wrappedInstance: NSLinguisticTag

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var adjective: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.adjective)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var adverb: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.adverb)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var classifier: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.classifier)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var closeParenthesis: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.closeParenthesis)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var closeQuote: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.closeQuote)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var conjunction: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.conjunction)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var dash: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.dash)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var determiner: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.determiner)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var idiom: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.idiom)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var interjection: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.interjection)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var noun: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.noun)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var number: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.number)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var openParenthesis: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.openParenthesis)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var openQuote: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.openQuote)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var organizationName: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.organizationName)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var other: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.other)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var otherPunctuation: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.otherPunctuation)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var otherWhitespace: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.otherWhitespace)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var otherWord: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.otherWord)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var paragraphBreak: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.paragraphBreak)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var particle: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.particle)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var personalName: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.personalName)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var placeName: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.placeName)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var preposition: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.preposition)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var pronoun: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.pronoun)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var punctuation: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.punctuation)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var sentenceTerminator: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.sentenceTerminator)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var verb: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.verb)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var whitespace: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.whitespace)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var word: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.word)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var wordJoiner: NSLinguisticTagWrapper {
    get {
      NSLinguisticTagWrapper(NSLinguisticTag.wordJoiner)
    }
  }

  init(_ wrappedInstance: NSLinguisticTag) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = NSLinguisticTag(rawValue: rawValue)
  }

  @objc init(_ rawValue: String) {
    wrappedInstance = NSLinguisticTag(rawValue)
  }

}

@objc public class NSLinguisticTagSchemeWrapper: NSObject {
  var wrappedInstance: NSLinguisticTagScheme

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var language: NSLinguisticTagSchemeWrapper {
    get {
      NSLinguisticTagSchemeWrapper(NSLinguisticTagScheme.language)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var lemma: NSLinguisticTagSchemeWrapper {
    get {
      NSLinguisticTagSchemeWrapper(NSLinguisticTagScheme.lemma)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var lexicalClass: NSLinguisticTagSchemeWrapper {
    get {
      NSLinguisticTagSchemeWrapper(NSLinguisticTagScheme.lexicalClass)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var nameType: NSLinguisticTagSchemeWrapper {
    get {
      NSLinguisticTagSchemeWrapper(NSLinguisticTagScheme.nameType)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var nameTypeOrLexicalClass: NSLinguisticTagSchemeWrapper {
    get {
      NSLinguisticTagSchemeWrapper(NSLinguisticTagScheme.nameTypeOrLexicalClass)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var script: NSLinguisticTagSchemeWrapper {
    get {
      NSLinguisticTagSchemeWrapper(NSLinguisticTagScheme.script)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc static public var tokenType: NSLinguisticTagSchemeWrapper {
    get {
      NSLinguisticTagSchemeWrapper(NSLinguisticTagScheme.tokenType)
    }
  }

  init(_ wrappedInstance: NSLinguisticTagScheme) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = NSLinguisticTagScheme(rawValue: rawValue)
  }

  @objc init(_ rawValue: String) {
    wrappedInstance = NSLinguisticTagScheme(rawValue)
  }

}

@objc public class ProgressKindWrapper: NSObject {
  var wrappedInstance: ProgressKind

  @available(macOS, introduced: 10.9)
  @objc static public var file: ProgressKindWrapper {
    get {
      ProgressKindWrapper(ProgressKind.file)
    }
  }

  init(_ wrappedInstance: ProgressKind) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = ProgressKind(rawValue: rawValue)
  }

  @objc init(_ rawValue: String) {
    wrappedInstance = ProgressKind(rawValue)
  }

}

@objc public class ProgressUserInfoKeyWrapper: NSObject {
  var wrappedInstance: ProgressUserInfoKey

  @available(macOS, introduced: 10.9)
  @objc static public var estimatedTimeRemainingKey: ProgressUserInfoKeyWrapper {
    get {
      ProgressUserInfoKeyWrapper(ProgressUserInfoKey.estimatedTimeRemainingKey)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var fileAnimationImageKey: ProgressUserInfoKeyWrapper {
    get {
      ProgressUserInfoKeyWrapper(ProgressUserInfoKey.fileAnimationImageKey)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var fileAnimationImageOriginalRectKey: ProgressUserInfoKeyWrapper {
    get {
      ProgressUserInfoKeyWrapper(ProgressUserInfoKey.fileAnimationImageOriginalRectKey)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var fileCompletedCountKey: ProgressUserInfoKeyWrapper {
    get {
      ProgressUserInfoKeyWrapper(ProgressUserInfoKey.fileCompletedCountKey)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var fileIconKey: ProgressUserInfoKeyWrapper {
    get {
      ProgressUserInfoKeyWrapper(ProgressUserInfoKey.fileIconKey)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var fileOperationKindKey: ProgressUserInfoKeyWrapper {
    get {
      ProgressUserInfoKeyWrapper(ProgressUserInfoKey.fileOperationKindKey)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var fileTotalCountKey: ProgressUserInfoKeyWrapper {
    get {
      ProgressUserInfoKeyWrapper(ProgressUserInfoKey.fileTotalCountKey)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var fileURLKey: ProgressUserInfoKeyWrapper {
    get {
      ProgressUserInfoKeyWrapper(ProgressUserInfoKey.fileURLKey)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var throughputKey: ProgressUserInfoKeyWrapper {
    get {
      ProgressUserInfoKeyWrapper(ProgressUserInfoKey.throughputKey)
    }
  }

  init(_ wrappedInstance: ProgressUserInfoKey) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = ProgressUserInfoKey(rawValue: rawValue)
  }

  @objc init(_ rawValue: String) {
    wrappedInstance = ProgressUserInfoKey(rawValue)
  }

}

@objc public class StreamNetworkServiceTypeValueWrapper: NSObject {
  var wrappedInstance: StreamNetworkServiceTypeValue

  @available(macOS, introduced: 10.7)
  @objc static public var background: StreamNetworkServiceTypeValueWrapper {
    get {
      StreamNetworkServiceTypeValueWrapper(StreamNetworkServiceTypeValue.background)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var callSignaling: StreamNetworkServiceTypeValueWrapper {
    get {
      StreamNetworkServiceTypeValueWrapper(StreamNetworkServiceTypeValue.callSignaling)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var video: StreamNetworkServiceTypeValueWrapper {
    get {
      StreamNetworkServiceTypeValueWrapper(StreamNetworkServiceTypeValue.video)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var voIP: StreamNetworkServiceTypeValueWrapper {
    get {
      StreamNetworkServiceTypeValueWrapper(StreamNetworkServiceTypeValue.voIP)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var voice: StreamNetworkServiceTypeValueWrapper {
    get {
      StreamNetworkServiceTypeValueWrapper(StreamNetworkServiceTypeValue.voice)
    }
  }

  init(_ wrappedInstance: StreamNetworkServiceTypeValue) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = StreamNetworkServiceTypeValue(rawValue: rawValue)
  }

}

@objc public class StreamSOCKSProxyConfigurationWrapper: NSObject {
  var wrappedInstance: StreamSOCKSProxyConfiguration

  @available(macOS, introduced: 10.3)
  @objc static public var hostKey: StreamSOCKSProxyConfigurationWrapper {
    get {
      StreamSOCKSProxyConfigurationWrapper(StreamSOCKSProxyConfiguration.hostKey)
    }
  }

  @available(macOS, introduced: 10.3)
  @objc static public var passwordKey: StreamSOCKSProxyConfigurationWrapper {
    get {
      StreamSOCKSProxyConfigurationWrapper(StreamSOCKSProxyConfiguration.passwordKey)
    }
  }

  @available(macOS, introduced: 10.3)
  @objc static public var portKey: StreamSOCKSProxyConfigurationWrapper {
    get {
      StreamSOCKSProxyConfigurationWrapper(StreamSOCKSProxyConfiguration.portKey)
    }
  }

  @available(macOS, introduced: 10.3)
  @objc static public var userKey: StreamSOCKSProxyConfigurationWrapper {
    get {
      StreamSOCKSProxyConfigurationWrapper(StreamSOCKSProxyConfiguration.userKey)
    }
  }

  @available(macOS, introduced: 10.3)
  @objc static public var versionKey: StreamSOCKSProxyConfigurationWrapper {
    get {
      StreamSOCKSProxyConfigurationWrapper(StreamSOCKSProxyConfiguration.versionKey)
    }
  }

  init(_ wrappedInstance: StreamSOCKSProxyConfiguration) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = StreamSOCKSProxyConfiguration(rawValue: rawValue)
  }

}

@objc public class StreamSOCKSProxyVersionWrapper: NSObject {
  var wrappedInstance: StreamSOCKSProxyVersion

  @available(macOS, introduced: 10.3)
  @objc static public var version4: StreamSOCKSProxyVersionWrapper {
    get {
      StreamSOCKSProxyVersionWrapper(StreamSOCKSProxyVersion.version4)
    }
  }

  @available(macOS, introduced: 10.3)
  @objc static public var version5: StreamSOCKSProxyVersionWrapper {
    get {
      StreamSOCKSProxyVersionWrapper(StreamSOCKSProxyVersion.version5)
    }
  }

  init(_ wrappedInstance: StreamSOCKSProxyVersion) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = StreamSOCKSProxyVersion(rawValue: rawValue)
  }

}

@objc public class StreamSocketSecurityLevelWrapper: NSObject {
  var wrappedInstance: StreamSocketSecurityLevel

  @available(macOS, introduced: 10.3)
  @objc static public var negotiatedSSL: StreamSocketSecurityLevelWrapper {
    get {
      StreamSocketSecurityLevelWrapper(StreamSocketSecurityLevel.negotiatedSSL)
    }
  }

  @available(macOS, introduced: 10.3)
  @objc static public var none: StreamSocketSecurityLevelWrapper {
    get {
      StreamSocketSecurityLevelWrapper(StreamSocketSecurityLevel.none)
    }
  }

  @available(macOS, introduced: 10.3)
  @objc static public var ssLv2: StreamSocketSecurityLevelWrapper {
    get {
      StreamSocketSecurityLevelWrapper(StreamSocketSecurityLevel.ssLv2)
    }
  }

  @available(macOS, introduced: 10.3)
  @objc static public var ssLv3: StreamSocketSecurityLevelWrapper {
    get {
      StreamSocketSecurityLevelWrapper(StreamSocketSecurityLevel.ssLv3)
    }
  }

  @available(macOS, introduced: 10.3)
  @objc static public var tlSv1: StreamSocketSecurityLevelWrapper {
    get {
      StreamSocketSecurityLevelWrapper(StreamSocketSecurityLevel.tlSv1)
    }
  }

  init(_ wrappedInstance: StreamSocketSecurityLevel) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = StreamSocketSecurityLevel(rawValue: rawValue)
  }

}

@objc public class StringEncodingDetectionOptionsKeyWrapper: NSObject {
  var wrappedInstance: StringEncodingDetectionOptionsKey

  @available(macOS, introduced: 10.10)
  @objc static public var allowLossyKey: StringEncodingDetectionOptionsKeyWrapper {
    get {
      StringEncodingDetectionOptionsKeyWrapper(StringEncodingDetectionOptionsKey.allowLossyKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var disallowedEncodingsKey: StringEncodingDetectionOptionsKeyWrapper {
    get {
      StringEncodingDetectionOptionsKeyWrapper(StringEncodingDetectionOptionsKey.disallowedEncodingsKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var fromWindowsKey: StringEncodingDetectionOptionsKeyWrapper {
    get {
      StringEncodingDetectionOptionsKeyWrapper(StringEncodingDetectionOptionsKey.fromWindowsKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var likelyLanguageKey: StringEncodingDetectionOptionsKeyWrapper {
    get {
      StringEncodingDetectionOptionsKeyWrapper(StringEncodingDetectionOptionsKey.likelyLanguageKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var lossySubstitutionKey: StringEncodingDetectionOptionsKeyWrapper {
    get {
      StringEncodingDetectionOptionsKeyWrapper(StringEncodingDetectionOptionsKey.lossySubstitutionKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var suggestedEncodingsKey: StringEncodingDetectionOptionsKeyWrapper {
    get {
      StringEncodingDetectionOptionsKeyWrapper(StringEncodingDetectionOptionsKey.suggestedEncodingsKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var useOnlySuggestedEncodingsKey: StringEncodingDetectionOptionsKeyWrapper {
    get {
      StringEncodingDetectionOptionsKeyWrapper(StringEncodingDetectionOptionsKey.useOnlySuggestedEncodingsKey)
    }
  }

  init(_ wrappedInstance: StringEncodingDetectionOptionsKey) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = StringEncodingDetectionOptionsKey(rawValue: rawValue)
  }

}

@objc public class StringTransformWrapper: NSObject {
  var wrappedInstance: StringTransform

  @available(macOS, introduced: 10.11)
  @objc static public var fullwidthToHalfwidth: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.fullwidthToHalfwidth)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var hiraganaToKatakana: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.hiraganaToKatakana)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var latinToArabic: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.latinToArabic)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var latinToCyrillic: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.latinToCyrillic)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var latinToGreek: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.latinToGreek)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var latinToHangul: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.latinToHangul)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var latinToHebrew: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.latinToHebrew)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var latinToHiragana: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.latinToHiragana)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var latinToKatakana: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.latinToKatakana)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var latinToThai: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.latinToThai)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var mandarinToLatin: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.mandarinToLatin)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var stripCombiningMarks: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.stripCombiningMarks)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var stripDiacritics: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.stripDiacritics)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var toLatin: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.toLatin)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var toUnicodeName: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.toUnicodeName)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var toXMLHex: StringTransformWrapper {
    get {
      StringTransformWrapper(StringTransform.toXMLHex)
    }
  }

  init(_ wrappedInstance: StringTransform) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = StringTransform(rawValue: rawValue)
  }

  @objc init(_ rawValue: String) {
    wrappedInstance = StringTransform(rawValue)
  }

}

@objc public class NSTextCheckingKeyWrapper: NSObject {
  var wrappedInstance: NSTextCheckingKey

  @available(macOS, introduced: 10.7)
  @objc static public var airline: NSTextCheckingKeyWrapper {
    get {
      NSTextCheckingKeyWrapper(NSTextCheckingKey.airline)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var city: NSTextCheckingKeyWrapper {
    get {
      NSTextCheckingKeyWrapper(NSTextCheckingKey.city)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var country: NSTextCheckingKeyWrapper {
    get {
      NSTextCheckingKeyWrapper(NSTextCheckingKey.country)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var flight: NSTextCheckingKeyWrapper {
    get {
      NSTextCheckingKeyWrapper(NSTextCheckingKey.flight)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var jobTitle: NSTextCheckingKeyWrapper {
    get {
      NSTextCheckingKeyWrapper(NSTextCheckingKey.jobTitle)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var name: NSTextCheckingKeyWrapper {
    get {
      NSTextCheckingKeyWrapper(NSTextCheckingKey.name)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var organization: NSTextCheckingKeyWrapper {
    get {
      NSTextCheckingKeyWrapper(NSTextCheckingKey.organization)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var phone: NSTextCheckingKeyWrapper {
    get {
      NSTextCheckingKeyWrapper(NSTextCheckingKey.phone)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var state: NSTextCheckingKeyWrapper {
    get {
      NSTextCheckingKeyWrapper(NSTextCheckingKey.state)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var street: NSTextCheckingKeyWrapper {
    get {
      NSTextCheckingKeyWrapper(NSTextCheckingKey.street)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var zip: NSTextCheckingKeyWrapper {
    get {
      NSTextCheckingKeyWrapper(NSTextCheckingKey.zip)
    }
  }

  init(_ wrappedInstance: NSTextCheckingKey) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = NSTextCheckingKey(rawValue: rawValue)
  }

  @objc init(_ rawValue: String) {
    wrappedInstance = NSTextCheckingKey(rawValue)
  }

}

@objc public class URLFileProtectionWrapper: NSObject {
  var wrappedInstance: URLFileProtection

  @available(macOS, introduced: 11.0)
  @objc static public var complete: URLFileProtectionWrapper {
    get {
      URLFileProtectionWrapper(URLFileProtection.complete)
    }
  }

  @available(macOS, introduced: 11.0)
  @objc static public var completeUnlessOpen: URLFileProtectionWrapper {
    get {
      URLFileProtectionWrapper(URLFileProtection.completeUnlessOpen)
    }
  }

  @available(macOS, introduced: 11.0)
  @objc static public var completeUntilFirstUserAuthentication: URLFileProtectionWrapper {
    get {
      URLFileProtectionWrapper(URLFileProtection.completeUntilFirstUserAuthentication)
    }
  }

  @available(macOS, introduced: 11.0)
  @objc static public var none: URLFileProtectionWrapper {
    get {
      URLFileProtectionWrapper(URLFileProtection.none)
    }
  }

  init(_ wrappedInstance: URLFileProtection) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = URLFileProtection(rawValue: rawValue)
  }

}

@objc public class URLFileResourceTypeWrapper: NSObject {
  var wrappedInstance: URLFileResourceType

  @available(macOS, introduced: 10.7)
  @objc static public var blockSpecial: URLFileResourceTypeWrapper {
    get {
      URLFileResourceTypeWrapper(URLFileResourceType.blockSpecial)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var characterSpecial: URLFileResourceTypeWrapper {
    get {
      URLFileResourceTypeWrapper(URLFileResourceType.characterSpecial)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var directory: URLFileResourceTypeWrapper {
    get {
      URLFileResourceTypeWrapper(URLFileResourceType.directory)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var namedPipe: URLFileResourceTypeWrapper {
    get {
      URLFileResourceTypeWrapper(URLFileResourceType.namedPipe)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var regular: URLFileResourceTypeWrapper {
    get {
      URLFileResourceTypeWrapper(URLFileResourceType.regular)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var socket: URLFileResourceTypeWrapper {
    get {
      URLFileResourceTypeWrapper(URLFileResourceType.socket)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var symbolicLink: URLFileResourceTypeWrapper {
    get {
      URLFileResourceTypeWrapper(URLFileResourceType.symbolicLink)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var unknown: URLFileResourceTypeWrapper {
    get {
      URLFileResourceTypeWrapper(URLFileResourceType.unknown)
    }
  }

  init(_ wrappedInstance: URLFileResourceType) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = URLFileResourceType(rawValue: rawValue)
  }

}

@objc public class URLResourceKeyWrapper: NSObject {
  var wrappedInstance: URLResourceKey

  @available(macOS, introduced: 10.10)
  @objc static public var addedToDirectoryDateKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.addedToDirectoryDateKey)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var applicationIsScriptableKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.applicationIsScriptableKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var attributeModificationDateKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.attributeModificationDateKey)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var canonicalPathKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.canonicalPathKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var contentAccessDateKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.contentAccessDateKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var contentModificationDateKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.contentModificationDateKey)
    }
  }

  @available(macOS, introduced: 11.0)
  @objc static public var contentTypeKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.contentTypeKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var creationDateKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.creationDateKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var customIconKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.customIconKey)
    }
  }

  @available(macOS, introduced: 14.0)
  @objc static public var directoryEntryCountKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.directoryEntryCountKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var documentIdentifierKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.documentIdentifierKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var effectiveIconKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.effectiveIconKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var fileAllocatedSizeKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.fileAllocatedSizeKey)
    }
  }

  @available(macOS, introduced: 11.0)
  @objc static public var fileContentIdentifierKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.fileContentIdentifierKey)
    }
  }

  @available(macOS, introduced: 13.3)
  @objc static public var fileIdentifierKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.fileIdentifierKey)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var fileProtectionKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.fileProtectionKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var fileResourceIdentifierKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.fileResourceIdentifierKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var fileResourceTypeKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.fileResourceTypeKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var fileSecurityKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.fileSecurityKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var fileSizeKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.fileSizeKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var generationIdentifierKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.generationIdentifierKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var hasHiddenExtensionKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.hasHiddenExtensionKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var isAliasFileKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isAliasFileKey)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var isApplicationKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isApplicationKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var isDirectoryKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isDirectoryKey)
    }
  }

  @available(macOS, introduced: 10.8)
  @objc static public var isExcludedFromBackupKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isExcludedFromBackupKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var isExecutableKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isExecutableKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var isHiddenKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isHiddenKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var isMountTriggerKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isMountTriggerKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var isPackageKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isPackageKey)
    }
  }

  @available(macOS, introduced: 11.0)
  @objc static public var isPurgeableKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isPurgeableKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var isReadableKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isReadableKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var isRegularFileKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isRegularFileKey)
    }
  }

  @available(macOS, introduced: 11.0)
  @objc static public var isSparseKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isSparseKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var isSymbolicLinkKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isSymbolicLinkKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var isSystemImmutableKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isSystemImmutableKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var isUbiquitousItemKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isUbiquitousItemKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var isUserImmutableKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isUserImmutableKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var isVolumeKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isVolumeKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var isWritableKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.isWritableKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var keysOfUnsetValuesKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.keysOfUnsetValuesKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var labelColorKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.labelColorKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var labelNumberKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.labelNumberKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var linkCountKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.linkCountKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var localizedLabelKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.localizedLabelKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var localizedNameKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.localizedNameKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var localizedTypeDescriptionKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.localizedTypeDescriptionKey)
    }
  }

  @available(macOS, introduced: 11.0)
  @objc static public var mayHaveExtendedAttributesKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.mayHaveExtendedAttributesKey)
    }
  }

  @available(macOS, introduced: 11.0)
  @objc static public var mayShareFileContentKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.mayShareFileContentKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var nameKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.nameKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var parentDirectoryURLKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.parentDirectoryURLKey)
    }
  }

  @available(macOS, introduced: 10.8)
  @objc static public var pathKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.pathKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var preferredIOBlockSizeKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.preferredIOBlockSizeKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var quarantinePropertiesKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.quarantinePropertiesKey)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var tagNamesKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.tagNamesKey)
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 12.0)
  @objc static public var thumbnailDictionaryKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.thumbnailDictionaryKey)
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 12.0)
  @objc static public var thumbnailKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.thumbnailKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var totalFileAllocatedSizeKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.totalFileAllocatedSizeKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var totalFileSizeKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.totalFileSizeKey)
    }
  }

  @available(macOS, introduced: 10.6, deprecated: 100000)
  @objc static public var typeIdentifierKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.typeIdentifierKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var ubiquitousItemContainerDisplayNameKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousItemContainerDisplayNameKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var ubiquitousItemDownloadRequestedKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousItemDownloadRequestedKey)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var ubiquitousItemDownloadingErrorKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousItemDownloadingErrorKey)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var ubiquitousItemDownloadingStatusKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousItemDownloadingStatusKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var ubiquitousItemHasUnresolvedConflictsKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousItemHasUnresolvedConflictsKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var ubiquitousItemIsDownloadingKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousItemIsDownloadingKey)
    }
  }

  @available(macOS, introduced: 11.3)
  @objc static public var ubiquitousItemIsExcludedFromSyncKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousItemIsExcludedFromSyncKey)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var ubiquitousItemIsSharedKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousItemIsSharedKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var ubiquitousItemIsUploadedKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousItemIsUploadedKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var ubiquitousItemIsUploadingKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousItemIsUploadingKey)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var ubiquitousItemUploadingErrorKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousItemUploadingErrorKey)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var ubiquitousSharedItemCurrentUserPermissionsKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousSharedItemCurrentUserPermissionsKey)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var ubiquitousSharedItemCurrentUserRoleKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousSharedItemCurrentUserRoleKey)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var ubiquitousSharedItemMostRecentEditorNameComponentsKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousSharedItemMostRecentEditorNameComponentsKey)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var ubiquitousSharedItemOwnerNameComponentsKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.ubiquitousSharedItemOwnerNameComponentsKey)
    }
  }

  @available(macOS, introduced: 10.13)
  @objc static public var volumeAvailableCapacityForImportantUsageKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeAvailableCapacityForImportantUsageKey)
    }
  }

  @available(macOS, introduced: 10.13)
  @objc static public var volumeAvailableCapacityForOpportunisticUsageKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeAvailableCapacityForOpportunisticUsageKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var volumeAvailableCapacityKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeAvailableCapacityKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeCreationDateKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeCreationDateKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeIdentifierKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeIdentifierKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeIsAutomountedKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeIsAutomountedKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeIsBrowsableKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeIsBrowsableKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeIsEjectableKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeIsEjectableKey)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var volumeIsEncryptedKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeIsEncryptedKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeIsInternalKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeIsInternalKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var volumeIsJournalingKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeIsJournalingKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeIsLocalKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeIsLocalKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeIsReadOnlyKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeIsReadOnlyKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeIsRemovableKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeIsRemovableKey)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var volumeIsRootFileSystemKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeIsRootFileSystemKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var volumeLocalizedFormatDescriptionKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeLocalizedFormatDescriptionKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeLocalizedNameKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeLocalizedNameKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeMaximumFileSizeKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeMaximumFileSizeKey)
    }
  }

  @available(macOS, introduced: 13.3)
  @objc static public var volumeMountFromLocationKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeMountFromLocationKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeNameKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeNameKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var volumeResourceCountKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeResourceCountKey)
    }
  }

  @available(macOS, introduced: 13.3)
  @objc static public var volumeSubtypeKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSubtypeKey)
    }
  }

  @available(macOS, introduced: 10.13)
  @objc static public var volumeSupportsAccessPermissionsKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsAccessPermissionsKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeSupportsAdvisoryFileLockingKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsAdvisoryFileLockingKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var volumeSupportsCasePreservedNamesKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsCasePreservedNamesKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var volumeSupportsCaseSensitiveNamesKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsCaseSensitiveNamesKey)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var volumeSupportsCompressionKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsCompressionKey)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var volumeSupportsExclusiveRenamingKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsExclusiveRenamingKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeSupportsExtendedSecurityKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsExtendedSecurityKey)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var volumeSupportsFileCloningKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsFileCloningKey)
    }
  }

  @available(macOS, introduced: 11.0)
  @objc static public var volumeSupportsFileProtectionKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsFileProtectionKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var volumeSupportsHardLinksKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsHardLinksKey)
    }
  }

  @available(macOS, introduced: 10.13)
  @objc static public var volumeSupportsImmutableFilesKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsImmutableFilesKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var volumeSupportsJournalingKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsJournalingKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var volumeSupportsPersistentIDsKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsPersistentIDsKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeSupportsRenamingKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsRenamingKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeSupportsRootDirectoryDatesKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsRootDirectoryDatesKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var volumeSupportsSparseFilesKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsSparseFilesKey)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var volumeSupportsSwapRenamingKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsSwapRenamingKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var volumeSupportsSymbolicLinksKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsSymbolicLinksKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeSupportsVolumeSizesKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsVolumeSizesKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var volumeSupportsZeroRunsKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeSupportsZeroRunsKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var volumeTotalCapacityKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeTotalCapacityKey)
    }
  }

  @available(macOS, introduced: 13.3)
  @objc static public var volumeTypeNameKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeTypeNameKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeURLForRemountingKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeURLForRemountingKey)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var volumeURLKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeURLKey)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var volumeUUIDStringKey: URLResourceKeyWrapper {
    get {
      URLResourceKeyWrapper(URLResourceKey.volumeUUIDStringKey)
    }
  }

  init(_ wrappedInstance: URLResourceKey) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = URLResourceKey(rawValue: rawValue)
  }

  @objc init(_ rawValue: String) {
    wrappedInstance = URLResourceKey(rawValue)
  }

}

@objc public class URLThumbnailDictionaryItemWrapper: NSObject {
  var wrappedInstance: URLThumbnailDictionaryItem

  @available(macOS, introduced: 10.10, deprecated: 12.0)
  @objc static public var NSThumbnail1024x1024SizeKey: URLThumbnailDictionaryItemWrapper {
    get {
      URLThumbnailDictionaryItemWrapper(URLThumbnailDictionaryItem.NSThumbnail1024x1024SizeKey)
    }
  }

  init(_ wrappedInstance: URLThumbnailDictionaryItem) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = URLThumbnailDictionaryItem(rawValue: rawValue)
  }

  @objc init(_ rawValue: String) {
    wrappedInstance = URLThumbnailDictionaryItem(rawValue)
  }

}

@objc public class URLUbiquitousItemDownloadingStatusWrapper: NSObject {
  var wrappedInstance: URLUbiquitousItemDownloadingStatus

  @available(macOS, introduced: 10.9)
  @objc static public var current: URLUbiquitousItemDownloadingStatusWrapper {
    get {
      URLUbiquitousItemDownloadingStatusWrapper(URLUbiquitousItemDownloadingStatus.current)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var downloaded: URLUbiquitousItemDownloadingStatusWrapper {
    get {
      URLUbiquitousItemDownloadingStatusWrapper(URLUbiquitousItemDownloadingStatus.downloaded)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var notDownloaded: URLUbiquitousItemDownloadingStatusWrapper {
    get {
      URLUbiquitousItemDownloadingStatusWrapper(URLUbiquitousItemDownloadingStatus.notDownloaded)
    }
  }

  init(_ wrappedInstance: URLUbiquitousItemDownloadingStatus) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = URLUbiquitousItemDownloadingStatus(rawValue: rawValue)
  }

}

@objc public class URLUbiquitousSharedItemPermissionsWrapper: NSObject {
  var wrappedInstance: URLUbiquitousSharedItemPermissions

  @available(macOS, introduced: 10.12)
  @objc static public var readOnly: URLUbiquitousSharedItemPermissionsWrapper {
    get {
      URLUbiquitousSharedItemPermissionsWrapper(URLUbiquitousSharedItemPermissions.readOnly)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var readWrite: URLUbiquitousSharedItemPermissionsWrapper {
    get {
      URLUbiquitousSharedItemPermissionsWrapper(URLUbiquitousSharedItemPermissions.readWrite)
    }
  }

  init(_ wrappedInstance: URLUbiquitousSharedItemPermissions) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = URLUbiquitousSharedItemPermissions(rawValue: rawValue)
  }

}

@objc public class URLUbiquitousSharedItemRoleWrapper: NSObject {
  var wrappedInstance: URLUbiquitousSharedItemRole

  @available(macOS, introduced: 10.12)
  @objc static public var owner: URLUbiquitousSharedItemRoleWrapper {
    get {
      URLUbiquitousSharedItemRoleWrapper(URLUbiquitousSharedItemRole.owner)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var participant: URLUbiquitousSharedItemRoleWrapper {
    get {
      URLUbiquitousSharedItemRoleWrapper(URLUbiquitousSharedItemRole.participant)
    }
  }

  init(_ wrappedInstance: URLUbiquitousSharedItemRole) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = URLUbiquitousSharedItemRole(rawValue: rawValue)
  }

}

@objc public class NSValueTransformerNameWrapper: NSObject {
  var wrappedInstance: NSValueTransformerName

  @available(macOS, introduced: 10.3)
  @objc static public var isNilTransformerName: NSValueTransformerNameWrapper {
    get {
      NSValueTransformerNameWrapper(NSValueTransformerName.isNilTransformerName)
    }
  }

  @available(macOS, introduced: 10.3)
  @objc static public var isNotNilTransformerName: NSValueTransformerNameWrapper {
    get {
      NSValueTransformerNameWrapper(NSValueTransformerName.isNotNilTransformerName)
    }
  }

  @available(macOS, introduced: 10.3, deprecated: 10.14)
  @objc static public var keyedUnarchiveFromDataTransformerName: NSValueTransformerNameWrapper {
    get {
      NSValueTransformerNameWrapper(NSValueTransformerName.keyedUnarchiveFromDataTransformerName)
    }
  }

  @available(macOS, introduced: 10.3)
  @objc static public var negateBooleanTransformerName: NSValueTransformerNameWrapper {
    get {
      NSValueTransformerNameWrapper(NSValueTransformerName.negateBooleanTransformerName)
    }
  }

  @available(macOS, introduced: 10.14)
  @objc static public var secureUnarchiveFromDataTransformerName: NSValueTransformerNameWrapper {
    get {
      NSValueTransformerNameWrapper(NSValueTransformerName.secureUnarchiveFromDataTransformerName)
    }
  }

  @available(macOS, introduced: 10.3, deprecated: 10.14)
  @objc static public var unarchiveFromDataTransformerName: NSValueTransformerNameWrapper {
    get {
      NSValueTransformerNameWrapper(NSValueTransformerName.unarchiveFromDataTransformerName)
    }
  }

  init(_ wrappedInstance: NSValueTransformerName) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(rawValue: String) {
    wrappedInstance = NSValueTransformerName(rawValue: rawValue)
  }

  @objc init(_ rawValue: String) {
    wrappedInstance = NSValueTransformerName(rawValue)
  }

}

@objc public class NSAffineTransformWrapper: NSObject {
  var wrappedInstance: NSAffineTransform

  @objc public var transformStruct: NSAffineTransformStructWrapper {
    get {
      NSAffineTransformStructWrapper(wrappedInstance.transformStruct)
    }
    set {
      wrappedInstance.transformStruct = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: NSAffineTransform) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSAffineTransform()
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSAffineTransform(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func append(_ transform: AffineTransformWrapper) {
    return wrappedInstance.append(transform.wrappedInstance)
  }

  @objc public func invert() {
    return wrappedInstance.invert()
  }

  @objc public func prepend(_ transform: AffineTransformWrapper) {
    return wrappedInstance.prepend(transform.wrappedInstance)
  }

  @objc public func rotate(byDegrees angle: Double) {
    return wrappedInstance.rotate(byDegrees: angle)
  }

  @objc public func rotate(byRadians angle: Double) {
    return wrappedInstance.rotate(byRadians: angle)
  }

  @objc public func scale(by scale: Double) {
    return wrappedInstance.scale(by: scale)
  }

  @objc public func scaleX(by scaleX: Double, yBy scaleY: Double) {
    return wrappedInstance.scaleX(by: scaleX, yBy: scaleY)
  }

  @objc public func translateX(by deltaX: Double, yBy deltaY: Double) {
    return wrappedInstance.translateX(by: deltaX, yBy: deltaY)
  }

}

@objc public class NSAppleEventDescriptorWrapper: NSObject {
  var wrappedInstance: NSAppleEventDescriptor

  @objc public var booleanValue: Bool {
    get {
      wrappedInstance.booleanValue
    }
  }

  @objc public var data: DataWrapper {
    get {
      DataWrapper(wrappedInstance.data)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var dateValue: DateWrapper? {
    get {
      wrappedInstance.dateValue == nil ? nil : DateWrapper(wrappedInstance.dateValue!)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var doubleValue: Double {
    get {
      wrappedInstance.doubleValue
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var fileURLValue: URLWrapper? {
    get {
      wrappedInstance.fileURLValue == nil ? nil : URLWrapper(wrappedInstance.fileURLValue!)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var isRecordDescriptor: Bool {
    get {
      wrappedInstance.isRecordDescriptor
    }
  }

  @objc public var numberOfItems: Int {
    get {
      wrappedInstance.numberOfItems
    }
  }

  @objc public var stringValue: String? {
    get {
      wrappedInstance.stringValue
    }
  }

  init(_ wrappedInstance: NSAppleEventDescriptor) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.11)
  @objc init(applicationURL: URLWrapper) {
    wrappedInstance = NSAppleEventDescriptor(applicationURL: applicationURL.wrappedInstance)
  }

  @objc init(boolean: Bool) {
    wrappedInstance = NSAppleEventDescriptor(boolean: boolean)
  }

  @available(macOS, introduced: 10.11)
  @objc init(bundleIdentifier: String) {
    wrappedInstance = NSAppleEventDescriptor(bundleIdentifier: bundleIdentifier)
  }

  @available(macOS, introduced: 10.11)
  @objc init(date: DateWrapper) {
    wrappedInstance = NSAppleEventDescriptor(date: date.wrappedInstance)
  }

  @available(macOS, introduced: 10.11)
  @objc init(double doubleValue: Double) {
    wrappedInstance = NSAppleEventDescriptor(double: doubleValue)
  }

  @available(macOS, introduced: 10.11)
  @objc init(fileURL: URLWrapper) {
    wrappedInstance = NSAppleEventDescriptor(fileURL: fileURL.wrappedInstance)
  }

  @objc init(string: String) {
    wrappedInstance = NSAppleEventDescriptor(string: string)
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSAppleEventDescriptor(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public func currentProcess() -> NSAppleEventDescriptorWrapper {
    let result = NSAppleEventDescriptor.currentProcess()
    return NSAppleEventDescriptorWrapper(result)
  }

  @objc static public func list() -> NSAppleEventDescriptorWrapper {
    let result = NSAppleEventDescriptor.list()
    return NSAppleEventDescriptorWrapper(result)
  }

  @objc static public func null() -> NSAppleEventDescriptorWrapper {
    let result = NSAppleEventDescriptor.null()
    return NSAppleEventDescriptorWrapper(result)
  }

  @objc static public func record() -> NSAppleEventDescriptorWrapper {
    let result = NSAppleEventDescriptor.record()
    return NSAppleEventDescriptorWrapper(result)
  }

  @objc public func atIndex(_ index: Int) -> NSAppleEventDescriptorWrapper? {
    let result = wrappedInstance.atIndex(index)
    return result == nil ? nil : NSAppleEventDescriptorWrapper(result!)
  }

  @objc public func insert(_ descriptor: NSAppleEventDescriptorWrapper, at index: Int) {
    return wrappedInstance.insert(descriptor.wrappedInstance, at: index)
  }

  @objc public func remove(at index: Int) {
    return wrappedInstance.remove(at: index)
  }

  @available(macOS, introduced: 10.11)
  @objc public class SendOptionsWrapper: NSObject {
    var wrappedInstance: NSAppleEventDescriptor.SendOptions

    @available(macOS, introduced: 10.11)
    @objc static public var alwaysInteract: NSAppleEventDescriptorWrapper.SendOptionsWrapper {
      get {
        SendOptionsWrapper(NSAppleEventDescriptor.SendOptions.alwaysInteract)
      }
    }

    @available(macOS, introduced: 10.11)
    @objc static public var canInteract: NSAppleEventDescriptorWrapper.SendOptionsWrapper {
      get {
        SendOptionsWrapper(NSAppleEventDescriptor.SendOptions.canInteract)
      }
    }

    @available(macOS, introduced: 10.11)
    @objc static public var canSwitchLayer: NSAppleEventDescriptorWrapper.SendOptionsWrapper {
      get {
        SendOptionsWrapper(NSAppleEventDescriptor.SendOptions.canSwitchLayer)
      }
    }

    @available(macOS, introduced: 10.11)
    @objc static public var defaultOptions: NSAppleEventDescriptorWrapper.SendOptionsWrapper {
      get {
        SendOptionsWrapper(NSAppleEventDescriptor.SendOptions.defaultOptions)
      }
    }

    @available(macOS, introduced: 10.11)
    @objc static public var dontAnnotate: NSAppleEventDescriptorWrapper.SendOptionsWrapper {
      get {
        SendOptionsWrapper(NSAppleEventDescriptor.SendOptions.dontAnnotate)
      }
    }

    @available(macOS, introduced: 10.11)
    @objc static public var dontExecute: NSAppleEventDescriptorWrapper.SendOptionsWrapper {
      get {
        SendOptionsWrapper(NSAppleEventDescriptor.SendOptions.dontExecute)
      }
    }

    @available(macOS, introduced: 10.11)
    @objc static public var dontRecord: NSAppleEventDescriptorWrapper.SendOptionsWrapper {
      get {
        SendOptionsWrapper(NSAppleEventDescriptor.SendOptions.dontRecord)
      }
    }

    @available(macOS, introduced: 10.11)
    @objc static public var neverInteract: NSAppleEventDescriptorWrapper.SendOptionsWrapper {
      get {
        SendOptionsWrapper(NSAppleEventDescriptor.SendOptions.neverInteract)
      }
    }

    @available(macOS, introduced: 10.11)
    @objc static public var noReply: NSAppleEventDescriptorWrapper.SendOptionsWrapper {
      get {
        SendOptionsWrapper(NSAppleEventDescriptor.SendOptions.noReply)
      }
    }

    @available(macOS, introduced: 10.11)
    @objc static public var queueReply: NSAppleEventDescriptorWrapper.SendOptionsWrapper {
      get {
        SendOptionsWrapper(NSAppleEventDescriptor.SendOptions.queueReply)
      }
    }

    @available(macOS, introduced: 10.11)
    @objc static public var waitForReply: NSAppleEventDescriptorWrapper.SendOptionsWrapper {
      get {
        SendOptionsWrapper(NSAppleEventDescriptor.SendOptions.waitForReply)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSAppleEventDescriptor.SendOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSAppleEventDescriptor.SendOptions()
    }

  }

}

@objc public class NSAppleEventManagerWrapper: NSObject {
  var wrappedInstance: NSAppleEventManager

  @objc public var currentAppleEvent: NSAppleEventDescriptorWrapper? {
    get {
      wrappedInstance.currentAppleEvent == nil ? nil : NSAppleEventDescriptorWrapper(wrappedInstance.currentAppleEvent!)
    }
  }

  @objc public var currentReplyAppleEvent: NSAppleEventDescriptorWrapper? {
    get {
      wrappedInstance.currentReplyAppleEvent == nil ? nil : NSAppleEventDescriptorWrapper(wrappedInstance.currentReplyAppleEvent!)
    }
  }

  init(_ wrappedInstance: NSAppleEventManager) {
    self.wrappedInstance = wrappedInstance
  }

  @objc static public func shared() -> NSAppleEventManagerWrapper {
    let result = NSAppleEventManager.shared()
    return NSAppleEventManagerWrapper(result)
  }

}

@objc public class NSAppleScriptWrapper: NSObject {
  var wrappedInstance: NSAppleScript

  @available(macOS, introduced: 10.2)
  @objc static public var errorAppName: String {
    get {
      NSAppleScript.errorAppName
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var errorBriefMessage: String {
    get {
      NSAppleScript.errorBriefMessage
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var errorMessage: String {
    get {
      NSAppleScript.errorMessage
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var errorNumber: String {
    get {
      NSAppleScript.errorNumber
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var errorRange: String {
    get {
      NSAppleScript.errorRange
    }
  }

  @objc public var isCompiled: Bool {
    get {
      wrappedInstance.isCompiled
    }
  }

  @objc public var source: String? {
    get {
      wrappedInstance.source
    }
  }

  init(_ wrappedInstance: NSAppleScript) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(source: String) {
    if let instance = NSAppleScript(source: source) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.0, deprecated: 10.13)
@objc public class NSArchiverWrapper: NSObject {
  var wrappedInstance: NSArchiver

  @available(macOS, introduced: 10.0, deprecated: 10.13)
  @objc public var archiverData: NSMutableDataWrapper {
    get {
      NSMutableDataWrapper(wrappedInstance.archiverData)
    }
  }

  init(_ wrappedInstance: NSArchiver) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.0, deprecated: 10.13)
  @objc init(forWritingWith mdata: NSMutableDataWrapper) {
    wrappedInstance = NSArchiver(forWritingWith: mdata.wrappedInstance)
  }

  @available(macOS, introduced: 10.0, deprecated: 10.13)
  @objc public func classNameEncoded(forTrueClassName trueName: String) -> String? {
    return wrappedInstance.classNameEncoded(forTrueClassName: trueName)
  }

  @available(macOS, introduced: 10.0, deprecated: 10.13)
  @objc public func encodeClassName(_ trueName: String, intoClassName inArchiveName: String) {
    return wrappedInstance.encodeClassName(trueName, intoClassName: inArchiveName)
  }

}

@objc public class NSArrayWrapper: NSObject {
  var wrappedInstance: NSArray

  @objc public var count: Int {
    get {
      wrappedInstance.count
    }
  }

  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @objc public var sortedArrayHint: DataWrapper {
    get {
      DataWrapper(wrappedInstance.sortedArrayHint)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var underestimatedCount: Int {
    get {
      wrappedInstance.underestimatedCount
    }
  }

  init(_ wrappedInstance: NSArray) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSArray()
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSArray(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func componentsJoined(by separator: String) -> String {
    return wrappedInstance.componentsJoined(by: separator)
  }

  @objc public func objectEnumerator() -> NSEnumeratorWrapper {
    let result = wrappedInstance.objectEnumerator()
    return NSEnumeratorWrapper(result)
  }

  @objc public func removeObserver(_ observer: NSObject, forKeyPath keyPath: String) {
    return wrappedInstance.removeObserver(observer, forKeyPath: keyPath)
  }

  @objc public func removeObserver(_ observer: NSObject, fromObjectsAt indexes: IndexSetWrapper, forKeyPath keyPath: String) {
    return wrappedInstance.removeObserver(observer, fromObjectsAt: indexes.wrappedInstance, forKeyPath: keyPath)
  }

  @objc public func reverseObjectEnumerator() -> NSEnumeratorWrapper {
    let result = wrappedInstance.reverseObjectEnumerator()
    return NSEnumeratorWrapper(result)
  }

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public func write(toFile path: String, atomically useAuxiliaryFile: Bool) -> Bool {
    return wrappedInstance.write(toFile: path, atomically: useAuxiliaryFile)
  }

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public func write(to url: URLWrapper, atomically: Bool) -> Bool {
    return wrappedInstance.write(to: url.wrappedInstance, atomically: atomically)
  }

  @available(macOS, introduced: 10.13)
  @objc public func write(to url: URLWrapper) throws {
    return try wrappedInstance.write(to: url.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func makeIterator() -> NSFastEnumerationIteratorWrapper {
    let result = wrappedInstance.makeIterator()
    return NSFastEnumerationIteratorWrapper(result)
  }

}

@objc public class NSAssertionHandlerWrapper: NSObject {
  var wrappedInstance: NSAssertionHandler

  @objc static public var current: NSAssertionHandlerWrapper {
    get {
      NSAssertionHandlerWrapper(NSAssertionHandler.current)
    }
  }

  init(_ wrappedInstance: NSAssertionHandler) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.0)
@objc public class NSAttributedStringWrapper: NSObject {
  var wrappedInstance: NSAttributedString

  @objc public var length: Int {
    get {
      wrappedInstance.length
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var string: String {
    get {
      wrappedInstance.string
    }
  }

  init(_ wrappedInstance: NSAttributedString) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(attributedString attrStr: NSAttributedStringWrapper) {
    wrappedInstance = NSAttributedString(attributedString: attrStr.wrappedInstance)
  }

  @objc init(string str: String) {
    wrappedInstance = NSAttributedString(string: str)
  }

  @available(macOS, introduced: 10.0)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSAttributedString(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 12.0)
  @objc public func inflecting() -> NSAttributedStringWrapper {
    let result = wrappedInstance.inflecting()
    return NSAttributedStringWrapper(result)
  }

  @objc public func isEqual(to other: NSAttributedStringWrapper) -> Bool {
    return wrappedInstance.isEqual(to: other.wrappedInstance)
  }

  @objc public class EnumerationOptionsWrapper: NSObject {
    var wrappedInstance: NSAttributedString.EnumerationOptions

    @objc static public var longestEffectiveRangeNotRequired: NSAttributedStringWrapper.EnumerationOptionsWrapper {
      get {
        EnumerationOptionsWrapper(NSAttributedString.EnumerationOptions.longestEffectiveRangeNotRequired)
      }
    }

    @objc static public var reverse: NSAttributedStringWrapper.EnumerationOptionsWrapper {
      get {
        EnumerationOptionsWrapper(NSAttributedString.EnumerationOptions.reverse)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSAttributedString.EnumerationOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSAttributedString.EnumerationOptions()
    }

  }

  @objc public class KeyWrapper: NSObject {
    var wrappedInstance: NSAttributedString.Key

    @available(macOS, introduced: 12.0)
    @objc static public var alternateDescription: NSAttributedStringWrapper.KeyWrapper {
      get {
        KeyWrapper(NSAttributedString.Key.alternateDescription)
      }
    }

    @available(macOS, introduced: 12.0)
    @objc static public var imageURL: NSAttributedStringWrapper.KeyWrapper {
      get {
        KeyWrapper(NSAttributedString.Key.imageURL)
      }
    }

    @available(macOS, introduced: 14.0)
    @objc static public var agreeWithArgument: NSAttributedStringWrapper.KeyWrapper {
      get {
        KeyWrapper(NSAttributedString.Key.agreeWithArgument)
      }
    }

    @available(macOS, introduced: 14.0)
    @objc static public var agreeWithConcept: NSAttributedStringWrapper.KeyWrapper {
      get {
        KeyWrapper(NSAttributedString.Key.agreeWithConcept)
      }
    }

    @available(macOS, introduced: 12.0)
    @objc static public var inflectionAlternative: NSAttributedStringWrapper.KeyWrapper {
      get {
        KeyWrapper(NSAttributedString.Key.inflectionAlternative)
      }
    }

    @available(macOS, introduced: 14.0)
    @objc static public var referentConcept: NSAttributedStringWrapper.KeyWrapper {
      get {
        KeyWrapper(NSAttributedString.Key.referentConcept)
      }
    }

    @available(macOS, introduced: 12.0)
    @objc static public var inflectionRule: NSAttributedStringWrapper.KeyWrapper {
      get {
        KeyWrapper(NSAttributedString.Key.inflectionRule)
      }
    }

    @available(macOS, introduced: 12.0)
    @objc static public var inlinePresentationIntent: NSAttributedStringWrapper.KeyWrapper {
      get {
        KeyWrapper(NSAttributedString.Key.inlinePresentationIntent)
      }
    }

    @available(macOS, introduced: 12.0)
    @objc static public var languageIdentifier: NSAttributedStringWrapper.KeyWrapper {
      get {
        KeyWrapper(NSAttributedString.Key.languageIdentifier)
      }
    }

    @available(macOS, introduced: 15.0)
    @objc static public var localizedNumberFormat: NSAttributedStringWrapper.KeyWrapper {
      get {
        KeyWrapper(NSAttributedString.Key.localizedNumberFormat)
      }
    }

    @available(macOS, introduced: 13.0)
    @objc static public var markdownSourcePosition: NSAttributedStringWrapper.KeyWrapper {
      get {
        KeyWrapper(NSAttributedString.Key.markdownSourcePosition)
      }
    }

    @available(macOS, introduced: 12.0)
    @objc static public var morphology: NSAttributedStringWrapper.KeyWrapper {
      get {
        KeyWrapper(NSAttributedString.Key.morphology)
      }
    }

    @available(macOS, introduced: 12.0)
    @objc static public var presentationIntentAttributeName: NSAttributedStringWrapper.KeyWrapper {
      get {
        KeyWrapper(NSAttributedString.Key.presentationIntentAttributeName)
      }
    }

    @available(macOS, introduced: 12.0)
    @objc static public var replacementIndex: NSAttributedStringWrapper.KeyWrapper {
      get {
        KeyWrapper(NSAttributedString.Key.replacementIndex)
      }
    }

    init(_ wrappedInstance: NSAttributedString.Key) {
      self.wrappedInstance = wrappedInstance
    }

    @objc init(rawValue: String) {
      wrappedInstance = NSAttributedString.Key(rawValue: rawValue)
    }

    @objc init(_ rawValue: String) {
      wrappedInstance = NSAttributedString.Key(rawValue)
    }

  }

}

@available(macOS, introduced: 10.10)
@objc public class NSBackgroundActivitySchedulerWrapper: NSObject {
  var wrappedInstance: NSBackgroundActivityScheduler

  @available(macOS, introduced: 10.10)
  @objc public var identifier: String {
    get {
      wrappedInstance.identifier
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var interval: TimeInterval {
    get {
      wrappedInstance.interval
    }
    set {
      wrappedInstance.interval = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var repeats: Bool {
    get {
      wrappedInstance.repeats
    }
    set {
      wrappedInstance.repeats = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var shouldDefer: Bool {
    get {
      wrappedInstance.shouldDefer
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var tolerance: TimeInterval {
    get {
      wrappedInstance.tolerance
    }
    set {
      wrappedInstance.tolerance = newValue
    }
  }

  init(_ wrappedInstance: NSBackgroundActivityScheduler) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @objc init(identifier: String) {
    wrappedInstance = NSBackgroundActivityScheduler(identifier: identifier)
  }

  @available(macOS, introduced: 10.10)
  @objc public func invalidate() {
    return wrappedInstance.invalidate()
  }

}

@available(macOS, introduced: 10.6)
@objc public class BlockOperationWrapper: NSObject {
  var wrappedInstance: BlockOperation

  init(_ wrappedInstance: BlockOperation) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class BundleWrapper: NSObject {
  var wrappedInstance: Bundle

  @objc static public var didLoadNotification: NSNotificationWrapper.NameWrapper {
    get {
      NameWrapper(Bundle.didLoadNotification)
    }
  }

  @objc static public var main: BundleWrapper {
    get {
      BundleWrapper(Bundle.main)
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 15.0)
  @objc public var appStoreReceiptURL: URLWrapper? {
    get {
      wrappedInstance.appStoreReceiptURL == nil ? nil : URLWrapper(wrappedInstance.appStoreReceiptURL!)
    }
  }

  @objc public var builtInPlugInsPath: String? {
    get {
      wrappedInstance.builtInPlugInsPath
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var builtInPlugInsURL: URLWrapper? {
    get {
      wrappedInstance.builtInPlugInsURL == nil ? nil : URLWrapper(wrappedInstance.builtInPlugInsURL!)
    }
  }

  @objc public var bundleIdentifier: String? {
    get {
      wrappedInstance.bundleIdentifier
    }
  }

  @objc public var bundlePath: String {
    get {
      wrappedInstance.bundlePath
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var bundleURL: URLWrapper {
    get {
      URLWrapper(wrappedInstance.bundleURL)
    }
  }

  @objc public var developmentLocalization: String? {
    get {
      wrappedInstance.developmentLocalization
    }
  }

  @objc public var executablePath: String? {
    get {
      wrappedInstance.executablePath
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var executableURL: URLWrapper? {
    get {
      wrappedInstance.executableURL == nil ? nil : URLWrapper(wrappedInstance.executableURL!)
    }
  }

  @objc public var isLoaded: Bool {
    get {
      wrappedInstance.isLoaded
    }
  }

  @objc public var privateFrameworksPath: String? {
    get {
      wrappedInstance.privateFrameworksPath
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var privateFrameworksURL: URLWrapper? {
    get {
      wrappedInstance.privateFrameworksURL == nil ? nil : URLWrapper(wrappedInstance.privateFrameworksURL!)
    }
  }

  @objc public var resourcePath: String? {
    get {
      wrappedInstance.resourcePath
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var resourceURL: URLWrapper? {
    get {
      wrappedInstance.resourceURL == nil ? nil : URLWrapper(wrappedInstance.resourceURL!)
    }
  }

  @objc public var sharedFrameworksPath: String? {
    get {
      wrappedInstance.sharedFrameworksPath
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var sharedFrameworksURL: URLWrapper? {
    get {
      wrappedInstance.sharedFrameworksURL == nil ? nil : URLWrapper(wrappedInstance.sharedFrameworksURL!)
    }
  }

  @objc public var sharedSupportPath: String? {
    get {
      wrappedInstance.sharedSupportPath
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var sharedSupportURL: URLWrapper? {
    get {
      wrappedInstance.sharedSupportURL == nil ? nil : URLWrapper(wrappedInstance.sharedSupportURL!)
    }
  }

  init(_ wrappedInstance: Bundle) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(identifier: String) {
    if let instance = Bundle(identifier: identifier) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init?(path: String) {
    if let instance = Bundle(path: path) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public func url(forResource name: String?, withExtension ext: String?, subdirectory subpath: String?, in bundleURL: URLWrapper) -> URLWrapper? {
    let result = Bundle.url(forResource: name, withExtension: ext, subdirectory: subpath, in: bundleURL.wrappedInstance)
    return result == nil ? nil : URLWrapper(result!)
  }

  @objc static public func path(forResource name: String?, ofType ext: String?, inDirectory bundlePath: String) -> String? {
    return Bundle.path(forResource: name, ofType: ext, inDirectory: bundlePath)
  }

  @available(macOS, introduced: 10.6)
  @objc public func url(forAuxiliaryExecutable executableName: String) -> URLWrapper? {
    let result = wrappedInstance.url(forAuxiliaryExecutable: executableName)
    return result == nil ? nil : URLWrapper(result!)
  }

  @available(macOS, introduced: 10.6)
  @objc public func url(forResource name: String?, withExtension ext: String?) -> URLWrapper? {
    let result = wrappedInstance.url(forResource: name, withExtension: ext)
    return result == nil ? nil : URLWrapper(result!)
  }

  @available(macOS, introduced: 10.6)
  @objc public func url(forResource name: String?, withExtension ext: String?, subdirectory subpath: String?) -> URLWrapper? {
    let result = wrappedInstance.url(forResource: name, withExtension: ext, subdirectory: subpath)
    return result == nil ? nil : URLWrapper(result!)
  }

  @available(macOS, introduced: 10.6)
  @objc public func url(forResource name: String?, withExtension ext: String?, subdirectory subpath: String?, localization localizationName: String?) -> URLWrapper? {
    let result = wrappedInstance.url(forResource: name, withExtension: ext, subdirectory: subpath, localization: localizationName)
    return result == nil ? nil : URLWrapper(result!)
  }

  @objc public func load() -> Bool {
    return wrappedInstance.load()
  }

  @available(macOS, introduced: 10.5)
  @objc public func loadAndReturnError() throws {
    return try wrappedInstance.loadAndReturnError()
  }

  @objc public func localizedString(forKey key: String, value: String?, table tableName: String?) -> String {
    return wrappedInstance.localizedString(forKey: key, value: value, table: tableName)
  }

  @objc public func path(forAuxiliaryExecutable executableName: String) -> String? {
    return wrappedInstance.path(forAuxiliaryExecutable: executableName)
  }

  @objc public func path(forResource name: String?, ofType ext: String?) -> String? {
    return wrappedInstance.path(forResource: name, ofType: ext)
  }

  @objc public func path(forResource name: String?, ofType ext: String?, inDirectory subpath: String?, forLocalization localizationName: String?) -> String? {
    return wrappedInstance.path(forResource: name, ofType: ext, inDirectory: subpath, forLocalization: localizationName)
  }

  @available(macOS, introduced: 10.5)
  @objc public func preflight() throws {
    return try wrappedInstance.preflight()
  }

  @objc public func unload() -> Bool {
    return wrappedInstance.unload()
  }

}

@available(macOS, introduced: 10.8)
@objc public class ByteCountFormatterWrapper: NSObject {
  var wrappedInstance: ByteCountFormatter

  @available(macOS, introduced: 10.8)
  @objc public var isAdaptive: Bool {
    get {
      wrappedInstance.isAdaptive
    }
    set {
      wrappedInstance.isAdaptive = newValue
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var allowedUnits: ByteCountFormatterWrapper.UnitsWrapper {
    get {
      UnitsWrapper(wrappedInstance.allowedUnits)
    }
    set {
      wrappedInstance.allowedUnits = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var allowsNonnumericFormatting: Bool {
    get {
      wrappedInstance.allowsNonnumericFormatting
    }
    set {
      wrappedInstance.allowsNonnumericFormatting = newValue
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var includesActualByteCount: Bool {
    get {
      wrappedInstance.includesActualByteCount
    }
    set {
      wrappedInstance.includesActualByteCount = newValue
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var includesCount: Bool {
    get {
      wrappedInstance.includesCount
    }
    set {
      wrappedInstance.includesCount = newValue
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var includesUnit: Bool {
    get {
      wrappedInstance.includesUnit
    }
    set {
      wrappedInstance.includesUnit = newValue
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var zeroPadsFractionDigits: Bool {
    get {
      wrappedInstance.zeroPadsFractionDigits
    }
    set {
      wrappedInstance.zeroPadsFractionDigits = newValue
    }
  }

  init(_ wrappedInstance: ByteCountFormatter) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public class UnitsWrapper: NSObject {
    var wrappedInstance: ByteCountFormatter.Units

    @objc static public var useAll: ByteCountFormatterWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatter.Units.useAll)
      }
    }

    @objc static public var useBytes: ByteCountFormatterWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatter.Units.useBytes)
      }
    }

    @objc static public var useEB: ByteCountFormatterWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatter.Units.useEB)
      }
    }

    @objc static public var useGB: ByteCountFormatterWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatter.Units.useGB)
      }
    }

    @objc static public var useKB: ByteCountFormatterWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatter.Units.useKB)
      }
    }

    @objc static public var useMB: ByteCountFormatterWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatter.Units.useMB)
      }
    }

    @objc static public var usePB: ByteCountFormatterWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatter.Units.usePB)
      }
    }

    @objc static public var useTB: ByteCountFormatterWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatter.Units.useTB)
      }
    }

    @objc static public var useYBOrHigher: ByteCountFormatterWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatter.Units.useYBOrHigher)
      }
    }

    @objc static public var useZB: ByteCountFormatterWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatter.Units.useZB)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: ByteCountFormatter.Units) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = ByteCountFormatter.Units()
    }

  }

}

@available(macOS, introduced: 10.6)
@objc public class NSCacheWrapper: NSObject {
  var wrappedInstance: NSCache

  @available(macOS, introduced: 10.6)
  @objc public var countLimit: Int {
    get {
      wrappedInstance.countLimit
    }
    set {
      wrappedInstance.countLimit = newValue
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var evictsObjectsWithDiscardedContent: Bool {
    get {
      wrappedInstance.evictsObjectsWithDiscardedContent
    }
    set {
      wrappedInstance.evictsObjectsWithDiscardedContent = newValue
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var name: String {
    get {
      wrappedInstance.name
    }
    set {
      wrappedInstance.name = newValue
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var totalCostLimit: Int {
    get {
      wrappedInstance.totalCostLimit
    }
    set {
      wrappedInstance.totalCostLimit = newValue
    }
  }

  init(_ wrappedInstance: NSCache) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.6)
  @objc public func removeAllObjects() {
    return wrappedInstance.removeAllObjects()
  }

}

@available(macOS, introduced: 10.2)
@objc public class CachedURLResponseWrapper: NSObject {
  var wrappedInstance: CachedURLResponse

  @available(macOS, introduced: 10.2)
  @objc public var data: DataWrapper {
    get {
      DataWrapper(wrappedInstance.data)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var response: URLResponseWrapper {
    get {
      URLResponseWrapper(wrappedInstance.response)
    }
  }

  init(_ wrappedInstance: CachedURLResponse) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.2)
  @objc init(response: URLResponseWrapper, data: DataWrapper) {
    wrappedInstance = CachedURLResponse(response: response.wrappedInstance, data: data.wrappedInstance)
  }

  @available(macOS, introduced: 10.2)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = CachedURLResponse(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@objc public class NSCalendarWrapper: NSObject {
  var wrappedInstance: NSCalendar

  @available(macOS, introduced: 10.5)
  @objc static public var autoupdatingCurrent: CalendarWrapper {
    get {
      CalendarWrapper(NSCalendar.autoupdatingCurrent)
    }
  }

  @objc static public var current: CalendarWrapper {
    get {
      CalendarWrapper(NSCalendar.current)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var amSymbol: String {
    get {
      wrappedInstance.amSymbol
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var pmSymbol: String {
    get {
      wrappedInstance.pmSymbol
    }
  }

  @objc public var calendarIdentifier: NSCalendarWrapper.IdentifierWrapper {
    get {
      IdentifierWrapper(wrappedInstance.calendarIdentifier)
    }
  }

  @objc public var firstWeekday: Int {
    get {
      wrappedInstance.firstWeekday
    }
    set {
      wrappedInstance.firstWeekday = newValue
    }
  }

  @objc public var locale: LocaleWrapper? {
    get {
      wrappedInstance.locale == nil ? nil : LocaleWrapper(wrappedInstance.locale!)
    }
    set {
      wrappedInstance.locale = newValue?.wrappedInstance
    }
  }

  @objc public var minimumDaysInFirstWeek: Int {
    get {
      wrappedInstance.minimumDaysInFirstWeek
    }
    set {
      wrappedInstance.minimumDaysInFirstWeek = newValue
    }
  }

  @objc public var timeZone: TimeZoneWrapper {
    get {
      TimeZoneWrapper(wrappedInstance.timeZone)
    }
    set {
      wrappedInstance.timeZone = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: NSCalendar) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.9)
  @objc init?(identifier calendarIdentifierConstant: NSCalendarWrapper.IdentifierWrapper) {
    if let instance = NSCalendar(identifier: calendarIdentifierConstant.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init?(calendarIdentifier ident: NSCalendarWrapper.IdentifierWrapper) {
    if let instance = NSCalendar(calendarIdentifier: ident.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSCalendar(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public func component(_ unit: NSCalendarWrapper.UnitWrapper, from date: DateWrapper) -> Int {
    return wrappedInstance.component(unit.wrappedInstance, from: date.wrappedInstance)
  }

  @objc public func components(_ unitFlags: NSCalendarWrapper.UnitWrapper, from date: DateWrapper) -> DateComponentsWrapper {
    let result = wrappedInstance.components(unitFlags.wrappedInstance, from: date.wrappedInstance)
    return DateComponentsWrapper(result)
  }

  @available(macOS, introduced: 10.9)
  @objc public func components(in timezone: TimeZoneWrapper, from date: DateWrapper) -> DateComponentsWrapper {
    let result = wrappedInstance.components(in: timezone.wrappedInstance, from: date.wrappedInstance)
    return DateComponentsWrapper(result)
  }

  @available(macOS, introduced: 10.9)
  @objc public func date(_ date: DateWrapper, matchesComponents components: DateComponentsWrapper) -> Bool {
    return wrappedInstance.date(date.wrappedInstance, matchesComponents: components.wrappedInstance)
  }

  @objc public func date(from comps: DateComponentsWrapper) -> DateWrapper? {
    let result = wrappedInstance.date(from: comps.wrappedInstance)
    return result == nil ? nil : DateWrapper(result!)
  }

  @available(macOS, introduced: 10.9)
  @objc public func date(era eraValue: Int, year yearValue: Int, month monthValue: Int, day dayValue: Int, hour hourValue: Int, minute minuteValue: Int, second secondValue: Int, nanosecond nanosecondValue: Int) -> DateWrapper? {
    let result = wrappedInstance.date(era: eraValue, year: yearValue, month: monthValue, day: dayValue, hour: hourValue, minute: minuteValue, second: secondValue, nanosecond: nanosecondValue)
    return result == nil ? nil : DateWrapper(result!)
  }

  @available(macOS, introduced: 10.9)
  @objc public func date(era eraValue: Int, yearForWeekOfYear yearValue: Int, weekOfYear weekValue: Int, weekday weekdayValue: Int, hour hourValue: Int, minute minuteValue: Int, second secondValue: Int, nanosecond nanosecondValue: Int) -> DateWrapper? {
    let result = wrappedInstance.date(era: eraValue, yearForWeekOfYear: yearValue, weekOfYear: weekValue, weekday: weekdayValue, hour: hourValue, minute: minuteValue, second: secondValue, nanosecond: nanosecondValue)
    return result == nil ? nil : DateWrapper(result!)
  }

  @available(macOS, introduced: 10.9)
  @objc public func isDate(_ date1: DateWrapper, equalTo date2: DateWrapper, toUnitGranularity unit: NSCalendarWrapper.UnitWrapper) -> Bool {
    return wrappedInstance.isDate(date1.wrappedInstance, equalTo: date2.wrappedInstance, toUnitGranularity: unit.wrappedInstance)
  }

  @available(macOS, introduced: 10.9)
  @objc public func isDate(_ date1: DateWrapper, inSameDayAs date2: DateWrapper) -> Bool {
    return wrappedInstance.isDate(date1.wrappedInstance, inSameDayAs: date2.wrappedInstance)
  }

  @available(macOS, introduced: 10.9)
  @objc public func isDateInToday(_ date: DateWrapper) -> Bool {
    return wrappedInstance.isDateInToday(date.wrappedInstance)
  }

  @available(macOS, introduced: 10.9)
  @objc public func isDateInTomorrow(_ date: DateWrapper) -> Bool {
    return wrappedInstance.isDateInTomorrow(date.wrappedInstance)
  }

  @available(macOS, introduced: 10.9)
  @objc public func isDateInWeekend(_ date: DateWrapper) -> Bool {
    return wrappedInstance.isDateInWeekend(date.wrappedInstance)
  }

  @available(macOS, introduced: 10.9)
  @objc public func isDateInYesterday(_ date: DateWrapper) -> Bool {
    return wrappedInstance.isDateInYesterday(date.wrappedInstance)
  }

  @objc public func ordinality(of smaller: NSCalendarWrapper.UnitWrapper, in larger: NSCalendarWrapper.UnitWrapper, for date: DateWrapper) -> Int {
    return wrappedInstance.ordinality(of: smaller.wrappedInstance, in: larger.wrappedInstance, for: date.wrappedInstance)
  }

  @available(macOS, introduced: 10.9)
  @objc public func startOfDay(for date: DateWrapper) -> DateWrapper {
    let result = wrappedInstance.startOfDay(for: date.wrappedInstance)
    return DateWrapper(result)
  }

  @objc public class OptionsWrapper: NSObject {
    var wrappedInstance: NSCalendar.Options

    @available(macOS, introduced: 10.9)
    @objc static public var matchFirst: NSCalendarWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSCalendar.Options.matchFirst)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var matchLast: NSCalendarWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSCalendar.Options.matchLast)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var matchNextTime: NSCalendarWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSCalendar.Options.matchNextTime)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var matchNextTimePreservingSmallerUnits: NSCalendarWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSCalendar.Options.matchNextTimePreservingSmallerUnits)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var matchPreviousTimePreservingSmallerUnits: NSCalendarWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSCalendar.Options.matchPreviousTimePreservingSmallerUnits)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var matchStrictly: NSCalendarWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSCalendar.Options.matchStrictly)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var searchBackwards: NSCalendarWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSCalendar.Options.searchBackwards)
      }
    }

    @objc static public var wrapComponents: NSCalendarWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSCalendar.Options.wrapComponents)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSCalendar.Options) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSCalendar.Options()
    }

  }

  @objc public class UnitWrapper: NSObject {
    var wrappedInstance: NSCalendar.Unit

    @available(macOS, introduced: 10.7, deprecated: 10.10)
    @objc static public var NSCalendarCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSCalendarCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var calendar: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.calendar)
      }
    }

    @objc static public var day: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.day)
      }
    }

    @available(macOS, introduced: 15.0)
    @objc static public var dayOfYear: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.dayOfYear)
      }
    }

    @objc static public var era: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.era)
      }
    }

    @objc static public var hour: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.hour)
      }
    }

    @objc static public var minute: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.minute)
      }
    }

    @objc static public var month: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.month)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var nanosecond: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.nanosecond)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var quarter: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.quarter)
      }
    }

    @objc static public var second: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.second)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var timeZone: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.timeZone)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var weekOfMonth: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.weekOfMonth)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var weekOfYear: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.weekOfYear)
      }
    }

    @objc static public var weekday: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.weekday)
      }
    }

    @objc static public var weekdayOrdinal: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.weekdayOrdinal)
      }
    }

    @objc static public var year: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.year)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var yearForWeekOfYear: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.yearForWeekOfYear)
      }
    }

    @available(macOS, introduced: 10.4, deprecated: 10.10)
    @objc static public var NSDayCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSDayCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.4, deprecated: 10.10)
    @objc static public var NSEraCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSEraCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.4, deprecated: 10.10)
    @objc static public var NSHourCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSHourCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.4, deprecated: 10.10)
    @objc static public var NSMinuteCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSMinuteCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.4, deprecated: 10.10)
    @objc static public var NSMonthCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSMonthCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.6, deprecated: 10.10)
    @objc static public var NSQuarterCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSQuarterCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.4, deprecated: 10.10)
    @objc static public var NSSecondCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSSecondCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.7, deprecated: 10.10)
    @objc static public var NSTimeZoneCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSTimeZoneCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.4, deprecated: 10.10)
    @objc static public var NSWeekCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSWeekCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.7, deprecated: 10.10)
    @objc static public var NSWeekOfMonthCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSWeekOfMonthCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.7, deprecated: 10.10)
    @objc static public var NSWeekOfYearCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSWeekOfYearCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.4, deprecated: 10.10)
    @objc static public var NSWeekdayCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSWeekdayCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.4, deprecated: 10.10)
    @objc static public var NSWeekdayOrdinalCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSWeekdayOrdinalCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.4, deprecated: 10.10)
    @objc static public var NSYearCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSYearCalendarUnit)
      }
    }

    @available(macOS, introduced: 10.7, deprecated: 10.10)
    @objc static public var NSYearForWeekOfYearCalendarUnit: NSCalendarWrapper.UnitWrapper {
      get {
        UnitWrapper(NSCalendar.Unit.NSYearForWeekOfYearCalendarUnit)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSCalendar.Unit) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSCalendar.Unit()
    }

  }

  @objc public class IdentifierWrapper: NSObject {
    var wrappedInstance: NSCalendar.Identifier

    @available(macOS, introduced: 10.6)
    @objc static public var buddhist: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.buddhist)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var chinese: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.chinese)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var coptic: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.coptic)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var ethiopicAmeteAlem: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.ethiopicAmeteAlem)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var ethiopicAmeteMihret: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.ethiopicAmeteMihret)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var gregorian: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.gregorian)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var hebrew: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.hebrew)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var ISO8601: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.ISO8601)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var indian: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.indian)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var islamic: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.islamic)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var islamicCivil: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.islamicCivil)
      }
    }

    @available(macOS, introduced: 10.10)
    @objc static public var islamicTabular: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.islamicTabular)
      }
    }

    @available(macOS, introduced: 10.10)
    @objc static public var islamicUmmAlQura: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.islamicUmmAlQura)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var japanese: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.japanese)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var persian: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.persian)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var republicOfChina: NSCalendarWrapper.IdentifierWrapper {
      get {
        IdentifierWrapper(NSCalendar.Identifier.republicOfChina)
      }
    }

    init(_ wrappedInstance: NSCalendar.Identifier) {
      self.wrappedInstance = wrappedInstance
    }

    @objc init(rawValue: String) {
      wrappedInstance = NSCalendar.Identifier(rawValue: rawValue)
    }

    @objc init(_ rawValue: String) {
      wrappedInstance = NSCalendar.Identifier(rawValue)
    }

  }

}

@objc public class NSCharacterSetWrapper: NSObject {
  var wrappedInstance: NSCharacterSet

  @available(macOS, introduced: 10.9)
  @objc static public var urlFragmentAllowed: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.urlFragmentAllowed)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var urlHostAllowed: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.urlHostAllowed)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var urlPasswordAllowed: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.urlPasswordAllowed)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var urlPathAllowed: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.urlPathAllowed)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var urlQueryAllowed: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.urlQueryAllowed)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var urlUserAllowed: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.urlUserAllowed)
    }
  }

  @objc static public var alphanumerics: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.alphanumerics)
    }
  }

  @objc static public var capitalizedLetters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.capitalizedLetters)
    }
  }

  @objc static public var controlCharacters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.controlCharacters)
    }
  }

  @objc static public var decimalDigits: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.decimalDigits)
    }
  }

  @objc static public var decomposables: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.decomposables)
    }
  }

  @objc static public var illegalCharacters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.illegalCharacters)
    }
  }

  @objc static public var letters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.letters)
    }
  }

  @objc static public var lowercaseLetters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.lowercaseLetters)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var newlines: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.newlines)
    }
  }

  @objc static public var nonBaseCharacters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.nonBaseCharacters)
    }
  }

  @objc static public var punctuationCharacters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.punctuationCharacters)
    }
  }

  @objc static public var symbols: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.symbols)
    }
  }

  @objc static public var uppercaseLetters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.uppercaseLetters)
    }
  }

  @objc static public var whitespacesAndNewlines: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.whitespacesAndNewlines)
    }
  }

  @objc static public var whitespaces: CharacterSetWrapper {
    get {
      CharacterSetWrapper(NSCharacterSet.whitespaces)
    }
  }

  @objc public var bitmapRepresentation: DataWrapper {
    get {
      DataWrapper(wrappedInstance.bitmapRepresentation)
    }
  }

  @objc public var inverted: CharacterSetWrapper {
    get {
      CharacterSetWrapper(wrappedInstance.inverted)
    }
  }

  init(_ wrappedInstance: NSCharacterSet) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(bitmapRepresentation data: DataWrapper) {
    wrappedInstance = NSCharacterSet(bitmapRepresentation: data.wrappedInstance)
  }

  @objc init(charactersIn aString: String) {
    wrappedInstance = NSCharacterSet(charactersIn: aString)
  }

  @objc init?(contentsOfFile fName: String) {
    if let instance = NSCharacterSet(contentsOfFile: fName) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init(coder: NSCoderWrapper) {
    wrappedInstance = NSCharacterSet(coder: coder.wrappedInstance)
  }

  @objc public func isSuperset(of theOtherSet: CharacterSetWrapper) -> Bool {
    return wrappedInstance.isSuperset(of: theOtherSet.wrappedInstance)
  }

}

@objc public class NSClassDescriptionWrapper: NSObject {
  var wrappedInstance: NSClassDescription

  init(_ wrappedInstance: NSClassDescription) {
    self.wrappedInstance = wrappedInstance
  }

  @objc static public func invalidateClassDescriptionCache() {
    return NSClassDescription.invalidateClassDescriptionCache()
  }

  @objc public func inverse(forRelationshipKey relationshipKey: String) -> String? {
    return wrappedInstance.inverse(forRelationshipKey: relationshipKey)
  }

}

@objc public class NSCloneCommandWrapper: NSObject {
  var wrappedInstance: NSCloneCommand

  @objc public var keySpecifier: NSScriptObjectSpecifierWrapper {
    get {
      NSScriptObjectSpecifierWrapper(wrappedInstance.keySpecifier)
    }
  }

  init(_ wrappedInstance: NSCloneCommand) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func setReceiversSpecifier(_ receiversRef: NSScriptObjectSpecifierWrapper?) {
    return wrappedInstance.setReceiversSpecifier(receiversRef?.wrappedInstance)
  }

}

@objc public class NSCloseCommandWrapper: NSObject {
  var wrappedInstance: NSCloseCommand

  init(_ wrappedInstance: NSCloseCommand) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSCoderWrapper: NSObject {
  var wrappedInstance: NSCoder

  @objc public var allowsKeyedCoding: Bool {
    get {
      wrappedInstance.allowsKeyedCoding
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var requiresSecureCoding: Bool {
    get {
      wrappedInstance.requiresSecureCoding
    }
  }

  init(_ wrappedInstance: NSCoder) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func containsValue(forKey key: String) -> Bool {
    return wrappedInstance.containsValue(forKey: key)
  }

  @objc public func decodeBool(forKey key: String) -> Bool {
    return wrappedInstance.decodeBool(forKey: key)
  }

  @objc public func decodeData() -> DataWrapper? {
    let result = wrappedInstance.decodeData()
    return result == nil ? nil : DataWrapper(result!)
  }

  @objc public func decodeDouble(forKey key: String) -> Double {
    return wrappedInstance.decodeDouble(forKey: key)
  }

  @objc public func decodeFloat(forKey key: String) -> Float {
    return wrappedInstance.decodeFloat(forKey: key)
  }

  @available(macOS, introduced: 10.5)
  @objc public func decodeInteger(forKey key: String) -> Int {
    return wrappedInstance.decodeInteger(forKey: key)
  }

  @objc public func encode(_ data: DataWrapper) {
    return wrappedInstance.encode(data.wrappedInstance)
  }

  @objc public func encode(_ value: Double, forKey key: String) {
    return wrappedInstance.encode(value, forKey: key)
  }

  @objc public func version(forClassName className: String) -> Int {
    return wrappedInstance.version(forClassName: className)
  }

}

@available(macOS, introduced: 10.4)
@objc public class NSComparisonPredicateWrapper: NSObject {
  var wrappedInstance: NSComparisonPredicate

  @available(macOS, introduced: 10.4)
  @objc public var leftExpression: NSExpressionWrapper {
    get {
      NSExpressionWrapper(wrappedInstance.leftExpression)
    }
  }

  @available(macOS, introduced: 10.4)
  @objc public var options: NSComparisonPredicateWrapper.OptionsWrapper {
    get {
      OptionsWrapper(wrappedInstance.options)
    }
  }

  @available(macOS, introduced: 10.4)
  @objc public var rightExpression: NSExpressionWrapper {
    get {
      NSExpressionWrapper(wrappedInstance.rightExpression)
    }
  }

  init(_ wrappedInstance: NSComparisonPredicate) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.4)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSComparisonPredicate(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public class OptionsWrapper: NSObject {
    var wrappedInstance: NSComparisonPredicate.Options

    @objc static public var caseInsensitive: NSComparisonPredicateWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSComparisonPredicate.Options.caseInsensitive)
      }
    }

    @objc static public var diacriticInsensitive: NSComparisonPredicateWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSComparisonPredicate.Options.diacriticInsensitive)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var normalized: NSComparisonPredicateWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSComparisonPredicate.Options.normalized)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSComparisonPredicate.Options) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSComparisonPredicate.Options()
    }

  }

}

@available(macOS, introduced: 10.4)
@objc public class NSCompoundPredicateWrapper: NSObject {
  var wrappedInstance: NSCompoundPredicate

  init(_ wrappedInstance: NSCompoundPredicate) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.4)
  @objc init(notPredicateWithSubpredicate predicate: NSPredicateWrapper) {
    wrappedInstance = NSCompoundPredicate(notPredicateWithSubpredicate: predicate.wrappedInstance)
  }

  @available(macOS, introduced: 10.4)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSCompoundPredicate(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.5)
@objc public class NSConditionWrapper: NSObject {
  var wrappedInstance: NSCondition

  @available(macOS, introduced: 10.5)
  @objc public var name: String? {
    get {
      wrappedInstance.name
    }
    set {
      wrappedInstance.name = newValue
    }
  }

  init(_ wrappedInstance: NSCondition) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.5)
  @objc public func broadcast() {
    return wrappedInstance.broadcast()
  }

  @available(macOS, introduced: 10.5)
  @objc public func signal() {
    return wrappedInstance.signal()
  }

  @available(macOS, introduced: 10.5)
  @objc public func wait() {
    return wrappedInstance.wait()
  }

  @available(macOS, introduced: 10.5)
  @objc public func wait(until limit: DateWrapper) -> Bool {
    return wrappedInstance.wait(until: limit.wrappedInstance)
  }

}

@objc public class NSConditionLockWrapper: NSObject {
  var wrappedInstance: NSConditionLock

  @objc public var condition: Int {
    get {
      wrappedInstance.condition
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var name: String? {
    get {
      wrappedInstance.name
    }
    set {
      wrappedInstance.name = newValue
    }
  }

  init(_ wrappedInstance: NSConditionLock) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(condition: Int) {
    wrappedInstance = NSConditionLock(condition: condition)
  }

  @objc public func lock(before limit: DateWrapper) -> Bool {
    return wrappedInstance.lock(before: limit.wrappedInstance)
  }

  @objc public func lock(whenCondition condition: Int) {
    return wrappedInstance.lock(whenCondition: condition)
  }

  @objc public func lock(whenCondition condition: Int, before limit: DateWrapper) -> Bool {
    return wrappedInstance.lock(whenCondition: condition, before: limit.wrappedInstance)
  }

  @objc public func `try`() -> Bool {
    return wrappedInstance.`try`()
  }

  @objc public func tryLock(whenCondition condition: Int) -> Bool {
    return wrappedInstance.tryLock(whenCondition: condition)
  }

  @objc public func unlock(withCondition condition: Int) {
    return wrappedInstance.unlock(withCondition: condition)
  }

}

@objc public class NSCountCommandWrapper: NSObject {
  var wrappedInstance: NSCountCommand

  init(_ wrappedInstance: NSCountCommand) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSCountedSetWrapper: NSObject {
  var wrappedInstance: NSCountedSet

  init(_ wrappedInstance: NSCountedSet) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(capacity numItems: Int) {
    wrappedInstance = NSCountedSet(capacity: numItems)
  }

  @objc public func objectEnumerator() -> NSEnumeratorWrapper {
    let result = wrappedInstance.objectEnumerator()
    return NSEnumeratorWrapper(result)
  }

}

@objc public class NSCreateCommandWrapper: NSObject {
  var wrappedInstance: NSCreateCommand

  @objc public var createClassDescription: NSScriptClassDescriptionWrapper {
    get {
      NSScriptClassDescriptionWrapper(wrappedInstance.createClassDescription)
    }
  }

  init(_ wrappedInstance: NSCreateCommand) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSDataWrapper: NSObject {
  var wrappedInstance: NSData

  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @objc public var length: Int {
    get {
      wrappedInstance.length
    }
  }

  @objc public var underestimatedCount: Int {
    get {
      wrappedInstance.underestimatedCount
    }
  }

  @objc public var count: Int {
    get {
      wrappedInstance.count
    }
  }

  @objc public var isEmpty: Bool {
    get {
      wrappedInstance.isEmpty
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var startIndex: Int {
    get {
      wrappedInstance.startIndex
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var endIndex: Int {
    get {
      wrappedInstance.endIndex
    }
  }

  init(_ wrappedInstance: NSData) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(contentsOfFile path: String) {
    if let instance = NSData(contentsOfFile: path) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.0, deprecated: 10.10)
  @objc init?(contentsOfMappedFile path: String) {
    if let instance = NSData(contentsOfMappedFile: path) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init(data: DataWrapper) {
    wrappedInstance = NSData(data: data.wrappedInstance)
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSData(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func isEqual(to other: DataWrapper) -> Bool {
    return wrappedInstance.isEqual(to: other.wrappedInstance)
  }

  @objc public func write(toFile path: String, atomically useAuxiliaryFile: Bool) -> Bool {
    return wrappedInstance.write(toFile: path, atomically: useAuxiliaryFile)
  }

  @objc public func write(to url: URLWrapper, atomically: Bool) -> Bool {
    return wrappedInstance.write(to: url.wrappedInstance, atomically: atomically)
  }

  @available(macOS, introduced: 10.9)
  @objc public class Base64DecodingOptionsWrapper: NSObject {
    var wrappedInstance: NSData.Base64DecodingOptions

    @available(macOS, introduced: 10.9)
    @objc static public var ignoreUnknownCharacters: NSDataWrapper.Base64DecodingOptionsWrapper {
      get {
        Base64DecodingOptionsWrapper(NSData.Base64DecodingOptions.ignoreUnknownCharacters)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSData.Base64DecodingOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSData.Base64DecodingOptions()
    }

  }

  @available(macOS, introduced: 10.9)
  @objc public class Base64EncodingOptionsWrapper: NSObject {
    var wrappedInstance: NSData.Base64EncodingOptions

    @available(macOS, introduced: 10.9)
    @objc static public var lineLength64Characters: NSDataWrapper.Base64EncodingOptionsWrapper {
      get {
        Base64EncodingOptionsWrapper(NSData.Base64EncodingOptions.lineLength64Characters)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var lineLength76Characters: NSDataWrapper.Base64EncodingOptionsWrapper {
      get {
        Base64EncodingOptionsWrapper(NSData.Base64EncodingOptions.lineLength76Characters)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var endLineWithCarriageReturn: NSDataWrapper.Base64EncodingOptionsWrapper {
      get {
        Base64EncodingOptionsWrapper(NSData.Base64EncodingOptions.endLineWithCarriageReturn)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var endLineWithLineFeed: NSDataWrapper.Base64EncodingOptionsWrapper {
      get {
        Base64EncodingOptionsWrapper(NSData.Base64EncodingOptions.endLineWithLineFeed)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSData.Base64EncodingOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSData.Base64EncodingOptions()
    }

  }

  @objc public class ReadingOptionsWrapper: NSObject {
    var wrappedInstance: NSData.ReadingOptions

    @available(macOS, introduced: 10.0, deprecated: 100000)
    @objc static public var dataReadingMapped: NSDataWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(NSData.ReadingOptions.dataReadingMapped)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var alwaysMapped: NSDataWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(NSData.ReadingOptions.alwaysMapped)
      }
    }

    @objc static public var mappedIfSafe: NSDataWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(NSData.ReadingOptions.mappedIfSafe)
      }
    }

    @objc static public var uncached: NSDataWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(NSData.ReadingOptions.uncached)
      }
    }

    @available(macOS, introduced: 10.0, deprecated: 100000)
    @objc static public var mappedRead: NSDataWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(NSData.ReadingOptions.mappedRead)
      }
    }

    @available(macOS, introduced: 10.0, deprecated: 100000)
    @objc static public var uncachedRead: NSDataWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(NSData.ReadingOptions.uncachedRead)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSData.ReadingOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSData.ReadingOptions()
    }

  }

  @available(macOS, introduced: 10.6)
  @objc public class SearchOptionsWrapper: NSObject {
    var wrappedInstance: NSData.SearchOptions

    @available(macOS, introduced: 10.6)
    @objc static public var anchored: NSDataWrapper.SearchOptionsWrapper {
      get {
        SearchOptionsWrapper(NSData.SearchOptions.anchored)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var backwards: NSDataWrapper.SearchOptionsWrapper {
      get {
        SearchOptionsWrapper(NSData.SearchOptions.backwards)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSData.SearchOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSData.SearchOptions()
    }

  }

  @objc public class WritingOptionsWrapper: NSObject {
    var wrappedInstance: NSData.WritingOptions

    @available(macOS, introduced: 10.0, deprecated: 100000)
    @objc static public var atomicWrite: NSDataWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(NSData.WritingOptions.atomicWrite)
      }
    }

    @objc static public var atomic: NSDataWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(NSData.WritingOptions.atomic)
      }
    }

    @available(macOS, introduced: 11.0)
    @objc static public var completeFileProtection: NSDataWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(NSData.WritingOptions.completeFileProtection)
      }
    }

    @available(macOS, introduced: 11.0)
    @objc static public var completeFileProtectionUnlessOpen: NSDataWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(NSData.WritingOptions.completeFileProtectionUnlessOpen)
      }
    }

    @available(macOS, introduced: 11.0)
    @objc static public var completeFileProtectionUntilFirstUserAuthentication: NSDataWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(NSData.WritingOptions.completeFileProtectionUntilFirstUserAuthentication)
      }
    }

    @available(macOS, introduced: 11.0)
    @objc static public var fileProtectionMask: NSDataWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(NSData.WritingOptions.fileProtectionMask)
      }
    }

    @available(macOS, introduced: 11.0)
    @objc static public var noFileProtection: NSDataWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(NSData.WritingOptions.noFileProtection)
      }
    }

    @available(macOS, introduced: 10.8)
    @objc static public var withoutOverwriting: NSDataWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(NSData.WritingOptions.withoutOverwriting)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSData.WritingOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSData.WritingOptions()
    }

  }

}

@available(macOS, introduced: 10.7)
@objc public class NSDataDetectorWrapper: NSObject {
  var wrappedInstance: NSDataDetector

  init(_ wrappedInstance: NSDataDetector) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSDateWrapper: NSObject {
  var wrappedInstance: NSDate

  @objc static public var distantFuture: DateWrapper {
    get {
      DateWrapper(NSDate.distantFuture)
    }
  }

  @objc static public var distantPast: DateWrapper {
    get {
      DateWrapper(NSDate.distantPast)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var now: DateWrapper {
    get {
      DateWrapper(NSDate.now)
    }
  }

  @objc static public var timeIntervalSinceReferenceDate: TimeInterval {
    get {
      NSDate.timeIntervalSinceReferenceDate
    }
  }

  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @objc public var timeIntervalSince1970: TimeInterval {
    get {
      wrappedInstance.timeIntervalSince1970
    }
  }

  @objc public var timeIntervalSinceNow: TimeInterval {
    get {
      wrappedInstance.timeIntervalSinceNow
    }
  }

  @objc public var timeIntervalSinceReferenceDate: TimeInterval {
    get {
      wrappedInstance.timeIntervalSinceReferenceDate
    }
  }

  init(_ wrappedInstance: NSDate) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSDate()
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSDate(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init(timeIntervalSinceReferenceDate ti: TimeInterval) {
    wrappedInstance = NSDate(timeIntervalSinceReferenceDate: ti)
  }

  @objc public func earlierDate(_ anotherDate: DateWrapper) -> DateWrapper {
    let result = wrappedInstance.earlierDate(anotherDate.wrappedInstance)
    return DateWrapper(result)
  }

  @objc public func isEqual(to otherDate: DateWrapper) -> Bool {
    return wrappedInstance.isEqual(to: otherDate.wrappedInstance)
  }

  @objc public func laterDate(_ anotherDate: DateWrapper) -> DateWrapper {
    let result = wrappedInstance.laterDate(anotherDate.wrappedInstance)
    return DateWrapper(result)
  }

  @objc public func timeIntervalSince(_ anotherDate: DateWrapper) -> TimeInterval {
    return wrappedInstance.timeIntervalSince(anotherDate.wrappedInstance)
  }

}

@objc public class NSDateComponentsWrapper: NSObject {
  var wrappedInstance: NSDateComponents

  @available(macOS, introduced: 10.7)
  @objc public var calendar: CalendarWrapper? {
    get {
      wrappedInstance.calendar == nil ? nil : CalendarWrapper(wrappedInstance.calendar!)
    }
    set {
      wrappedInstance.calendar = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var date: DateWrapper? {
    get {
      wrappedInstance.date == nil ? nil : DateWrapper(wrappedInstance.date!)
    }
  }

  @objc public var day: Int {
    get {
      wrappedInstance.day
    }
    set {
      wrappedInstance.day = newValue
    }
  }

  @available(macOS, introduced: 15.0)
  @objc public var dayOfYear: Int {
    get {
      wrappedInstance.dayOfYear
    }
    set {
      wrappedInstance.dayOfYear = newValue
    }
  }

  @objc public var era: Int {
    get {
      wrappedInstance.era
    }
    set {
      wrappedInstance.era = newValue
    }
  }

  @objc public var hour: Int {
    get {
      wrappedInstance.hour
    }
    set {
      wrappedInstance.hour = newValue
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var isLeapMonth: Bool {
    get {
      wrappedInstance.isLeapMonth
    }
    set {
      wrappedInstance.isLeapMonth = newValue
    }
  }

  @objc public var minute: Int {
    get {
      wrappedInstance.minute
    }
    set {
      wrappedInstance.minute = newValue
    }
  }

  @objc public var month: Int {
    get {
      wrappedInstance.month
    }
    set {
      wrappedInstance.month = newValue
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var nanosecond: Int {
    get {
      wrappedInstance.nanosecond
    }
    set {
      wrappedInstance.nanosecond = newValue
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var quarter: Int {
    get {
      wrappedInstance.quarter
    }
    set {
      wrappedInstance.quarter = newValue
    }
  }

  @objc public var second: Int {
    get {
      wrappedInstance.second
    }
    set {
      wrappedInstance.second = newValue
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var timeZone: TimeZoneWrapper? {
    get {
      wrappedInstance.timeZone == nil ? nil : TimeZoneWrapper(wrappedInstance.timeZone!)
    }
    set {
      wrappedInstance.timeZone = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var isValidDate: Bool {
    get {
      wrappedInstance.isValidDate
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var weekOfMonth: Int {
    get {
      wrappedInstance.weekOfMonth
    }
    set {
      wrappedInstance.weekOfMonth = newValue
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var weekOfYear: Int {
    get {
      wrappedInstance.weekOfYear
    }
    set {
      wrappedInstance.weekOfYear = newValue
    }
  }

  @objc public var weekday: Int {
    get {
      wrappedInstance.weekday
    }
    set {
      wrappedInstance.weekday = newValue
    }
  }

  @objc public var weekdayOrdinal: Int {
    get {
      wrappedInstance.weekdayOrdinal
    }
    set {
      wrappedInstance.weekdayOrdinal = newValue
    }
  }

  @objc public var year: Int {
    get {
      wrappedInstance.year
    }
    set {
      wrappedInstance.year = newValue
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var yearForWeekOfYear: Int {
    get {
      wrappedInstance.yearForWeekOfYear
    }
    set {
      wrappedInstance.yearForWeekOfYear = newValue
    }
  }

  init(_ wrappedInstance: NSDateComponents) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSDateComponents(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public func isValidDate(in calendar: CalendarWrapper) -> Bool {
    return wrappedInstance.isValidDate(in: calendar.wrappedInstance)
  }

  @available(macOS, introduced: 10.9)
  @objc public func setValue(_ value: Int, forComponent unit: NSCalendarWrapper.UnitWrapper) {
    return wrappedInstance.setValue(value, forComponent: unit.wrappedInstance)
  }

  @available(macOS, introduced: 10.9)
  @objc public func value(forComponent unit: NSCalendarWrapper.UnitWrapper) -> Int {
    return wrappedInstance.value(forComponent: unit.wrappedInstance)
  }

}

@available(macOS, introduced: 10.10)
@objc public class DateComponentsFormatterWrapper: NSObject {
  var wrappedInstance: DateComponentsFormatter

  @available(macOS, introduced: 10.10)
  @objc public var allowedUnits: NSCalendarWrapper.UnitWrapper {
    get {
      UnitWrapper(wrappedInstance.allowedUnits)
    }
    set {
      wrappedInstance.allowedUnits = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var allowsFractionalUnits: Bool {
    get {
      wrappedInstance.allowsFractionalUnits
    }
    set {
      wrappedInstance.allowsFractionalUnits = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var calendar: CalendarWrapper? {
    get {
      wrappedInstance.calendar == nil ? nil : CalendarWrapper(wrappedInstance.calendar!)
    }
    set {
      wrappedInstance.calendar = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var collapsesLargestUnit: Bool {
    get {
      wrappedInstance.collapsesLargestUnit
    }
    set {
      wrappedInstance.collapsesLargestUnit = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var includesApproximationPhrase: Bool {
    get {
      wrappedInstance.includesApproximationPhrase
    }
    set {
      wrappedInstance.includesApproximationPhrase = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var includesTimeRemainingPhrase: Bool {
    get {
      wrappedInstance.includesTimeRemainingPhrase
    }
    set {
      wrappedInstance.includesTimeRemainingPhrase = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var maximumUnitCount: Int {
    get {
      wrappedInstance.maximumUnitCount
    }
    set {
      wrappedInstance.maximumUnitCount = newValue
    }
  }

  @available(macOS, introduced: 10.13)
  @objc public var referenceDate: DateWrapper? {
    get {
      wrappedInstance.referenceDate == nil ? nil : DateWrapper(wrappedInstance.referenceDate!)
    }
    set {
      wrappedInstance.referenceDate = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var zeroFormattingBehavior: DateComponentsFormatterWrapper.ZeroFormattingBehaviorWrapper {
    get {
      ZeroFormattingBehaviorWrapper(wrappedInstance.zeroFormattingBehavior)
    }
    set {
      wrappedInstance.zeroFormattingBehavior = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: DateComponentsFormatter) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @objc public func string(from startDate: DateWrapper, to endDate: DateWrapper) -> String? {
    return wrappedInstance.string(from: startDate.wrappedInstance, to: endDate.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @objc public func string(from components: DateComponentsWrapper) -> String? {
    return wrappedInstance.string(from: components.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @objc public class ZeroFormattingBehaviorWrapper: NSObject {
    var wrappedInstance: DateComponentsFormatter.ZeroFormattingBehavior

    @available(macOS, introduced: 10.10)
    @objc static public var `default`: DateComponentsFormatterWrapper.ZeroFormattingBehaviorWrapper {
      get {
        ZeroFormattingBehaviorWrapper(DateComponentsFormatter.ZeroFormattingBehavior.`default`)
      }
    }

    @available(macOS, introduced: 10.10)
    @objc static public var dropAll: DateComponentsFormatterWrapper.ZeroFormattingBehaviorWrapper {
      get {
        ZeroFormattingBehaviorWrapper(DateComponentsFormatter.ZeroFormattingBehavior.dropAll)
      }
    }

    @available(macOS, introduced: 10.10)
    @objc static public var dropLeading: DateComponentsFormatterWrapper.ZeroFormattingBehaviorWrapper {
      get {
        ZeroFormattingBehaviorWrapper(DateComponentsFormatter.ZeroFormattingBehavior.dropLeading)
      }
    }

    @available(macOS, introduced: 10.10)
    @objc static public var dropMiddle: DateComponentsFormatterWrapper.ZeroFormattingBehaviorWrapper {
      get {
        ZeroFormattingBehaviorWrapper(DateComponentsFormatter.ZeroFormattingBehavior.dropMiddle)
      }
    }

    @available(macOS, introduced: 10.10)
    @objc static public var dropTrailing: DateComponentsFormatterWrapper.ZeroFormattingBehaviorWrapper {
      get {
        ZeroFormattingBehaviorWrapper(DateComponentsFormatter.ZeroFormattingBehavior.dropTrailing)
      }
    }

    @available(macOS, introduced: 10.10)
    @objc static public var pad: DateComponentsFormatterWrapper.ZeroFormattingBehaviorWrapper {
      get {
        ZeroFormattingBehaviorWrapper(DateComponentsFormatter.ZeroFormattingBehavior.pad)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: DateComponentsFormatter.ZeroFormattingBehavior) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = DateComponentsFormatter.ZeroFormattingBehavior()
    }

  }

}

@objc public class DateFormatterWrapper: NSObject {
  var wrappedInstance: DateFormatter

  @objc public var amSymbol: String {
    get {
      wrappedInstance.amSymbol
    }
    set {
      wrappedInstance.amSymbol = newValue
    }
  }

  @objc public var pmSymbol: String {
    get {
      wrappedInstance.pmSymbol
    }
    set {
      wrappedInstance.pmSymbol = newValue
    }
  }

  @objc public var calendar: CalendarWrapper {
    get {
      CalendarWrapper(wrappedInstance.calendar)
    }
    set {
      wrappedInstance.calendar = newValue.wrappedInstance
    }
  }

  @objc public var dateFormat: String {
    get {
      wrappedInstance.dateFormat
    }
    set {
      wrappedInstance.dateFormat = newValue
    }
  }

  @objc public var defaultDate: DateWrapper? {
    get {
      wrappedInstance.defaultDate == nil ? nil : DateWrapper(wrappedInstance.defaultDate!)
    }
    set {
      wrappedInstance.defaultDate = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var doesRelativeDateFormatting: Bool {
    get {
      wrappedInstance.doesRelativeDateFormatting
    }
    set {
      wrappedInstance.doesRelativeDateFormatting = newValue
    }
  }

  @objc public var generatesCalendarDates: Bool {
    get {
      wrappedInstance.generatesCalendarDates
    }
    set {
      wrappedInstance.generatesCalendarDates = newValue
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var gregorianStartDate: DateWrapper? {
    get {
      wrappedInstance.gregorianStartDate == nil ? nil : DateWrapper(wrappedInstance.gregorianStartDate!)
    }
    set {
      wrappedInstance.gregorianStartDate = newValue?.wrappedInstance
    }
  }

  @objc public var isLenient: Bool {
    get {
      wrappedInstance.isLenient
    }
    set {
      wrappedInstance.isLenient = newValue
    }
  }

  @objc public var locale: LocaleWrapper {
    get {
      LocaleWrapper(wrappedInstance.locale)
    }
    set {
      wrappedInstance.locale = newValue.wrappedInstance
    }
  }

  @objc public var timeZone: TimeZoneWrapper {
    get {
      TimeZoneWrapper(wrappedInstance.timeZone)
    }
    set {
      wrappedInstance.timeZone = newValue.wrappedInstance
    }
  }

  @objc public var twoDigitStartDate: DateWrapper? {
    get {
      wrappedInstance.twoDigitStartDate == nil ? nil : DateWrapper(wrappedInstance.twoDigitStartDate!)
    }
    set {
      wrappedInstance.twoDigitStartDate = newValue?.wrappedInstance
    }
  }

  init(_ wrappedInstance: DateFormatter) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.6)
  @objc static public func dateFormat(fromTemplate tmplate: String, options opts: Int, locale: LocaleWrapper?) -> String? {
    return DateFormatter.dateFormat(fromTemplate: tmplate, options: opts, locale: locale?.wrappedInstance)
  }

  @objc public func date(from string: String) -> DateWrapper? {
    let result = wrappedInstance.date(from: string)
    return result == nil ? nil : DateWrapper(result!)
  }

  @available(macOS, introduced: 10.10)
  @objc public func setLocalizedDateFormatFromTemplate(_ dateFormatTemplate: String) {
    return wrappedInstance.setLocalizedDateFormatFromTemplate(dateFormatTemplate)
  }

  @objc public func string(from date: DateWrapper) -> String {
    return wrappedInstance.string(from: date.wrappedInstance)
  }

}

@available(macOS, introduced: 10.12)
@objc public class NSDateIntervalWrapper: NSObject {
  var wrappedInstance: NSDateInterval

  @available(macOS, introduced: 10.12)
  @objc public var duration: TimeInterval {
    get {
      wrappedInstance.duration
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var endDate: DateWrapper {
    get {
      DateWrapper(wrappedInstance.endDate)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var startDate: DateWrapper {
    get {
      DateWrapper(wrappedInstance.startDate)
    }
  }

  init(_ wrappedInstance: NSDateInterval) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.12)
  @objc init(coder: NSCoderWrapper) {
    wrappedInstance = NSDateInterval(coder: coder.wrappedInstance)
  }

  @available(macOS, introduced: 10.12)
  @objc init(start startDate: DateWrapper, duration: TimeInterval) {
    wrappedInstance = NSDateInterval(start: startDate.wrappedInstance, duration: duration)
  }

  @available(macOS, introduced: 10.12)
  @objc public func contains(_ date: DateWrapper) -> Bool {
    return wrappedInstance.contains(date.wrappedInstance)
  }

  @available(macOS, introduced: 10.12)
  @objc public func intersection(with dateInterval: DateIntervalWrapper) -> DateIntervalWrapper? {
    let result = wrappedInstance.intersection(with: dateInterval.wrappedInstance)
    return result == nil ? nil : DateIntervalWrapper(result!)
  }

  @available(macOS, introduced: 10.12)
  @objc public func intersects(_ dateInterval: DateIntervalWrapper) -> Bool {
    return wrappedInstance.intersects(dateInterval.wrappedInstance)
  }

  @available(macOS, introduced: 10.12)
  @objc public func isEqual(to dateInterval: DateIntervalWrapper) -> Bool {
    return wrappedInstance.isEqual(to: dateInterval.wrappedInstance)
  }

}

@available(macOS, introduced: 10.10)
@objc public class DateIntervalFormatterWrapper: NSObject {
  var wrappedInstance: DateIntervalFormatter

  @available(macOS, introduced: 10.10)
  @objc public var calendar: CalendarWrapper {
    get {
      CalendarWrapper(wrappedInstance.calendar)
    }
    set {
      wrappedInstance.calendar = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var dateTemplate: String {
    get {
      wrappedInstance.dateTemplate
    }
    set {
      wrappedInstance.dateTemplate = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var locale: LocaleWrapper {
    get {
      LocaleWrapper(wrappedInstance.locale)
    }
    set {
      wrappedInstance.locale = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var timeZone: TimeZoneWrapper {
    get {
      TimeZoneWrapper(wrappedInstance.timeZone)
    }
    set {
      wrappedInstance.timeZone = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: DateIntervalFormatter) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @objc public func string(from fromDate: DateWrapper, to toDate: DateWrapper) -> String {
    return wrappedInstance.string(from: fromDate.wrappedInstance, to: toDate.wrappedInstance)
  }

  @available(macOS, introduced: 10.12)
  @objc public func string(from dateInterval: DateIntervalWrapper) -> String? {
    return wrappedInstance.string(from: dateInterval.wrappedInstance)
  }

}

@objc public class NSDecimalNumberWrapper: NSObject {
  var wrappedInstance: NSDecimalNumber

  @objc static public var maximum: NSDecimalNumberWrapper {
    get {
      NSDecimalNumberWrapper(NSDecimalNumber.maximum)
    }
  }

  @objc static public var minimum: NSDecimalNumberWrapper {
    get {
      NSDecimalNumberWrapper(NSDecimalNumber.minimum)
    }
  }

  @objc static public var notANumber: NSDecimalNumberWrapper {
    get {
      NSDecimalNumberWrapper(NSDecimalNumber.notANumber)
    }
  }

  @objc static public var one: NSDecimalNumberWrapper {
    get {
      NSDecimalNumberWrapper(NSDecimalNumber.one)
    }
  }

  @objc static public var zero: NSDecimalNumberWrapper {
    get {
      NSDecimalNumberWrapper(NSDecimalNumber.zero)
    }
  }

  @objc public var decimalValue: DecimalWrapper {
    get {
      DecimalWrapper(wrappedInstance.decimalValue)
    }
  }

  @objc public var doubleValue: Double {
    get {
      wrappedInstance.doubleValue
    }
  }

  init(_ wrappedInstance: NSDecimalNumber) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(decimal dcm: DecimalWrapper) {
    wrappedInstance = NSDecimalNumber(decimal: dcm.wrappedInstance)
  }

  @objc public func adding(_ decimalNumber: NSDecimalNumberWrapper) -> NSDecimalNumberWrapper {
    let result = wrappedInstance.adding(decimalNumber.wrappedInstance)
    return NSDecimalNumberWrapper(result)
  }

  @objc public func dividing(by decimalNumber: NSDecimalNumberWrapper) -> NSDecimalNumberWrapper {
    let result = wrappedInstance.dividing(by: decimalNumber.wrappedInstance)
    return NSDecimalNumberWrapper(result)
  }

  @objc public func multiplying(by decimalNumber: NSDecimalNumberWrapper) -> NSDecimalNumberWrapper {
    let result = wrappedInstance.multiplying(by: decimalNumber.wrappedInstance)
    return NSDecimalNumberWrapper(result)
  }

  @objc public func raising(toPower power: Int) -> NSDecimalNumberWrapper {
    let result = wrappedInstance.raising(toPower: power)
    return NSDecimalNumberWrapper(result)
  }

  @objc public func subtracting(_ decimalNumber: NSDecimalNumberWrapper) -> NSDecimalNumberWrapper {
    let result = wrappedInstance.subtracting(decimalNumber.wrappedInstance)
    return NSDecimalNumberWrapper(result)
  }

}

@objc public class NSDecimalNumberHandlerWrapper: NSObject {
  var wrappedInstance: NSDecimalNumberHandler

  @objc static public var `default`: NSDecimalNumberHandlerWrapper {
    get {
      NSDecimalNumberHandlerWrapper(NSDecimalNumberHandler.`default`)
    }
  }

  init(_ wrappedInstance: NSDecimalNumberHandler) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSDecimalNumberHandler(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@objc public class NSDeleteCommandWrapper: NSObject {
  var wrappedInstance: NSDeleteCommand

  @objc public var keySpecifier: NSScriptObjectSpecifierWrapper {
    get {
      NSScriptObjectSpecifierWrapper(wrappedInstance.keySpecifier)
    }
  }

  init(_ wrappedInstance: NSDeleteCommand) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func setReceiversSpecifier(_ receiversRef: NSScriptObjectSpecifierWrapper?) {
    return wrappedInstance.setReceiversSpecifier(receiversRef?.wrappedInstance)
  }

}

@objc public class NSDictionaryWrapper: NSObject {
  var wrappedInstance: NSDictionary

  @objc public var count: Int {
    get {
      wrappedInstance.count
    }
  }

  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @objc public var descriptionInStringsFileFormat: String {
    get {
      wrappedInstance.descriptionInStringsFileFormat
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var underestimatedCount: Int {
    get {
      wrappedInstance.underestimatedCount
    }
  }

  init(_ wrappedInstance: NSDictionary) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSDictionary()
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSDictionary(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func fileCreationDate() -> DateWrapper? {
    let result = wrappedInstance.fileCreationDate()
    return result == nil ? nil : DateWrapper(result!)
  }

  @objc public func fileExtensionHidden() -> Bool {
    return wrappedInstance.fileExtensionHidden()
  }

  @objc public func fileGroupOwnerAccountID() -> NSNumberWrapper? {
    let result = wrappedInstance.fileGroupOwnerAccountID()
    return result == nil ? nil : NSNumberWrapper(result!)
  }

  @objc public func fileGroupOwnerAccountName() -> String? {
    return wrappedInstance.fileGroupOwnerAccountName()
  }

  @objc public func fileIsAppendOnly() -> Bool {
    return wrappedInstance.fileIsAppendOnly()
  }

  @objc public func fileIsImmutable() -> Bool {
    return wrappedInstance.fileIsImmutable()
  }

  @objc public func fileModificationDate() -> DateWrapper? {
    let result = wrappedInstance.fileModificationDate()
    return result == nil ? nil : DateWrapper(result!)
  }

  @objc public func fileOwnerAccountID() -> NSNumberWrapper? {
    let result = wrappedInstance.fileOwnerAccountID()
    return result == nil ? nil : NSNumberWrapper(result!)
  }

  @objc public func fileOwnerAccountName() -> String? {
    return wrappedInstance.fileOwnerAccountName()
  }

  @objc public func filePosixPermissions() -> Int {
    return wrappedInstance.filePosixPermissions()
  }

  @objc public func fileSystemFileNumber() -> Int {
    return wrappedInstance.fileSystemFileNumber()
  }

  @objc public func fileSystemNumber() -> Int {
    return wrappedInstance.fileSystemNumber()
  }

  @objc public func fileType() -> String? {
    return wrappedInstance.fileType()
  }

  @objc public func keyEnumerator() -> NSEnumeratorWrapper {
    let result = wrappedInstance.keyEnumerator()
    return NSEnumeratorWrapper(result)
  }

  @objc public func objectEnumerator() -> NSEnumeratorWrapper {
    let result = wrappedInstance.objectEnumerator()
    return NSEnumeratorWrapper(result)
  }

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public func write(toFile path: String, atomically useAuxiliaryFile: Bool) -> Bool {
    return wrappedInstance.write(toFile: path, atomically: useAuxiliaryFile)
  }

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public func write(to url: URLWrapper, atomically: Bool) -> Bool {
    return wrappedInstance.write(to: url.wrappedInstance, atomically: atomically)
  }

  @available(macOS, introduced: 10.13)
  @objc public func write(to url: URLWrapper) throws {
    return try wrappedInstance.write(to: url.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func makeIterator() -> NSDictionaryWrapper.IteratorWrapper {
    let result = wrappedInstance.makeIterator()
    return IteratorWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public class IteratorWrapper: NSObject {
    var wrappedInstance: NSDictionary.Iterator

    init(_ wrappedInstance: NSDictionary.Iterator) {
      self.wrappedInstance = wrappedInstance
    }

  }

}

@available(macOS, introduced: 10.12)
@objc public class DimensionWrapper: NSObject {
  var wrappedInstance: Dimension

  @available(macOS, introduced: 10.12)
  @objc public var converter: UnitConverterWrapper {
    get {
      UnitConverterWrapper(wrappedInstance.converter)
    }
  }

  init(_ wrappedInstance: Dimension) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.12)
  @objc init(symbol: String, converter: UnitConverterWrapper) {
    wrappedInstance = Dimension(symbol: symbol, converter: converter.wrappedInstance)
  }

}

@objc public class NSDistributedLockWrapper: NSObject {
  var wrappedInstance: NSDistributedLock

  @objc public var lockDate: DateWrapper {
    get {
      DateWrapper(wrappedInstance.lockDate)
    }
  }

  init(_ wrappedInstance: NSDistributedLock) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(path: String) {
    if let instance = NSDistributedLock(path: path) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func `break`() {
    return wrappedInstance.`break`()
  }

  @objc public func `try`() -> Bool {
    return wrappedInstance.`try`()
  }

  @objc public func unlock() {
    return wrappedInstance.unlock()
  }

}

@objc public class DistributedNotificationCenterWrapper: NSObject {
  var wrappedInstance: DistributedNotificationCenter

  @objc public var suspended: Bool {
    get {
      wrappedInstance.suspended
    }
    set {
      wrappedInstance.suspended = newValue
    }
  }

  init(_ wrappedInstance: DistributedNotificationCenter) {
    self.wrappedInstance = wrappedInstance
  }

  @objc static public func `default`() -> DistributedNotificationCenterWrapper {
    let result = DistributedNotificationCenter.`default`()
    return DistributedNotificationCenterWrapper(result)
  }

  @objc static public func forType(_ notificationCenterType: DistributedNotificationCenterWrapper.CenterTypeWrapper) -> DistributedNotificationCenterWrapper {
    let result = DistributedNotificationCenter.forType(notificationCenterType.wrappedInstance)
    return DistributedNotificationCenterWrapper(result)
  }

  @objc public func post(name aName: NSNotificationWrapper.NameWrapper, object anObject: String?) {
    return wrappedInstance.post(name: aName.wrappedInstance, object: anObject)
  }

  @objc public class OptionsWrapper: NSObject {
    var wrappedInstance: DistributedNotificationCenter.Options

    @objc static public var deliverImmediately: DistributedNotificationCenterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(DistributedNotificationCenter.Options.deliverImmediately)
      }
    }

    @objc static public var postToAllSessions: DistributedNotificationCenterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(DistributedNotificationCenter.Options.postToAllSessions)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: DistributedNotificationCenter.Options) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = DistributedNotificationCenter.Options()
    }

  }

  @objc public class CenterTypeWrapper: NSObject {
    var wrappedInstance: DistributedNotificationCenter.CenterType

    @objc static public var localNotificationCenterType: DistributedNotificationCenterWrapper.CenterTypeWrapper {
      get {
        CenterTypeWrapper(DistributedNotificationCenter.CenterType.localNotificationCenterType)
      }
    }

    init(_ wrappedInstance: DistributedNotificationCenter.CenterType) {
      self.wrappedInstance = wrappedInstance
    }

    @objc init(rawValue: String) {
      wrappedInstance = DistributedNotificationCenter.CenterType(rawValue: rawValue)
    }

    @objc init(_ rawValue: String) {
      wrappedInstance = DistributedNotificationCenter.CenterType(rawValue)
    }

  }

}

@available(macOS, introduced: 10.10)
@objc public class EnergyFormatterWrapper: NSObject {
  var wrappedInstance: EnergyFormatter

  @available(macOS, introduced: 10.10)
  @objc public var isForFoodEnergyUse: Bool {
    get {
      wrappedInstance.isForFoodEnergyUse
    }
    set {
      wrappedInstance.isForFoodEnergyUse = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var numberFormatter: NumberFormatterWrapper {
    get {
      NumberFormatterWrapper(wrappedInstance.numberFormatter)
    }
    set {
      wrappedInstance.numberFormatter = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: EnergyFormatter) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @objc public func string(fromJoules numberInJoules: Double) -> String {
    return wrappedInstance.string(fromJoules: numberInJoules)
  }

}

@objc public class NSEnumeratorWrapper: NSObject {
  var wrappedInstance: NSEnumerator

  @objc public var underestimatedCount: Int {
    get {
      wrappedInstance.underestimatedCount
    }
  }

  init(_ wrappedInstance: NSEnumerator) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func makeIterator() -> NSFastEnumerationIteratorWrapper {
    let result = wrappedInstance.makeIterator()
    return NSFastEnumerationIteratorWrapper(result)
  }

}

@objc public class NSErrorWrapper: NSObject {
  var wrappedInstance: NSError

  @objc public var code: Int {
    get {
      wrappedInstance.code
    }
  }

  @objc public var domain: String {
    get {
      wrappedInstance.domain
    }
  }

  @objc public var helpAnchor: String? {
    get {
      wrappedInstance.helpAnchor
    }
  }

  @objc public var localizedDescription: String {
    get {
      wrappedInstance.localizedDescription
    }
  }

  @objc public var localizedFailureReason: String? {
    get {
      wrappedInstance.localizedFailureReason
    }
  }

  @objc public var localizedRecoverySuggestion: String? {
    get {
      wrappedInstance.localizedRecoverySuggestion
    }
  }

  init(_ wrappedInstance: NSError) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSError(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@objc public class NSExceptionWrapper: NSObject {
  var wrappedInstance: NSException

  @objc public var name: NSExceptionNameWrapper {
    get {
      NSExceptionNameWrapper(wrappedInstance.name)
    }
  }

  @objc public var reason: String? {
    get {
      wrappedInstance.reason
    }
  }

  init(_ wrappedInstance: NSException) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSException(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func raise() {
    return wrappedInstance.raise()
  }

}

@objc public class NSExistsCommandWrapper: NSObject {
  var wrappedInstance: NSExistsCommand

  init(_ wrappedInstance: NSExistsCommand) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.4)
@objc public class NSExpressionWrapper: NSObject {
  var wrappedInstance: NSExpression

  @available(macOS, introduced: 10.11)
  @objc public var `false`: NSExpressionWrapper {
    get {
      NSExpressionWrapper(wrappedInstance.`false`)
    }
  }

  @available(macOS, introduced: 10.4)
  @objc public var function: String {
    get {
      wrappedInstance.function
    }
  }

  @available(macOS, introduced: 10.4)
  @objc public var keyPath: String {
    get {
      wrappedInstance.keyPath
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var left: NSExpressionWrapper {
    get {
      NSExpressionWrapper(wrappedInstance.left)
    }
  }

  @available(macOS, introduced: 10.4)
  @objc public var operand: NSExpressionWrapper {
    get {
      NSExpressionWrapper(wrappedInstance.operand)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var predicate: NSPredicateWrapper {
    get {
      NSPredicateWrapper(wrappedInstance.predicate)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var right: NSExpressionWrapper {
    get {
      NSExpressionWrapper(wrappedInstance.right)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var `true`: NSExpressionWrapper {
    get {
      NSExpressionWrapper(wrappedInstance.`true`)
    }
  }

  @available(macOS, introduced: 10.4)
  @objc public var variable: String {
    get {
      wrappedInstance.variable
    }
  }

  init(_ wrappedInstance: NSExpression) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.11)
  @objc init(forConditional predicate: NSPredicateWrapper, trueExpression: NSExpressionWrapper, falseExpression: NSExpressionWrapper) {
    wrappedInstance = NSExpression(forConditional: predicate.wrappedInstance, trueExpression: trueExpression.wrappedInstance, falseExpression: falseExpression.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc init(forIntersectSet left: NSExpressionWrapper, with right: NSExpressionWrapper) {
    wrappedInstance = NSExpression(forIntersectSet: left.wrappedInstance, with: right.wrappedInstance)
  }

  @available(macOS, introduced: 10.4)
  @objc init(forKeyPath keyPath: String) {
    wrappedInstance = NSExpression(forKeyPath: keyPath)
  }

  @available(macOS, introduced: 10.5)
  @objc init(forMinusSet left: NSExpressionWrapper, with right: NSExpressionWrapper) {
    wrappedInstance = NSExpression(forMinusSet: left.wrappedInstance, with: right.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc init(forSubquery expression: NSExpressionWrapper, usingIteratorVariable variable: String, predicate: NSPredicateWrapper) {
    wrappedInstance = NSExpression(forSubquery: expression.wrappedInstance, usingIteratorVariable: variable, predicate: predicate.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc init(forUnionSet left: NSExpressionWrapper, with right: NSExpressionWrapper) {
    wrappedInstance = NSExpression(forUnionSet: left.wrappedInstance, with: right.wrappedInstance)
  }

  @available(macOS, introduced: 10.4)
  @objc init(forVariable string: String) {
    wrappedInstance = NSExpression(forVariable: string)
  }

  @available(macOS, introduced: 10.4)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSExpression(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public func expressionForAnyKey() -> NSExpressionWrapper {
    let result = NSExpression.expressionForAnyKey()
    return NSExpressionWrapper(result)
  }

  @available(macOS, introduced: 10.4)
  @objc static public func expressionForEvaluatedObject() -> NSExpressionWrapper {
    let result = NSExpression.expressionForEvaluatedObject()
    return NSExpressionWrapper(result)
  }

  @available(macOS, introduced: 10.9)
  @objc public func allowEvaluation() {
    return wrappedInstance.allowEvaluation()
  }

}

@available(macOS, introduced: 10.10)
@objc public class NSExtensionContextWrapper: NSObject {
  var wrappedInstance: NSExtensionContext

  init(_ wrappedInstance: NSExtensionContext) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @objc public func open(_ URL: URLWrapper) async -> Bool {
    return await wrappedInstance.open(URL.wrappedInstance)
  }

}

@available(macOS, introduced: 10.10)
@objc public class NSExtensionItemWrapper: NSObject {
  var wrappedInstance: NSExtensionItem

  @available(macOS, introduced: 10.10)
  @objc public var attributedContentText: NSAttributedStringWrapper? {
    get {
      wrappedInstance.attributedContentText == nil ? nil : NSAttributedStringWrapper(wrappedInstance.attributedContentText!)
    }
    set {
      wrappedInstance.attributedContentText = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var attributedTitle: NSAttributedStringWrapper? {
    get {
      wrappedInstance.attributedTitle == nil ? nil : NSAttributedStringWrapper(wrappedInstance.attributedTitle!)
    }
    set {
      wrappedInstance.attributedTitle = newValue?.wrappedInstance
    }
  }

  init(_ wrappedInstance: NSExtensionItem) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSExtensionItem(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.10)
@objc public class NSFileAccessIntentWrapper: NSObject {
  var wrappedInstance: NSFileAccessIntent

  @available(macOS, introduced: 10.10)
  @objc public var url: URLWrapper {
    get {
      URLWrapper(wrappedInstance.url)
    }
  }

  init(_ wrappedInstance: NSFileAccessIntent) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.7)
@objc public class NSFileCoordinatorWrapper: NSObject {
  var wrappedInstance: NSFileCoordinator

  @available(macOS, introduced: 10.7)
  @objc public var purposeIdentifier: String {
    get {
      wrappedInstance.purposeIdentifier
    }
    set {
      wrappedInstance.purposeIdentifier = newValue
    }
  }

  init(_ wrappedInstance: NSFileCoordinator) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.7)
  @objc public func cancel() {
    return wrappedInstance.cancel()
  }

  @available(macOS, introduced: 10.7)
  @objc public func item(at oldURL: URLWrapper, didMoveTo newURL: URLWrapper) {
    return wrappedInstance.item(at: oldURL.wrappedInstance, didMoveTo: newURL.wrappedInstance)
  }

  @available(macOS, introduced: 10.8)
  @objc public func item(at oldURL: URLWrapper, willMoveTo newURL: URLWrapper) {
    return wrappedInstance.item(at: oldURL.wrappedInstance, willMoveTo: newURL.wrappedInstance)
  }

  @objc public class ReadingOptionsWrapper: NSObject {
    var wrappedInstance: NSFileCoordinator.ReadingOptions

    @available(macOS, introduced: 10.10)
    @objc static public var forUploading: NSFileCoordinatorWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(NSFileCoordinator.ReadingOptions.forUploading)
      }
    }

    @available(macOS, introduced: 10.10)
    @objc static public var immediatelyAvailableMetadataOnly: NSFileCoordinatorWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(NSFileCoordinator.ReadingOptions.immediatelyAvailableMetadataOnly)
      }
    }

    @objc static public var resolvesSymbolicLink: NSFileCoordinatorWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(NSFileCoordinator.ReadingOptions.resolvesSymbolicLink)
      }
    }

    @objc static public var withoutChanges: NSFileCoordinatorWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(NSFileCoordinator.ReadingOptions.withoutChanges)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSFileCoordinator.ReadingOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSFileCoordinator.ReadingOptions()
    }

  }

  @objc public class WritingOptionsWrapper: NSObject {
    var wrappedInstance: NSFileCoordinator.WritingOptions

    @available(macOS, introduced: 10.10)
    @objc static public var contentIndependentMetadataOnly: NSFileCoordinatorWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(NSFileCoordinator.WritingOptions.contentIndependentMetadataOnly)
      }
    }

    @objc static public var forDeleting: NSFileCoordinatorWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(NSFileCoordinator.WritingOptions.forDeleting)
      }
    }

    @objc static public var forMerging: NSFileCoordinatorWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(NSFileCoordinator.WritingOptions.forMerging)
      }
    }

    @objc static public var forMoving: NSFileCoordinatorWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(NSFileCoordinator.WritingOptions.forMoving)
      }
    }

    @objc static public var forReplacing: NSFileCoordinatorWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(NSFileCoordinator.WritingOptions.forReplacing)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSFileCoordinator.WritingOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSFileCoordinator.WritingOptions()
    }

  }

}

@objc public class FileHandleWrapper: NSObject {
  var wrappedInstance: FileHandle

  @objc static public var readCompletionNotification: NSNotificationWrapper.NameWrapper {
    get {
      NameWrapper(FileHandle.readCompletionNotification)
    }
  }

  @objc static public var nullDevice: FileHandleWrapper {
    get {
      FileHandleWrapper(FileHandle.nullDevice)
    }
  }

  @objc static public var standardError: FileHandleWrapper {
    get {
      FileHandleWrapper(FileHandle.standardError)
    }
  }

  @objc static public var standardInput: FileHandleWrapper {
    get {
      FileHandleWrapper(FileHandle.standardInput)
    }
  }

  @objc static public var standardOutput: FileHandleWrapper {
    get {
      FileHandleWrapper(FileHandle.standardOutput)
    }
  }

  @objc public var availableData: DataWrapper {
    get {
      DataWrapper(wrappedInstance.availableData)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var bytes: FileHandleWrapper.AsyncBytesWrapper {
    get {
      AsyncBytesWrapper(wrappedInstance.bytes)
    }
  }

  init(_ wrappedInstance: FileHandle) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = FileHandle(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func acceptConnectionInBackgroundAndNotify() {
    return wrappedInstance.acceptConnectionInBackgroundAndNotify()
  }

  @available(macOS, introduced: 10.15)
  @objc public func close() throws {
    return try wrappedInstance.close()
  }

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public func closeFile() {
    return wrappedInstance.closeFile()
  }

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public func readData(ofLength length: Int) -> DataWrapper {
    let result = wrappedInstance.readData(ofLength: length)
    return DataWrapper(result)
  }

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public func readDataToEndOfFile() -> DataWrapper {
    let result = wrappedInstance.readDataToEndOfFile()
    return DataWrapper(result)
  }

  @objc public func readInBackgroundAndNotify() {
    return wrappedInstance.readInBackgroundAndNotify()
  }

  @objc public func readToEndOfFileInBackgroundAndNotify() {
    return wrappedInstance.readToEndOfFileInBackgroundAndNotify()
  }

  @available(macOS, introduced: 10.15)
  @objc public func synchronize() throws {
    return try wrappedInstance.synchronize()
  }

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public func synchronizeFile() {
    return wrappedInstance.synchronizeFile()
  }

  @objc public func waitForDataInBackgroundAndNotify() {
    return wrappedInstance.waitForDataInBackgroundAndNotify()
  }

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public func write(_ data: DataWrapper) {
    return wrappedInstance.write(data.wrappedInstance)
  }

  @available(macOS, introduced: 10.15.4)
  @available(watchOS, introduced: 6.2)
  @available(iOS, introduced: 13.4)
  @available(tvOS, introduced: 13.4)
  @objc public func read(upToCount count: Int) throws -> DataWrapper? {
    let result = try wrappedInstance.read(upToCount: count)
    return result == nil ? nil : DataWrapper(result!)
  }

  @available(macOS, introduced: 10.15.4)
  @available(watchOS, introduced: 6.2)
  @available(iOS, introduced: 13.4)
  @available(tvOS, introduced: 13.4)
  @objc public func readToEnd() throws -> DataWrapper? {
    let result = try wrappedInstance.readToEnd()
    return result == nil ? nil : DataWrapper(result!)
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class AsyncBytesWrapper: NSObject {
    var wrappedInstance: FileHandle.AsyncBytes

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var characters: AsyncCharacterSequenceWrapper {
      get {
        AsyncCharacterSequenceWrapper(wrappedInstance.characters)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var unicodeScalars: AsyncUnicodeScalarSequenceWrapper {
      get {
        AsyncUnicodeScalarSequenceWrapper(wrappedInstance.unicodeScalars)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var lines: AsyncLineSequenceWrapper {
      get {
        AsyncLineSequenceWrapper(wrappedInstance.lines)
      }
    }

    init(_ wrappedInstance: FileHandle.AsyncBytes) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func makeAsyncIterator() -> AsyncBytesWrapper.IteratorWrapper {
      let result = wrappedInstance.makeAsyncIterator()
      return IteratorWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class IteratorWrapper: NSObject {
      var wrappedInstance: AsyncBytes.Iterator

      init(_ wrappedInstance: AsyncBytes.Iterator) {
        self.wrappedInstance = wrappedInstance
      }

    }

  }

}

@objc public class FileManagerWrapper: NSObject {
  var wrappedInstance: FileManager

  @objc static public var `default`: FileManagerWrapper {
    get {
      FileManagerWrapper(FileManager.`default`)
    }
  }

  @objc public var currentDirectoryPath: String {
    get {
      wrappedInstance.currentDirectoryPath
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var homeDirectoryForCurrentUser: URLWrapper {
    get {
      URLWrapper(wrappedInstance.homeDirectoryForCurrentUser)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var temporaryDirectory: URLWrapper {
    get {
      URLWrapper(wrappedInstance.temporaryDirectory)
    }
  }

  init(_ wrappedInstance: FileManager) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.7)
  @objc public func url(forUbiquityContainerIdentifier containerIdentifier: String?) -> URLWrapper? {
    let result = wrappedInstance.url(forUbiquityContainerIdentifier: containerIdentifier)
    return result == nil ? nil : URLWrapper(result!)
  }

  @objc public func changeCurrentDirectoryPath(_ path: String) -> Bool {
    return wrappedInstance.changeCurrentDirectoryPath(path)
  }

  @available(macOS, introduced: 10.8)
  @objc public func containerURL(forSecurityApplicationGroupIdentifier groupIdentifier: String) -> URLWrapper? {
    let result = wrappedInstance.containerURL(forSecurityApplicationGroupIdentifier: groupIdentifier)
    return result == nil ? nil : URLWrapper(result!)
  }

  @objc public func contents(atPath path: String) -> DataWrapper? {
    let result = wrappedInstance.contents(atPath: path)
    return result == nil ? nil : DataWrapper(result!)
  }

  @objc public func contentsEqual(atPath path1: String, andPath path2: String) -> Bool {
    return wrappedInstance.contentsEqual(atPath: path1, andPath: path2)
  }

  @available(macOS, introduced: 10.5)
  @objc public func copyItem(atPath srcPath: String, toPath dstPath: String) throws {
    return try wrappedInstance.copyItem(atPath: srcPath, toPath: dstPath)
  }

  @available(macOS, introduced: 10.6)
  @objc public func copyItem(at srcURL: URLWrapper, to dstURL: URLWrapper) throws {
    return try wrappedInstance.copyItem(at: srcURL.wrappedInstance, to: dstURL.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc public func createSymbolicLink(atPath path: String, withDestinationPath destPath: String) throws {
    return try wrappedInstance.createSymbolicLink(atPath: path, withDestinationPath: destPath)
  }

  @available(macOS, introduced: 10.7)
  @objc public func createSymbolicLink(at url: URLWrapper, withDestinationURL destURL: URLWrapper) throws {
    return try wrappedInstance.createSymbolicLink(at: url.wrappedInstance, withDestinationURL: destURL.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc public func destinationOfSymbolicLink(atPath path: String) throws -> String {
    return try wrappedInstance.destinationOfSymbolicLink(atPath: path)
  }

  @objc public func displayName(atPath path: String) -> String {
    return wrappedInstance.displayName(atPath: path)
  }

  @objc public func enumerator(atPath path: String) -> FileManagerWrapper.DirectoryEnumeratorWrapper? {
    let result = wrappedInstance.enumerator(atPath: path)
    return result == nil ? nil : DirectoryEnumeratorWrapper(result!)
  }

  @available(macOS, introduced: 10.7)
  @objc public func evictUbiquitousItem(at url: URLWrapper) throws {
    return try wrappedInstance.evictUbiquitousItem(at: url.wrappedInstance)
  }

  @objc public func fileExists(atPath path: String) -> Bool {
    return wrappedInstance.fileExists(atPath: path)
  }

  @available(macOS, introduced: 10.12)
  @objc public func homeDirectory(forUser userName: String) -> URLWrapper? {
    let result = wrappedInstance.homeDirectory(forUser: userName)
    return result == nil ? nil : URLWrapper(result!)
  }

  @objc public func isDeletableFile(atPath path: String) -> Bool {
    return wrappedInstance.isDeletableFile(atPath: path)
  }

  @objc public func isExecutableFile(atPath path: String) -> Bool {
    return wrappedInstance.isExecutableFile(atPath: path)
  }

  @objc public func isReadableFile(atPath path: String) -> Bool {
    return wrappedInstance.isReadableFile(atPath: path)
  }

  @available(macOS, introduced: 10.7)
  @objc public func isUbiquitousItem(at url: URLWrapper) -> Bool {
    return wrappedInstance.isUbiquitousItem(at: url.wrappedInstance)
  }

  @objc public func isWritableFile(atPath path: String) -> Bool {
    return wrappedInstance.isWritableFile(atPath: path)
  }

  @available(macOS, introduced: 10.5)
  @objc public func linkItem(atPath srcPath: String, toPath dstPath: String) throws {
    return try wrappedInstance.linkItem(atPath: srcPath, toPath: dstPath)
  }

  @available(macOS, introduced: 10.6)
  @objc public func linkItem(at srcURL: URLWrapper, to dstURL: URLWrapper) throws {
    return try wrappedInstance.linkItem(at: srcURL.wrappedInstance, to: dstURL.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc public func moveItem(atPath srcPath: String, toPath dstPath: String) throws {
    return try wrappedInstance.moveItem(atPath: srcPath, toPath: dstPath)
  }

  @available(macOS, introduced: 10.6)
  @objc public func moveItem(at srcURL: URLWrapper, to dstURL: URLWrapper) throws {
    return try wrappedInstance.moveItem(at: srcURL.wrappedInstance, to: dstURL.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc public func removeItem(atPath path: String) throws {
    return try wrappedInstance.removeItem(atPath: path)
  }

  @available(macOS, introduced: 10.6)
  @objc public func removeItem(at URL: URLWrapper) throws {
    return try wrappedInstance.removeItem(at: URL.wrappedInstance)
  }

  @available(macOS, introduced: 10.7)
  @objc public func setUbiquitous(_ flag: Bool, itemAt url: URLWrapper, destinationURL: URLWrapper) throws {
    return try wrappedInstance.setUbiquitous(flag, itemAt: url.wrappedInstance, destinationURL: destinationURL.wrappedInstance)
  }

  @available(macOS, introduced: 10.7)
  @objc public func startDownloadingUbiquitousItem(at url: URLWrapper) throws {
    return try wrappedInstance.startDownloadingUbiquitousItem(at: url.wrappedInstance)
  }

  @available(macOS, introduced: 10.6)
  @objc public class DirectoryEnumerationOptionsWrapper: NSObject {
    var wrappedInstance: FileManager.DirectoryEnumerationOptions

    @available(macOS, introduced: 10.15)
    @objc static public var includesDirectoriesPostOrder: FileManagerWrapper.DirectoryEnumerationOptionsWrapper {
      get {
        DirectoryEnumerationOptionsWrapper(FileManager.DirectoryEnumerationOptions.includesDirectoriesPostOrder)
      }
    }

    @available(macOS, introduced: 10.15)
    @objc static public var producesRelativePathURLs: FileManagerWrapper.DirectoryEnumerationOptionsWrapper {
      get {
        DirectoryEnumerationOptionsWrapper(FileManager.DirectoryEnumerationOptions.producesRelativePathURLs)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var skipsHiddenFiles: FileManagerWrapper.DirectoryEnumerationOptionsWrapper {
      get {
        DirectoryEnumerationOptionsWrapper(FileManager.DirectoryEnumerationOptions.skipsHiddenFiles)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var skipsPackageDescendants: FileManagerWrapper.DirectoryEnumerationOptionsWrapper {
      get {
        DirectoryEnumerationOptionsWrapper(FileManager.DirectoryEnumerationOptions.skipsPackageDescendants)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var skipsSubdirectoryDescendants: FileManagerWrapper.DirectoryEnumerationOptionsWrapper {
      get {
        DirectoryEnumerationOptionsWrapper(FileManager.DirectoryEnumerationOptions.skipsSubdirectoryDescendants)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: FileManager.DirectoryEnumerationOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = FileManager.DirectoryEnumerationOptions()
    }

  }

  @available(macOS, introduced: 10.6)
  @objc public class ItemReplacementOptionsWrapper: NSObject {
    var wrappedInstance: FileManager.ItemReplacementOptions

    @available(macOS, introduced: 10.6)
    @objc static public var usingNewMetadataOnly: FileManagerWrapper.ItemReplacementOptionsWrapper {
      get {
        ItemReplacementOptionsWrapper(FileManager.ItemReplacementOptions.usingNewMetadataOnly)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var withoutDeletingBackupItem: FileManagerWrapper.ItemReplacementOptionsWrapper {
      get {
        ItemReplacementOptionsWrapper(FileManager.ItemReplacementOptions.withoutDeletingBackupItem)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: FileManager.ItemReplacementOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = FileManager.ItemReplacementOptions()
    }

  }

  @available(macOS, introduced: 10.11)
  @objc public class UnmountOptionsWrapper: NSObject {
    var wrappedInstance: FileManager.UnmountOptions

    @available(macOS, introduced: 10.11)
    @objc static public var allPartitionsAndEjectDisk: FileManagerWrapper.UnmountOptionsWrapper {
      get {
        UnmountOptionsWrapper(FileManager.UnmountOptions.allPartitionsAndEjectDisk)
      }
    }

    @available(macOS, introduced: 10.11)
    @objc static public var withoutUI: FileManagerWrapper.UnmountOptionsWrapper {
      get {
        UnmountOptionsWrapper(FileManager.UnmountOptions.withoutUI)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: FileManager.UnmountOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = FileManager.UnmountOptions()
    }

  }

  @objc public class SearchPathDomainMaskWrapper: NSObject {
    var wrappedInstance: FileManager.SearchPathDomainMask

    @objc static public var allDomainsMask: FileManagerWrapper.SearchPathDomainMaskWrapper {
      get {
        SearchPathDomainMaskWrapper(FileManager.SearchPathDomainMask.allDomainsMask)
      }
    }

    @objc static public var localDomainMask: FileManagerWrapper.SearchPathDomainMaskWrapper {
      get {
        SearchPathDomainMaskWrapper(FileManager.SearchPathDomainMask.localDomainMask)
      }
    }

    @objc static public var networkDomainMask: FileManagerWrapper.SearchPathDomainMaskWrapper {
      get {
        SearchPathDomainMaskWrapper(FileManager.SearchPathDomainMask.networkDomainMask)
      }
    }

    @objc static public var systemDomainMask: FileManagerWrapper.SearchPathDomainMaskWrapper {
      get {
        SearchPathDomainMaskWrapper(FileManager.SearchPathDomainMask.systemDomainMask)
      }
    }

    @objc static public var userDomainMask: FileManagerWrapper.SearchPathDomainMaskWrapper {
      get {
        SearchPathDomainMaskWrapper(FileManager.SearchPathDomainMask.userDomainMask)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: FileManager.SearchPathDomainMask) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = FileManager.SearchPathDomainMask()
    }

  }

  @available(macOS, introduced: 10.6)
  @objc public class VolumeEnumerationOptionsWrapper: NSObject {
    var wrappedInstance: FileManager.VolumeEnumerationOptions

    @available(macOS, introduced: 10.6)
    @objc static public var produceFileReferenceURLs: FileManagerWrapper.VolumeEnumerationOptionsWrapper {
      get {
        VolumeEnumerationOptionsWrapper(FileManager.VolumeEnumerationOptions.produceFileReferenceURLs)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var skipHiddenVolumes: FileManagerWrapper.VolumeEnumerationOptionsWrapper {
      get {
        VolumeEnumerationOptionsWrapper(FileManager.VolumeEnumerationOptions.skipHiddenVolumes)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: FileManager.VolumeEnumerationOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = FileManager.VolumeEnumerationOptions()
    }

  }

  @objc public class DirectoryEnumeratorWrapper: NSObject {
    var wrappedInstance: FileManager.DirectoryEnumerator

    @available(macOS, introduced: 10.15)
    @objc public var isEnumeratingDirectoryPostOrder: Bool {
      get {
        wrappedInstance.isEnumeratingDirectoryPostOrder
      }
    }

    @available(macOS, introduced: 10.6)
    @objc public var level: Int {
      get {
        wrappedInstance.level
      }
    }

    init(_ wrappedInstance: FileManager.DirectoryEnumerator) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 10.6)
    @objc public func skipDescendants() {
      return wrappedInstance.skipDescendants()
    }

    @objc public func skipDescendents() {
      return wrappedInstance.skipDescendents()
    }

  }

}

@available(macOS, introduced: 10.13)
@objc public class NSFileProviderServiceWrapper: NSObject {
  var wrappedInstance: NSFileProviderService

  @available(macOS, introduced: 10.13)
  @objc public var name: NSFileProviderServiceNameWrapper {
    get {
      NSFileProviderServiceNameWrapper(wrappedInstance.name)
    }
  }

  init(_ wrappedInstance: NSFileProviderService) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.13)
  @objc public func fileProviderConnection() async throws -> NSXPCConnectionWrapper {
    let result = try await wrappedInstance.fileProviderConnection()
    return NSXPCConnectionWrapper(result)
  }

}

@available(macOS, introduced: 10.7)
@objc public class NSFileSecurityWrapper: NSObject {
  var wrappedInstance: NSFileSecurity

  init(_ wrappedInstance: NSFileSecurity) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.7)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSFileSecurity(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.7)
@objc public class NSFileVersionWrapper: NSObject {
  var wrappedInstance: NSFileVersion

  @available(macOS, introduced: 10.7)
  @objc public var url: URLWrapper {
    get {
      URLWrapper(wrappedInstance.url)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var isConflict: Bool {
    get {
      wrappedInstance.isConflict
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var isDiscardable: Bool {
    get {
      wrappedInstance.isDiscardable
    }
    set {
      wrappedInstance.isDiscardable = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var hasLocalContents: Bool {
    get {
      wrappedInstance.hasLocalContents
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var hasThumbnail: Bool {
    get {
      wrappedInstance.hasThumbnail
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var localizedName: String? {
    get {
      wrappedInstance.localizedName
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var localizedNameOfSavingComputer: String? {
    get {
      wrappedInstance.localizedNameOfSavingComputer
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var modificationDate: DateWrapper? {
    get {
      wrappedInstance.modificationDate == nil ? nil : DateWrapper(wrappedInstance.modificationDate!)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var originatorNameComponents: PersonNameComponentsWrapper? {
    get {
      wrappedInstance.originatorNameComponents == nil ? nil : PersonNameComponentsWrapper(wrappedInstance.originatorNameComponents!)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var isResolved: Bool {
    get {
      wrappedInstance.isResolved
    }
    set {
      wrappedInstance.isResolved = newValue
    }
  }

  init(_ wrappedInstance: NSFileVersion) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.7)
  @objc static public func currentVersionOfItem(at url: URLWrapper) -> NSFileVersionWrapper? {
    let result = NSFileVersion.currentVersionOfItem(at: url.wrappedInstance)
    return result == nil ? nil : NSFileVersionWrapper(result!)
  }

  @available(macOS, introduced: 10.7)
  @objc static public func removeOtherVersionsOfItem(at url: URLWrapper) throws {
    return try NSFileVersion.removeOtherVersionsOfItem(at: url.wrappedInstance)
  }

  @available(macOS, introduced: 10.7)
  @objc static public func temporaryDirectoryURLForNewVersionOfItem(at url: URLWrapper) -> URLWrapper {
    let result = NSFileVersion.temporaryDirectoryURLForNewVersionOfItem(at: url.wrappedInstance)
    return URLWrapper(result)
  }

  @available(macOS, introduced: 10.7)
  @objc public func remove() throws {
    return try wrappedInstance.remove()
  }

  @objc public class AddingOptionsWrapper: NSObject {
    var wrappedInstance: NSFileVersion.AddingOptions

    @objc static public var byMoving: NSFileVersionWrapper.AddingOptionsWrapper {
      get {
        AddingOptionsWrapper(NSFileVersion.AddingOptions.byMoving)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSFileVersion.AddingOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSFileVersion.AddingOptions()
    }

  }

  @objc public class ReplacingOptionsWrapper: NSObject {
    var wrappedInstance: NSFileVersion.ReplacingOptions

    @objc static public var byMoving: NSFileVersionWrapper.ReplacingOptionsWrapper {
      get {
        ReplacingOptionsWrapper(NSFileVersion.ReplacingOptions.byMoving)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSFileVersion.ReplacingOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSFileVersion.ReplacingOptions()
    }

  }

}

@available(macOS, introduced: 10.0)
@objc public class FileWrapperWrapper: NSObject {
  var wrappedInstance: FileWrapper

  @available(macOS, introduced: 10.0)
  @objc public var isDirectory: Bool {
    get {
      wrappedInstance.isDirectory
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var fileWrappers: FileWrapperWrapper {
    get {
      FileWrapperWrapper(wrappedInstance.fileWrappers)
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var filename: String? {
    get {
      wrappedInstance.filename
    }
    set {
      wrappedInstance.filename = newValue
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var preferredFilename: String? {
    get {
      wrappedInstance.preferredFilename
    }
    set {
      wrappedInstance.preferredFilename = newValue
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var isRegularFile: Bool {
    get {
      wrappedInstance.isRegularFile
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var regularFileContents: DataWrapper? {
    get {
      wrappedInstance.regularFileContents == nil ? nil : DataWrapper(wrappedInstance.regularFileContents!)
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var serializedRepresentation: DataWrapper? {
    get {
      wrappedInstance.serializedRepresentation == nil ? nil : DataWrapper(wrappedInstance.serializedRepresentation!)
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var isSymbolicLink: Bool {
    get {
      wrappedInstance.isSymbolicLink
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var symbolicLinkDestinationURL: URLWrapper? {
    get {
      wrappedInstance.symbolicLinkDestinationURL == nil ? nil : URLWrapper(wrappedInstance.symbolicLinkDestinationURL!)
    }
  }

  init(_ wrappedInstance: FileWrapper) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.0)
  @objc init(regularFileWithContents contents: DataWrapper) {
    wrappedInstance = FileWrapper(regularFileWithContents: contents.wrappedInstance)
  }

  @available(macOS, introduced: 10.6)
  @objc init(symbolicLinkWithDestinationURL url: URLWrapper) {
    wrappedInstance = FileWrapper(symbolicLinkWithDestinationURL: url.wrappedInstance)
  }

  @available(macOS, introduced: 10.0)
  @objc init?(coder inCoder: NSCoderWrapper) {
    if let instance = FileWrapper(coder: inCoder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.0)
  @objc init?(serializedRepresentation serializeRepresentation: DataWrapper) {
    if let instance = FileWrapper(serializedRepresentation: serializeRepresentation.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.0, deprecated: 10.10)
  @objc public func addFile(withPath path: String) -> String {
    return wrappedInstance.addFile(withPath: path)
  }

  @available(macOS, introduced: 10.0)
  @objc public func addFileWrapper(_ child: FileWrapperWrapper) -> String {
    return wrappedInstance.addFileWrapper(child.wrappedInstance)
  }

  @available(macOS, introduced: 10.0)
  @objc public func addRegularFile(withContents data: DataWrapper, preferredFilename fileName: String) -> String {
    return wrappedInstance.addRegularFile(withContents: data.wrappedInstance, preferredFilename: fileName)
  }

  @available(macOS, introduced: 10.0, deprecated: 10.10)
  @objc public func addSymbolicLink(withDestination path: String, preferredFilename filename: String) -> String {
    return wrappedInstance.addSymbolicLink(withDestination: path, preferredFilename: filename)
  }

  @available(macOS, introduced: 10.0)
  @objc public func keyForChildFileWrapper(_ child: FileWrapperWrapper) -> String? {
    return wrappedInstance.keyForChildFileWrapper(child.wrappedInstance)
  }

  @available(macOS, introduced: 10.6)
  @objc public func matchesContents(of url: URLWrapper) -> Bool {
    return wrappedInstance.matchesContents(of: url.wrappedInstance)
  }

  @available(macOS, introduced: 10.0, deprecated: 10.10)
  @objc public func needsToBeUpdated(fromPath path: String) -> Bool {
    return wrappedInstance.needsToBeUpdated(fromPath: path)
  }

  @available(macOS, introduced: 10.0)
  @objc public func removeFileWrapper(_ child: FileWrapperWrapper) {
    return wrappedInstance.removeFileWrapper(child.wrappedInstance)
  }

  @available(macOS, introduced: 10.0, deprecated: 10.10)
  @objc public func symbolicLinkDestination() -> String {
    return wrappedInstance.symbolicLinkDestination()
  }

  @available(macOS, introduced: 10.0, deprecated: 10.10)
  @objc public func update(fromPath path: String) -> Bool {
    return wrappedInstance.update(fromPath: path)
  }

  @available(macOS, introduced: 10.0, deprecated: 10.10)
  @objc public func write(toFile path: String, atomically atomicFlag: Bool, updateFilenames updateFilenamesFlag: Bool) -> Bool {
    return wrappedInstance.write(toFile: path, atomically: atomicFlag, updateFilenames: updateFilenamesFlag)
  }

  @available(macOS, introduced: 10.6)
  @objc public class ReadingOptionsWrapper: NSObject {
    var wrappedInstance: FileWrapper.ReadingOptions

    @available(macOS, introduced: 10.6)
    @objc static public var immediate: FileWrapperWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(FileWrapper.ReadingOptions.immediate)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var withoutMapping: FileWrapperWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(FileWrapper.ReadingOptions.withoutMapping)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: FileWrapper.ReadingOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = FileWrapper.ReadingOptions()
    }

  }

  @available(macOS, introduced: 10.6)
  @objc public class WritingOptionsWrapper: NSObject {
    var wrappedInstance: FileWrapper.WritingOptions

    @available(macOS, introduced: 10.6)
    @objc static public var atomic: FileWrapperWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(FileWrapper.WritingOptions.atomic)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var withNameUpdating: FileWrapperWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(FileWrapper.WritingOptions.withNameUpdating)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: FileWrapper.WritingOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = FileWrapper.WritingOptions()
    }

  }

}

@objc public class FormatterWrapper: NSObject {
  var wrappedInstance: Formatter

  init(_ wrappedInstance: Formatter) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = Formatter(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@objc public class NSGetCommandWrapper: NSObject {
  var wrappedInstance: NSGetCommand

  init(_ wrappedInstance: NSGetCommand) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.2)
@objc public class HTTPCookieWrapper: NSObject {
  var wrappedInstance: HTTPCookie

  @available(macOS, introduced: 10.2)
  @objc public var isHTTPOnly: Bool {
    get {
      wrappedInstance.isHTTPOnly
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var comment: String? {
    get {
      wrappedInstance.comment
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var commentURL: URLWrapper? {
    get {
      wrappedInstance.commentURL == nil ? nil : URLWrapper(wrappedInstance.commentURL!)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var domain: String {
    get {
      wrappedInstance.domain
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var expiresDate: DateWrapper? {
    get {
      wrappedInstance.expiresDate == nil ? nil : DateWrapper(wrappedInstance.expiresDate!)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var name: String {
    get {
      wrappedInstance.name
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var path: String {
    get {
      wrappedInstance.path
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var sameSitePolicy: HTTPCookieStringPolicyWrapper? {
    get {
      wrappedInstance.sameSitePolicy == nil ? nil : HTTPCookieStringPolicyWrapper(wrappedInstance.sameSitePolicy!)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var isSecure: Bool {
    get {
      wrappedInstance.isSecure
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var isSessionOnly: Bool {
    get {
      wrappedInstance.isSessionOnly
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var value: String {
    get {
      wrappedInstance.value
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var version: Int {
    get {
      wrappedInstance.version
    }
  }

  init(_ wrappedInstance: HTTPCookie) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.2)
@objc public class HTTPCookieStorageWrapper: NSObject {
  var wrappedInstance: HTTPCookieStorage

  @available(macOS, introduced: 10.2)
  @objc static public var shared: HTTPCookieStorageWrapper {
    get {
      HTTPCookieStorageWrapper(HTTPCookieStorage.shared)
    }
  }

  init(_ wrappedInstance: HTTPCookieStorage) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.11)
  @objc static public func sharedCookieStorage(forGroupContainerIdentifier identifier: String) -> HTTPCookieStorageWrapper {
    let result = HTTPCookieStorage.sharedCookieStorage(forGroupContainerIdentifier: identifier)
    return HTTPCookieStorageWrapper(result)
  }

  @available(macOS, introduced: 10.2)
  @objc public func deleteCookie(_ cookie: HTTPCookieWrapper) {
    return wrappedInstance.deleteCookie(cookie.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @objc public func removeCookies(since date: DateWrapper) {
    return wrappedInstance.removeCookies(since: date.wrappedInstance)
  }

  @available(macOS, introduced: 10.2)
  @objc public func setCookie(_ cookie: HTTPCookieWrapper) {
    return wrappedInstance.setCookie(cookie.wrappedInstance)
  }

}

@available(macOS, introduced: 10.2)
@objc public class HTTPURLResponseWrapper: NSObject {
  var wrappedInstance: HTTPURLResponse

  @available(macOS, introduced: 10.2)
  @objc public var statusCode: Int {
    get {
      wrappedInstance.statusCode
    }
  }

  init(_ wrappedInstance: HTTPURLResponse) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.2)
  @objc static public func localizedString(forStatusCode statusCode: Int) -> String {
    return HTTPURLResponse.localizedString(forStatusCode: statusCode)
  }

  @available(macOS, introduced: 10.15)
  @objc public func value(forHTTPHeaderField field: String) -> String? {
    return wrappedInstance.value(forHTTPHeaderField: field)
  }

}

@available(macOS, introduced: 10.5)
@objc public class NSHashTableWrapper: NSObject {
  var wrappedInstance: NSHashTable

  @available(macOS, introduced: 10.5)
  @objc public var count: Int {
    get {
      wrappedInstance.count
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var pointerFunctions: NSPointerFunctionsWrapper {
    get {
      NSPointerFunctionsWrapper(wrappedInstance.pointerFunctions)
    }
  }

  init(_ wrappedInstance: NSHashTable) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.5)
  @objc init(pointerFunctions functions: NSPointerFunctionsWrapper, capacity initialCapacity: Int) {
    wrappedInstance = NSHashTable(pointerFunctions: functions.wrappedInstance, capacity: initialCapacity)
  }

  @available(macOS, introduced: 10.5)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSHashTable(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.8)
  @objc static public func weakObjects() -> NSHashTableWrapper {
    let result = NSHashTable.weakObjects()
    return NSHashTableWrapper(result)
  }

  @available(macOS, introduced: 10.5)
  @objc public func objectEnumerator() -> NSEnumeratorWrapper {
    let result = wrappedInstance.objectEnumerator()
    return NSEnumeratorWrapper(result)
  }

  @available(macOS, introduced: 10.5)
  @objc public func removeAllObjects() {
    return wrappedInstance.removeAllObjects()
  }

}

@available(macOS, introduced: 10.0, deprecated: 100000)
@objc public class HostWrapper: NSObject {
  var wrappedInstance: Host

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public var address: String? {
    get {
      wrappedInstance.address
    }
  }

  @available(macOS, introduced: 10.6, deprecated: 100000)
  @objc public var localizedName: String? {
    get {
      wrappedInstance.localizedName
    }
  }

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public var name: String? {
    get {
      wrappedInstance.name
    }
  }

  init(_ wrappedInstance: Host) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public func isEqual(to aHost: HostWrapper) -> Bool {
    return wrappedInstance.isEqual(to: aHost.wrappedInstance)
  }

}

@available(macOS, introduced: 10.12)
@objc public class ISO8601DateFormatterWrapper: NSObject {
  var wrappedInstance: ISO8601DateFormatter

  @available(macOS, introduced: 10.12)
  @objc public var formatOptions: ISO8601DateFormatterWrapper.OptionsWrapper {
    get {
      OptionsWrapper(wrappedInstance.formatOptions)
    }
    set {
      wrappedInstance.formatOptions = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var timeZone: TimeZoneWrapper {
    get {
      TimeZoneWrapper(wrappedInstance.timeZone)
    }
    set {
      wrappedInstance.timeZone = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: ISO8601DateFormatter) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.12)
  @objc override init() {
    wrappedInstance = ISO8601DateFormatter()
  }

  @available(macOS, introduced: 10.12)
  @objc public func date(from string: String) -> DateWrapper? {
    let result = wrappedInstance.date(from: string)
    return result == nil ? nil : DateWrapper(result!)
  }

  @available(macOS, introduced: 10.12)
  @objc public func string(from date: DateWrapper) -> String {
    return wrappedInstance.string(from: date.wrappedInstance)
  }

  @objc public class OptionsWrapper: NSObject {
    var wrappedInstance: ISO8601DateFormatter.Options

    @available(macOS, introduced: 10.12)
    @objc static public var withColonSeparatorInTime: ISO8601DateFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(ISO8601DateFormatter.Options.withColonSeparatorInTime)
      }
    }

    @available(macOS, introduced: 10.12)
    @objc static public var withColonSeparatorInTimeZone: ISO8601DateFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(ISO8601DateFormatter.Options.withColonSeparatorInTimeZone)
      }
    }

    @available(macOS, introduced: 10.12)
    @objc static public var withDashSeparatorInDate: ISO8601DateFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(ISO8601DateFormatter.Options.withDashSeparatorInDate)
      }
    }

    @available(macOS, introduced: 10.12)
    @objc static public var withDay: ISO8601DateFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(ISO8601DateFormatter.Options.withDay)
      }
    }

    @available(macOS, introduced: 10.13)
    @objc static public var withFractionalSeconds: ISO8601DateFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(ISO8601DateFormatter.Options.withFractionalSeconds)
      }
    }

    @available(macOS, introduced: 10.12)
    @objc static public var withFullDate: ISO8601DateFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(ISO8601DateFormatter.Options.withFullDate)
      }
    }

    @available(macOS, introduced: 10.12)
    @objc static public var withFullTime: ISO8601DateFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(ISO8601DateFormatter.Options.withFullTime)
      }
    }

    @available(macOS, introduced: 10.12)
    @objc static public var withInternetDateTime: ISO8601DateFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(ISO8601DateFormatter.Options.withInternetDateTime)
      }
    }

    @available(macOS, introduced: 10.12)
    @objc static public var withMonth: ISO8601DateFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(ISO8601DateFormatter.Options.withMonth)
      }
    }

    @available(macOS, introduced: 10.12)
    @objc static public var withSpaceBetweenDateAndTime: ISO8601DateFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(ISO8601DateFormatter.Options.withSpaceBetweenDateAndTime)
      }
    }

    @available(macOS, introduced: 10.12)
    @objc static public var withTime: ISO8601DateFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(ISO8601DateFormatter.Options.withTime)
      }
    }

    @available(macOS, introduced: 10.12)
    @objc static public var withTimeZone: ISO8601DateFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(ISO8601DateFormatter.Options.withTimeZone)
      }
    }

    @available(macOS, introduced: 10.12)
    @objc static public var withWeekOfYear: ISO8601DateFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(ISO8601DateFormatter.Options.withWeekOfYear)
      }
    }

    @available(macOS, introduced: 10.12)
    @objc static public var withYear: ISO8601DateFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(ISO8601DateFormatter.Options.withYear)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: ISO8601DateFormatter.Options) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = ISO8601DateFormatter.Options()
    }

  }

}

@objc public class NSIndexPathWrapper: NSObject {
  var wrappedInstance: NSIndexPath

  @objc public var length: Int {
    get {
      wrappedInstance.length
    }
  }

  init(_ wrappedInstance: NSIndexPath) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSIndexPath(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func index(atPosition position: Int) -> Int {
    return wrappedInstance.index(atPosition: position)
  }

  @objc public func adding(_ index: Int) -> IndexPathWrapper {
    let result = wrappedInstance.adding(index)
    return IndexPathWrapper(result)
  }

  @objc public func removingLastIndex() -> IndexPathWrapper {
    let result = wrappedInstance.removingLastIndex()
    return IndexPathWrapper(result)
  }

}

@objc public class NSIndexSetWrapper: NSObject {
  var wrappedInstance: NSIndexSet

  @objc public var count: Int {
    get {
      wrappedInstance.count
    }
  }

  @objc public var firstIndex: Int {
    get {
      wrappedInstance.firstIndex
    }
  }

  @objc public var lastIndex: Int {
    get {
      wrappedInstance.lastIndex
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var underestimatedCount: Int {
    get {
      wrappedInstance.underestimatedCount
    }
  }

  init(_ wrappedInstance: NSIndexSet) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(indexSet: IndexSetWrapper) {
    wrappedInstance = NSIndexSet(indexSet: indexSet.wrappedInstance)
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSIndexSet(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func contains(_ value: Int) -> Bool {
    return wrappedInstance.contains(value)
  }

  @objc public func indexGreaterThanIndex(_ value: Int) -> Int {
    return wrappedInstance.indexGreaterThanIndex(value)
  }

  @objc public func indexGreaterThanOrEqual(to value: Int) -> Int {
    return wrappedInstance.indexGreaterThanOrEqual(to: value)
  }

  @objc public func indexLessThanIndex(_ value: Int) -> Int {
    return wrappedInstance.indexLessThanIndex(value)
  }

  @objc public func indexLessThanOrEqual(to value: Int) -> Int {
    return wrappedInstance.indexLessThanOrEqual(to: value)
  }

  @objc public func isEqual(to indexSet: IndexSetWrapper) -> Bool {
    return wrappedInstance.isEqual(to: indexSet.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func makeIterator() -> NSIndexSetIteratorWrapper {
    let result = wrappedInstance.makeIterator()
    return NSIndexSetIteratorWrapper(result)
  }

}

@objc public class NSIndexSpecifierWrapper: NSObject {
  var wrappedInstance: NSIndexSpecifier

  @objc public var index: Int {
    get {
      wrappedInstance.index
    }
    set {
      wrappedInstance.index = newValue
    }
  }

  init(_ wrappedInstance: NSIndexSpecifier) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(containerClassDescription classDesc: NSScriptClassDescriptionWrapper, containerSpecifier container: NSScriptObjectSpecifierWrapper?, key property: String, index: Int) {
    wrappedInstance = NSIndexSpecifier(containerClassDescription: classDesc.wrappedInstance, containerSpecifier: container?.wrappedInstance, key: property, index: index)
  }

}

@objc public class InputStreamWrapper: NSObject {
  var wrappedInstance: InputStream

  @objc public var hasBytesAvailable: Bool {
    get {
      wrappedInstance.hasBytesAvailable
    }
  }

  init(_ wrappedInstance: InputStream) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(data: DataWrapper) {
    wrappedInstance = InputStream(data: data.wrappedInstance)
  }

  @available(macOS, introduced: 10.6)
  @objc init?(url: URLWrapper) {
    if let instance = InputStream(url: url.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.10)
@objc public class NSItemProviderWrapper: NSObject {
  var wrappedInstance: NSItemProvider

  @available(macOS, introduced: 10.10)
  @objc static public var errorDomain: String {
    get {
      NSItemProvider.errorDomain
    }
  }

  @available(macOS, introduced: 10.14)
  @objc public var suggestedName: String? {
    get {
      wrappedInstance.suggestedName
    }
    set {
      wrappedInstance.suggestedName = newValue
    }
  }

  init(_ wrappedInstance: NSItemProvider) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @objc override init() {
    wrappedInstance = NSItemProvider()
  }

  @available(macOS, introduced: 10.10)
  @objc public func hasItemConformingToTypeIdentifier(_ typeIdentifier: String) -> Bool {
    return wrappedInstance.hasItemConformingToTypeIdentifier(typeIdentifier)
  }

}

@available(macOS, introduced: 10.7)
@objc public class JSONSerializationWrapper: NSObject {
  var wrappedInstance: JSONSerialization

  init(_ wrappedInstance: JSONSerialization) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.7)
  @objc public class ReadingOptionsWrapper: NSObject {
    var wrappedInstance: JSONSerialization.ReadingOptions

    @available(macOS, introduced: 10.7, deprecated: 100000)
    @objc static public var allowFragments: JSONSerializationWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(JSONSerialization.ReadingOptions.allowFragments)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var fragmentsAllowed: JSONSerializationWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(JSONSerialization.ReadingOptions.fragmentsAllowed)
      }
    }

    @available(macOS, introduced: 12.0)
    @objc static public var json5Allowed: JSONSerializationWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(JSONSerialization.ReadingOptions.json5Allowed)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var mutableContainers: JSONSerializationWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(JSONSerialization.ReadingOptions.mutableContainers)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var mutableLeaves: JSONSerializationWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(JSONSerialization.ReadingOptions.mutableLeaves)
      }
    }

    @available(macOS, introduced: 12.0)
    @objc static public var topLevelDictionaryAssumed: JSONSerializationWrapper.ReadingOptionsWrapper {
      get {
        ReadingOptionsWrapper(JSONSerialization.ReadingOptions.topLevelDictionaryAssumed)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: JSONSerialization.ReadingOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = JSONSerialization.ReadingOptions()
    }

  }

  @available(macOS, introduced: 10.7)
  @objc public class WritingOptionsWrapper: NSObject {
    var wrappedInstance: JSONSerialization.WritingOptions

    @available(macOS, introduced: 10.7)
    @objc static public var fragmentsAllowed: JSONSerializationWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(JSONSerialization.WritingOptions.fragmentsAllowed)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var prettyPrinted: JSONSerializationWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(JSONSerialization.WritingOptions.prettyPrinted)
      }
    }

    @available(macOS, introduced: 10.13)
    @objc static public var sortedKeys: JSONSerializationWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(JSONSerialization.WritingOptions.sortedKeys)
      }
    }

    @available(macOS, introduced: 10.15)
    @objc static public var withoutEscapingSlashes: JSONSerializationWrapper.WritingOptionsWrapper {
      get {
        WritingOptionsWrapper(JSONSerialization.WritingOptions.withoutEscapingSlashes)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: JSONSerialization.WritingOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = JSONSerialization.WritingOptions()
    }

  }

}

@available(macOS, introduced: 15.0)
@objc public class NSKeyValueSharedObserversWrapper: NSObject {
  var wrappedInstance: NSKeyValueSharedObservers

  init(_ wrappedInstance: NSKeyValueSharedObservers) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 15.0)
  @objc public func snapshot() -> NSKeyValueSharedObserversSnapshotWrapper {
    let result = wrappedInstance.snapshot()
    return NSKeyValueSharedObserversSnapshotWrapper(result)
  }

}

@available(macOS, introduced: 15.0)
@objc public class NSKeyValueSharedObserversSnapshotWrapper: NSObject {
  var wrappedInstance: NSKeyValueSharedObserversSnapshot

  init(_ wrappedInstance: NSKeyValueSharedObserversSnapshot) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSKeyedArchiverWrapper: NSObject {
  var wrappedInstance: NSKeyedArchiver

  @available(macOS, introduced: 10.12)
  @objc public var encodedData: DataWrapper {
    get {
      DataWrapper(wrappedInstance.encodedData)
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var requiresSecureCoding: Bool {
    get {
      wrappedInstance.requiresSecureCoding
    }
    set {
      wrappedInstance.requiresSecureCoding = newValue
    }
  }

  init(_ wrappedInstance: NSKeyedArchiver) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.12, deprecated: 10.14)
  @objc override init() {
    wrappedInstance = NSKeyedArchiver()
  }

  @available(macOS, introduced: 10.2, deprecated: 10.14)
  @objc init(forWritingWith data: NSMutableDataWrapper) {
    wrappedInstance = NSKeyedArchiver(forWritingWith: data.wrappedInstance)
  }

  @available(macOS, introduced: 10.13)
  @objc init(requiringSecureCoding requiresSecureCoding: Bool) {
    wrappedInstance = NSKeyedArchiver(requiringSecureCoding: requiresSecureCoding)
  }

  @objc public func encode(_ value: Float, forKey key: String) {
    return wrappedInstance.encode(value, forKey: key)
  }

  @objc public func finishEncoding() {
    return wrappedInstance.finishEncoding()
  }

}

@objc public class NSKeyedUnarchiverWrapper: NSObject {
  var wrappedInstance: NSKeyedUnarchiver

  @available(macOS, introduced: 10.8)
  @objc public var requiresSecureCoding: Bool {
    get {
      wrappedInstance.requiresSecureCoding
    }
    set {
      wrappedInstance.requiresSecureCoding = newValue
    }
  }

  init(_ wrappedInstance: NSKeyedUnarchiver) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.2, deprecated: 10.14)
  @objc override init() {
    wrappedInstance = NSKeyedUnarchiver()
  }

  @available(macOS, introduced: 10.13)
  @objc init(forReadingFrom data: DataWrapper) throws {
    wrappedInstance = try NSKeyedUnarchiver(forReadingFrom: data.wrappedInstance)
  }

  @available(macOS, introduced: 10.2, deprecated: 10.14)
  @objc init(forReadingWith data: DataWrapper) {
    wrappedInstance = NSKeyedUnarchiver(forReadingWith: data.wrappedInstance)
  }

  @objc public func containsValue(forKey key: String) -> Bool {
    return wrappedInstance.containsValue(forKey: key)
  }

  @objc public func decodeBool(forKey key: String) -> Bool {
    return wrappedInstance.decodeBool(forKey: key)
  }

  @objc public func decodeDouble(forKey key: String) -> Double {
    return wrappedInstance.decodeDouble(forKey: key)
  }

  @objc public func decodeFloat(forKey key: String) -> Float {
    return wrappedInstance.decodeFloat(forKey: key)
  }

  @objc public func finishDecoding() {
    return wrappedInstance.finishDecoding()
  }

}

@available(macOS, introduced: 10.10)
@objc public class LengthFormatterWrapper: NSObject {
  var wrappedInstance: LengthFormatter

  @available(macOS, introduced: 10.10)
  @objc public var isForPersonHeightUse: Bool {
    get {
      wrappedInstance.isForPersonHeightUse
    }
    set {
      wrappedInstance.isForPersonHeightUse = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var numberFormatter: NumberFormatterWrapper {
    get {
      NumberFormatterWrapper(wrappedInstance.numberFormatter)
    }
    set {
      wrappedInstance.numberFormatter = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: LengthFormatter) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @objc public func string(fromMeters numberInMeters: Double) -> String {
    return wrappedInstance.string(fromMeters: numberInMeters)
  }

}

@available(macOS, introduced: 10.7, deprecated: 100000)
@objc public class NSLinguisticTaggerWrapper: NSObject {
  var wrappedInstance: NSLinguisticTagger

  @available(macOS, introduced: 10.13, deprecated: 100000)
  @objc public var dominantLanguage: String? {
    get {
      wrappedInstance.dominantLanguage
    }
  }

  @available(macOS, introduced: 10.7, deprecated: 100000)
  @objc public var string: String? {
    get {
      wrappedInstance.string
    }
    set {
      wrappedInstance.string = newValue
    }
  }

  init(_ wrappedInstance: NSLinguisticTagger) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.13, deprecated: 100000)
  @objc static public func dominantLanguage(for string: String) -> String? {
    return NSLinguisticTagger.dominantLanguage(for: string)
  }

  @objc public class OptionsWrapper: NSObject {
    var wrappedInstance: NSLinguisticTagger.Options

    @objc static public var joinNames: NSLinguisticTaggerWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSLinguisticTagger.Options.joinNames)
      }
    }

    @objc static public var omitOther: NSLinguisticTaggerWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSLinguisticTagger.Options.omitOther)
      }
    }

    @objc static public var omitPunctuation: NSLinguisticTaggerWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSLinguisticTagger.Options.omitPunctuation)
      }
    }

    @objc static public var omitWhitespace: NSLinguisticTaggerWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSLinguisticTagger.Options.omitWhitespace)
      }
    }

    @objc static public var omitWords: NSLinguisticTaggerWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSLinguisticTagger.Options.omitWords)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSLinguisticTagger.Options) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSLinguisticTagger.Options()
    }

  }

}

@available(macOS, introduced: 10.15)
@objc public class ListFormatterWrapper: NSObject {
  var wrappedInstance: ListFormatter

  @available(macOS, introduced: 10.15)
  @objc public var itemFormatter: FormatterWrapper? {
    get {
      wrappedInstance.itemFormatter == nil ? nil : FormatterWrapper(wrappedInstance.itemFormatter!)
    }
    set {
      wrappedInstance.itemFormatter = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var locale: LocaleWrapper {
    get {
      LocaleWrapper(wrappedInstance.locale)
    }
    set {
      wrappedInstance.locale = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: ListFormatter) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSLocaleWrapper: NSObject {
  var wrappedInstance: NSLocale

  @available(macOS, introduced: 10.5)
  @objc static public var currentLocaleDidChangeNotification: NSNotificationWrapper.NameWrapper {
    get {
      NameWrapper(NSLocale.currentLocaleDidChangeNotification)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var autoupdatingCurrent: LocaleWrapper {
    get {
      LocaleWrapper(NSLocale.autoupdatingCurrent)
    }
  }

  @objc static public var current: LocaleWrapper {
    get {
      LocaleWrapper(NSLocale.current)
    }
  }

  @objc static public var system: LocaleWrapper {
    get {
      LocaleWrapper(NSLocale.system)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var alternateQuotationBeginDelimiter: String {
    get {
      wrappedInstance.alternateQuotationBeginDelimiter
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var alternateQuotationEndDelimiter: String {
    get {
      wrappedInstance.alternateQuotationEndDelimiter
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var calendarIdentifier: String {
    get {
      wrappedInstance.calendarIdentifier
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var collationIdentifier: String? {
    get {
      wrappedInstance.collationIdentifier
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var collatorIdentifier: String {
    get {
      wrappedInstance.collatorIdentifier
    }
  }

  @available(macOS, introduced: 10.12, deprecated: 100000)
  @objc public var countryCode: String? {
    get {
      wrappedInstance.countryCode
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var currencyCode: String? {
    get {
      wrappedInstance.currencyCode
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var currencySymbol: String {
    get {
      wrappedInstance.currencySymbol
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var decimalSeparator: String {
    get {
      wrappedInstance.decimalSeparator
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var exemplarCharacterSet: CharacterSetWrapper {
    get {
      CharacterSetWrapper(wrappedInstance.exemplarCharacterSet)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var groupingSeparator: String {
    get {
      wrappedInstance.groupingSeparator
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var languageCode: String {
    get {
      wrappedInstance.languageCode
    }
  }

  @available(macOS, introduced: 14.0)
  @objc public var languageIdentifier: String {
    get {
      wrappedInstance.languageIdentifier
    }
  }

  @objc public var localeIdentifier: String {
    get {
      wrappedInstance.localeIdentifier
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var quotationBeginDelimiter: String {
    get {
      wrappedInstance.quotationBeginDelimiter
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var quotationEndDelimiter: String {
    get {
      wrappedInstance.quotationEndDelimiter
    }
  }

  @available(macOS, introduced: 14.0)
  @objc public var regionCode: String? {
    get {
      wrappedInstance.regionCode
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var scriptCode: String? {
    get {
      wrappedInstance.scriptCode
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var usesMetricSystem: Bool {
    get {
      wrappedInstance.usesMetricSystem
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var variantCode: String? {
    get {
      wrappedInstance.variantCode
    }
  }

  init(_ wrappedInstance: NSLocale) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSLocale(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init(localeIdentifier string: String) {
    wrappedInstance = NSLocale(localeIdentifier: string)
  }

  @objc static public func canonicalLanguageIdentifier(from string: String) -> String {
    return NSLocale.canonicalLanguageIdentifier(from: string)
  }

  @objc static public func canonicalLocaleIdentifier(from string: String) -> String {
    return NSLocale.canonicalLocaleIdentifier(from: string)
  }

  @available(macOS, introduced: 10.12)
  @objc public func localizedString(forCalendarIdentifier calendarIdentifier: String) -> String? {
    return wrappedInstance.localizedString(forCalendarIdentifier: calendarIdentifier)
  }

  @available(macOS, introduced: 10.12)
  @objc public func localizedString(forCollationIdentifier collationIdentifier: String) -> String? {
    return wrappedInstance.localizedString(forCollationIdentifier: collationIdentifier)
  }

  @available(macOS, introduced: 10.12)
  @objc public func localizedString(forCollatorIdentifier collatorIdentifier: String) -> String? {
    return wrappedInstance.localizedString(forCollatorIdentifier: collatorIdentifier)
  }

  @available(macOS, introduced: 10.12)
  @objc public func localizedString(forCountryCode countryCode: String) -> String? {
    return wrappedInstance.localizedString(forCountryCode: countryCode)
  }

  @available(macOS, introduced: 10.12)
  @objc public func localizedString(forCurrencyCode currencyCode: String) -> String? {
    return wrappedInstance.localizedString(forCurrencyCode: currencyCode)
  }

  @available(macOS, introduced: 10.12)
  @objc public func localizedString(forLanguageCode languageCode: String) -> String? {
    return wrappedInstance.localizedString(forLanguageCode: languageCode)
  }

  @available(macOS, introduced: 10.12)
  @objc public func localizedString(forLocaleIdentifier localeIdentifier: String) -> String {
    return wrappedInstance.localizedString(forLocaleIdentifier: localeIdentifier)
  }

  @available(macOS, introduced: 10.12)
  @objc public func localizedString(forScriptCode scriptCode: String) -> String? {
    return wrappedInstance.localizedString(forScriptCode: scriptCode)
  }

  @available(macOS, introduced: 10.12)
  @objc public func localizedString(forVariantCode variantCode: String) -> String? {
    return wrappedInstance.localizedString(forVariantCode: variantCode)
  }

  @objc public class KeyWrapper: NSObject {
    var wrappedInstance: NSLocale.Key

    @available(macOS, introduced: 10.6)
    @objc static public var alternateQuotationBeginDelimiterKey: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.alternateQuotationBeginDelimiterKey)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var alternateQuotationEndDelimiterKey: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.alternateQuotationEndDelimiterKey)
      }
    }

    @objc static public var calendar: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.calendar)
      }
    }

    @objc static public var collationIdentifier: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.collationIdentifier)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var collatorIdentifier: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.collatorIdentifier)
      }
    }

    @objc static public var countryCode: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.countryCode)
      }
    }

    @objc static public var currencyCode: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.currencyCode)
      }
    }

    @objc static public var currencySymbol: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.currencySymbol)
      }
    }

    @objc static public var decimalSeparator: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.decimalSeparator)
      }
    }

    @objc static public var exemplarCharacterSet: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.exemplarCharacterSet)
      }
    }

    @objc static public var groupingSeparator: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.groupingSeparator)
      }
    }

    @objc static public var identifier: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.identifier)
      }
    }

    @objc static public var languageCode: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.languageCode)
      }
    }

    @objc static public var measurementSystem: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.measurementSystem)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var quotationBeginDelimiterKey: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.quotationBeginDelimiterKey)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var quotationEndDelimiterKey: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.quotationEndDelimiterKey)
      }
    }

    @objc static public var scriptCode: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.scriptCode)
      }
    }

    @objc static public var usesMetricSystem: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.usesMetricSystem)
      }
    }

    @objc static public var variantCode: NSLocaleWrapper.KeyWrapper {
      get {
        KeyWrapper(NSLocale.Key.variantCode)
      }
    }

    init(_ wrappedInstance: NSLocale.Key) {
      self.wrappedInstance = wrappedInstance
    }

    @objc init(rawValue: String) {
      wrappedInstance = NSLocale.Key(rawValue: rawValue)
    }

  }

}

@objc public class NSLockWrapper: NSObject {
  var wrappedInstance: NSLock

  @available(macOS, introduced: 10.5)
  @objc public var name: String? {
    get {
      wrappedInstance.name
    }
    set {
      wrappedInstance.name = newValue
    }
  }

  init(_ wrappedInstance: NSLock) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func lock(before limit: DateWrapper) -> Bool {
    return wrappedInstance.lock(before: limit.wrappedInstance)
  }

  @objc public func `try`() -> Bool {
    return wrappedInstance.`try`()
  }

}

@objc public class NSLogicalTestWrapper: NSObject {
  var wrappedInstance: NSLogicalTest

  init(_ wrappedInstance: NSLogicalTest) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(notTestWith subTest: NSScriptWhoseTestWrapper) {
    wrappedInstance = NSLogicalTest(notTestWith: subTest.wrappedInstance)
  }

}

@objc public class NSMachPortWrapper: NSObject {
  var wrappedInstance: NSMachPort

  init(_ wrappedInstance: NSMachPort) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func remove(from runLoop: RunLoopWrapper, forMode mode: RunLoopWrapper.ModeWrapper) {
    return wrappedInstance.remove(from: runLoop.wrappedInstance, forMode: mode.wrappedInstance)
  }

  @objc public func schedule(in runLoop: RunLoopWrapper, forMode mode: RunLoopWrapper.ModeWrapper) {
    return wrappedInstance.schedule(in: runLoop.wrappedInstance, forMode: mode.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc public class OptionsWrapper: NSObject {
    var wrappedInstance: NSMachPort.Options

    @available(macOS, introduced: 10.5)
    @objc static public var deallocateReceiveRight: NSMachPortWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSMachPort.Options.deallocateReceiveRight)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var deallocateSendRight: NSMachPortWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSMachPort.Options.deallocateSendRight)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSMachPort.Options) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSMachPort.Options()
    }

  }

}

@available(macOS, introduced: 10.5)
@objc public class NSMapTableWrapper: NSObject {
  var wrappedInstance: NSMapTable

  @available(macOS, introduced: 10.5)
  @objc public var count: Int {
    get {
      wrappedInstance.count
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var keyPointerFunctions: NSPointerFunctionsWrapper {
    get {
      NSPointerFunctionsWrapper(wrappedInstance.keyPointerFunctions)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var valuePointerFunctions: NSPointerFunctionsWrapper {
    get {
      NSPointerFunctionsWrapper(wrappedInstance.valuePointerFunctions)
    }
  }

  init(_ wrappedInstance: NSMapTable) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.5)
  @objc init(keyPointerFunctions keyFunctions: NSPointerFunctionsWrapper, valuePointerFunctions valueFunctions: NSPointerFunctionsWrapper, capacity initialCapacity: Int) {
    wrappedInstance = NSMapTable(keyPointerFunctions: keyFunctions.wrappedInstance, valuePointerFunctions: valueFunctions.wrappedInstance, capacity: initialCapacity)
  }

  @available(macOS, introduced: 10.5)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSMapTable(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.8)
  @objc static public func strongToStrongObjects() -> NSMapTableWrapper {
    let result = NSMapTable.strongToStrongObjects()
    return NSMapTableWrapper(result)
  }

  @available(macOS, introduced: 10.8)
  @objc static public func strongToWeakObjects() -> NSMapTableWrapper {
    let result = NSMapTable.strongToWeakObjects()
    return NSMapTableWrapper(result)
  }

  @available(macOS, introduced: 10.8)
  @objc static public func weakToStrongObjects() -> NSMapTableWrapper {
    let result = NSMapTable.weakToStrongObjects()
    return NSMapTableWrapper(result)
  }

  @available(macOS, introduced: 10.8)
  @objc static public func weakToWeakObjects() -> NSMapTableWrapper {
    let result = NSMapTable.weakToWeakObjects()
    return NSMapTableWrapper(result)
  }

  @available(macOS, introduced: 10.5)
  @objc public func keyEnumerator() -> NSEnumeratorWrapper {
    let result = wrappedInstance.keyEnumerator()
    return NSEnumeratorWrapper(result)
  }

  @available(macOS, introduced: 10.5)
  @objc public func objectEnumerator() -> NSEnumeratorWrapper? {
    let result = wrappedInstance.objectEnumerator()
    return result == nil ? nil : NSEnumeratorWrapper(result!)
  }

  @available(macOS, introduced: 10.5)
  @objc public func removeAllObjects() {
    return wrappedInstance.removeAllObjects()
  }

}

@available(macOS, introduced: 10.10)
@objc public class MassFormatterWrapper: NSObject {
  var wrappedInstance: MassFormatter

  @available(macOS, introduced: 10.10)
  @objc public var isForPersonMassUse: Bool {
    get {
      wrappedInstance.isForPersonMassUse
    }
    set {
      wrappedInstance.isForPersonMassUse = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var numberFormatter: NumberFormatterWrapper {
    get {
      NumberFormatterWrapper(wrappedInstance.numberFormatter)
    }
    set {
      wrappedInstance.numberFormatter = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: MassFormatter) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @objc public func string(fromKilograms numberInKilograms: Double) -> String {
    return wrappedInstance.string(fromKilograms: numberInKilograms)
  }

}

@available(macOS, introduced: 10.12)
@objc public class NSMeasurementWrapper: NSObject {
  var wrappedInstance: NSMeasurement

  @available(macOS, introduced: 10.12)
  @objc public var doubleValue: Double {
    get {
      wrappedInstance.doubleValue
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var unit: UnitWrapper {
    get {
      UnitWrapper(wrappedInstance.unit)
    }
  }

  init(_ wrappedInstance: NSMeasurement) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.12)
  @objc init(doubleValue: Double, unit: UnitWrapper) {
    wrappedInstance = NSMeasurement(doubleValue: doubleValue, unit: unit.wrappedInstance)
  }

  @available(macOS, introduced: 10.12)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSMeasurement(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public func canBeConverted(to unit: UnitWrapper) -> Bool {
    return wrappedInstance.canBeConverted(to: unit.wrappedInstance)
  }

  @available(macOS, introduced: 10.12)
  @objc public func converting(to unit: UnitWrapper) -> MeasurementWrapper {
    let result = wrappedInstance.converting(to: unit.wrappedInstance)
    return MeasurementWrapper(result)
  }

}

@available(macOS, introduced: 10.12)
@objc public class MeasurementFormatterWrapper: NSObject {
  var wrappedInstance: MeasurementFormatter

  @available(macOS, introduced: 10.12)
  @objc public var locale: LocaleWrapper {
    get {
      LocaleWrapper(wrappedInstance.locale)
    }
    set {
      wrappedInstance.locale = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var numberFormatter: NumberFormatterWrapper {
    get {
      NumberFormatterWrapper(wrappedInstance.numberFormatter)
    }
    set {
      wrappedInstance.numberFormatter = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var unitOptions: MeasurementFormatterWrapper.UnitOptionsWrapper {
    get {
      UnitOptionsWrapper(wrappedInstance.unitOptions)
    }
    set {
      wrappedInstance.unitOptions = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: MeasurementFormatter) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.12)
  @objc public func string(from unit: UnitWrapper) -> String {
    return wrappedInstance.string(from: unit.wrappedInstance)
  }

  @available(macOS, introduced: 10.12)
  @objc public class UnitOptionsWrapper: NSObject {
    var wrappedInstance: MeasurementFormatter.UnitOptions

    @available(macOS, introduced: 10.12)
    @objc static public var naturalScale: MeasurementFormatterWrapper.UnitOptionsWrapper {
      get {
        UnitOptionsWrapper(MeasurementFormatter.UnitOptions.naturalScale)
      }
    }

    @available(macOS, introduced: 10.12)
    @objc static public var providedUnit: MeasurementFormatterWrapper.UnitOptionsWrapper {
      get {
        UnitOptionsWrapper(MeasurementFormatter.UnitOptions.providedUnit)
      }
    }

    @available(macOS, introduced: 10.12)
    @objc static public var temperatureWithoutUnit: MeasurementFormatterWrapper.UnitOptionsWrapper {
      get {
        UnitOptionsWrapper(MeasurementFormatter.UnitOptions.temperatureWithoutUnit)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: MeasurementFormatter.UnitOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = MeasurementFormatter.UnitOptions()
    }

  }

}

@objc public class MessagePortWrapper: NSObject {
  var wrappedInstance: MessagePort

  init(_ wrappedInstance: MessagePort) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.4)
@objc public class NSMetadataItemWrapper: NSObject {
  var wrappedInstance: NSMetadataItem

  init(_ wrappedInstance: NSMetadataItem) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.9)
  @objc init?(url: URLWrapper) {
    if let instance = NSMetadataItem(url: url.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.4)
@objc public class NSMetadataQueryWrapper: NSObject {
  var wrappedInstance: NSMetadataQuery

  @available(macOS, introduced: 10.4)
  @objc public var isGathering: Bool {
    get {
      wrappedInstance.isGathering
    }
  }

  @available(macOS, introduced: 10.4)
  @objc public var notificationBatchingInterval: TimeInterval {
    get {
      wrappedInstance.notificationBatchingInterval
    }
    set {
      wrappedInstance.notificationBatchingInterval = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var operationQueue: OperationQueueWrapper? {
    get {
      wrappedInstance.operationQueue == nil ? nil : OperationQueueWrapper(wrappedInstance.operationQueue!)
    }
    set {
      wrappedInstance.operationQueue = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.4)
  @objc public var predicate: NSPredicateWrapper? {
    get {
      wrappedInstance.predicate == nil ? nil : NSPredicateWrapper(wrappedInstance.predicate!)
    }
    set {
      wrappedInstance.predicate = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.4)
  @objc public var resultCount: Int {
    get {
      wrappedInstance.resultCount
    }
  }

  @available(macOS, introduced: 10.4)
  @objc public var isStarted: Bool {
    get {
      wrappedInstance.isStarted
    }
  }

  @available(macOS, introduced: 10.4)
  @objc public var isStopped: Bool {
    get {
      wrappedInstance.isStopped
    }
  }

  init(_ wrappedInstance: NSMetadataQuery) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.4)
  @objc public func disableUpdates() {
    return wrappedInstance.disableUpdates()
  }

  @available(macOS, introduced: 10.4)
  @objc public func enableUpdates() {
    return wrappedInstance.enableUpdates()
  }

  @available(macOS, introduced: 10.4)
  @objc public func start() -> Bool {
    return wrappedInstance.start()
  }

  @available(macOS, introduced: 10.4)
  @objc public func stop() {
    return wrappedInstance.stop()
  }

}

@available(macOS, introduced: 10.4)
@objc public class NSMetadataQueryAttributeValueTupleWrapper: NSObject {
  var wrappedInstance: NSMetadataQueryAttributeValueTuple

  @available(macOS, introduced: 10.4)
  @objc public var attribute: String {
    get {
      wrappedInstance.attribute
    }
  }

  @available(macOS, introduced: 10.4)
  @objc public var count: Int {
    get {
      wrappedInstance.count
    }
  }

  init(_ wrappedInstance: NSMetadataQueryAttributeValueTuple) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.4)
@objc public class NSMetadataQueryResultGroupWrapper: NSObject {
  var wrappedInstance: NSMetadataQueryResultGroup

  @available(macOS, introduced: 10.4)
  @objc public var attribute: String {
    get {
      wrappedInstance.attribute
    }
  }

  @available(macOS, introduced: 10.4)
  @objc public var resultCount: Int {
    get {
      wrappedInstance.resultCount
    }
  }

  init(_ wrappedInstance: NSMetadataQueryResultGroup) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSMiddleSpecifierWrapper: NSObject {
  var wrappedInstance: NSMiddleSpecifier

  init(_ wrappedInstance: NSMiddleSpecifier) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSMoveCommandWrapper: NSObject {
  var wrappedInstance: NSMoveCommand

  @objc public var keySpecifier: NSScriptObjectSpecifierWrapper {
    get {
      NSScriptObjectSpecifierWrapper(wrappedInstance.keySpecifier)
    }
  }

  init(_ wrappedInstance: NSMoveCommand) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func setReceiversSpecifier(_ receiversRef: NSScriptObjectSpecifierWrapper?) {
    return wrappedInstance.setReceiversSpecifier(receiversRef?.wrappedInstance)
  }

}

@objc public class NSMutableArrayWrapper: NSObject {
  var wrappedInstance: NSMutableArray

  init(_ wrappedInstance: NSMutableArray) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSMutableArray()
  }

  @objc init(capacity numItems: Int) {
    wrappedInstance = NSMutableArray(capacity: numItems)
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSMutableArray(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func exchangeObject(at idx1: Int, withObjectAt idx2: Int) {
    return wrappedInstance.exchangeObject(at: idx1, withObjectAt: idx2)
  }

  @objc public func filter(using predicate: NSPredicateWrapper) {
    return wrappedInstance.filter(using: predicate.wrappedInstance)
  }

  @objc public func removeAllObjects() {
    return wrappedInstance.removeAllObjects()
  }

  @objc public func removeLastObject() {
    return wrappedInstance.removeLastObject()
  }

  @objc public func removeObject(at index: Int) {
    return wrappedInstance.removeObject(at: index)
  }

  @objc public func removeObjects(at indexes: IndexSetWrapper) {
    return wrappedInstance.removeObjects(at: indexes.wrappedInstance)
  }

}

@available(macOS, introduced: 10.0)
@objc public class NSMutableAttributedStringWrapper: NSObject {
  var wrappedInstance: NSMutableAttributedString

  @objc public var mutableString: NSMutableStringWrapper {
    get {
      NSMutableStringWrapper(wrappedInstance.mutableString)
    }
  }

  init(_ wrappedInstance: NSMutableAttributedString) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func append(_ attrString: NSAttributedStringWrapper) {
    return wrappedInstance.append(attrString.wrappedInstance)
  }

  @objc public func beginEditing() {
    return wrappedInstance.beginEditing()
  }

  @objc public func endEditing() {
    return wrappedInstance.endEditing()
  }

  @objc public func insert(_ attrString: NSAttributedStringWrapper, at loc: Int) {
    return wrappedInstance.insert(attrString.wrappedInstance, at: loc)
  }

  @objc public func setAttributedString(_ attrString: NSAttributedStringWrapper) {
    return wrappedInstance.setAttributedString(attrString.wrappedInstance)
  }

}

@objc public class NSMutableCharacterSetWrapper: NSObject {
  var wrappedInstance: NSMutableCharacterSet

  init(_ wrappedInstance: NSMutableCharacterSet) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(bitmapRepresentation data: DataWrapper) {
    wrappedInstance = NSMutableCharacterSet(bitmapRepresentation: data.wrappedInstance)
  }

  @objc init(charactersIn aString: String) {
    wrappedInstance = NSMutableCharacterSet(charactersIn: aString)
  }

  @objc init?(contentsOfFile fName: String) {
    if let instance = NSMutableCharacterSet(contentsOfFile: fName) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc static public func alphanumeric() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.alphanumeric()
    return NSMutableCharacterSetWrapper(result)
  }

  @objc static public func capitalizedLetter() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.capitalizedLetter()
    return NSMutableCharacterSetWrapper(result)
  }

  @objc static public func control() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.control()
    return NSMutableCharacterSetWrapper(result)
  }

  @objc static public func decimalDigit() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.decimalDigit()
    return NSMutableCharacterSetWrapper(result)
  }

  @objc static public func decomposable() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.decomposable()
    return NSMutableCharacterSetWrapper(result)
  }

  @objc static public func illegal() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.illegal()
    return NSMutableCharacterSetWrapper(result)
  }

  @objc static public func letter() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.letter()
    return NSMutableCharacterSetWrapper(result)
  }

  @objc static public func lowercaseLetter() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.lowercaseLetter()
    return NSMutableCharacterSetWrapper(result)
  }

  @available(macOS, introduced: 10.5)
  @objc static public func newline() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.newline()
    return NSMutableCharacterSetWrapper(result)
  }

  @objc static public func nonBase() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.nonBase()
    return NSMutableCharacterSetWrapper(result)
  }

  @objc static public func punctuation() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.punctuation()
    return NSMutableCharacterSetWrapper(result)
  }

  @objc static public func symbol() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.symbol()
    return NSMutableCharacterSetWrapper(result)
  }

  @objc static public func uppercaseLetter() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.uppercaseLetter()
    return NSMutableCharacterSetWrapper(result)
  }

  @objc static public func whitespaceAndNewline() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.whitespaceAndNewline()
    return NSMutableCharacterSetWrapper(result)
  }

  @objc static public func whitespace() -> NSMutableCharacterSetWrapper {
    let result = NSMutableCharacterSet.whitespace()
    return NSMutableCharacterSetWrapper(result)
  }

  @objc public func addCharacters(in aString: String) {
    return wrappedInstance.addCharacters(in: aString)
  }

  @objc public func formIntersection(with otherSet: CharacterSetWrapper) {
    return wrappedInstance.formIntersection(with: otherSet.wrappedInstance)
  }

  @objc public func formUnion(with otherSet: CharacterSetWrapper) {
    return wrappedInstance.formUnion(with: otherSet.wrappedInstance)
  }

  @objc public func invert() {
    return wrappedInstance.invert()
  }

  @objc public func removeCharacters(in aString: String) {
    return wrappedInstance.removeCharacters(in: aString)
  }

}

@objc public class NSMutableDataWrapper: NSObject {
  var wrappedInstance: NSMutableData

  @objc public var length: Int {
    get {
      wrappedInstance.length
    }
    set {
      wrappedInstance.length = newValue
    }
  }

  init(_ wrappedInstance: NSMutableData) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(capacity: Int) {
    if let instance = NSMutableData(capacity: capacity) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init?(length: Int) {
    if let instance = NSMutableData(length: length) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func append(_ other: DataWrapper) {
    return wrappedInstance.append(other.wrappedInstance)
  }

  @objc public func increaseLength(by extraLength: Int) {
    return wrappedInstance.increaseLength(by: extraLength)
  }

  @objc public func setData(_ data: DataWrapper) {
    return wrappedInstance.setData(data.wrappedInstance)
  }

}

@objc public class NSMutableDictionaryWrapper: NSObject {
  var wrappedInstance: NSMutableDictionary

  init(_ wrappedInstance: NSMutableDictionary) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSMutableDictionary()
  }

  @objc init(capacity numItems: Int) {
    wrappedInstance = NSMutableDictionary(capacity: numItems)
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSMutableDictionary(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func removeAllObjects() {
    return wrappedInstance.removeAllObjects()
  }

}

@objc public class NSMutableIndexSetWrapper: NSObject {
  var wrappedInstance: NSMutableIndexSet

  init(_ wrappedInstance: NSMutableIndexSet) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func add(_ indexSet: IndexSetWrapper) {
    return wrappedInstance.add(indexSet.wrappedInstance)
  }

  @objc public func removeAllIndexes() {
    return wrappedInstance.removeAllIndexes()
  }

  @objc public func remove(_ indexSet: IndexSetWrapper) {
    return wrappedInstance.remove(indexSet.wrappedInstance)
  }

  @objc public func shiftIndexesStarting(at index: Int, by delta: Int) {
    return wrappedInstance.shiftIndexesStarting(at: index, by: delta)
  }

}

@available(macOS, introduced: 10.7)
@objc public class NSMutableOrderedSetWrapper: NSObject {
  var wrappedInstance: NSMutableOrderedSet

  init(_ wrappedInstance: NSMutableOrderedSet) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.7)
  @objc override init() {
    wrappedInstance = NSMutableOrderedSet()
  }

  @available(macOS, introduced: 10.7)
  @objc init(capacity numItems: Int) {
    wrappedInstance = NSMutableOrderedSet(capacity: numItems)
  }

  @available(macOS, introduced: 10.7)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSMutableOrderedSet(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func exchangeObject(at idx1: Int, withObjectAt idx2: Int) {
    return wrappedInstance.exchangeObject(at: idx1, withObjectAt: idx2)
  }

  @available(macOS, introduced: 10.7)
  @objc public func filter(using p: NSPredicateWrapper) {
    return wrappedInstance.filter(using: p.wrappedInstance)
  }

  @objc public func intersect(_ other: NSOrderedSetWrapper) {
    return wrappedInstance.intersect(other.wrappedInstance)
  }

  @objc public func minus(_ other: NSOrderedSetWrapper) {
    return wrappedInstance.minus(other.wrappedInstance)
  }

  @objc public func moveObjects(at indexes: IndexSetWrapper, to idx: Int) {
    return wrappedInstance.moveObjects(at: indexes.wrappedInstance, to: idx)
  }

  @objc public func removeAllObjects() {
    return wrappedInstance.removeAllObjects()
  }

  @available(macOS, introduced: 10.7)
  @objc public func removeObject(at idx: Int) {
    return wrappedInstance.removeObject(at: idx)
  }

  @objc public func removeObjects(at indexes: IndexSetWrapper) {
    return wrappedInstance.removeObjects(at: indexes.wrappedInstance)
  }

  @objc public func union(_ other: NSOrderedSetWrapper) {
    return wrappedInstance.union(other.wrappedInstance)
  }

}

@objc public class NSMutableSetWrapper: NSObject {
  var wrappedInstance: NSMutableSet

  init(_ wrappedInstance: NSMutableSet) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSMutableSet()
  }

  @objc init(capacity numItems: Int) {
    wrappedInstance = NSMutableSet(capacity: numItems)
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSMutableSet(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public func filter(using predicate: NSPredicateWrapper) {
    return wrappedInstance.filter(using: predicate.wrappedInstance)
  }

  @objc public func removeAllObjects() {
    return wrappedInstance.removeAllObjects()
  }

}

@objc public class NSMutableStringWrapper: NSObject {
  var wrappedInstance: NSMutableString

  init(_ wrappedInstance: NSMutableString) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(capacity: Int) {
    wrappedInstance = NSMutableString(capacity: capacity)
  }

  @objc public func append(_ aString: String) {
    return wrappedInstance.append(aString)
  }

  @objc public func insert(_ aString: String, at loc: Int) {
    return wrappedInstance.insert(aString, at: loc)
  }

  @objc public func setString(_ aString: String) {
    return wrappedInstance.setString(aString)
  }

}

@available(macOS, introduced: 10.2)
@objc public class NSMutableURLRequestWrapper: NSObject {
  var wrappedInstance: NSMutableURLRequest

  @objc public var httpBody: DataWrapper? {
    get {
      wrappedInstance.httpBody == nil ? nil : DataWrapper(wrappedInstance.httpBody!)
    }
    set {
      wrappedInstance.httpBody = newValue?.wrappedInstance
    }
  }

  @objc public var httpBodyStream: InputStreamWrapper? {
    get {
      wrappedInstance.httpBodyStream == nil ? nil : InputStreamWrapper(wrappedInstance.httpBodyStream!)
    }
    set {
      wrappedInstance.httpBodyStream = newValue?.wrappedInstance
    }
  }

  @objc public var httpMethod: String {
    get {
      wrappedInstance.httpMethod
    }
    set {
      wrappedInstance.httpMethod = newValue
    }
  }

  @objc public var httpShouldHandleCookies: Bool {
    get {
      wrappedInstance.httpShouldHandleCookies
    }
    set {
      wrappedInstance.httpShouldHandleCookies = newValue
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var httpShouldUsePipelining: Bool {
    get {
      wrappedInstance.httpShouldUsePipelining
    }
    set {
      wrappedInstance.httpShouldUsePipelining = newValue
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var url: URLWrapper? {
    get {
      wrappedInstance.url == nil ? nil : URLWrapper(wrappedInstance.url!)
    }
    set {
      wrappedInstance.url = newValue?.wrappedInstance
    }
  }

  @objc public var allHTTPHeaderFields: String {
    get {
      wrappedInstance.allHTTPHeaderFields
    }
    set {
      wrappedInstance.allHTTPHeaderFields = newValue
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var allowsCellularAccess: Bool {
    get {
      wrappedInstance.allowsCellularAccess
    }
    set {
      wrappedInstance.allowsCellularAccess = newValue
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var allowsConstrainedNetworkAccess: Bool {
    get {
      wrappedInstance.allowsConstrainedNetworkAccess
    }
    set {
      wrappedInstance.allowsConstrainedNetworkAccess = newValue
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var allowsExpensiveNetworkAccess: Bool {
    get {
      wrappedInstance.allowsExpensiveNetworkAccess
    }
    set {
      wrappedInstance.allowsExpensiveNetworkAccess = newValue
    }
  }

  @available(macOS, introduced: 15.0)
  @objc public var allowsPersistentDNS: Bool {
    get {
      wrappedInstance.allowsPersistentDNS
    }
    set {
      wrappedInstance.allowsPersistentDNS = newValue
    }
  }

  @available(macOS, introduced: 11.3)
  @objc public var assumesHTTP3Capable: Bool {
    get {
      wrappedInstance.assumesHTTP3Capable
    }
    set {
      wrappedInstance.assumesHTTP3Capable = newValue
    }
  }

  @available(macOS, introduced: 15.2)
  @objc public var cookiePartitionIdentifier: String? {
    get {
      wrappedInstance.cookiePartitionIdentifier
    }
    set {
      wrappedInstance.cookiePartitionIdentifier = newValue
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var mainDocumentURL: URLWrapper? {
    get {
      wrappedInstance.mainDocumentURL == nil ? nil : URLWrapper(wrappedInstance.mainDocumentURL!)
    }
    set {
      wrappedInstance.mainDocumentURL = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 13.0)
  @objc public var requiresDNSSECValidation: Bool {
    get {
      wrappedInstance.requiresDNSSECValidation
    }
    set {
      wrappedInstance.requiresDNSSECValidation = newValue
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var timeoutInterval: TimeInterval {
    get {
      wrappedInstance.timeoutInterval
    }
    set {
      wrappedInstance.timeoutInterval = newValue
    }
  }

  init(_ wrappedInstance: NSMutableURLRequest) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func addValue(_ value: String, forHTTPHeaderField field: String) {
    return wrappedInstance.addValue(value, forHTTPHeaderField: field)
  }

  @objc public func setValue(_ value: String?, forHTTPHeaderField field: String) {
    return wrappedInstance.setValue(value, forHTTPHeaderField: field)
  }

}

@objc public class NSNameSpecifierWrapper: NSObject {
  var wrappedInstance: NSNameSpecifier

  @objc public var name: String {
    get {
      wrappedInstance.name
    }
    set {
      wrappedInstance.name = newValue
    }
  }

  init(_ wrappedInstance: NSNameSpecifier) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder inCoder: NSCoderWrapper) {
    if let instance = NSNameSpecifier(coder: inCoder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init(containerClassDescription classDesc: NSScriptClassDescriptionWrapper, containerSpecifier container: NSScriptObjectSpecifierWrapper?, key property: String, name: String) {
    wrappedInstance = NSNameSpecifier(containerClassDescription: classDesc.wrappedInstance, containerSpecifier: container?.wrappedInstance, key: property, name: name)
  }

}

@available(macOS, introduced: 10.2, deprecated: 100000)
@objc public class NetServiceWrapper: NSObject {
  var wrappedInstance: NetService

  @available(macOS, introduced: 10.2)
  @objc static public var errorCode: String {
    get {
      NetService.errorCode
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var errorDomain: String {
    get {
      NetService.errorDomain
    }
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public var domain: String {
    get {
      wrappedInstance.domain
    }
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public var hostName: String? {
    get {
      wrappedInstance.hostName
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 100000)
  @objc public var includesPeerToPeer: Bool {
    get {
      wrappedInstance.includesPeerToPeer
    }
    set {
      wrappedInstance.includesPeerToPeer = newValue
    }
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public var name: String {
    get {
      wrappedInstance.name
    }
  }

  @available(macOS, introduced: 10.5, deprecated: 100000)
  @objc public var port: Int {
    get {
      wrappedInstance.port
    }
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public var type: String {
    get {
      wrappedInstance.type
    }
  }

  init(_ wrappedInstance: NetService) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func txtRecordData() -> DataWrapper? {
    let result = wrappedInstance.txtRecordData()
    return result == nil ? nil : DataWrapper(result!)
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func publish() {
    return wrappedInstance.publish()
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func remove(from aRunLoop: RunLoopWrapper, forMode mode: RunLoopWrapper.ModeWrapper) {
    return wrappedInstance.remove(from: aRunLoop.wrappedInstance, forMode: mode.wrappedInstance)
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func resolve(withTimeout timeout: TimeInterval) {
    return wrappedInstance.resolve(withTimeout: timeout)
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func schedule(in aRunLoop: RunLoopWrapper, forMode mode: RunLoopWrapper.ModeWrapper) {
    return wrappedInstance.schedule(in: aRunLoop.wrappedInstance, forMode: mode.wrappedInstance)
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func setTXTRecord(_ recordData: DataWrapper?) -> Bool {
    return wrappedInstance.setTXTRecord(recordData?.wrappedInstance)
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func startMonitoring() {
    return wrappedInstance.startMonitoring()
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func stop() {
    return wrappedInstance.stop()
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func stopMonitoring() {
    return wrappedInstance.stopMonitoring()
  }

  @available(macOS, introduced: 10.2)
  @objc public class OptionsWrapper: NSObject {
    var wrappedInstance: NetService.Options

    @available(macOS, introduced: 10.9)
    @objc static public var listenForConnections: NetServiceWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NetService.Options.listenForConnections)
      }
    }

    @available(macOS, introduced: 10.2)
    @objc static public var noAutoRename: NetServiceWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NetService.Options.noAutoRename)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NetService.Options) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NetService.Options()
    }

  }

}

@available(macOS, introduced: 10.2, deprecated: 100000)
@objc public class NetServiceBrowserWrapper: NSObject {
  var wrappedInstance: NetServiceBrowser

  @available(macOS, introduced: 10.10, deprecated: 100000)
  @objc public var includesPeerToPeer: Bool {
    get {
      wrappedInstance.includesPeerToPeer
    }
    set {
      wrappedInstance.includesPeerToPeer = newValue
    }
  }

  init(_ wrappedInstance: NetServiceBrowser) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc override init() {
    wrappedInstance = NetServiceBrowser()
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func remove(from aRunLoop: RunLoopWrapper, forMode mode: RunLoopWrapper.ModeWrapper) {
    return wrappedInstance.remove(from: aRunLoop.wrappedInstance, forMode: mode.wrappedInstance)
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func schedule(in aRunLoop: RunLoopWrapper, forMode mode: RunLoopWrapper.ModeWrapper) {
    return wrappedInstance.schedule(in: aRunLoop.wrappedInstance, forMode: mode.wrappedInstance)
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func searchForBrowsableDomains() {
    return wrappedInstance.searchForBrowsableDomains()
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func searchForRegistrationDomains() {
    return wrappedInstance.searchForRegistrationDomains()
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func searchForServices(ofType type: String, inDomain domainString: String) {
    return wrappedInstance.searchForServices(ofType: type, inDomain: domainString)
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc public func stop() {
    return wrappedInstance.stop()
  }

}

@objc public class NSNotificationWrapper: NSObject {
  var wrappedInstance: NSNotification

  @objc public var name: NSNotificationWrapper.NameWrapper {
    get {
      NameWrapper(wrappedInstance.name)
    }
  }

  init(_ wrappedInstance: NSNotification) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSNotification(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public class NameWrapper: NSObject {
    var wrappedInstance: NSNotification.Name

    @objc static public var NSAppleEventManagerWillProcessFirstEvent: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSAppleEventManagerWillProcessFirstEvent)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var NSCalendarDayChanged: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSCalendarDayChanged)
      }
    }

    @objc static public var NSClassDescriptionNeededForClass: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSClassDescriptionNeededForClass)
      }
    }

    @objc static public var NSDidBecomeSingleThreaded: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSDidBecomeSingleThreaded)
      }
    }

    @objc static public var NSFileHandleConnectionAccepted: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSFileHandleConnectionAccepted)
      }
    }

    @objc static public var NSFileHandleDataAvailable: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSFileHandleDataAvailable)
      }
    }

    @objc static public var NSFileHandleReadToEndOfFileCompletion: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSFileHandleReadToEndOfFileCompletion)
      }
    }

    @available(macOS, introduced: 10.2)
    @objc static public var NSHTTPCookieManagerAcceptPolicyChanged: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSHTTPCookieManagerAcceptPolicyChanged)
      }
    }

    @available(macOS, introduced: 10.2)
    @objc static public var NSHTTPCookieManagerCookiesChanged: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSHTTPCookieManagerCookiesChanged)
      }
    }

    @available(macOS, introduced: 10.4)
    @objc static public var NSMetadataQueryDidFinishGathering: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSMetadataQueryDidFinishGathering)
      }
    }

    @available(macOS, introduced: 10.4)
    @objc static public var NSMetadataQueryDidStartGathering: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSMetadataQueryDidStartGathering)
      }
    }

    @available(macOS, introduced: 10.4)
    @objc static public var NSMetadataQueryDidUpdate: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSMetadataQueryDidUpdate)
      }
    }

    @available(macOS, introduced: 10.4)
    @objc static public var NSMetadataQueryGatheringProgress: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSMetadataQueryGatheringProgress)
      }
    }

    @available(macOS, introduced: 12.0)
    @objc static public var NSProcessInfoPowerStateDidChange: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSProcessInfoPowerStateDidChange)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var NSSystemClockDidChange: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSSystemClockDidChange)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var NSSystemTimeZoneDidChange: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSSystemTimeZoneDidChange)
      }
    }

    @objc static public var NSThreadWillExit: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSThreadWillExit)
      }
    }

    @available(macOS, introduced: 10.2)
    @objc static public var NSURLCredentialStorageChanged: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSURLCredentialStorageChanged)
      }
    }

    @available(macOS, introduced: 10.8)
    @objc static public var NSUbiquityIdentityDidChange: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSUbiquityIdentityDidChange)
      }
    }

    @available(macOS, introduced: 10.0)
    @objc static public var NSUndoManagerCheckpoint: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSUndoManagerCheckpoint)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var NSUndoManagerDidCloseUndoGroup: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSUndoManagerDidCloseUndoGroup)
      }
    }

    @available(macOS, introduced: 10.0)
    @objc static public var NSUndoManagerDidOpenUndoGroup: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSUndoManagerDidOpenUndoGroup)
      }
    }

    @available(macOS, introduced: 10.0)
    @objc static public var NSUndoManagerDidRedoChange: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSUndoManagerDidRedoChange)
      }
    }

    @available(macOS, introduced: 10.0)
    @objc static public var NSUndoManagerDidUndoChange: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSUndoManagerDidUndoChange)
      }
    }

    @available(macOS, introduced: 10.0)
    @objc static public var NSUndoManagerWillCloseUndoGroup: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSUndoManagerWillCloseUndoGroup)
      }
    }

    @available(macOS, introduced: 10.0)
    @objc static public var NSUndoManagerWillRedoChange: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSUndoManagerWillRedoChange)
      }
    }

    @available(macOS, introduced: 10.0)
    @objc static public var NSUndoManagerWillUndoChange: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSUndoManagerWillUndoChange)
      }
    }

    @objc static public var NSWillBecomeMultiThreaded: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(NSNotification.Name.NSWillBecomeMultiThreaded)
      }
    }

    init(_ wrappedInstance: NSNotification.Name) {
      self.wrappedInstance = wrappedInstance
    }

    @objc init(rawValue: String) {
      wrappedInstance = NSNotification.Name(rawValue: rawValue)
    }

    @objc init(_ rawValue: String) {
      wrappedInstance = NSNotification.Name(rawValue)
    }

  }

}

@objc public class NotificationCenterWrapper: NSObject {
  var wrappedInstance: NotificationCenter

  @objc static public var `default`: NotificationCenterWrapper {
    get {
      NotificationCenterWrapper(NotificationCenter.`default`)
    }
  }

  init(_ wrappedInstance: NotificationCenter) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func post(_ notification: NotificationWrapper) {
    return wrappedInstance.post(notification.wrappedInstance)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public class NotificationsWrapper: NSObject {
    var wrappedInstance: NotificationCenter.Notifications

    init(_ wrappedInstance: NotificationCenter.Notifications) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func makeAsyncIterator() -> NotificationsWrapper.IteratorWrapper {
      let result = wrappedInstance.makeAsyncIterator()
      return IteratorWrapper(result)
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public class IteratorWrapper: NSObject {
      var wrappedInstance: Notifications.Iterator

      init(_ wrappedInstance: Notifications.Iterator) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public func next() async -> NotificationWrapper? {
        let result = await wrappedInstance.next()
        return result == nil ? nil : NotificationWrapper(result!)
      }

    }

  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public class PublisherWrapper: NSObject {
    var wrappedInstance: NotificationCenter.Publisher

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public var name: NSNotificationWrapper.NameWrapper {
      get {
        NameWrapper(wrappedInstance.name)
      }
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public var center: NotificationCenterWrapper {
      get {
        NotificationCenterWrapper(wrappedInstance.center)
      }
    }

    init(_ wrappedInstance: NotificationCenter.Publisher) {
      self.wrappedInstance = wrappedInstance
    }

  }

}

@objc public class NotificationQueueWrapper: NSObject {
  var wrappedInstance: NotificationQueue

  @objc static public var `default`: NotificationQueueWrapper {
    get {
      NotificationQueueWrapper(NotificationQueue.`default`)
    }
  }

  init(_ wrappedInstance: NotificationQueue) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(notificationCenter: NotificationCenterWrapper) {
    wrappedInstance = NotificationQueue(notificationCenter: notificationCenter.wrappedInstance)
  }

  @objc public func dequeueNotifications(matching notification: NotificationWrapper, coalesceMask: Int) {
    return wrappedInstance.dequeueNotifications(matching: notification.wrappedInstance, coalesceMask: coalesceMask)
  }

  @objc public class NotificationCoalescingWrapper: NSObject {
    var wrappedInstance: NotificationQueue.NotificationCoalescing

    @objc static public var onName: NotificationQueueWrapper.NotificationCoalescingWrapper {
      get {
        NotificationCoalescingWrapper(NotificationQueue.NotificationCoalescing.onName)
      }
    }

    @objc static public var onSender: NotificationQueueWrapper.NotificationCoalescingWrapper {
      get {
        NotificationCoalescingWrapper(NotificationQueue.NotificationCoalescing.onSender)
      }
    }

    @objc static public var none: NotificationQueueWrapper.NotificationCoalescingWrapper {
      get {
        NotificationCoalescingWrapper(NotificationQueue.NotificationCoalescing.none)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NotificationQueue.NotificationCoalescing) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NotificationQueue.NotificationCoalescing()
    }

  }

}

@objc public class NSNullWrapper: NSObject {
  var wrappedInstance: NSNull

  init(_ wrappedInstance: NSNull) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSNull(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@objc public class NSNumberWrapper: NSObject {
  var wrappedInstance: NSNumber

  @objc public var boolValue: Bool {
    get {
      wrappedInstance.boolValue
    }
  }

  @objc public var decimalValue: DecimalWrapper {
    get {
      DecimalWrapper(wrappedInstance.decimalValue)
    }
  }

  @objc public var doubleValue: Double {
    get {
      wrappedInstance.doubleValue
    }
  }

  @objc public var floatValue: Float {
    get {
      wrappedInstance.floatValue
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var intValue: Int {
    get {
      wrappedInstance.intValue
    }
  }

  @objc public var stringValue: String {
    get {
      wrappedInstance.stringValue
    }
  }

  init(_ wrappedInstance: NSNumber) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSNumber(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init(value: Float) {
    wrappedInstance = NSNumber(value: value)
  }

  @objc public func isEqual(to number: NSNumberWrapper) -> Bool {
    return wrappedInstance.isEqual(to: number.wrappedInstance)
  }

}

@objc public class NumberFormatterWrapper: NSObject {
  var wrappedInstance: NumberFormatter

  @objc public var allowsFloats: Bool {
    get {
      wrappedInstance.allowsFloats
    }
    set {
      wrappedInstance.allowsFloats = newValue
    }
  }

  @objc public var alwaysShowsDecimalSeparator: Bool {
    get {
      wrappedInstance.alwaysShowsDecimalSeparator
    }
    set {
      wrappedInstance.alwaysShowsDecimalSeparator = newValue
    }
  }

  @objc public var attributedStringForNil: NSAttributedStringWrapper {
    get {
      NSAttributedStringWrapper(wrappedInstance.attributedStringForNil)
    }
    set {
      wrappedInstance.attributedStringForNil = newValue.wrappedInstance
    }
  }

  @objc public var attributedStringForNotANumber: NSAttributedStringWrapper {
    get {
      NSAttributedStringWrapper(wrappedInstance.attributedStringForNotANumber)
    }
    set {
      wrappedInstance.attributedStringForNotANumber = newValue.wrappedInstance
    }
  }

  @objc public var attributedStringForZero: NSAttributedStringWrapper {
    get {
      NSAttributedStringWrapper(wrappedInstance.attributedStringForZero)
    }
    set {
      wrappedInstance.attributedStringForZero = newValue.wrappedInstance
    }
  }

  @objc public var currencyCode: String {
    get {
      wrappedInstance.currencyCode
    }
    set {
      wrappedInstance.currencyCode = newValue
    }
  }

  @objc public var currencyDecimalSeparator: String {
    get {
      wrappedInstance.currencyDecimalSeparator
    }
    set {
      wrappedInstance.currencyDecimalSeparator = newValue
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var currencyGroupingSeparator: String {
    get {
      wrappedInstance.currencyGroupingSeparator
    }
    set {
      wrappedInstance.currencyGroupingSeparator = newValue
    }
  }

  @objc public var currencySymbol: String {
    get {
      wrappedInstance.currencySymbol
    }
    set {
      wrappedInstance.currencySymbol = newValue
    }
  }

  @objc public var decimalSeparator: String {
    get {
      wrappedInstance.decimalSeparator
    }
    set {
      wrappedInstance.decimalSeparator = newValue
    }
  }

  @objc public var exponentSymbol: String {
    get {
      wrappedInstance.exponentSymbol
    }
    set {
      wrappedInstance.exponentSymbol = newValue
    }
  }

  @objc public var format: String {
    get {
      wrappedInstance.format
    }
    set {
      wrappedInstance.format = newValue
    }
  }

  @objc public var formatWidth: Int {
    get {
      wrappedInstance.formatWidth
    }
    set {
      wrappedInstance.formatWidth = newValue
    }
  }

  @objc public var generatesDecimalNumbers: Bool {
    get {
      wrappedInstance.generatesDecimalNumbers
    }
    set {
      wrappedInstance.generatesDecimalNumbers = newValue
    }
  }

  @objc public var groupingSeparator: String {
    get {
      wrappedInstance.groupingSeparator
    }
    set {
      wrappedInstance.groupingSeparator = newValue
    }
  }

  @objc public var groupingSize: Int {
    get {
      wrappedInstance.groupingSize
    }
    set {
      wrappedInstance.groupingSize = newValue
    }
  }

  @objc public var hasThousandSeparators: Bool {
    get {
      wrappedInstance.hasThousandSeparators
    }
    set {
      wrappedInstance.hasThousandSeparators = newValue
    }
  }

  @objc public var internationalCurrencySymbol: String {
    get {
      wrappedInstance.internationalCurrencySymbol
    }
    set {
      wrappedInstance.internationalCurrencySymbol = newValue
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var isLenient: Bool {
    get {
      wrappedInstance.isLenient
    }
    set {
      wrappedInstance.isLenient = newValue
    }
  }

  @objc public var locale: LocaleWrapper {
    get {
      LocaleWrapper(wrappedInstance.locale)
    }
    set {
      wrappedInstance.locale = newValue.wrappedInstance
    }
  }

  @objc public var localizesFormat: Bool {
    get {
      wrappedInstance.localizesFormat
    }
    set {
      wrappedInstance.localizesFormat = newValue
    }
  }

  @objc public var maximum: NSNumberWrapper? {
    get {
      wrappedInstance.maximum == nil ? nil : NSNumberWrapper(wrappedInstance.maximum!)
    }
    set {
      wrappedInstance.maximum = newValue?.wrappedInstance
    }
  }

  @objc public var maximumFractionDigits: Int {
    get {
      wrappedInstance.maximumFractionDigits
    }
    set {
      wrappedInstance.maximumFractionDigits = newValue
    }
  }

  @objc public var maximumIntegerDigits: Int {
    get {
      wrappedInstance.maximumIntegerDigits
    }
    set {
      wrappedInstance.maximumIntegerDigits = newValue
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var maximumSignificantDigits: Int {
    get {
      wrappedInstance.maximumSignificantDigits
    }
    set {
      wrappedInstance.maximumSignificantDigits = newValue
    }
  }

  @objc public var minimum: NSNumberWrapper? {
    get {
      wrappedInstance.minimum == nil ? nil : NSNumberWrapper(wrappedInstance.minimum!)
    }
    set {
      wrappedInstance.minimum = newValue?.wrappedInstance
    }
  }

  @objc public var minimumFractionDigits: Int {
    get {
      wrappedInstance.minimumFractionDigits
    }
    set {
      wrappedInstance.minimumFractionDigits = newValue
    }
  }

  @available(macOS, introduced: 15.0)
  @objc public var minimumGroupingDigits: Int {
    get {
      wrappedInstance.minimumGroupingDigits
    }
    set {
      wrappedInstance.minimumGroupingDigits = newValue
    }
  }

  @objc public var minimumIntegerDigits: Int {
    get {
      wrappedInstance.minimumIntegerDigits
    }
    set {
      wrappedInstance.minimumIntegerDigits = newValue
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var minimumSignificantDigits: Int {
    get {
      wrappedInstance.minimumSignificantDigits
    }
    set {
      wrappedInstance.minimumSignificantDigits = newValue
    }
  }

  @objc public var minusSign: String {
    get {
      wrappedInstance.minusSign
    }
    set {
      wrappedInstance.minusSign = newValue
    }
  }

  @objc public var multiplier: NSNumberWrapper? {
    get {
      wrappedInstance.multiplier == nil ? nil : NSNumberWrapper(wrappedInstance.multiplier!)
    }
    set {
      wrappedInstance.multiplier = newValue?.wrappedInstance
    }
  }

  @objc public var negativeFormat: String {
    get {
      wrappedInstance.negativeFormat
    }
    set {
      wrappedInstance.negativeFormat = newValue
    }
  }

  @objc public var negativeInfinitySymbol: String {
    get {
      wrappedInstance.negativeInfinitySymbol
    }
    set {
      wrappedInstance.negativeInfinitySymbol = newValue
    }
  }

  @objc public var negativePrefix: String {
    get {
      wrappedInstance.negativePrefix
    }
    set {
      wrappedInstance.negativePrefix = newValue
    }
  }

  @objc public var negativeSuffix: String {
    get {
      wrappedInstance.negativeSuffix
    }
    set {
      wrappedInstance.negativeSuffix = newValue
    }
  }

  @objc public var nilSymbol: String {
    get {
      wrappedInstance.nilSymbol
    }
    set {
      wrappedInstance.nilSymbol = newValue
    }
  }

  @objc public var notANumberSymbol: String {
    get {
      wrappedInstance.notANumberSymbol
    }
    set {
      wrappedInstance.notANumberSymbol = newValue
    }
  }

  @objc public var paddingCharacter: String {
    get {
      wrappedInstance.paddingCharacter
    }
    set {
      wrappedInstance.paddingCharacter = newValue
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var isPartialStringValidationEnabled: Bool {
    get {
      wrappedInstance.isPartialStringValidationEnabled
    }
    set {
      wrappedInstance.isPartialStringValidationEnabled = newValue
    }
  }

  @objc public var perMillSymbol: String {
    get {
      wrappedInstance.perMillSymbol
    }
    set {
      wrappedInstance.perMillSymbol = newValue
    }
  }

  @objc public var percentSymbol: String {
    get {
      wrappedInstance.percentSymbol
    }
    set {
      wrappedInstance.percentSymbol = newValue
    }
  }

  @objc public var plusSign: String {
    get {
      wrappedInstance.plusSign
    }
    set {
      wrappedInstance.plusSign = newValue
    }
  }

  @objc public var positiveFormat: String {
    get {
      wrappedInstance.positiveFormat
    }
    set {
      wrappedInstance.positiveFormat = newValue
    }
  }

  @objc public var positiveInfinitySymbol: String {
    get {
      wrappedInstance.positiveInfinitySymbol
    }
    set {
      wrappedInstance.positiveInfinitySymbol = newValue
    }
  }

  @objc public var positivePrefix: String {
    get {
      wrappedInstance.positivePrefix
    }
    set {
      wrappedInstance.positivePrefix = newValue
    }
  }

  @objc public var positiveSuffix: String {
    get {
      wrappedInstance.positiveSuffix
    }
    set {
      wrappedInstance.positiveSuffix = newValue
    }
  }

  @objc public var roundingBehavior: NSDecimalNumberHandlerWrapper {
    get {
      NSDecimalNumberHandlerWrapper(wrappedInstance.roundingBehavior)
    }
    set {
      wrappedInstance.roundingBehavior = newValue.wrappedInstance
    }
  }

  @objc public var roundingIncrement: NSNumberWrapper {
    get {
      NSNumberWrapper(wrappedInstance.roundingIncrement)
    }
    set {
      wrappedInstance.roundingIncrement = newValue.wrappedInstance
    }
  }

  @objc public var secondaryGroupingSize: Int {
    get {
      wrappedInstance.secondaryGroupingSize
    }
    set {
      wrappedInstance.secondaryGroupingSize = newValue
    }
  }

  @objc public var thousandSeparator: String {
    get {
      wrappedInstance.thousandSeparator
    }
    set {
      wrappedInstance.thousandSeparator = newValue
    }
  }

  @objc public var usesGroupingSeparator: Bool {
    get {
      wrappedInstance.usesGroupingSeparator
    }
    set {
      wrappedInstance.usesGroupingSeparator = newValue
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var usesSignificantDigits: Bool {
    get {
      wrappedInstance.usesSignificantDigits
    }
    set {
      wrappedInstance.usesSignificantDigits = newValue
    }
  }

  @objc public var zeroSymbol: String? {
    get {
      wrappedInstance.zeroSymbol
    }
    set {
      wrappedInstance.zeroSymbol = newValue
    }
  }

  init(_ wrappedInstance: NumberFormatter) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func number(from string: String) -> NSNumberWrapper? {
    let result = wrappedInstance.number(from: string)
    return result == nil ? nil : NSNumberWrapper(result!)
  }

  @objc public func string(from number: NSNumberWrapper) -> String? {
    return wrappedInstance.string(from: number.wrappedInstance)
  }

}

@available(macOS, introduced: 10.5)
@objc public class OperationWrapper: NSObject {
  var wrappedInstance: Operation

  @available(macOS, introduced: 10.8)
  @objc public var isAsynchronous: Bool {
    get {
      wrappedInstance.isAsynchronous
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var isCancelled: Bool {
    get {
      wrappedInstance.isCancelled
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var isConcurrent: Bool {
    get {
      wrappedInstance.isConcurrent
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var isExecuting: Bool {
    get {
      wrappedInstance.isExecuting
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var isFinished: Bool {
    get {
      wrappedInstance.isFinished
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var name: String? {
    get {
      wrappedInstance.name
    }
    set {
      wrappedInstance.name = newValue
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var isReady: Bool {
    get {
      wrappedInstance.isReady
    }
  }

  @available(macOS, introduced: 10.6, deprecated: 10.10)
  @objc public var threadPriority: Double {
    get {
      wrappedInstance.threadPriority
    }
    set {
      wrappedInstance.threadPriority = newValue
    }
  }

  init(_ wrappedInstance: Operation) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.5)
  @objc public func addDependency(_ op: OperationWrapper) {
    return wrappedInstance.addDependency(op.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc public func cancel() {
    return wrappedInstance.cancel()
  }

  @available(macOS, introduced: 10.5)
  @objc public func main() {
    return wrappedInstance.main()
  }

  @available(macOS, introduced: 10.5)
  @objc public func removeDependency(_ op: OperationWrapper) {
    return wrappedInstance.removeDependency(op.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc public func start() {
    return wrappedInstance.start()
  }

  @available(macOS, introduced: 10.6)
  @objc public func waitUntilFinished() {
    return wrappedInstance.waitUntilFinished()
  }

}

@available(macOS, introduced: 10.5)
@objc public class OperationQueueWrapper: NSObject {
  var wrappedInstance: OperationQueue

  @objc static public var defaultMaxConcurrentOperationCount: Int {
    get {
      OperationQueue.defaultMaxConcurrentOperationCount
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var current: OperationQueueWrapper? {
    get {
      OperationQueue.current == nil ? nil : OperationQueueWrapper(OperationQueue.current!)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var main: OperationQueueWrapper {
    get {
      OperationQueueWrapper(OperationQueue.main)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var maxConcurrentOperationCount: Int {
    get {
      wrappedInstance.maxConcurrentOperationCount
    }
    set {
      wrappedInstance.maxConcurrentOperationCount = newValue
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var name: String? {
    get {
      wrappedInstance.name
    }
    set {
      wrappedInstance.name = newValue
    }
  }

  @available(macOS, introduced: 10.6, deprecated: 100000)
  @objc public var operationCount: Int {
    get {
      wrappedInstance.operationCount
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var progress: ProgressWrapper {
    get {
      ProgressWrapper(wrappedInstance.progress)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var isSuspended: Bool {
    get {
      wrappedInstance.isSuspended
    }
    set {
      wrappedInstance.isSuspended = newValue
    }
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public var minimumTolerance: SchedulerTimeTypeWrapper.StrideWrapper {
    get {
      StrideWrapper(wrappedInstance.minimumTolerance)
    }
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public var now: OperationQueueWrapper.SchedulerTimeTypeWrapper {
    get {
      SchedulerTimeTypeWrapper(wrappedInstance.now)
    }
  }

  init(_ wrappedInstance: OperationQueue) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.5)
  @objc public func addOperation(_ op: OperationWrapper) {
    return wrappedInstance.addOperation(op.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc public func cancelAllOperations() {
    return wrappedInstance.cancelAllOperations()
  }

  @available(macOS, introduced: 10.5)
  @objc public func waitUntilAllOperationsAreFinished() {
    return wrappedInstance.waitUntilAllOperationsAreFinished()
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public class SchedulerOptionsWrapper: NSObject {
    var wrappedInstance: OperationQueue.SchedulerOptions

    init(_ wrappedInstance: OperationQueue.SchedulerOptions) {
      self.wrappedInstance = wrappedInstance
    }

  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public class SchedulerTimeTypeWrapper: NSObject {
    var wrappedInstance: OperationQueue.SchedulerTimeType

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public var date: DateWrapper {
      get {
        DateWrapper(wrappedInstance.date)
      }
      set {
        wrappedInstance.date = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: OperationQueue.SchedulerTimeType) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc init(_ date: DateWrapper) {
      wrappedInstance = OperationQueue.SchedulerTimeType(date.wrappedInstance)
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public func advanced(by n: SchedulerTimeTypeWrapper.StrideWrapper) -> OperationQueueWrapper.SchedulerTimeTypeWrapper {
      let result = wrappedInstance.advanced(by: n.wrappedInstance)
      return SchedulerTimeTypeWrapper(result)
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public func distance(to other: OperationQueueWrapper.SchedulerTimeTypeWrapper) -> SchedulerTimeTypeWrapper.StrideWrapper {
      let result = wrappedInstance.distance(to: other.wrappedInstance)
      return StrideWrapper(result)
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public class StrideWrapper: NSObject {
      var wrappedInstance: SchedulerTimeType.Stride

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc public var timeInterval: TimeInterval {
        get {
          wrappedInstance.timeInterval
        }
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc public var magnitude: TimeInterval {
        get {
          wrappedInstance.magnitude
        }
        set {
          wrappedInstance.magnitude = newValue
        }
      }

      init(_ wrappedInstance: SchedulerTimeType.Stride) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc init(floatLiteral value: TimeInterval) {
        wrappedInstance = SchedulerTimeType.Stride(floatLiteral: value)
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc init(integerLiteral value: TimeInterval) {
        wrappedInstance = SchedulerTimeType.Stride(integerLiteral: value)
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc init(_ timeInterval: TimeInterval) {
        wrappedInstance = SchedulerTimeType.Stride(timeInterval)
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc static public func nanoseconds(_ ns: Int) -> SchedulerTimeTypeWrapper.StrideWrapper {
        let result = SchedulerTimeType.Stride.nanoseconds(ns)
        return StrideWrapper(result)
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc static public func microseconds(_ us: Int) -> SchedulerTimeTypeWrapper.StrideWrapper {
        let result = SchedulerTimeType.Stride.microseconds(us)
        return StrideWrapper(result)
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc static public func milliseconds(_ ms: Int) -> SchedulerTimeTypeWrapper.StrideWrapper {
        let result = SchedulerTimeType.Stride.milliseconds(ms)
        return StrideWrapper(result)
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc static public func seconds(_ s: Int) -> SchedulerTimeTypeWrapper.StrideWrapper {
        let result = SchedulerTimeType.Stride.seconds(s)
        return StrideWrapper(result)
      }

      @objc public func negate() {
        return wrappedInstance.negate()
      }

    }

  }

}

@available(macOS, introduced: 10.15)
@objc public class NSOrderedCollectionChangeWrapper: NSObject {
  var wrappedInstance: NSOrderedCollectionChange

  @available(macOS, introduced: 10.15)
  @objc public var associatedIndex: Int {
    get {
      wrappedInstance.associatedIndex
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var index: Int {
    get {
      wrappedInstance.index
    }
  }

  init(_ wrappedInstance: NSOrderedCollectionChange) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.15)
@objc public class NSOrderedCollectionDifferenceWrapper: NSObject {
  var wrappedInstance: NSOrderedCollectionDifference

  @available(macOS, introduced: 10.15)
  @objc public var hasChanges: Bool {
    get {
      wrappedInstance.hasChanges
    }
  }

  init(_ wrappedInstance: NSOrderedCollectionDifference) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.7)
@objc public class NSOrderedSetWrapper: NSObject {
  var wrappedInstance: NSOrderedSet

  @available(macOS, introduced: 10.7)
  @objc public var count: Int {
    get {
      wrappedInstance.count
    }
  }

  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @objc public var reversed: NSOrderedSetWrapper {
    get {
      NSOrderedSetWrapper(wrappedInstance.reversed)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var underestimatedCount: Int {
    get {
      wrappedInstance.underestimatedCount
    }
  }

  init(_ wrappedInstance: NSOrderedSet) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.7)
  @objc override init() {
    wrappedInstance = NSOrderedSet()
  }

  @available(macOS, introduced: 10.7)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSOrderedSet(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public func filtered(using p: NSPredicateWrapper) -> NSOrderedSetWrapper {
    let result = wrappedInstance.filtered(using: p.wrappedInstance)
    return NSOrderedSetWrapper(result)
  }

  @objc public func intersects(_ other: NSOrderedSetWrapper) -> Bool {
    return wrappedInstance.intersects(other.wrappedInstance)
  }

  @objc public func isEqual(to other: NSOrderedSetWrapper) -> Bool {
    return wrappedInstance.isEqual(to: other.wrappedInstance)
  }

  @objc public func isSubset(of other: NSOrderedSetWrapper) -> Bool {
    return wrappedInstance.isSubset(of: other.wrappedInstance)
  }

  @objc public func objectEnumerator() -> NSEnumeratorWrapper {
    let result = wrappedInstance.objectEnumerator()
    return NSEnumeratorWrapper(result)
  }

  @objc public func removeObserver(_ observer: NSObject, forKeyPath keyPath: String) {
    return wrappedInstance.removeObserver(observer, forKeyPath: keyPath)
  }

  @objc public func reverseObjectEnumerator() -> NSEnumeratorWrapper {
    let result = wrappedInstance.reverseObjectEnumerator()
    return NSEnumeratorWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func makeIterator() -> NSFastEnumerationIteratorWrapper {
    let result = wrappedInstance.makeIterator()
    return NSFastEnumerationIteratorWrapper(result)
  }

}

@available(macOS, introduced: 10.6)
@objc public class NSOrthographyWrapper: NSObject {
  var wrappedInstance: NSOrthography

  @available(macOS, introduced: 10.6)
  @objc public var dominantLanguage: String {
    get {
      wrappedInstance.dominantLanguage
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var dominantScript: String {
    get {
      wrappedInstance.dominantScript
    }
  }

  init(_ wrappedInstance: NSOrthography) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.6)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSOrthography(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public func dominantLanguage(forScript script: String) -> String? {
    return wrappedInstance.dominantLanguage(forScript: script)
  }

}

@objc public class OutputStreamWrapper: NSObject {
  var wrappedInstance: OutputStream

  @objc public var hasSpaceAvailable: Bool {
    get {
      wrappedInstance.hasSpaceAvailable
    }
  }

  init(_ wrappedInstance: OutputStream) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.6)
  @objc init?(url: URLWrapper, append shouldAppend: Bool) {
    if let instance = OutputStream(url: url.wrappedInstance, append: shouldAppend) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.11)
@objc public class NSPersonNameComponentsWrapper: NSObject {
  var wrappedInstance: NSPersonNameComponents

  @available(macOS, introduced: 10.11)
  @objc public var familyName: String? {
    get {
      wrappedInstance.familyName
    }
    set {
      wrappedInstance.familyName = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var givenName: String? {
    get {
      wrappedInstance.givenName
    }
    set {
      wrappedInstance.givenName = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var middleName: String? {
    get {
      wrappedInstance.middleName
    }
    set {
      wrappedInstance.middleName = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var namePrefix: String? {
    get {
      wrappedInstance.namePrefix
    }
    set {
      wrappedInstance.namePrefix = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var nameSuffix: String? {
    get {
      wrappedInstance.nameSuffix
    }
    set {
      wrappedInstance.nameSuffix = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var nickname: String? {
    get {
      wrappedInstance.nickname
    }
    set {
      wrappedInstance.nickname = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var phoneticRepresentation: PersonNameComponentsWrapper? {
    get {
      wrappedInstance.phoneticRepresentation == nil ? nil : PersonNameComponentsWrapper(wrappedInstance.phoneticRepresentation!)
    }
    set {
      wrappedInstance.phoneticRepresentation = newValue?.wrappedInstance
    }
  }

  init(_ wrappedInstance: NSPersonNameComponents) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.11)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSPersonNameComponents(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.11)
@objc public class PersonNameComponentsFormatterWrapper: NSObject {
  var wrappedInstance: PersonNameComponentsFormatter

  @available(macOS, introduced: 12.0)
  @objc public var locale: LocaleWrapper {
    get {
      LocaleWrapper(wrappedInstance.locale)
    }
    set {
      wrappedInstance.locale = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var isPhonetic: Bool {
    get {
      wrappedInstance.isPhonetic
    }
    set {
      wrappedInstance.isPhonetic = newValue
    }
  }

  init(_ wrappedInstance: PersonNameComponentsFormatter) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.11)
  @objc public func annotatedString(from components: PersonNameComponentsWrapper) -> NSAttributedStringWrapper {
    let result = wrappedInstance.annotatedString(from: components.wrappedInstance)
    return NSAttributedStringWrapper(result)
  }

  @available(macOS, introduced: 10.12)
  @objc public func personNameComponents(from string: String) -> PersonNameComponentsWrapper? {
    let result = wrappedInstance.personNameComponents(from: string)
    return result == nil ? nil : PersonNameComponentsWrapper(result!)
  }

  @available(macOS, introduced: 10.11)
  @objc public func string(from components: PersonNameComponentsWrapper) -> String {
    return wrappedInstance.string(from: components.wrappedInstance)
  }

  @available(macOS, introduced: 10.11)
  @objc public class OptionsWrapper: NSObject {
    var wrappedInstance: PersonNameComponentsFormatter.Options

    @available(macOS, introduced: 10.11)
    @objc static public var phonetic: PersonNameComponentsFormatterWrapper.OptionsWrapper {
      get {
        OptionsWrapper(PersonNameComponentsFormatter.Options.phonetic)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: PersonNameComponentsFormatter.Options) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = PersonNameComponentsFormatter.Options()
    }

  }

}

@objc public class PipeWrapper: NSObject {
  var wrappedInstance: Pipe

  @objc public var fileHandleForReading: FileHandleWrapper {
    get {
      FileHandleWrapper(wrappedInstance.fileHandleForReading)
    }
  }

  @objc public var fileHandleForWriting: FileHandleWrapper {
    get {
      FileHandleWrapper(wrappedInstance.fileHandleForWriting)
    }
  }

  init(_ wrappedInstance: Pipe) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.5)
@objc public class NSPointerArrayWrapper: NSObject {
  var wrappedInstance: NSPointerArray

  @available(macOS, introduced: 10.5)
  @objc public var count: Int {
    get {
      wrappedInstance.count
    }
    set {
      wrappedInstance.count = newValue
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var pointerFunctions: NSPointerFunctionsWrapper {
    get {
      NSPointerFunctionsWrapper(wrappedInstance.pointerFunctions)
    }
  }

  init(_ wrappedInstance: NSPointerArray) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.5)
  @objc init(pointerFunctions functions: NSPointerFunctionsWrapper) {
    wrappedInstance = NSPointerArray(pointerFunctions: functions.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSPointerArray(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.8)
  @objc static public func strongObjects() -> NSPointerArrayWrapper {
    let result = NSPointerArray.strongObjects()
    return NSPointerArrayWrapper(result)
  }

  @available(macOS, introduced: 10.8)
  @objc static public func weakObjects() -> NSPointerArrayWrapper {
    let result = NSPointerArray.weakObjects()
    return NSPointerArrayWrapper(result)
  }

  @available(macOS, introduced: 10.5)
  @objc public func compact() {
    return wrappedInstance.compact()
  }

  @available(macOS, introduced: 10.5)
  @objc public func removePointer(at index: Int) {
    return wrappedInstance.removePointer(at: index)
  }

}

@available(macOS, introduced: 10.5)
@objc public class NSPointerFunctionsWrapper: NSObject {
  var wrappedInstance: NSPointerFunctions

  @available(macOS, introduced: 10.5, deprecated: 10.12)
  @objc public var usesStrongWriteBarrier: Bool {
    get {
      wrappedInstance.usesStrongWriteBarrier
    }
    set {
      wrappedInstance.usesStrongWriteBarrier = newValue
    }
  }

  @available(macOS, introduced: 10.5, deprecated: 10.12)
  @objc public var usesWeakReadAndWriteBarriers: Bool {
    get {
      wrappedInstance.usesWeakReadAndWriteBarriers
    }
    set {
      wrappedInstance.usesWeakReadAndWriteBarriers = newValue
    }
  }

  init(_ wrappedInstance: NSPointerFunctions) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public class OptionsWrapper: NSObject {
    var wrappedInstance: NSPointerFunctions.Options

    @available(macOS, introduced: 10.5)
    @objc static public var cStringPersonality: NSPointerFunctionsWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSPointerFunctions.Options.cStringPersonality)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var copyIn: NSPointerFunctionsWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSPointerFunctions.Options.copyIn)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var integerPersonality: NSPointerFunctionsWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSPointerFunctions.Options.integerPersonality)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var machVirtualMemory: NSPointerFunctionsWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSPointerFunctions.Options.machVirtualMemory)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var mallocMemory: NSPointerFunctionsWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSPointerFunctions.Options.mallocMemory)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var objectPersonality: NSPointerFunctionsWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSPointerFunctions.Options.objectPersonality)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var objectPointerPersonality: NSPointerFunctionsWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSPointerFunctions.Options.objectPointerPersonality)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var opaqueMemory: NSPointerFunctionsWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSPointerFunctions.Options.opaqueMemory)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var opaquePersonality: NSPointerFunctionsWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSPointerFunctions.Options.opaquePersonality)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var strongMemory: NSPointerFunctionsWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSPointerFunctions.Options.strongMemory)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var structPersonality: NSPointerFunctionsWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSPointerFunctions.Options.structPersonality)
      }
    }

    @available(macOS, introduced: 10.8)
    @objc static public var weakMemory: NSPointerFunctionsWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSPointerFunctions.Options.weakMemory)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSPointerFunctions.Options) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSPointerFunctions.Options()
    }

  }

}

@objc public class PortWrapper: NSObject {
  var wrappedInstance: Port

  @objc static public var didBecomeInvalidNotification: NSNotificationWrapper.NameWrapper {
    get {
      NameWrapper(Port.didBecomeInvalidNotification)
    }
  }

  @objc public var reservedSpaceLength: Int {
    get {
      wrappedInstance.reservedSpaceLength
    }
  }

  @objc public var isValid: Bool {
    get {
      wrappedInstance.isValid
    }
  }

  init(_ wrappedInstance: Port) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = Port(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func invalidate() {
    return wrappedInstance.invalidate()
  }

  @objc public func remove(from runLoop: RunLoopWrapper, forMode mode: RunLoopWrapper.ModeWrapper) {
    return wrappedInstance.remove(from: runLoop.wrappedInstance, forMode: mode.wrappedInstance)
  }

  @objc public func schedule(in runLoop: RunLoopWrapper, forMode mode: RunLoopWrapper.ModeWrapper) {
    return wrappedInstance.schedule(in: runLoop.wrappedInstance, forMode: mode.wrappedInstance)
  }

  @objc public func send(before limitDate: DateWrapper, components: NSMutableArrayWrapper?, from receivePort: PortWrapper?, reserved headerSpaceReserved: Int) -> Bool {
    return wrappedInstance.send(before: limitDate.wrappedInstance, components: components?.wrappedInstance, from: receivePort?.wrappedInstance, reserved: headerSpaceReserved)
  }

  @objc public func send(before limitDate: DateWrapper, msgid msgID: Int, components: NSMutableArrayWrapper?, from receivePort: PortWrapper?, reserved headerSpaceReserved: Int) -> Bool {
    return wrappedInstance.send(before: limitDate.wrappedInstance, msgid: msgID, components: components?.wrappedInstance, from: receivePort?.wrappedInstance, reserved: headerSpaceReserved)
  }

}

@objc public class PortMessageWrapper: NSObject {
  var wrappedInstance: PortMessage

  @objc public var receivePort: PortWrapper? {
    get {
      wrappedInstance.receivePort == nil ? nil : PortWrapper(wrappedInstance.receivePort!)
    }
  }

  @objc public var sendPort: PortWrapper? {
    get {
      wrappedInstance.sendPort == nil ? nil : PortWrapper(wrappedInstance.sendPort!)
    }
  }

  init(_ wrappedInstance: PortMessage) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func send(before date: DateWrapper) -> Bool {
    return wrappedInstance.send(before: date.wrappedInstance)
  }

}

@objc public class NSPositionalSpecifierWrapper: NSObject {
  var wrappedInstance: NSPositionalSpecifier

  @objc public var insertionIndex: Int {
    get {
      wrappedInstance.insertionIndex
    }
  }

  @objc public var insertionKey: String? {
    get {
      wrappedInstance.insertionKey
    }
  }

  @objc public var insertionReplaces: Bool {
    get {
      wrappedInstance.insertionReplaces
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var objectSpecifier: NSScriptObjectSpecifierWrapper {
    get {
      NSScriptObjectSpecifierWrapper(wrappedInstance.objectSpecifier)
    }
  }

  init(_ wrappedInstance: NSPositionalSpecifier) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func evaluate() {
    return wrappedInstance.evaluate()
  }

  @objc public func setInsertionClassDescription(_ classDescription: NSScriptClassDescriptionWrapper) {
    return wrappedInstance.setInsertionClassDescription(classDescription.wrappedInstance)
  }

}

@available(macOS, introduced: 10.4)
@objc public class NSPredicateWrapper: NSObject {
  var wrappedInstance: NSPredicate

  @available(macOS, introduced: 10.4)
  @objc public var predicateFormat: String {
    get {
      wrappedInstance.predicateFormat
    }
  }

  init(_ wrappedInstance: NSPredicate) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.9)
  @objc init?(fromMetadataQueryString queryString: String) {
    if let instance = NSPredicate(fromMetadataQueryString: queryString) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.4)
  @objc init(value: Bool) {
    wrappedInstance = NSPredicate(value: value)
  }

  @available(macOS, introduced: 10.4)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSPredicate(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public func allowEvaluation() {
    return wrappedInstance.allowEvaluation()
  }

}

@objc public class ProcessInfoWrapper: NSObject {
  var wrappedInstance: ProcessInfo

  @available(macOS, introduced: 10.10.3)
  @objc static public var thermalStateDidChangeNotification: NSNotificationWrapper.NameWrapper {
    get {
      NameWrapper(ProcessInfo.thermalStateDidChangeNotification)
    }
  }

  @objc static public var processInfo: ProcessInfoWrapper {
    get {
      ProcessInfoWrapper(ProcessInfo.processInfo)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var activeProcessorCount: Int {
    get {
      wrappedInstance.activeProcessorCount
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var automaticTerminationSupportEnabled: Bool {
    get {
      wrappedInstance.automaticTerminationSupportEnabled
    }
    set {
      wrappedInstance.automaticTerminationSupportEnabled = newValue
    }
  }

  @objc public var environment: String {
    get {
      wrappedInstance.environment
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var fullUserName: String {
    get {
      wrappedInstance.fullUserName
    }
  }

  @objc public var globallyUniqueString: String {
    get {
      wrappedInstance.globallyUniqueString
    }
  }

  @objc public var hostName: String {
    get {
      wrappedInstance.hostName
    }
  }

  @available(macOS, introduced: 11.0)
  @objc public var isiOSAppOnMac: Bool {
    get {
      wrappedInstance.isiOSAppOnMac
    }
  }

  @available(macOS, introduced: 12.0)
  @objc public var isLowPowerModeEnabled: Bool {
    get {
      wrappedInstance.isLowPowerModeEnabled
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var isMacCatalystApp: Bool {
    get {
      wrappedInstance.isMacCatalystApp
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var operatingSystemVersion: OperatingSystemVersionWrapper {
    get {
      OperatingSystemVersionWrapper(wrappedInstance.operatingSystemVersion)
    }
  }

  @objc public var operatingSystemVersionString: String {
    get {
      wrappedInstance.operatingSystemVersionString
    }
  }

  @objc public var processName: String {
    get {
      wrappedInstance.processName
    }
    set {
      wrappedInstance.processName = newValue
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var processorCount: Int {
    get {
      wrappedInstance.processorCount
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var systemUptime: TimeInterval {
    get {
      wrappedInstance.systemUptime
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var userName: String {
    get {
      wrappedInstance.userName
    }
  }

  init(_ wrappedInstance: ProcessInfo) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.7)
  @objc public func disableAutomaticTermination(_ reason: String) {
    return wrappedInstance.disableAutomaticTermination(reason)
  }

  @available(macOS, introduced: 10.6)
  @objc public func disableSuddenTermination() {
    return wrappedInstance.disableSuddenTermination()
  }

  @available(macOS, introduced: 10.7)
  @objc public func enableAutomaticTermination(_ reason: String) {
    return wrappedInstance.enableAutomaticTermination(reason)
  }

  @available(macOS, introduced: 10.6)
  @objc public func enableSuddenTermination() {
    return wrappedInstance.enableSuddenTermination()
  }

  @available(macOS, introduced: 10.10)
  @objc public func isOperatingSystemAtLeast(_ version: OperatingSystemVersionWrapper) -> Bool {
    return wrappedInstance.isOperatingSystemAtLeast(version.wrappedInstance)
  }

  @available(macOS, introduced: 10.0, deprecated: 10.10)
  @objc public func operatingSystem() -> Int {
    return wrappedInstance.operatingSystem()
  }

  @available(macOS, introduced: 10.0, deprecated: 10.10)
  @objc public func operatingSystemName() -> String {
    return wrappedInstance.operatingSystemName()
  }

  @available(macOS, introduced: 10.9)
  @objc public class ActivityOptionsWrapper: NSObject {
    var wrappedInstance: ProcessInfo.ActivityOptions

    @available(macOS, introduced: 13.0)
    @objc static public var animationTrackingEnabled: ProcessInfoWrapper.ActivityOptionsWrapper {
      get {
        ActivityOptionsWrapper(ProcessInfo.ActivityOptions.animationTrackingEnabled)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var automaticTerminationDisabled: ProcessInfoWrapper.ActivityOptionsWrapper {
      get {
        ActivityOptionsWrapper(ProcessInfo.ActivityOptions.automaticTerminationDisabled)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var background: ProcessInfoWrapper.ActivityOptionsWrapper {
      get {
        ActivityOptionsWrapper(ProcessInfo.ActivityOptions.background)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var idleDisplaySleepDisabled: ProcessInfoWrapper.ActivityOptionsWrapper {
      get {
        ActivityOptionsWrapper(ProcessInfo.ActivityOptions.idleDisplaySleepDisabled)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var idleSystemSleepDisabled: ProcessInfoWrapper.ActivityOptionsWrapper {
      get {
        ActivityOptionsWrapper(ProcessInfo.ActivityOptions.idleSystemSleepDisabled)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var latencyCritical: ProcessInfoWrapper.ActivityOptionsWrapper {
      get {
        ActivityOptionsWrapper(ProcessInfo.ActivityOptions.latencyCritical)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var suddenTerminationDisabled: ProcessInfoWrapper.ActivityOptionsWrapper {
      get {
        ActivityOptionsWrapper(ProcessInfo.ActivityOptions.suddenTerminationDisabled)
      }
    }

    @available(macOS, introduced: 13.0)
    @objc static public var trackingEnabled: ProcessInfoWrapper.ActivityOptionsWrapper {
      get {
        ActivityOptionsWrapper(ProcessInfo.ActivityOptions.trackingEnabled)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var userInitiated: ProcessInfoWrapper.ActivityOptionsWrapper {
      get {
        ActivityOptionsWrapper(ProcessInfo.ActivityOptions.userInitiated)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var userInitiatedAllowingIdleSystemSleep: ProcessInfoWrapper.ActivityOptionsWrapper {
      get {
        ActivityOptionsWrapper(ProcessInfo.ActivityOptions.userInitiatedAllowingIdleSystemSleep)
      }
    }

    @available(macOS, introduced: 13.0)
    @objc static public var userInteractive: ProcessInfoWrapper.ActivityOptionsWrapper {
      get {
        ActivityOptionsWrapper(ProcessInfo.ActivityOptions.userInteractive)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: ProcessInfo.ActivityOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = ProcessInfo.ActivityOptions()
    }

  }

}

@available(macOS, introduced: 10.9)
@objc public class ProgressWrapper: NSObject {
  var wrappedInstance: Progress

  @available(macOS, introduced: 10.9)
  @objc public var isCancellable: Bool {
    get {
      wrappedInstance.isCancellable
    }
    set {
      wrappedInstance.isCancellable = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var isCancelled: Bool {
    get {
      wrappedInstance.isCancelled
    }
  }

  @available(macOS, introduced: 10.13)
  @objc public var fileOperationKind: ProgressWrapper.FileOperationKindWrapper? {
    get {
      wrappedInstance.fileOperationKind == nil ? nil : FileOperationKindWrapper(wrappedInstance.fileOperationKind!)
    }
    set {
      wrappedInstance.fileOperationKind = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.13)
  @objc public var fileURL: URLWrapper? {
    get {
      wrappedInstance.fileURL == nil ? nil : URLWrapper(wrappedInstance.fileURL!)
    }
    set {
      wrappedInstance.fileURL = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var isFinished: Bool {
    get {
      wrappedInstance.isFinished
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var fractionCompleted: Double {
    get {
      wrappedInstance.fractionCompleted
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var isIndeterminate: Bool {
    get {
      wrappedInstance.isIndeterminate
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var kind: ProgressKindWrapper? {
    get {
      wrappedInstance.kind == nil ? nil : ProgressKindWrapper(wrappedInstance.kind!)
    }
    set {
      wrappedInstance.kind = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var localizedAdditionalDescription: String {
    get {
      wrappedInstance.localizedAdditionalDescription
    }
    set {
      wrappedInstance.localizedAdditionalDescription = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var localizedDescription: String {
    get {
      wrappedInstance.localizedDescription
    }
    set {
      wrappedInstance.localizedDescription = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var isOld: Bool {
    get {
      wrappedInstance.isOld
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var isPausable: Bool {
    get {
      wrappedInstance.isPausable
    }
    set {
      wrappedInstance.isPausable = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var isPaused: Bool {
    get {
      wrappedInstance.isPaused
    }
  }

  @available(macOS, introduced: 10.13)
  @available(watchOS, introduced: 4.0)
  @available(iOS, introduced: 11.0)
  @available(tvOS, introduced: 11.0)
  @objc public var throughput: Int? {
    get {
      wrappedInstance.throughput
    }
    set {
      wrappedInstance.throughput = newValue
    }
  }

  @available(macOS, introduced: 10.13)
  @available(watchOS, introduced: 4.0)
  @available(iOS, introduced: 11.0)
  @available(tvOS, introduced: 11.0)
  @objc public var fileTotalCount: Int? {
    get {
      wrappedInstance.fileTotalCount
    }
    set {
      wrappedInstance.fileTotalCount = newValue
    }
  }

  @available(macOS, introduced: 10.13)
  @available(watchOS, introduced: 4.0)
  @available(iOS, introduced: 11.0)
  @available(tvOS, introduced: 11.0)
  @objc public var fileCompletedCount: Int? {
    get {
      wrappedInstance.fileCompletedCount
    }
    set {
      wrappedInstance.fileCompletedCount = newValue
    }
  }

  @available(macOS, introduced: 10.13)
  @available(watchOS, introduced: 4.0)
  @available(iOS, introduced: 11.0)
  @available(tvOS, introduced: 11.0)
  @objc public var estimatedTimeRemaining: TimeInterval? {
    get {
      wrappedInstance.estimatedTimeRemaining
    }
    set {
      wrappedInstance.estimatedTimeRemaining = newValue
    }
  }

  init(_ wrappedInstance: Progress) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.9)
  @objc static public func current() -> ProgressWrapper? {
    let result = Progress.current()
    return result == nil ? nil : ProgressWrapper(result!)
  }

  @available(macOS, introduced: 10.9)
  @objc public func cancel() {
    return wrappedInstance.cancel()
  }

  @available(macOS, introduced: 10.9)
  @objc public func pause() {
    return wrappedInstance.pause()
  }

  @available(macOS, introduced: 10.9)
  @objc public func publish() {
    return wrappedInstance.publish()
  }

  @available(macOS, introduced: 10.9)
  @objc public func resignCurrent() {
    return wrappedInstance.resignCurrent()
  }

  @available(macOS, introduced: 10.11)
  @objc public func resume() {
    return wrappedInstance.resume()
  }

  @available(macOS, introduced: 10.9)
  @objc public func unpublish() {
    return wrappedInstance.unpublish()
  }

  @objc public class FileOperationKindWrapper: NSObject {
    var wrappedInstance: Progress.FileOperationKind

    @available(macOS, introduced: 10.9)
    @objc static public var copying: ProgressWrapper.FileOperationKindWrapper {
      get {
        FileOperationKindWrapper(Progress.FileOperationKind.copying)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var decompressingAfterDownloading: ProgressWrapper.FileOperationKindWrapper {
      get {
        FileOperationKindWrapper(Progress.FileOperationKind.decompressingAfterDownloading)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var downloading: ProgressWrapper.FileOperationKindWrapper {
      get {
        FileOperationKindWrapper(Progress.FileOperationKind.downloading)
      }
    }

    @available(macOS, introduced: 12.0)
    @objc static public var duplicating: ProgressWrapper.FileOperationKindWrapper {
      get {
        FileOperationKindWrapper(Progress.FileOperationKind.duplicating)
      }
    }

    @available(macOS, introduced: 10.9)
    @objc static public var receiving: ProgressWrapper.FileOperationKindWrapper {
      get {
        FileOperationKindWrapper(Progress.FileOperationKind.receiving)
      }
    }

    @available(macOS, introduced: 10.10)
    @objc static public var uploading: ProgressWrapper.FileOperationKindWrapper {
      get {
        FileOperationKindWrapper(Progress.FileOperationKind.uploading)
      }
    }

    init(_ wrappedInstance: Progress.FileOperationKind) {
      self.wrappedInstance = wrappedInstance
    }

    @objc init(rawValue: String) {
      wrappedInstance = Progress.FileOperationKind(rawValue: rawValue)
    }

    @objc init(_ rawValue: String) {
      wrappedInstance = Progress.FileOperationKind(rawValue)
    }

  }

}

@objc public class PropertyListSerializationWrapper: NSObject {
  var wrappedInstance: PropertyListSerialization

  init(_ wrappedInstance: PropertyListSerialization) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public class MutabilityOptionsWrapper: NSObject {
    var wrappedInstance: PropertyListSerialization.MutabilityOptions

    @objc static public var mutableContainers: PropertyListSerializationWrapper.MutabilityOptionsWrapper {
      get {
        MutabilityOptionsWrapper(PropertyListSerialization.MutabilityOptions.mutableContainers)
      }
    }

    @objc static public var mutableContainersAndLeaves: PropertyListSerializationWrapper.MutabilityOptionsWrapper {
      get {
        MutabilityOptionsWrapper(PropertyListSerialization.MutabilityOptions.mutableContainersAndLeaves)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: PropertyListSerialization.MutabilityOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = PropertyListSerialization.MutabilityOptions()
    }

  }

}

@objc public class NSPropertySpecifierWrapper: NSObject {
  var wrappedInstance: NSPropertySpecifier

  init(_ wrappedInstance: NSPropertySpecifier) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSProtocolCheckerWrapper: NSObject {
  var wrappedInstance: NSProtocolChecker

  @objc public var target: NSObject? {
    get {
      wrappedInstance.target
    }
  }

  init(_ wrappedInstance: NSProtocolChecker) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSProxyWrapper: NSObject {
  var wrappedInstance: NSProxy

  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: NSProxy) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func dealloc() {
    return wrappedInstance.dealloc()
  }

  @objc public func finalize() {
    return wrappedInstance.finalize()
  }

}

@available(macOS, introduced: 10.6)
@objc public class NSPurgeableDataWrapper: NSObject {
  var wrappedInstance: NSPurgeableData

  init(_ wrappedInstance: NSPurgeableData) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSQuitCommandWrapper: NSObject {
  var wrappedInstance: NSQuitCommand

  init(_ wrappedInstance: NSQuitCommand) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSRandomSpecifierWrapper: NSObject {
  var wrappedInstance: NSRandomSpecifier

  init(_ wrappedInstance: NSRandomSpecifier) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSRangeSpecifierWrapper: NSObject {
  var wrappedInstance: NSRangeSpecifier

  @objc public var endSpecifier: NSScriptObjectSpecifierWrapper? {
    get {
      wrappedInstance.endSpecifier == nil ? nil : NSScriptObjectSpecifierWrapper(wrappedInstance.endSpecifier!)
    }
    set {
      wrappedInstance.endSpecifier = newValue?.wrappedInstance
    }
  }

  @objc public var startSpecifier: NSScriptObjectSpecifierWrapper? {
    get {
      wrappedInstance.startSpecifier == nil ? nil : NSScriptObjectSpecifierWrapper(wrappedInstance.startSpecifier!)
    }
    set {
      wrappedInstance.startSpecifier = newValue?.wrappedInstance
    }
  }

  init(_ wrappedInstance: NSRangeSpecifier) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder inCoder: NSCoderWrapper) {
    if let instance = NSRangeSpecifier(coder: inCoder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init(containerClassDescription classDesc: NSScriptClassDescriptionWrapper, containerSpecifier container: NSScriptObjectSpecifierWrapper?, key property: String, start startSpec: NSScriptObjectSpecifierWrapper?, end endSpec: NSScriptObjectSpecifierWrapper?) {
    wrappedInstance = NSRangeSpecifier(containerClassDescription: classDesc.wrappedInstance, containerSpecifier: container?.wrappedInstance, key: property, start: startSpec?.wrappedInstance, end: endSpec?.wrappedInstance)
  }

}

@objc public class NSRecursiveLockWrapper: NSObject {
  var wrappedInstance: NSRecursiveLock

  @available(macOS, introduced: 10.5)
  @objc public var name: String? {
    get {
      wrappedInstance.name
    }
    set {
      wrappedInstance.name = newValue
    }
  }

  init(_ wrappedInstance: NSRecursiveLock) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func lock(before limit: DateWrapper) -> Bool {
    return wrappedInstance.lock(before: limit.wrappedInstance)
  }

  @objc public func `try`() -> Bool {
    return wrappedInstance.`try`()
  }

}

@available(macOS, introduced: 10.7)
@objc public class NSRegularExpressionWrapper: NSObject {
  var wrappedInstance: NSRegularExpression

  @available(macOS, introduced: 10.7)
  @objc public var numberOfCaptureGroups: Int {
    get {
      wrappedInstance.numberOfCaptureGroups
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var options: NSRegularExpressionWrapper.OptionsWrapper {
    get {
      OptionsWrapper(wrappedInstance.options)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var pattern: String {
    get {
      wrappedInstance.pattern
    }
  }

  init(_ wrappedInstance: NSRegularExpression) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.7)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSRegularExpression(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public func escapedPattern(for string: String) -> String {
    return NSRegularExpression.escapedPattern(for: string)
  }

  @objc static public func escapedTemplate(for string: String) -> String {
    return NSRegularExpression.escapedTemplate(for: string)
  }

  @objc public func replacementString(for result: NSTextCheckingResultWrapper, in string: String, offset: Int, template templ: String) -> String {
    return wrappedInstance.replacementString(for: result1.wrappedInstance, in: string, offset: offset, template: templ)
  }

  @objc public class MatchingFlagsWrapper: NSObject {
    var wrappedInstance: NSRegularExpression.MatchingFlags

    @objc static public var completed: NSRegularExpressionWrapper.MatchingFlagsWrapper {
      get {
        MatchingFlagsWrapper(NSRegularExpression.MatchingFlags.completed)
      }
    }

    @objc static public var hitEnd: NSRegularExpressionWrapper.MatchingFlagsWrapper {
      get {
        MatchingFlagsWrapper(NSRegularExpression.MatchingFlags.hitEnd)
      }
    }

    @objc static public var internalError: NSRegularExpressionWrapper.MatchingFlagsWrapper {
      get {
        MatchingFlagsWrapper(NSRegularExpression.MatchingFlags.internalError)
      }
    }

    @objc static public var progress: NSRegularExpressionWrapper.MatchingFlagsWrapper {
      get {
        MatchingFlagsWrapper(NSRegularExpression.MatchingFlags.progress)
      }
    }

    @objc static public var requiredEnd: NSRegularExpressionWrapper.MatchingFlagsWrapper {
      get {
        MatchingFlagsWrapper(NSRegularExpression.MatchingFlags.requiredEnd)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSRegularExpression.MatchingFlags) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSRegularExpression.MatchingFlags()
    }

  }

  @objc public class MatchingOptionsWrapper: NSObject {
    var wrappedInstance: NSRegularExpression.MatchingOptions

    @objc static public var anchored: NSRegularExpressionWrapper.MatchingOptionsWrapper {
      get {
        MatchingOptionsWrapper(NSRegularExpression.MatchingOptions.anchored)
      }
    }

    @objc static public var reportCompletion: NSRegularExpressionWrapper.MatchingOptionsWrapper {
      get {
        MatchingOptionsWrapper(NSRegularExpression.MatchingOptions.reportCompletion)
      }
    }

    @objc static public var reportProgress: NSRegularExpressionWrapper.MatchingOptionsWrapper {
      get {
        MatchingOptionsWrapper(NSRegularExpression.MatchingOptions.reportProgress)
      }
    }

    @objc static public var withTransparentBounds: NSRegularExpressionWrapper.MatchingOptionsWrapper {
      get {
        MatchingOptionsWrapper(NSRegularExpression.MatchingOptions.withTransparentBounds)
      }
    }

    @objc static public var withoutAnchoringBounds: NSRegularExpressionWrapper.MatchingOptionsWrapper {
      get {
        MatchingOptionsWrapper(NSRegularExpression.MatchingOptions.withoutAnchoringBounds)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSRegularExpression.MatchingOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSRegularExpression.MatchingOptions()
    }

  }

  @objc public class OptionsWrapper: NSObject {
    var wrappedInstance: NSRegularExpression.Options

    @objc static public var allowCommentsAndWhitespace: NSRegularExpressionWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSRegularExpression.Options.allowCommentsAndWhitespace)
      }
    }

    @objc static public var anchorsMatchLines: NSRegularExpressionWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSRegularExpression.Options.anchorsMatchLines)
      }
    }

    @objc static public var caseInsensitive: NSRegularExpressionWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSRegularExpression.Options.caseInsensitive)
      }
    }

    @objc static public var dotMatchesLineSeparators: NSRegularExpressionWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSRegularExpression.Options.dotMatchesLineSeparators)
      }
    }

    @objc static public var ignoreMetacharacters: NSRegularExpressionWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSRegularExpression.Options.ignoreMetacharacters)
      }
    }

    @objc static public var useUnicodeWordBoundaries: NSRegularExpressionWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSRegularExpression.Options.useUnicodeWordBoundaries)
      }
    }

    @objc static public var useUnixLineSeparators: NSRegularExpressionWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSRegularExpression.Options.useUnixLineSeparators)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSRegularExpression.Options) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSRegularExpression.Options()
    }

  }

}

@available(macOS, introduced: 10.15)
@objc public class RelativeDateTimeFormatterWrapper: NSObject {
  var wrappedInstance: RelativeDateTimeFormatter

  @available(macOS, introduced: 10.15)
  @objc public var calendar: CalendarWrapper {
    get {
      CalendarWrapper(wrappedInstance.calendar)
    }
    set {
      wrappedInstance.calendar = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var locale: LocaleWrapper {
    get {
      LocaleWrapper(wrappedInstance.locale)
    }
    set {
      wrappedInstance.locale = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: RelativeDateTimeFormatter) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.15)
  @objc public func localizedString(for date: DateWrapper, relativeTo referenceDate: DateWrapper) -> String {
    return wrappedInstance.localizedString(for: date.wrappedInstance, relativeTo: referenceDate.wrappedInstance)
  }

  @available(macOS, introduced: 10.15)
  @objc public func localizedString(from dateComponents: DateComponentsWrapper) -> String {
    return wrappedInstance.localizedString(from: dateComponents.wrappedInstance)
  }

  @available(macOS, introduced: 10.15)
  @objc public func localizedString(fromTimeInterval timeInterval: TimeInterval) -> String {
    return wrappedInstance.localizedString(fromTimeInterval: timeInterval)
  }

}

@objc public class NSRelativeSpecifierWrapper: NSObject {
  var wrappedInstance: NSRelativeSpecifier

  @objc public var baseSpecifier: NSScriptObjectSpecifierWrapper? {
    get {
      wrappedInstance.baseSpecifier == nil ? nil : NSScriptObjectSpecifierWrapper(wrappedInstance.baseSpecifier!)
    }
    set {
      wrappedInstance.baseSpecifier = newValue?.wrappedInstance
    }
  }

  init(_ wrappedInstance: NSRelativeSpecifier) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder inCoder: NSCoderWrapper) {
    if let instance = NSRelativeSpecifier(coder: inCoder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@objc public class RunLoopWrapper: NSObject {
  var wrappedInstance: RunLoop

  @objc static public var current: RunLoopWrapper {
    get {
      RunLoopWrapper(RunLoop.current)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var main: RunLoopWrapper {
    get {
      RunLoopWrapper(RunLoop.main)
    }
  }

  @objc public var currentMode: RunLoopWrapper.ModeWrapper? {
    get {
      wrappedInstance.currentMode == nil ? nil : ModeWrapper(wrappedInstance.currentMode!)
    }
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public var minimumTolerance: SchedulerTimeTypeWrapper.StrideWrapper {
    get {
      StrideWrapper(wrappedInstance.minimumTolerance)
    }
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public var now: RunLoopWrapper.SchedulerTimeTypeWrapper {
    get {
      SchedulerTimeTypeWrapper(wrappedInstance.now)
    }
  }

  init(_ wrappedInstance: RunLoop) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func acceptInput(forMode mode: RunLoopWrapper.ModeWrapper, before limitDate: DateWrapper) {
    return wrappedInstance.acceptInput(forMode: mode.wrappedInstance, before: limitDate.wrappedInstance)
  }

  @objc public func add(_ timer: TimerWrapper, forMode mode: RunLoopWrapper.ModeWrapper) {
    return wrappedInstance.add(timer.wrappedInstance, forMode: mode.wrappedInstance)
  }

  @objc public func limitDate(forMode mode: RunLoopWrapper.ModeWrapper) -> DateWrapper? {
    let result = wrappedInstance.limitDate(forMode: mode.wrappedInstance)
    return result == nil ? nil : DateWrapper(result!)
  }

  @objc public func remove(_ aPort: PortWrapper, forMode mode: RunLoopWrapper.ModeWrapper) {
    return wrappedInstance.remove(aPort.wrappedInstance, forMode: mode.wrappedInstance)
  }

  @objc public func run() {
    return wrappedInstance.run()
  }

  @objc public func run(mode: RunLoopWrapper.ModeWrapper, before limitDate: DateWrapper) -> Bool {
    return wrappedInstance.run(mode: mode.wrappedInstance, before: limitDate.wrappedInstance)
  }

  @objc public func run(until limitDate: DateWrapper) {
    return wrappedInstance.run(until: limitDate.wrappedInstance)
  }

  @objc public class ModeWrapper: NSObject {
    var wrappedInstance: RunLoop.Mode

    @objc static public var `default`: RunLoopWrapper.ModeWrapper {
      get {
        ModeWrapper(RunLoop.Mode.`default`)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var common: RunLoopWrapper.ModeWrapper {
      get {
        ModeWrapper(RunLoop.Mode.common)
      }
    }

    init(_ wrappedInstance: RunLoop.Mode) {
      self.wrappedInstance = wrappedInstance
    }

    @objc init(rawValue: String) {
      wrappedInstance = RunLoop.Mode(rawValue: rawValue)
    }

    @objc init(_ rawValue: String) {
      wrappedInstance = RunLoop.Mode(rawValue)
    }

  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public class SchedulerOptionsWrapper: NSObject {
    var wrappedInstance: RunLoop.SchedulerOptions

    init(_ wrappedInstance: RunLoop.SchedulerOptions) {
      self.wrappedInstance = wrappedInstance
    }

  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public class SchedulerTimeTypeWrapper: NSObject {
    var wrappedInstance: RunLoop.SchedulerTimeType

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public var date: DateWrapper {
      get {
        DateWrapper(wrappedInstance.date)
      }
      set {
        wrappedInstance.date = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: RunLoop.SchedulerTimeType) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc init(_ date: DateWrapper) {
      wrappedInstance = RunLoop.SchedulerTimeType(date.wrappedInstance)
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public func advanced(by n: SchedulerTimeTypeWrapper.StrideWrapper) -> RunLoopWrapper.SchedulerTimeTypeWrapper {
      let result = wrappedInstance.advanced(by: n.wrappedInstance)
      return SchedulerTimeTypeWrapper(result)
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public func distance(to other: RunLoopWrapper.SchedulerTimeTypeWrapper) -> SchedulerTimeTypeWrapper.StrideWrapper {
      let result = wrappedInstance.distance(to: other.wrappedInstance)
      return StrideWrapper(result)
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public class StrideWrapper: NSObject {
      var wrappedInstance: SchedulerTimeType.Stride

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc public var timeInterval: TimeInterval {
        get {
          wrappedInstance.timeInterval
        }
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc public var magnitude: TimeInterval {
        get {
          wrappedInstance.magnitude
        }
        set {
          wrappedInstance.magnitude = newValue
        }
      }

      init(_ wrappedInstance: SchedulerTimeType.Stride) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc init(floatLiteral value: TimeInterval) {
        wrappedInstance = SchedulerTimeType.Stride(floatLiteral: value)
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc init(integerLiteral value: TimeInterval) {
        wrappedInstance = SchedulerTimeType.Stride(integerLiteral: value)
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc init(_ timeInterval: TimeInterval) {
        wrappedInstance = SchedulerTimeType.Stride(timeInterval)
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc static public func nanoseconds(_ ns: Int) -> SchedulerTimeTypeWrapper.StrideWrapper {
        let result = SchedulerTimeType.Stride.nanoseconds(ns)
        return StrideWrapper(result)
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc static public func microseconds(_ us: Int) -> SchedulerTimeTypeWrapper.StrideWrapper {
        let result = SchedulerTimeType.Stride.microseconds(us)
        return StrideWrapper(result)
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc static public func milliseconds(_ ms: Int) -> SchedulerTimeTypeWrapper.StrideWrapper {
        let result = SchedulerTimeType.Stride.milliseconds(ms)
        return StrideWrapper(result)
      }

      @available(macOS, introduced: 10.15)
      @available(watchOS, introduced: 6.0)
      @available(iOS, introduced: 13.0)
      @available(tvOS, introduced: 13.0)
      @objc static public func seconds(_ s: Int) -> SchedulerTimeTypeWrapper.StrideWrapper {
        let result = SchedulerTimeType.Stride.seconds(s)
        return StrideWrapper(result)
      }

      @objc public func negate() {
        return wrappedInstance.negate()
      }

    }

  }

}

@objc public class ScannerWrapper: NSObject {
  var wrappedInstance: Scanner

  @objc public var isAtEnd: Bool {
    get {
      wrappedInstance.isAtEnd
    }
  }

  @objc public var caseSensitive: Bool {
    get {
      wrappedInstance.caseSensitive
    }
    set {
      wrappedInstance.caseSensitive = newValue
    }
  }

  @objc public var charactersToBeSkipped: CharacterSetWrapper? {
    get {
      wrappedInstance.charactersToBeSkipped == nil ? nil : CharacterSetWrapper(wrappedInstance.charactersToBeSkipped!)
    }
    set {
      wrappedInstance.charactersToBeSkipped = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.0, deprecated: 10.15)
  @objc public var scanLocation: Int {
    get {
      wrappedInstance.scanLocation
    }
    set {
      wrappedInstance.scanLocation = newValue
    }
  }

  @objc public var string: String {
    get {
      wrappedInstance.string
    }
  }

  init(_ wrappedInstance: Scanner) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(string: String) {
    wrappedInstance = Scanner(string: string)
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public func scanString(_ searchString: String) -> String? {
    return wrappedInstance.scanString(searchString)
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public func scanDecimal() -> DecimalWrapper? {
    let result = wrappedInstance.scanDecimal()
    return result == nil ? nil : DecimalWrapper(result!)
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public func scanCharacters(from set: CharacterSetWrapper) -> String? {
    return wrappedInstance.scanCharacters(from: set.wrappedInstance)
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public func scanUpToString(_ substring: String) -> String? {
    return wrappedInstance.scanUpToString(substring)
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public func scanUpToCharacters(from set: CharacterSetWrapper) -> String? {
    return wrappedInstance.scanUpToCharacters(from: set.wrappedInstance)
  }

}

@objc public class NSScriptClassDescriptionWrapper: NSObject {
  var wrappedInstance: NSScriptClassDescription

  @objc public var className: String? {
    get {
      wrappedInstance.className
    }
  }

  @objc public var defaultSubcontainerAttributeKey: String? {
    get {
      wrappedInstance.defaultSubcontainerAttributeKey
    }
  }

  @objc public var implementationClassName: String? {
    get {
      wrappedInstance.implementationClassName
    }
  }

  @objc public var suiteName: String? {
    get {
      wrappedInstance.suiteName
    }
  }

  @objc public var superclass: NSScriptClassDescriptionWrapper? {
    get {
      wrappedInstance.superclass == nil ? nil : NSScriptClassDescriptionWrapper(wrappedInstance.superclass!)
    }
  }

  init(_ wrappedInstance: NSScriptClassDescription) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func forKey(_ key: String) -> NSScriptClassDescriptionWrapper? {
    let result = wrappedInstance.forKey(key)
    return result == nil ? nil : NSScriptClassDescriptionWrapper(result!)
  }

  @available(macOS, introduced: 10.5)
  @objc public func hasOrderedToManyRelationship(forKey key: String) -> Bool {
    return wrappedInstance.hasOrderedToManyRelationship(forKey: key)
  }

  @available(macOS, introduced: 10.5)
  @objc public func hasProperty(forKey key: String) -> Bool {
    return wrappedInstance.hasProperty(forKey: key)
  }

  @available(macOS, introduced: 10.5)
  @objc public func hasReadableProperty(forKey key: String) -> Bool {
    return wrappedInstance.hasReadableProperty(forKey: key)
  }

  @available(macOS, introduced: 10.5)
  @objc public func hasWritableProperty(forKey key: String) -> Bool {
    return wrappedInstance.hasWritableProperty(forKey: key)
  }

  @objc public func isLocationRequiredToCreate(forKey toManyRelationshipKey: String) -> Bool {
    return wrappedInstance.isLocationRequiredToCreate(forKey: toManyRelationshipKey)
  }

  @objc public func supportsCommand(_ commandDescription: NSScriptCommandDescriptionWrapper) -> Bool {
    return wrappedInstance.supportsCommand(commandDescription.wrappedInstance)
  }

  @objc public func type(forKey key: String) -> String? {
    return wrappedInstance.type(forKey: key)
  }

}

@objc public class NSScriptCoercionHandlerWrapper: NSObject {
  var wrappedInstance: NSScriptCoercionHandler

  init(_ wrappedInstance: NSScriptCoercionHandler) {
    self.wrappedInstance = wrappedInstance
  }

  @objc static public func shared() -> NSScriptCoercionHandlerWrapper {
    let result = NSScriptCoercionHandler.shared()
    return NSScriptCoercionHandlerWrapper(result)
  }

}

@objc public class NSScriptCommandWrapper: NSObject {
  var wrappedInstance: NSScriptCommand

  @objc public var appleEvent: NSAppleEventDescriptorWrapper? {
    get {
      wrappedInstance.appleEvent == nil ? nil : NSAppleEventDescriptorWrapper(wrappedInstance.appleEvent!)
    }
  }

  @objc public var commandDescription: NSScriptCommandDescriptionWrapper {
    get {
      NSScriptCommandDescriptionWrapper(wrappedInstance.commandDescription)
    }
  }

  @objc public var receiversSpecifier: NSScriptObjectSpecifierWrapper? {
    get {
      wrappedInstance.receiversSpecifier == nil ? nil : NSScriptObjectSpecifierWrapper(wrappedInstance.receiversSpecifier!)
    }
    set {
      wrappedInstance.receiversSpecifier = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var scriptErrorExpectedTypeDescriptor: NSAppleEventDescriptorWrapper? {
    get {
      wrappedInstance.scriptErrorExpectedTypeDescriptor == nil ? nil : NSAppleEventDescriptorWrapper(wrappedInstance.scriptErrorExpectedTypeDescriptor!)
    }
    set {
      wrappedInstance.scriptErrorExpectedTypeDescriptor = newValue?.wrappedInstance
    }
  }

  @objc public var scriptErrorNumber: Int {
    get {
      wrappedInstance.scriptErrorNumber
    }
    set {
      wrappedInstance.scriptErrorNumber = newValue
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var scriptErrorOffendingObjectDescriptor: NSAppleEventDescriptorWrapper? {
    get {
      wrappedInstance.scriptErrorOffendingObjectDescriptor == nil ? nil : NSAppleEventDescriptorWrapper(wrappedInstance.scriptErrorOffendingObjectDescriptor!)
    }
    set {
      wrappedInstance.scriptErrorOffendingObjectDescriptor = newValue?.wrappedInstance
    }
  }

  @objc public var scriptErrorString: String? {
    get {
      wrappedInstance.scriptErrorString
    }
    set {
      wrappedInstance.scriptErrorString = newValue
    }
  }

  @objc public var isWellFormed: Bool {
    get {
      wrappedInstance.isWellFormed
    }
  }

  init(_ wrappedInstance: NSScriptCommand) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(commandDescription commandDef: NSScriptCommandDescriptionWrapper) {
    wrappedInstance = NSScriptCommand(commandDescription: commandDef.wrappedInstance)
  }

  @objc static public func current() -> NSScriptCommandWrapper? {
    let result = NSScriptCommand.current()
    return result == nil ? nil : NSScriptCommandWrapper(result!)
  }

  @objc public func suspendExecution() {
    return wrappedInstance.suspendExecution()
  }

}

@objc public class NSScriptCommandDescriptionWrapper: NSObject {
  var wrappedInstance: NSScriptCommandDescription

  @objc public var commandClassName: String {
    get {
      wrappedInstance.commandClassName
    }
  }

  @objc public var commandName: String {
    get {
      wrappedInstance.commandName
    }
  }

  @objc public var returnType: String? {
    get {
      wrappedInstance.returnType
    }
  }

  @objc public var suiteName: String {
    get {
      wrappedInstance.suiteName
    }
  }

  init(_ wrappedInstance: NSScriptCommandDescription) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder inCoder: NSCoderWrapper) {
    if let instance = NSScriptCommandDescription(coder: inCoder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func createCommandInstance() -> NSScriptCommandWrapper {
    let result = wrappedInstance.createCommandInstance()
    return NSScriptCommandWrapper(result)
  }

  @objc public func isOptionalArgument(withName argumentName: String) -> Bool {
    return wrappedInstance.isOptionalArgument(withName: argumentName)
  }

  @objc public func typeForArgument(withName argumentName: String) -> String? {
    return wrappedInstance.typeForArgument(withName: argumentName)
  }

}

@objc public class NSScriptExecutionContextWrapper: NSObject {
  var wrappedInstance: NSScriptExecutionContext

  init(_ wrappedInstance: NSScriptExecutionContext) {
    self.wrappedInstance = wrappedInstance
  }

  @objc static public func shared() -> NSScriptExecutionContextWrapper {
    let result = NSScriptExecutionContext.shared()
    return NSScriptExecutionContextWrapper(result)
  }

}

@objc public class NSScriptObjectSpecifierWrapper: NSObject {
  var wrappedInstance: NSScriptObjectSpecifier

  @objc public var child: NSScriptObjectSpecifierWrapper? {
    get {
      wrappedInstance.child == nil ? nil : NSScriptObjectSpecifierWrapper(wrappedInstance.child!)
    }
    set {
      wrappedInstance.child = newValue?.wrappedInstance
    }
  }

  @objc public var containerClassDescription: NSScriptClassDescriptionWrapper? {
    get {
      wrappedInstance.containerClassDescription == nil ? nil : NSScriptClassDescriptionWrapper(wrappedInstance.containerClassDescription!)
    }
    set {
      wrappedInstance.containerClassDescription = newValue?.wrappedInstance
    }
  }

  @objc public var containerIsObjectBeingTested: Bool {
    get {
      wrappedInstance.containerIsObjectBeingTested
    }
    set {
      wrappedInstance.containerIsObjectBeingTested = newValue
    }
  }

  @objc public var containerIsRangeContainerObject: Bool {
    get {
      wrappedInstance.containerIsRangeContainerObject
    }
    set {
      wrappedInstance.containerIsRangeContainerObject = newValue
    }
  }

  @objc public var container: NSScriptObjectSpecifierWrapper? {
    get {
      wrappedInstance.container == nil ? nil : NSScriptObjectSpecifierWrapper(wrappedInstance.container!)
    }
    set {
      wrappedInstance.container = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var descriptor: NSAppleEventDescriptorWrapper? {
    get {
      wrappedInstance.descriptor == nil ? nil : NSAppleEventDescriptorWrapper(wrappedInstance.descriptor!)
    }
  }

  @objc public var evaluationErrorNumber: Int {
    get {
      wrappedInstance.evaluationErrorNumber
    }
    set {
      wrappedInstance.evaluationErrorNumber = newValue
    }
  }

  @objc public var evaluationError: NSScriptObjectSpecifierWrapper? {
    get {
      wrappedInstance.evaluationError == nil ? nil : NSScriptObjectSpecifierWrapper(wrappedInstance.evaluationError!)
    }
  }

  @objc public var key: String {
    get {
      wrappedInstance.key
    }
    set {
      wrappedInstance.key = newValue
    }
  }

  @objc public var keyClassDescription: NSScriptClassDescriptionWrapper? {
    get {
      wrappedInstance.keyClassDescription == nil ? nil : NSScriptClassDescriptionWrapper(wrappedInstance.keyClassDescription!)
    }
  }

  init(_ wrappedInstance: NSScriptObjectSpecifier) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.5)
  @objc init?(descriptor: NSAppleEventDescriptorWrapper) {
    if let instance = NSScriptObjectSpecifier(descriptor: descriptor.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init?(coder inCoder: NSCoderWrapper) {
    if let instance = NSScriptObjectSpecifier(coder: inCoder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init(containerClassDescription classDesc: NSScriptClassDescriptionWrapper, containerSpecifier container: NSScriptObjectSpecifierWrapper?, key property: String) {
    wrappedInstance = NSScriptObjectSpecifier(containerClassDescription: classDesc.wrappedInstance, containerSpecifier: container?.wrappedInstance, key: property)
  }

}

@objc public class NSScriptSuiteRegistryWrapper: NSObject {
  var wrappedInstance: NSScriptSuiteRegistry

  init(_ wrappedInstance: NSScriptSuiteRegistry) {
    self.wrappedInstance = wrappedInstance
  }

  @objc static public func setShared(_ registry: NSScriptSuiteRegistryWrapper) {
    return NSScriptSuiteRegistry.setShared(registry.wrappedInstance)
  }

  @objc static public func shared() -> NSScriptSuiteRegistryWrapper {
    let result = NSScriptSuiteRegistry.shared()
    return NSScriptSuiteRegistryWrapper(result)
  }

  @objc public func aeteResource(_ languageName: String) -> DataWrapper? {
    let result = wrappedInstance.aeteResource(languageName)
    return result == nil ? nil : DataWrapper(result!)
  }

  @objc public func bundle(forSuite suiteName: String) -> BundleWrapper? {
    let result = wrappedInstance.bundle(forSuite: suiteName)
    return result == nil ? nil : BundleWrapper(result!)
  }

  @objc public func loadSuites(from bundle: BundleWrapper) {
    return wrappedInstance.loadSuites(from: bundle.wrappedInstance)
  }

  @objc public func register(_ commandDescription: NSScriptCommandDescriptionWrapper) {
    return wrappedInstance.register(commandDescription.wrappedInstance)
  }

}

@objc public class NSScriptWhoseTestWrapper: NSObject {
  var wrappedInstance: NSScriptWhoseTest

  init(_ wrappedInstance: NSScriptWhoseTest) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSScriptWhoseTest()
  }

  @objc init?(coder inCoder: NSCoderWrapper) {
    if let instance = NSScriptWhoseTest(coder: inCoder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func isTrue() -> Bool {
    return wrappedInstance.isTrue()
  }

}

@available(macOS, introduced: 10.14)
@objc public class NSSecureUnarchiveFromDataTransformerWrapper: NSObject {
  var wrappedInstance: NSSecureUnarchiveFromDataTransformer

  init(_ wrappedInstance: NSSecureUnarchiveFromDataTransformer) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSSetWrapper: NSObject {
  var wrappedInstance: NSSet

  @objc public var count: Int {
    get {
      wrappedInstance.count
    }
  }

  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var underestimatedCount: Int {
    get {
      wrappedInstance.underestimatedCount
    }
  }

  init(_ wrappedInstance: NSSet) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSSet()
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSSet(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func objectEnumerator() -> NSEnumeratorWrapper {
    let result = wrappedInstance.objectEnumerator()
    return NSEnumeratorWrapper(result)
  }

  @objc public func removeObserver(_ observer: NSObject, forKeyPath keyPath: String) {
    return wrappedInstance.removeObserver(observer, forKeyPath: keyPath)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func makeIterator() -> NSFastEnumerationIteratorWrapper {
    let result = wrappedInstance.makeIterator()
    return NSFastEnumerationIteratorWrapper(result)
  }

}

@objc public class NSSetCommandWrapper: NSObject {
  var wrappedInstance: NSSetCommand

  @objc public var keySpecifier: NSScriptObjectSpecifierWrapper {
    get {
      NSScriptObjectSpecifierWrapper(wrappedInstance.keySpecifier)
    }
  }

  init(_ wrappedInstance: NSSetCommand) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func setReceiversSpecifier(_ receiversRef: NSScriptObjectSpecifierWrapper?) {
    return wrappedInstance.setReceiversSpecifier(receiversRef?.wrappedInstance)
  }

}

@objc public class SocketPortWrapper: NSObject {
  var wrappedInstance: SocketPort

  @objc public var address: DataWrapper {
    get {
      DataWrapper(wrappedInstance.address)
    }
  }

  init(_ wrappedInstance: SocketPort) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSSortDescriptorWrapper: NSObject {
  var wrappedInstance: NSSortDescriptor

  @objc public var ascending: Bool {
    get {
      wrappedInstance.ascending
    }
  }

  @objc public var key: String? {
    get {
      wrappedInstance.key
    }
  }

  init(_ wrappedInstance: NSSortDescriptor) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSSortDescriptor(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init(key: String?, ascending: Bool) {
    wrappedInstance = NSSortDescriptor(key: key, ascending: ascending)
  }

  @available(macOS, introduced: 10.9)
  @objc public func allowEvaluation() {
    return wrappedInstance.allowEvaluation()
  }

}

@objc public class NSSpecifierTestWrapper: NSObject {
  var wrappedInstance: NSSpecifierTest

  init(_ wrappedInstance: NSSpecifierTest) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder inCoder: NSCoderWrapper) {
    if let instance = NSSpecifierTest(coder: inCoder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@objc public class NSSpellServerWrapper: NSObject {
  var wrappedInstance: NSSpellServer

  init(_ wrappedInstance: NSSpellServer) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func isWord(inUserDictionaries word: String, caseSensitive flag: Bool) -> Bool {
    return wrappedInstance.isWord(inUserDictionaries: word, caseSensitive: flag)
  }

  @objc public func registerLanguage(_ language: String?, byVendor vendor: String?) -> Bool {
    return wrappedInstance.registerLanguage(language, byVendor: vendor)
  }

  @objc public func run() {
    return wrappedInstance.run()
  }

}

@objc public class StreamWrapper: NSObject {
  var wrappedInstance: Stream

  init(_ wrappedInstance: Stream) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func close() {
    return wrappedInstance.close()
  }

  @objc public func open() {
    return wrappedInstance.open()
  }

  @objc public func remove(from aRunLoop: RunLoopWrapper, forMode mode: RunLoopWrapper.ModeWrapper) {
    return wrappedInstance.remove(from: aRunLoop.wrappedInstance, forMode: mode.wrappedInstance)
  }

  @objc public func schedule(in aRunLoop: RunLoopWrapper, forMode mode: RunLoopWrapper.ModeWrapper) {
    return wrappedInstance.schedule(in: aRunLoop.wrappedInstance, forMode: mode.wrappedInstance)
  }

  @objc public class EventWrapper: NSObject {
    var wrappedInstance: Stream.Event

    @objc static public var endEncountered: StreamWrapper.EventWrapper {
      get {
        EventWrapper(Stream.Event.endEncountered)
      }
    }

    @objc static public var errorOccurred: StreamWrapper.EventWrapper {
      get {
        EventWrapper(Stream.Event.errorOccurred)
      }
    }

    @objc static public var hasBytesAvailable: StreamWrapper.EventWrapper {
      get {
        EventWrapper(Stream.Event.hasBytesAvailable)
      }
    }

    @objc static public var hasSpaceAvailable: StreamWrapper.EventWrapper {
      get {
        EventWrapper(Stream.Event.hasSpaceAvailable)
      }
    }

    @objc static public var openCompleted: StreamWrapper.EventWrapper {
      get {
        EventWrapper(Stream.Event.openCompleted)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: Stream.Event) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = Stream.Event()
    }

  }

  @objc public class PropertyKeyWrapper: NSObject {
    var wrappedInstance: Stream.PropertyKey

    @available(macOS, introduced: 10.3)
    @objc static public var dataWrittenToMemoryStreamKey: StreamWrapper.PropertyKeyWrapper {
      get {
        PropertyKeyWrapper(Stream.PropertyKey.dataWrittenToMemoryStreamKey)
      }
    }

    @available(macOS, introduced: 10.3)
    @objc static public var fileCurrentOffsetKey: StreamWrapper.PropertyKeyWrapper {
      get {
        PropertyKeyWrapper(Stream.PropertyKey.fileCurrentOffsetKey)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var networkServiceType: StreamWrapper.PropertyKeyWrapper {
      get {
        PropertyKeyWrapper(Stream.PropertyKey.networkServiceType)
      }
    }

    @available(macOS, introduced: 10.3)
    @objc static public var socksProxyConfigurationKey: StreamWrapper.PropertyKeyWrapper {
      get {
        PropertyKeyWrapper(Stream.PropertyKey.socksProxyConfigurationKey)
      }
    }

    @available(macOS, introduced: 10.3)
    @objc static public var socketSecurityLevelKey: StreamWrapper.PropertyKeyWrapper {
      get {
        PropertyKeyWrapper(Stream.PropertyKey.socketSecurityLevelKey)
      }
    }

    init(_ wrappedInstance: Stream.PropertyKey) {
      self.wrappedInstance = wrappedInstance
    }

    @objc init(rawValue: String) {
      wrappedInstance = Stream.PropertyKey(rawValue: rawValue)
    }

    @objc init(_ rawValue: String) {
      wrappedInstance = Stream.PropertyKey(rawValue)
    }

  }

}

@objc public class NSStringWrapper: NSObject {
  var wrappedInstance: NSString

  @objc public var isAbsolutePath: Bool {
    get {
      wrappedInstance.isAbsolutePath
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var boolValue: Bool {
    get {
      wrappedInstance.boolValue
    }
  }

  @objc public var capitalized: String {
    get {
      wrappedInstance.capitalized
    }
  }

  @objc public var decomposedStringWithCanonicalMapping: String {
    get {
      wrappedInstance.decomposedStringWithCanonicalMapping
    }
  }

  @objc public var decomposedStringWithCompatibilityMapping: String {
    get {
      wrappedInstance.decomposedStringWithCompatibilityMapping
    }
  }

  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @objc public var doubleValue: Double {
    get {
      wrappedInstance.doubleValue
    }
  }

  @objc public var floatValue: Float {
    get {
      wrappedInstance.floatValue
    }
  }

  @objc public var hash: Int {
    get {
      wrappedInstance.hash
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var integerValue: Int {
    get {
      wrappedInstance.integerValue
    }
  }

  @objc public var lastPathComponent: String {
    get {
      wrappedInstance.lastPathComponent
    }
  }

  @objc public var length: Int {
    get {
      wrappedInstance.length
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var localizedCapitalized: String {
    get {
      wrappedInstance.localizedCapitalized
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var localizedLowercase: String {
    get {
      wrappedInstance.localizedLowercase
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var localizedUppercase: String {
    get {
      wrappedInstance.localizedUppercase
    }
  }

  @objc public var lowercased: String {
    get {
      wrappedInstance.lowercased
    }
  }

  @objc public var pathExtension: String {
    get {
      wrappedInstance.pathExtension
    }
  }

  @objc public var precomposedStringWithCanonicalMapping: String {
    get {
      wrappedInstance.precomposedStringWithCanonicalMapping
    }
  }

  @objc public var precomposedStringWithCompatibilityMapping: String {
    get {
      wrappedInstance.precomposedStringWithCompatibilityMapping
    }
  }

  @objc public var abbreviatingWithTildeInPath: String {
    get {
      wrappedInstance.abbreviatingWithTildeInPath
    }
  }

  @objc public var deletingLastPathComponent: String {
    get {
      wrappedInstance.deletingLastPathComponent
    }
  }

  @objc public var deletingPathExtension: String {
    get {
      wrappedInstance.deletingPathExtension
    }
  }

  @objc public var expandingTildeInPath: String {
    get {
      wrappedInstance.expandingTildeInPath
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var removingPercentEncoding: String? {
    get {
      wrappedInstance.removingPercentEncoding
    }
  }

  @objc public var resolvingSymlinksInPath: String {
    get {
      wrappedInstance.resolvingSymlinksInPath
    }
  }

  @objc public var standardizingPath: String {
    get {
      wrappedInstance.standardizingPath
    }
  }

  @objc public var uppercased: String {
    get {
      wrappedInstance.uppercased
    }
  }

  init(_ wrappedInstance: NSString) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = NSString()
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSString(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public func capitalized(with locale: LocaleWrapper?) -> String {
    return wrappedInstance.capitalized(with: locale?.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @objc public func contains(_ str: String) -> Bool {
    return wrappedInstance.contains(str)
  }

  @objc public func hasPrefix(_ str: String) -> Bool {
    return wrappedInstance.hasPrefix(str)
  }

  @objc public func hasSuffix(_ str: String) -> Bool {
    return wrappedInstance.hasSuffix(str)
  }

  @objc public func isEqual(to aString: String) -> Bool {
    return wrappedInstance.isEqual(to: aString)
  }

  @available(macOS, introduced: 10.10)
  @objc public func localizedCaseInsensitiveContains(_ str: String) -> Bool {
    return wrappedInstance.localizedCaseInsensitiveContains(str)
  }

  @available(macOS, introduced: 10.11)
  @objc public func localizedStandardContains(_ str: String) -> Bool {
    return wrappedInstance.localizedStandardContains(str)
  }

  @available(macOS, introduced: 10.8)
  @objc public func lowercased(with locale: LocaleWrapper?) -> String {
    return wrappedInstance.lowercased(with: locale?.wrappedInstance)
  }

  @available(macOS, introduced: 10.9)
  @objc public func addingPercentEncoding(withAllowedCharacters allowedCharacters: CharacterSetWrapper) -> String? {
    return wrappedInstance.addingPercentEncoding(withAllowedCharacters: allowedCharacters.wrappedInstance)
  }

  @objc public func appendingPathComponent(_ str: String) -> String {
    return wrappedInstance.appendingPathComponent(str)
  }

  @objc public func appendingPathExtension(_ str: String) -> String? {
    return wrappedInstance.appendingPathExtension(str)
  }

  @objc public func appending(_ aString: String) -> String {
    return wrappedInstance.appending(aString)
  }

  @available(macOS, introduced: 10.11)
  @objc public func applyingTransform(_ transform: StringTransformWrapper, reverse: Bool) -> String? {
    return wrappedInstance.applyingTransform(transform.wrappedInstance, reverse: reverse)
  }

  @objc public func padding(toLength newLength: Int, withPad padString: String, startingAt padIndex: Int) -> String {
    return wrappedInstance.padding(toLength: newLength, withPad: padString, startingAt: padIndex)
  }

  @available(macOS, introduced: 10.5)
  @objc public func replacingOccurrences(of target: String, with replacement: String) -> String {
    return wrappedInstance.replacingOccurrences(of: target, with: replacement)
  }

  @objc public func trimmingCharacters(in set: CharacterSetWrapper) -> String {
    return wrappedInstance.trimmingCharacters(in: set.wrappedInstance)
  }

  @objc public func substring(from: Int) -> String {
    return wrappedInstance.substring(from: from)
  }

  @objc public func substring(to: Int) -> String {
    return wrappedInstance.substring(to: to)
  }

  @available(macOS, introduced: 10.8)
  @objc public func uppercased(with locale: LocaleWrapper?) -> String {
    return wrappedInstance.uppercased(with: locale?.wrappedInstance)
  }

  @available(macOS, introduced: 10.11)
  @objc public func variantFittingPresentationWidth(_ width: Int) -> String {
    return wrappedInstance.variantFittingPresentationWidth(width)
  }

  @objc public class CompareOptionsWrapper: NSObject {
    var wrappedInstance: NSString.CompareOptions

    @objc static public var anchored: NSStringWrapper.CompareOptionsWrapper {
      get {
        CompareOptionsWrapper(NSString.CompareOptions.anchored)
      }
    }

    @objc static public var backwards: NSStringWrapper.CompareOptionsWrapper {
      get {
        CompareOptionsWrapper(NSString.CompareOptions.backwards)
      }
    }

    @objc static public var caseInsensitive: NSStringWrapper.CompareOptionsWrapper {
      get {
        CompareOptionsWrapper(NSString.CompareOptions.caseInsensitive)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var diacriticInsensitive: NSStringWrapper.CompareOptionsWrapper {
      get {
        CompareOptionsWrapper(NSString.CompareOptions.diacriticInsensitive)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var forcedOrdering: NSStringWrapper.CompareOptionsWrapper {
      get {
        CompareOptionsWrapper(NSString.CompareOptions.forcedOrdering)
      }
    }

    @objc static public var literal: NSStringWrapper.CompareOptionsWrapper {
      get {
        CompareOptionsWrapper(NSString.CompareOptions.literal)
      }
    }

    @objc static public var numeric: NSStringWrapper.CompareOptionsWrapper {
      get {
        CompareOptionsWrapper(NSString.CompareOptions.numeric)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var regularExpression: NSStringWrapper.CompareOptionsWrapper {
      get {
        CompareOptionsWrapper(NSString.CompareOptions.regularExpression)
      }
    }

    @available(macOS, introduced: 10.5)
    @objc static public var widthInsensitive: NSStringWrapper.CompareOptionsWrapper {
      get {
        CompareOptionsWrapper(NSString.CompareOptions.widthInsensitive)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSString.CompareOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSString.CompareOptions()
    }

  }

  @objc public class EncodingConversionOptionsWrapper: NSObject {
    var wrappedInstance: NSString.EncodingConversionOptions

    @objc static public var allowLossy: NSStringWrapper.EncodingConversionOptionsWrapper {
      get {
        EncodingConversionOptionsWrapper(NSString.EncodingConversionOptions.allowLossy)
      }
    }

    @objc static public var externalRepresentation: NSStringWrapper.EncodingConversionOptionsWrapper {
      get {
        EncodingConversionOptionsWrapper(NSString.EncodingConversionOptions.externalRepresentation)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSString.EncodingConversionOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSString.EncodingConversionOptions()
    }

  }

  @objc public class EnumerationOptionsWrapper: NSObject {
    var wrappedInstance: NSString.EnumerationOptions

    @available(macOS, introduced: 11.0)
    @objc static public var byCaretPositions: NSStringWrapper.EnumerationOptionsWrapper {
      get {
        EnumerationOptionsWrapper(NSString.EnumerationOptions.byCaretPositions)
      }
    }

    @objc static public var byComposedCharacterSequences: NSStringWrapper.EnumerationOptionsWrapper {
      get {
        EnumerationOptionsWrapper(NSString.EnumerationOptions.byComposedCharacterSequences)
      }
    }

    @available(macOS, introduced: 11.0)
    @objc static public var byDeletionClusters: NSStringWrapper.EnumerationOptionsWrapper {
      get {
        EnumerationOptionsWrapper(NSString.EnumerationOptions.byDeletionClusters)
      }
    }

    @objc static public var byLines: NSStringWrapper.EnumerationOptionsWrapper {
      get {
        EnumerationOptionsWrapper(NSString.EnumerationOptions.byLines)
      }
    }

    @objc static public var byParagraphs: NSStringWrapper.EnumerationOptionsWrapper {
      get {
        EnumerationOptionsWrapper(NSString.EnumerationOptions.byParagraphs)
      }
    }

    @objc static public var bySentences: NSStringWrapper.EnumerationOptionsWrapper {
      get {
        EnumerationOptionsWrapper(NSString.EnumerationOptions.bySentences)
      }
    }

    @objc static public var byWords: NSStringWrapper.EnumerationOptionsWrapper {
      get {
        EnumerationOptionsWrapper(NSString.EnumerationOptions.byWords)
      }
    }

    @objc static public var localized: NSStringWrapper.EnumerationOptionsWrapper {
      get {
        EnumerationOptionsWrapper(NSString.EnumerationOptions.localized)
      }
    }

    @objc static public var reverse: NSStringWrapper.EnumerationOptionsWrapper {
      get {
        EnumerationOptionsWrapper(NSString.EnumerationOptions.reverse)
      }
    }

    @objc static public var substringNotRequired: NSStringWrapper.EnumerationOptionsWrapper {
      get {
        EnumerationOptionsWrapper(NSString.EnumerationOptions.substringNotRequired)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSString.EnumerationOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSString.EnumerationOptions()
    }

  }

}

@objc public class ProcessWrapper: NSObject {
  var wrappedInstance: Process

  @objc static public var didTerminateNotification: NSNotificationWrapper.NameWrapper {
    get {
      NameWrapper(Process.didTerminateNotification)
    }
  }

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public var currentDirectoryPath: String {
    get {
      wrappedInstance.currentDirectoryPath
    }
    set {
      wrappedInstance.currentDirectoryPath = newValue
    }
  }

  @available(macOS, introduced: 10.13)
  @objc public var currentDirectoryURL: URLWrapper? {
    get {
      wrappedInstance.currentDirectoryURL == nil ? nil : URLWrapper(wrappedInstance.currentDirectoryURL!)
    }
    set {
      wrappedInstance.currentDirectoryURL = newValue?.wrappedInstance
    }
  }

  @objc public var environment: String {
    get {
      wrappedInstance.environment
    }
    set {
      wrappedInstance.environment = newValue
    }
  }

  @available(macOS, introduced: 10.13)
  @objc public var executableURL: URLWrapper? {
    get {
      wrappedInstance.executableURL == nil ? nil : URLWrapper(wrappedInstance.executableURL!)
    }
    set {
      wrappedInstance.executableURL = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public var launchPath: String? {
    get {
      wrappedInstance.launchPath
    }
    set {
      wrappedInstance.launchPath = newValue
    }
  }

  @available(macOS, introduced: 14.4)
  @objc public var launchRequirementData: DataWrapper? {
    get {
      wrappedInstance.launchRequirementData == nil ? nil : DataWrapper(wrappedInstance.launchRequirementData!)
    }
    set {
      wrappedInstance.launchRequirementData = newValue?.wrappedInstance
    }
  }

  @objc public var isRunning: Bool {
    get {
      wrappedInstance.isRunning
    }
  }

  init(_ wrappedInstance: Process) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = Process()
  }

  @objc public func interrupt() {
    return wrappedInstance.interrupt()
  }

  @available(macOS, introduced: 10.0, deprecated: 100000)
  @objc public func launch() {
    return wrappedInstance.launch()
  }

  @available(macOS, introduced: 10.13)
  @objc public func run() throws {
    return try wrappedInstance.run()
  }

  @objc public func resume() -> Bool {
    return wrappedInstance.resume()
  }

  @objc public func suspend() -> Bool {
    return wrappedInstance.suspend()
  }

  @objc public func terminate() {
    return wrappedInstance.terminate()
  }

  @objc public func waitUntilExit() {
    return wrappedInstance.waitUntilExit()
  }

}

@available(macOS, introduced: 10.6)
@objc public class NSTextCheckingResultWrapper: NSObject {
  var wrappedInstance: NSTextCheckingResult

  @objc public var url: URLWrapper? {
    get {
      wrappedInstance.url == nil ? nil : URLWrapper(wrappedInstance.url!)
    }
  }

  @objc public var addressComponents: String {
    get {
      wrappedInstance.addressComponents
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var components: String {
    get {
      wrappedInstance.components
    }
  }

  @objc public var date: DateWrapper? {
    get {
      wrappedInstance.date == nil ? nil : DateWrapper(wrappedInstance.date!)
    }
  }

  @objc public var duration: TimeInterval {
    get {
      wrappedInstance.duration
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var numberOfRanges: Int {
    get {
      wrappedInstance.numberOfRanges
    }
  }

  @objc public var orthography: NSOrthographyWrapper? {
    get {
      wrappedInstance.orthography == nil ? nil : NSOrthographyWrapper(wrappedInstance.orthography!)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var phoneNumber: String? {
    get {
      wrappedInstance.phoneNumber
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var regularExpression: NSRegularExpressionWrapper? {
    get {
      wrappedInstance.regularExpression == nil ? nil : NSRegularExpressionWrapper(wrappedInstance.regularExpression!)
    }
  }

  @objc public var replacementString: String? {
    get {
      wrappedInstance.replacementString
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var resultType: NSTextCheckingResultWrapper.CheckingTypeWrapper {
    get {
      CheckingTypeWrapper(wrappedInstance.resultType)
    }
  }

  @objc public var timeZone: TimeZoneWrapper? {
    get {
      wrappedInstance.timeZone == nil ? nil : TimeZoneWrapper(wrappedInstance.timeZone!)
    }
  }

  init(_ wrappedInstance: NSTextCheckingResult) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.6)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSTextCheckingResult(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public func adjustingRanges(offset: Int) -> NSTextCheckingResultWrapper {
    let result = wrappedInstance.adjustingRanges(offset: offset)
    return NSTextCheckingResultWrapper(result)
  }

  @objc public class CheckingTypeWrapper: NSObject {
    var wrappedInstance: NSTextCheckingResult.CheckingType

    @objc static public var address: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.address)
      }
    }

    @objc static public var correction: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.correction)
      }
    }

    @objc static public var dash: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.dash)
      }
    }

    @objc static public var date: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.date)
      }
    }

    @objc static public var grammar: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.grammar)
      }
    }

    @objc static public var link: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.link)
      }
    }

    @objc static public var orthography: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.orthography)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var phoneNumber: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.phoneNumber)
      }
    }

    @objc static public var quote: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.quote)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var regularExpression: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.regularExpression)
      }
    }

    @objc static public var replacement: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.replacement)
      }
    }

    @objc static public var spelling: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.spelling)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var transitInformation: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.transitInformation)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var allCustomTypes: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.allCustomTypes)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var allSystemTypes: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.allSystemTypes)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var allTypes: NSTextCheckingResultWrapper.CheckingTypeWrapper {
      get {
        CheckingTypeWrapper(NSTextCheckingResult.CheckingType.allTypes)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSTextCheckingResult.CheckingType) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSTextCheckingResult.CheckingType()
    }

  }

}

@objc public class ThreadWrapper: NSObject {
  var wrappedInstance: Thread

  @objc static public var current: ThreadWrapper {
    get {
      ThreadWrapper(Thread.current)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var isMainThread: Bool {
    get {
      Thread.isMainThread
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var main: ThreadWrapper {
    get {
      ThreadWrapper(Thread.main)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var isCancelled: Bool {
    get {
      wrappedInstance.isCancelled
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var isExecuting: Bool {
    get {
      wrappedInstance.isExecuting
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var isFinished: Bool {
    get {
      wrappedInstance.isFinished
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var isMainThread: Bool {
    get {
      wrappedInstance.isMainThread
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var name: String? {
    get {
      wrappedInstance.name
    }
    set {
      wrappedInstance.name = newValue
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var stackSize: Int {
    get {
      wrappedInstance.stackSize
    }
    set {
      wrappedInstance.stackSize = newValue
    }
  }

  @objc public var threadDictionary: NSMutableDictionaryWrapper {
    get {
      NSMutableDictionaryWrapper(wrappedInstance.threadDictionary)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var threadPriority: Double {
    get {
      wrappedInstance.threadPriority
    }
    set {
      wrappedInstance.threadPriority = newValue
    }
  }

  init(_ wrappedInstance: Thread) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.5)
  @objc override init() {
    wrappedInstance = Thread()
  }

  @objc static public func exit() {
    return Thread.exit()
  }

  @objc static public func isMultiThreaded() -> Bool {
    return Thread.isMultiThreaded()
  }

  @objc static public func setThreadPriority(_ p: Double) -> Bool {
    return Thread.setThreadPriority(p)
  }

  @objc static public func sleep(forTimeInterval ti: TimeInterval) {
    return Thread.sleep(forTimeInterval: ti)
  }

  @objc static public func sleep(until date: DateWrapper) {
    return Thread.sleep(until: date.wrappedInstance)
  }

  @objc static public func threadPriority() -> Double {
    return Thread.threadPriority()
  }

  @available(macOS, introduced: 10.5)
  @objc public func cancel() {
    return wrappedInstance.cancel()
  }

  @available(macOS, introduced: 10.5)
  @objc public func main() {
    return wrappedInstance.main()
  }

  @available(macOS, introduced: 10.5)
  @objc public func start() {
    return wrappedInstance.start()
  }

}

@objc public class NSTimeZoneWrapper: NSObject {
  var wrappedInstance: NSTimeZone

  @available(macOS, introduced: 10.6)
  @objc static public var abbreviationDictionary: String {
    get {
      NSTimeZone.abbreviationDictionary
    }
    set {
      NSTimeZone.abbreviationDictionary = newValue
    }
  }

  @objc static public var `default`: TimeZoneWrapper {
    get {
      TimeZoneWrapper(NSTimeZone.`default`)
    }
    set {
      NSTimeZone.`default` = newValue.wrappedInstance
    }
  }

  @objc static public var local: TimeZoneWrapper {
    get {
      TimeZoneWrapper(NSTimeZone.local)
    }
  }

  @objc static public var system: TimeZoneWrapper {
    get {
      TimeZoneWrapper(NSTimeZone.system)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var timeZoneDataVersion: String {
    get {
      NSTimeZone.timeZoneDataVersion
    }
  }

  @objc public var abbreviation: String? {
    get {
      wrappedInstance.abbreviation
    }
  }

  @objc public var data: DataWrapper {
    get {
      DataWrapper(wrappedInstance.data)
    }
  }

  @objc public var isDaylightSavingTime: Bool {
    get {
      wrappedInstance.isDaylightSavingTime
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var daylightSavingTimeOffset: TimeInterval {
    get {
      wrappedInstance.daylightSavingTimeOffset
    }
  }

  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @objc public var name: String {
    get {
      wrappedInstance.name
    }
  }

  @available(macOS, introduced: 10.5)
  @objc public var nextDaylightSavingTimeTransition: DateWrapper? {
    get {
      wrappedInstance.nextDaylightSavingTimeTransition == nil ? nil : DateWrapper(wrappedInstance.nextDaylightSavingTimeTransition!)
    }
  }

  @objc public var secondsFromGMT: Int {
    get {
      wrappedInstance.secondsFromGMT
    }
  }

  init(_ wrappedInstance: NSTimeZone) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(name tzName: String) {
    if let instance = NSTimeZone(name: tzName) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init?(name tzName: String, data aData: DataWrapper?) {
    if let instance = NSTimeZone(name: tzName, data: aData?.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSTimeZone(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc static public func resetSystemTimeZone() {
    return NSTimeZone.resetSystemTimeZone()
  }

  @objc public func abbreviation(for aDate: DateWrapper) -> String? {
    return wrappedInstance.abbreviation(for: aDate.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc public func daylightSavingTimeOffset(for aDate: DateWrapper) -> TimeInterval {
    return wrappedInstance.daylightSavingTimeOffset(for: aDate.wrappedInstance)
  }

  @objc public func isDaylightSavingTime(for aDate: DateWrapper) -> Bool {
    return wrappedInstance.isDaylightSavingTime(for: aDate.wrappedInstance)
  }

  @objc public func isEqual(to aTimeZone: TimeZoneWrapper) -> Bool {
    return wrappedInstance.isEqual(to: aTimeZone.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc public func nextDaylightSavingTimeTransition(after aDate: DateWrapper) -> DateWrapper? {
    let result = wrappedInstance.nextDaylightSavingTimeTransition(after: aDate.wrappedInstance)
    return result == nil ? nil : DateWrapper(result!)
  }

  @objc public func secondsFromGMT(for aDate: DateWrapper) -> Int {
    return wrappedInstance.secondsFromGMT(for: aDate.wrappedInstance)
  }

}

@objc public class TimerWrapper: NSObject {
  var wrappedInstance: Timer

  @objc public var fireDate: DateWrapper {
    get {
      DateWrapper(wrappedInstance.fireDate)
    }
    set {
      wrappedInstance.fireDate = newValue.wrappedInstance
    }
  }

  @objc public var timeInterval: TimeInterval {
    get {
      wrappedInstance.timeInterval
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var tolerance: TimeInterval {
    get {
      wrappedInstance.tolerance
    }
    set {
      wrappedInstance.tolerance = newValue
    }
  }

  @objc public var isValid: Bool {
    get {
      wrappedInstance.isValid
    }
  }

  init(_ wrappedInstance: Timer) {
    self.wrappedInstance = wrappedInstance
  }

  @objc public func fire() {
    return wrappedInstance.fire()
  }

  @objc public func invalidate() {
    return wrappedInstance.invalidate()
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public class TimerPublisherWrapper: NSObject {
    var wrappedInstance: Timer.TimerPublisher

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public var mode: RunLoopWrapper.ModeWrapper {
      get {
        ModeWrapper(wrappedInstance.mode)
      }
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public var options: RunLoopWrapper.SchedulerOptionsWrapper? {
      get {
        wrappedInstance.options == nil ? nil : SchedulerOptionsWrapper(wrappedInstance.options!)
      }
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public var runLoop: RunLoopWrapper {
      get {
        RunLoopWrapper(wrappedInstance.runLoop)
      }
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public var interval: TimeInterval {
      get {
        wrappedInstance.interval
      }
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public var tolerance: TimeInterval? {
      get {
        wrappedInstance.tolerance
      }
    }

    init(_ wrappedInstance: Timer.TimerPublisher) {
      self.wrappedInstance = wrappedInstance
    }

  }

}

@objc public class NSURLWrapper: NSObject {
  var wrappedInstance: NSURL

  @available(macOS, introduced: 10.6)
  @objc public var deletingLastPathComponent: URLWrapper? {
    get {
      wrappedInstance.deletingLastPathComponent == nil ? nil : URLWrapper(wrappedInstance.deletingLastPathComponent!)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var deletingPathExtension: URLWrapper? {
    get {
      wrappedInstance.deletingPathExtension == nil ? nil : URLWrapper(wrappedInstance.deletingPathExtension!)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var resolvingSymlinksInPath: URLWrapper? {
    get {
      wrappedInstance.resolvingSymlinksInPath == nil ? nil : URLWrapper(wrappedInstance.resolvingSymlinksInPath!)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var standardizingPath: URLWrapper? {
    get {
      wrappedInstance.standardizingPath == nil ? nil : URLWrapper(wrappedInstance.standardizingPath!)
    }
  }

  @objc public var absoluteString: String? {
    get {
      wrappedInstance.absoluteString
    }
  }

  @objc public var absoluteURL: URLWrapper? {
    get {
      wrappedInstance.absoluteURL == nil ? nil : URLWrapper(wrappedInstance.absoluteURL!)
    }
  }

  @objc public var baseURL: URLWrapper? {
    get {
      wrappedInstance.baseURL == nil ? nil : URLWrapper(wrappedInstance.baseURL!)
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var dataRepresentation: DataWrapper {
    get {
      DataWrapper(wrappedInstance.dataRepresentation)
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var filePathURL: URLWrapper? {
    get {
      wrappedInstance.filePathURL == nil ? nil : URLWrapper(wrappedInstance.filePathURL!)
    }
  }

  @objc public var isFileURL: Bool {
    get {
      wrappedInstance.isFileURL
    }
  }

  @objc public var fragment: String? {
    get {
      wrappedInstance.fragment
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var hasDirectoryPath: Bool {
    get {
      wrappedInstance.hasDirectoryPath
    }
  }

  @objc public var host: String? {
    get {
      wrappedInstance.host
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var lastPathComponent: String? {
    get {
      wrappedInstance.lastPathComponent
    }
  }

  @available(macOS, introduced: 10.2, deprecated: 10.15)
  @objc public var parameterString: String? {
    get {
      wrappedInstance.parameterString
    }
  }

  @objc public var password: String? {
    get {
      wrappedInstance.password
    }
  }

  @objc public var path: String? {
    get {
      wrappedInstance.path
    }
  }

  @available(macOS, introduced: 10.6)
  @objc public var pathExtension: String? {
    get {
      wrappedInstance.pathExtension
    }
  }

  @objc public var port: NSNumberWrapper? {
    get {
      wrappedInstance.port == nil ? nil : NSNumberWrapper(wrappedInstance.port!)
    }
  }

  @objc public var query: String? {
    get {
      wrappedInstance.query
    }
  }

  @objc public var relativePath: String? {
    get {
      wrappedInstance.relativePath
    }
  }

  @objc public var relativeString: String {
    get {
      wrappedInstance.relativeString
    }
  }

  @objc public var resourceSpecifier: String? {
    get {
      wrappedInstance.resourceSpecifier
    }
  }

  @objc public var scheme: String? {
    get {
      wrappedInstance.scheme
    }
  }

  @objc public var standardized: URLWrapper? {
    get {
      wrappedInstance.standardized == nil ? nil : URLWrapper(wrappedInstance.standardized!)
    }
  }

  @objc public var user: String? {
    get {
      wrappedInstance.user
    }
  }

  init(_ wrappedInstance: NSURL) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.11)
  @objc init(absoluteURLWithDataRepresentation data: DataWrapper, relativeTo baseURL: URLWrapper?) {
    wrappedInstance = NSURL(absoluteURLWithDataRepresentation: data.wrappedInstance, relativeTo: baseURL?.wrappedInstance)
  }

  @objc init(fileURLWithPath path: String) {
    wrappedInstance = NSURL(fileURLWithPath: path)
  }

  @available(macOS, introduced: 10.5)
  @objc init(fileURLWithPath path: String, isDirectory isDir: Bool) {
    wrappedInstance = NSURL(fileURLWithPath: path, isDirectory: isDir)
  }

  @available(macOS, introduced: 10.11)
  @objc init(fileURLWithPath path: String, isDirectory isDir: Bool, relativeTo baseURL: URLWrapper?) {
    wrappedInstance = NSURL(fileURLWithPath: path, isDirectory: isDir, relativeTo: baseURL?.wrappedInstance)
  }

  @available(macOS, introduced: 10.11)
  @objc init(fileURLWithPath path: String, relativeTo baseURL: URLWrapper?) {
    wrappedInstance = NSURL(fileURLWithPath: path, relativeTo: baseURL?.wrappedInstance)
  }

  @available(macOS, introduced: 10.11)
  @objc init(dataRepresentation data: DataWrapper, relativeTo baseURL: URLWrapper?) {
    wrappedInstance = NSURL(dataRepresentation: data.wrappedInstance, relativeTo: baseURL?.wrappedInstance)
  }

  @objc init?(string URLString: String, relativeTo baseURL: URLWrapper?) {
    if let instance = NSURL(string: URLString, relativeTo: baseURL?.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSURL(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public func absoluteURL(withDataRepresentation data: DataWrapper, relativeTo baseURL: URLWrapper?) -> URLWrapper {
    let result = NSURL.absoluteURL(withDataRepresentation: data.wrappedInstance, relativeTo: baseURL?.wrappedInstance)
    return URLWrapper(result)
  }

  @available(macOS, introduced: 10.6)
  @objc static public func bookmarkData(withContentsOf bookmarkFileURL: URLWrapper) throws -> DataWrapper {
    let result = try NSURL.bookmarkData(withContentsOf: bookmarkFileURL.wrappedInstance)
    return DataWrapper(result)
  }

  @objc static public func fileURL(withPath path: String) -> URLWrapper {
    let result = NSURL.fileURL(withPath: path)
    return URLWrapper(result)
  }

  @available(macOS, introduced: 10.5)
  @objc static public func fileURL(withPath path: String, isDirectory isDir: Bool) -> URLWrapper {
    let result = NSURL.fileURL(withPath: path, isDirectory: isDir)
    return URLWrapper(result)
  }

  @available(macOS, introduced: 10.11)
  @objc static public func fileURL(withPath path: String, isDirectory isDir: Bool, relativeTo baseURL: URLWrapper?) -> URLWrapper {
    let result = NSURL.fileURL(withPath: path, isDirectory: isDir, relativeTo: baseURL?.wrappedInstance)
    return URLWrapper(result)
  }

  @available(macOS, introduced: 10.11)
  @objc static public func fileURL(withPath path: String, relativeTo baseURL: URLWrapper?) -> URLWrapper {
    let result = NSURL.fileURL(withPath: path, relativeTo: baseURL?.wrappedInstance)
    return URLWrapper(result)
  }

  @available(macOS, introduced: 10.6)
  @objc static public func writeBookmarkData(_ bookmarkData: DataWrapper, to bookmarkFileURL: URLWrapper, options: NSURL.BookmarkFileCreationOptions) throws {
    return try NSURL.writeBookmarkData(bookmarkData.wrappedInstance, to: bookmarkFileURL.wrappedInstance, options: options)
  }

  @available(macOS, introduced: 10.6)
  @objc public func appendingPathComponent(_ pathComponent: String) -> URLWrapper? {
    let result = wrappedInstance.appendingPathComponent(pathComponent)
    return result == nil ? nil : URLWrapper(result!)
  }

  @available(macOS, introduced: 10.7)
  @objc public func appendingPathComponent(_ pathComponent: String, isDirectory: Bool) -> URLWrapper? {
    let result = wrappedInstance.appendingPathComponent(pathComponent, isDirectory: isDirectory)
    return result == nil ? nil : URLWrapper(result!)
  }

  @available(macOS, introduced: 10.6)
  @objc public func appendingPathExtension(_ pathExtension: String) -> URLWrapper? {
    let result = wrappedInstance.appendingPathExtension(pathExtension)
    return result == nil ? nil : URLWrapper(result!)
  }

  @available(macOS, introduced: 10.6)
  @objc public func fileReferenceURL() -> URLWrapper? {
    let result = wrappedInstance.fileReferenceURL()
    return result == nil ? nil : URLWrapper(result!)
  }

  @available(macOS, introduced: 10.6)
  @objc public func isFileReferenceURL() -> Bool {
    return wrappedInstance.isFileReferenceURL()
  }

  @available(macOS, introduced: 10.9)
  @objc public func removeAllCachedResourceValues() {
    return wrappedInstance.removeAllCachedResourceValues()
  }

  @available(macOS, introduced: 10.9)
  @objc public func removeCachedResourceValue(forKey key: URLResourceKeyWrapper) {
    return wrappedInstance.removeCachedResourceValue(forKey: key.wrappedInstance)
  }

  @available(macOS, introduced: 10.7)
  @objc public func startAccessingSecurityScopedResource() -> Bool {
    return wrappedInstance.startAccessingSecurityScopedResource()
  }

  @available(macOS, introduced: 10.7)
  @objc public func stopAccessingSecurityScopedResource() {
    return wrappedInstance.stopAccessingSecurityScopedResource()
  }

  @available(macOS, introduced: 10.6)
  @objc public class BookmarkCreationOptionsWrapper: NSObject {
    var wrappedInstance: NSURL.BookmarkCreationOptions

    @available(macOS, introduced: 10.6)
    @objc static public var minimalBookmark: NSURLWrapper.BookmarkCreationOptionsWrapper {
      get {
        BookmarkCreationOptionsWrapper(NSURL.BookmarkCreationOptions.minimalBookmark)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var securityScopeAllowOnlyReadAccess: NSURLWrapper.BookmarkCreationOptionsWrapper {
      get {
        BookmarkCreationOptionsWrapper(NSURL.BookmarkCreationOptions.securityScopeAllowOnlyReadAccess)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var suitableForBookmarkFile: NSURLWrapper.BookmarkCreationOptionsWrapper {
      get {
        BookmarkCreationOptionsWrapper(NSURL.BookmarkCreationOptions.suitableForBookmarkFile)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var withSecurityScope: NSURLWrapper.BookmarkCreationOptionsWrapper {
      get {
        BookmarkCreationOptionsWrapper(NSURL.BookmarkCreationOptions.withSecurityScope)
      }
    }

    @available(macOS, introduced: 10.7)
    @objc static public var withoutImplicitSecurityScope: NSURLWrapper.BookmarkCreationOptionsWrapper {
      get {
        BookmarkCreationOptionsWrapper(NSURL.BookmarkCreationOptions.withoutImplicitSecurityScope)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSURL.BookmarkCreationOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSURL.BookmarkCreationOptions()
    }

  }

  @available(macOS, introduced: 10.6)
  @objc public class BookmarkResolutionOptionsWrapper: NSObject {
    var wrappedInstance: NSURL.BookmarkResolutionOptions

    @available(macOS, introduced: 10.7)
    @objc static public var withSecurityScope: NSURLWrapper.BookmarkResolutionOptionsWrapper {
      get {
        BookmarkResolutionOptionsWrapper(NSURL.BookmarkResolutionOptions.withSecurityScope)
      }
    }

    @available(macOS, introduced: 11.2)
    @objc static public var withoutImplicitStartAccessing: NSURLWrapper.BookmarkResolutionOptionsWrapper {
      get {
        BookmarkResolutionOptionsWrapper(NSURL.BookmarkResolutionOptions.withoutImplicitStartAccessing)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var withoutMounting: NSURLWrapper.BookmarkResolutionOptionsWrapper {
      get {
        BookmarkResolutionOptionsWrapper(NSURL.BookmarkResolutionOptions.withoutMounting)
      }
    }

    @available(macOS, introduced: 10.6)
    @objc static public var withoutUI: NSURLWrapper.BookmarkResolutionOptionsWrapper {
      get {
        BookmarkResolutionOptionsWrapper(NSURL.BookmarkResolutionOptions.withoutUI)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSURL.BookmarkResolutionOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSURL.BookmarkResolutionOptions()
    }

  }

}

@available(macOS, introduced: 10.2)
@objc public class URLAuthenticationChallengeWrapper: NSObject {
  var wrappedInstance: URLAuthenticationChallenge

  @available(macOS, introduced: 10.2)
  @objc public var failureResponse: URLResponseWrapper? {
    get {
      wrappedInstance.failureResponse == nil ? nil : URLResponseWrapper(wrappedInstance.failureResponse!)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var previousFailureCount: Int {
    get {
      wrappedInstance.previousFailureCount
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var proposedCredential: URLCredentialWrapper? {
    get {
      wrappedInstance.proposedCredential == nil ? nil : URLCredentialWrapper(wrappedInstance.proposedCredential!)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var protectionSpace: URLProtectionSpaceWrapper {
    get {
      URLProtectionSpaceWrapper(wrappedInstance.protectionSpace)
    }
  }

  init(_ wrappedInstance: URLAuthenticationChallenge) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.2)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = URLAuthenticationChallenge(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.2)
@objc public class URLCacheWrapper: NSObject {
  var wrappedInstance: URLCache

  @available(macOS, introduced: 10.2)
  @objc static public var shared: URLCacheWrapper {
    get {
      URLCacheWrapper(URLCache.shared)
    }
    set {
      URLCache.shared = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var currentDiskUsage: Int {
    get {
      wrappedInstance.currentDiskUsage
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var currentMemoryUsage: Int {
    get {
      wrappedInstance.currentMemoryUsage
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var diskCapacity: Int {
    get {
      wrappedInstance.diskCapacity
    }
    set {
      wrappedInstance.diskCapacity = newValue
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var memoryCapacity: Int {
    get {
      wrappedInstance.memoryCapacity
    }
    set {
      wrappedInstance.memoryCapacity = newValue
    }
  }

  init(_ wrappedInstance: URLCache) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.2, deprecated: 100000)
  @objc init(memoryCapacity: Int, diskCapacity: Int, diskPath path: String?) {
    wrappedInstance = URLCache(memoryCapacity: memoryCapacity, diskCapacity: diskCapacity, diskPath: path)
  }

  @available(macOS, introduced: 10.2)
  @objc public func cachedResponse(for request: URLRequestWrapper) -> CachedURLResponseWrapper? {
    let result = wrappedInstance.cachedResponse(for: request.wrappedInstance)
    return result == nil ? nil : CachedURLResponseWrapper(result!)
  }

  @available(macOS, introduced: 10.2)
  @objc public func removeAllCachedResponses() {
    return wrappedInstance.removeAllCachedResponses()
  }

  @available(macOS, introduced: 10.2)
  @objc public func removeCachedResponse(for request: URLRequestWrapper) {
    return wrappedInstance.removeCachedResponse(for: request.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @objc public func removeCachedResponses(since date: DateWrapper) {
    return wrappedInstance.removeCachedResponses(since: date.wrappedInstance)
  }

  @available(macOS, introduced: 10.2)
  @objc public func storeCachedResponse(_ cachedResponse: CachedURLResponseWrapper, for request: URLRequestWrapper) {
    return wrappedInstance.storeCachedResponse(cachedResponse.wrappedInstance, for: request.wrappedInstance)
  }

}

@available(macOS, introduced: 10.9)
@objc public class NSURLComponentsWrapper: NSObject {
  var wrappedInstance: NSURLComponents

  @available(macOS, introduced: 10.9)
  @objc public var url: URLWrapper? {
    get {
      wrappedInstance.url == nil ? nil : URLWrapper(wrappedInstance.url!)
    }
  }

  @available(macOS, introduced: 13.0)
  @objc public var encodedHost: String? {
    get {
      wrappedInstance.encodedHost
    }
    set {
      wrappedInstance.encodedHost = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var fragment: String? {
    get {
      wrappedInstance.fragment
    }
    set {
      wrappedInstance.fragment = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var host: String? {
    get {
      wrappedInstance.host
    }
    set {
      wrappedInstance.host = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var password: String? {
    get {
      wrappedInstance.password
    }
    set {
      wrappedInstance.password = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var path: String? {
    get {
      wrappedInstance.path
    }
    set {
      wrappedInstance.path = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var percentEncodedFragment: String? {
    get {
      wrappedInstance.percentEncodedFragment
    }
    set {
      wrappedInstance.percentEncodedFragment = newValue
    }
  }

  @available(macOS, introduced: 10.9, deprecated: 100000)
  @objc public var percentEncodedHost: String? {
    get {
      wrappedInstance.percentEncodedHost
    }
    set {
      wrappedInstance.percentEncodedHost = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var percentEncodedPassword: String? {
    get {
      wrappedInstance.percentEncodedPassword
    }
    set {
      wrappedInstance.percentEncodedPassword = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var percentEncodedPath: String? {
    get {
      wrappedInstance.percentEncodedPath
    }
    set {
      wrappedInstance.percentEncodedPath = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var percentEncodedQuery: String? {
    get {
      wrappedInstance.percentEncodedQuery
    }
    set {
      wrappedInstance.percentEncodedQuery = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var percentEncodedUser: String? {
    get {
      wrappedInstance.percentEncodedUser
    }
    set {
      wrappedInstance.percentEncodedUser = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var port: NSNumberWrapper? {
    get {
      wrappedInstance.port == nil ? nil : NSNumberWrapper(wrappedInstance.port!)
    }
    set {
      wrappedInstance.port = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var query: String? {
    get {
      wrappedInstance.query
    }
    set {
      wrappedInstance.query = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var scheme: String? {
    get {
      wrappedInstance.scheme
    }
    set {
      wrappedInstance.scheme = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var string: String? {
    get {
      wrappedInstance.string
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var user: String? {
    get {
      wrappedInstance.user
    }
    set {
      wrappedInstance.user = newValue
    }
  }

  init(_ wrappedInstance: NSURLComponents) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.9)
  @objc override init() {
    wrappedInstance = NSURLComponents()
  }

  @available(macOS, introduced: 10.9)
  @objc init?(string URLString: String) {
    if let instance = NSURLComponents(string: URLString) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 14.0)
  @objc init?(string URLString: String, encodingInvalidCharacters: Bool) {
    if let instance = NSURLComponents(string: URLString, encodingInvalidCharacters: encodingInvalidCharacters) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.9)
  @objc init?(url: URLWrapper, resolvingAgainstBaseURL resolve: Bool) {
    if let instance = NSURLComponents(url: url.wrappedInstance, resolvingAgainstBaseURL: resolve) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public func url(relativeTo baseURL: URLWrapper?) -> URLWrapper? {
    let result = wrappedInstance.url(relativeTo: baseURL?.wrappedInstance)
    return result == nil ? nil : URLWrapper(result!)
  }

}

@available(macOS, introduced: 10.2)
@objc public class NSURLConnectionWrapper: NSObject {
  var wrappedInstance: NSURLConnection

  @available(macOS, introduced: 10.8)
  @objc public var currentRequest: URLRequestWrapper {
    get {
      URLRequestWrapper(wrappedInstance.currentRequest)
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var originalRequest: URLRequestWrapper {
    get {
      URLRequestWrapper(wrappedInstance.originalRequest)
    }
  }

  init(_ wrappedInstance: NSURLConnection) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.2)
  @objc static public func canHandle(_ request: URLRequestWrapper) -> Bool {
    return NSURLConnection.canHandle(request.wrappedInstance)
  }

  @available(macOS, introduced: 10.2)
  @objc public func cancel() {
    return wrappedInstance.cancel()
  }

  @available(macOS, introduced: 10.5)
  @objc public func schedule(in aRunLoop: RunLoopWrapper, forMode mode: RunLoopWrapper.ModeWrapper) {
    return wrappedInstance.schedule(in: aRunLoop.wrappedInstance, forMode: mode.wrappedInstance)
  }

  @available(macOS, introduced: 10.7)
  @objc public func setDelegateQueue(_ queue: OperationQueueWrapper?) {
    return wrappedInstance.setDelegateQueue(queue?.wrappedInstance)
  }

  @available(macOS, introduced: 10.5)
  @objc public func start() {
    return wrappedInstance.start()
  }

  @available(macOS, introduced: 10.5)
  @objc public func unschedule(from aRunLoop: RunLoopWrapper, forMode mode: RunLoopWrapper.ModeWrapper) {
    return wrappedInstance.unschedule(from: aRunLoop.wrappedInstance, forMode: mode.wrappedInstance)
  }

}

@available(macOS, introduced: 10.2)
@objc public class URLCredentialWrapper: NSObject {
  var wrappedInstance: URLCredential

  @objc public var hasPassword: Bool {
    get {
      wrappedInstance.hasPassword
    }
  }

  @objc public var password: String? {
    get {
      wrappedInstance.password
    }
  }

  @objc public var user: String? {
    get {
      wrappedInstance.user
    }
  }

  init(_ wrappedInstance: URLCredential) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.2)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = URLCredential(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.2)
@objc public class URLCredentialStorageWrapper: NSObject {
  var wrappedInstance: URLCredentialStorage

  @available(macOS, introduced: 10.2)
  @objc static public var shared: URLCredentialStorageWrapper {
    get {
      URLCredentialStorageWrapper(URLCredentialStorage.shared)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var allCredentials: URLCredentialWrapper {
    get {
      URLCredentialWrapper(wrappedInstance.allCredentials)
    }
  }

  init(_ wrappedInstance: URLCredentialStorage) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.2)
  @objc public func defaultCredential(for space: URLProtectionSpaceWrapper) -> URLCredentialWrapper? {
    let result = wrappedInstance.defaultCredential(for: space.wrappedInstance)
    return result == nil ? nil : URLCredentialWrapper(result!)
  }

  @available(macOS, introduced: 10.10)
  @objc public func defaultCredential(for space: URLProtectionSpaceWrapper, task: URLSessionTaskWrapper) async -> URLCredentialWrapper? {
    let result = await wrappedInstance.defaultCredential(for: space.wrappedInstance, task: task.wrappedInstance)
    return result == nil ? nil : URLCredentialWrapper(result!)
  }

  @available(macOS, introduced: 10.2)
  @objc public func remove(_ credential: URLCredentialWrapper, for space: URLProtectionSpaceWrapper) {
    return wrappedInstance.remove(credential.wrappedInstance, for: space.wrappedInstance)
  }

  @available(macOS, introduced: 10.2)
  @objc public func set(_ credential: URLCredentialWrapper, for space: URLProtectionSpaceWrapper) {
    return wrappedInstance.set(credential.wrappedInstance, for: space.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @objc public func set(_ credential: URLCredentialWrapper, for protectionSpace: URLProtectionSpaceWrapper, task: URLSessionTaskWrapper) {
    return wrappedInstance.set(credential.wrappedInstance, for: protectionSpace.wrappedInstance, task: task.wrappedInstance)
  }

  @available(macOS, introduced: 10.2)
  @objc public func setDefaultCredential(_ credential: URLCredentialWrapper, for space: URLProtectionSpaceWrapper) {
    return wrappedInstance.setDefaultCredential(credential.wrappedInstance, for: space.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @objc public func setDefaultCredential(_ credential: URLCredentialWrapper, for protectionSpace: URLProtectionSpaceWrapper, task: URLSessionTaskWrapper) {
    return wrappedInstance.setDefaultCredential(credential.wrappedInstance, for: protectionSpace.wrappedInstance, task: task.wrappedInstance)
  }

}

@available(macOS, introduced: 10.2)
@objc public class NSURLDownloadWrapper: NSObject {
  var wrappedInstance: NSURLDownload

  @available(macOS, introduced: 10.2)
  @objc public var deletesFileUponFailure: Bool {
    get {
      wrappedInstance.deletesFileUponFailure
    }
    set {
      wrappedInstance.deletesFileUponFailure = newValue
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var request: URLRequestWrapper {
    get {
      URLRequestWrapper(wrappedInstance.request)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var resumeData: DataWrapper? {
    get {
      wrappedInstance.resumeData == nil ? nil : DataWrapper(wrappedInstance.resumeData!)
    }
  }

  init(_ wrappedInstance: NSURLDownload) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.2)
  @objc static public func canResumeDownloadDecoded(withEncodingMIMEType MIMEType: String) -> Bool {
    return NSURLDownload.canResumeDownloadDecoded(withEncodingMIMEType: MIMEType)
  }

  @available(macOS, introduced: 10.2)
  @objc public func cancel() {
    return wrappedInstance.cancel()
  }

  @available(macOS, introduced: 10.2)
  @objc public func setDestination(_ path: String, allowOverwrite: Bool) {
    return wrappedInstance.setDestination(path, allowOverwrite: allowOverwrite)
  }

}

@objc public class NSURLHandleWrapper: NSObject {
  var wrappedInstance: NSURLHandle

  init(_ wrappedInstance: NSURLHandle) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.2)
@objc public class URLProtectionSpaceWrapper: NSObject {
  var wrappedInstance: URLProtectionSpace

  @available(macOS, introduced: 10.2)
  @objc public var authenticationMethod: String {
    get {
      wrappedInstance.authenticationMethod
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var host: String {
    get {
      wrappedInstance.host
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var port: Int {
    get {
      wrappedInstance.port
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var `protocol`: String? {
    get {
      wrappedInstance.`protocol`
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var proxyType: String? {
    get {
      wrappedInstance.proxyType
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var realm: String? {
    get {
      wrappedInstance.realm
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var receivesCredentialSecurely: Bool {
    get {
      wrappedInstance.receivesCredentialSecurely
    }
  }

  init(_ wrappedInstance: URLProtectionSpace) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.2)
  @objc init(host: String, port: Int, protocol: String?, realm: String?, authenticationMethod: String?) {
    wrappedInstance = URLProtectionSpace(host: host, port: port, protocol: protocol, realm: realm, authenticationMethod: authenticationMethod)
  }

  @available(macOS, introduced: 10.2)
  @objc init(proxyHost host: String, port: Int, type: String?, realm: String?, authenticationMethod: String?) {
    wrappedInstance = URLProtectionSpace(proxyHost: host, port: port, type: type, realm: realm, authenticationMethod: authenticationMethod)
  }

  @available(macOS, introduced: 10.2)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = URLProtectionSpace(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public func isProxy() -> Bool {
    return wrappedInstance.isProxy()
  }

}

@available(macOS, introduced: 10.2)
@objc public class URLProtocolWrapper: NSObject {
  var wrappedInstance: URLProtocol

  @available(macOS, introduced: 10.2)
  @objc public var cachedResponse: CachedURLResponseWrapper? {
    get {
      wrappedInstance.cachedResponse == nil ? nil : CachedURLResponseWrapper(wrappedInstance.cachedResponse!)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var request: URLRequestWrapper {
    get {
      URLRequestWrapper(wrappedInstance.request)
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var task: URLSessionTaskWrapper? {
    get {
      wrappedInstance.task == nil ? nil : URLSessionTaskWrapper(wrappedInstance.task!)
    }
  }

  init(_ wrappedInstance: URLProtocol) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @objc static public func canInit(with task: URLSessionTaskWrapper) -> Bool {
    return URLProtocol.canInit(with: task.wrappedInstance)
  }

  @available(macOS, introduced: 10.2)
  @objc static public func canonicalRequest(for request: URLRequestWrapper) -> URLRequestWrapper {
    let result = URLProtocol.canonicalRequest(for: request.wrappedInstance)
    return URLRequestWrapper(result)
  }

  @available(macOS, introduced: 10.2)
  @objc static public func removeProperty(forKey key: String, in request: NSMutableURLRequestWrapper) {
    return URLProtocol.removeProperty(forKey: key, in: request.wrappedInstance)
  }

  @available(macOS, introduced: 10.2)
  @objc static public func requestIsCacheEquivalent(_ a: URLRequestWrapper, to b: URLRequestWrapper) -> Bool {
    return URLProtocol.requestIsCacheEquivalent(a.wrappedInstance, to: b.wrappedInstance)
  }

  @available(macOS, introduced: 10.2)
  @objc public func startLoading() {
    return wrappedInstance.startLoading()
  }

  @available(macOS, introduced: 10.2)
  @objc public func stopLoading() {
    return wrappedInstance.stopLoading()
  }

}

@available(macOS, introduced: 10.10)
@objc public class NSURLQueryItemWrapper: NSObject {
  var wrappedInstance: NSURLQueryItem

  @available(macOS, introduced: 10.10)
  @objc public var name: String {
    get {
      wrappedInstance.name
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var value: String? {
    get {
      wrappedInstance.value
    }
  }

  init(_ wrappedInstance: NSURLQueryItem) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @objc init(name: String, value: String?) {
    wrappedInstance = NSURLQueryItem(name: name, value: value)
  }

  @available(macOS, introduced: 10.10)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSURLQueryItem(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.2)
@objc public class NSURLRequestWrapper: NSObject {
  var wrappedInstance: NSURLRequest

  @available(macOS, introduced: 10.2)
  @objc static public var supportsSecureCoding: Bool {
    get {
      NSURLRequest.supportsSecureCoding
    }
  }

  @objc public var httpBody: DataWrapper? {
    get {
      wrappedInstance.httpBody == nil ? nil : DataWrapper(wrappedInstance.httpBody!)
    }
  }

  @objc public var httpBodyStream: InputStreamWrapper? {
    get {
      wrappedInstance.httpBodyStream == nil ? nil : InputStreamWrapper(wrappedInstance.httpBodyStream!)
    }
  }

  @objc public var httpMethod: String? {
    get {
      wrappedInstance.httpMethod
    }
  }

  @objc public var httpShouldHandleCookies: Bool {
    get {
      wrappedInstance.httpShouldHandleCookies
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var httpShouldUsePipelining: Bool {
    get {
      wrappedInstance.httpShouldUsePipelining
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var url: URLWrapper? {
    get {
      wrappedInstance.url == nil ? nil : URLWrapper(wrappedInstance.url!)
    }
  }

  @objc public var allHTTPHeaderFields: String {
    get {
      wrappedInstance.allHTTPHeaderFields
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var allowsCellularAccess: Bool {
    get {
      wrappedInstance.allowsCellularAccess
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var allowsConstrainedNetworkAccess: Bool {
    get {
      wrappedInstance.allowsConstrainedNetworkAccess
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var allowsExpensiveNetworkAccess: Bool {
    get {
      wrappedInstance.allowsExpensiveNetworkAccess
    }
  }

  @available(macOS, introduced: 15.0)
  @objc public var allowsPersistentDNS: Bool {
    get {
      wrappedInstance.allowsPersistentDNS
    }
  }

  @available(macOS, introduced: 11.3)
  @objc public var assumesHTTP3Capable: Bool {
    get {
      wrappedInstance.assumesHTTP3Capable
    }
  }

  @available(macOS, introduced: 15.2)
  @objc public var cookiePartitionIdentifier: String? {
    get {
      wrappedInstance.cookiePartitionIdentifier
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var mainDocumentURL: URLWrapper? {
    get {
      wrappedInstance.mainDocumentURL == nil ? nil : URLWrapper(wrappedInstance.mainDocumentURL!)
    }
  }

  @available(macOS, introduced: 13.0)
  @objc public var requiresDNSSECValidation: Bool {
    get {
      wrappedInstance.requiresDNSSECValidation
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var timeoutInterval: TimeInterval {
    get {
      wrappedInstance.timeoutInterval
    }
  }

  init(_ wrappedInstance: NSURLRequest) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.2)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSURLRequest(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func value(forHTTPHeaderField field: String) -> String? {
    return wrappedInstance.value(forHTTPHeaderField: field)
  }

}

@available(macOS, introduced: 10.2)
@objc public class URLResponseWrapper: NSObject {
  var wrappedInstance: URLResponse

  @available(macOS, introduced: 10.2)
  @objc public var mimeType: String? {
    get {
      wrappedInstance.mimeType
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var url: URLWrapper? {
    get {
      wrappedInstance.url == nil ? nil : URLWrapper(wrappedInstance.url!)
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var suggestedFilename: String? {
    get {
      wrappedInstance.suggestedFilename
    }
  }

  @available(macOS, introduced: 10.2)
  @objc public var textEncodingName: String? {
    get {
      wrappedInstance.textEncodingName
    }
  }

  init(_ wrappedInstance: URLResponse) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.2)
  @objc init(url URL: URLWrapper, mimeType MIMEType: String?, expectedContentLength length: Int, textEncodingName name: String?) {
    wrappedInstance = URLResponse(url: URL.wrappedInstance, mimeType: MIMEType, expectedContentLength: length, textEncodingName: name)
  }

  @available(macOS, introduced: 10.2)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = URLResponse(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.9)
@objc public class URLSessionWrapper: NSObject {
  var wrappedInstance: URLSession

  @available(macOS, introduced: 10.9)
  @objc static public var shared: URLSessionWrapper {
    get {
      URLSessionWrapper(URLSession.shared)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var configuration: URLSessionConfigurationWrapper {
    get {
      URLSessionConfigurationWrapper(wrappedInstance.configuration)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var delegateQueue: OperationQueueWrapper {
    get {
      OperationQueueWrapper(wrappedInstance.delegateQueue)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var sessionDescription: String? {
    get {
      wrappedInstance.sessionDescription
    }
    set {
      wrappedInstance.sessionDescription = newValue
    }
  }

  init(_ wrappedInstance: URLSession) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.9)
  @objc init(configuration: URLSessionConfigurationWrapper) {
    wrappedInstance = URLSession(configuration: configuration.wrappedInstance)
  }

  @available(macOS, introduced: 10.9, deprecated: 10.15)
  @objc override init() {
    wrappedInstance = URLSession()
  }

  @available(macOS, introduced: 10.9)
  @objc public func dataTask(with request: URLRequestWrapper) -> URLSessionDataTaskWrapper {
    let result = wrappedInstance.dataTask(with: request.wrappedInstance)
    return URLSessionDataTaskWrapper(result)
  }

  @available(macOS, introduced: 10.9)
  @objc public func downloadTask(with request: URLRequestWrapper) -> URLSessionDownloadTaskWrapper {
    let result = wrappedInstance.downloadTask(with: request.wrappedInstance)
    return URLSessionDownloadTaskWrapper(result)
  }

  @available(macOS, introduced: 10.9)
  @objc public func downloadTask(withResumeData resumeData: DataWrapper) -> URLSessionDownloadTaskWrapper {
    let result = wrappedInstance.downloadTask(withResumeData: resumeData.wrappedInstance)
    return URLSessionDownloadTaskWrapper(result)
  }

  @available(macOS, introduced: 10.9)
  @objc public func finishTasksAndInvalidate() {
    return wrappedInstance.finishTasksAndInvalidate()
  }

  @available(macOS, introduced: 10.9)
  @objc public func invalidateAndCancel() {
    return wrappedInstance.invalidateAndCancel()
  }

  @available(macOS, introduced: 10.9)
  @objc public func reset() async {
    return await wrappedInstance.reset()
  }

  @available(macOS, introduced: 10.11)
  @objc public func streamTask(withHostName hostname: String, port: Int) -> URLSessionStreamTaskWrapper {
    let result = wrappedInstance.streamTask(withHostName: hostname, port: port)
    return URLSessionStreamTaskWrapper(result)
  }

  @available(macOS, introduced: 10.11, deprecated: 100000)
  @objc public func streamTask(with service: NetServiceWrapper) -> URLSessionStreamTaskWrapper {
    let result = wrappedInstance.streamTask(with: service.wrappedInstance)
    return URLSessionStreamTaskWrapper(result)
  }

  @available(macOS, introduced: 10.9)
  @objc public func uploadTask(with request: URLRequestWrapper, from bodyData: DataWrapper) -> URLSessionUploadTaskWrapper {
    let result = wrappedInstance.uploadTask(with: request.wrappedInstance, from: bodyData.wrappedInstance)
    return URLSessionUploadTaskWrapper(result)
  }

  @available(macOS, introduced: 10.9)
  @objc public func uploadTask(with request: URLRequestWrapper, fromFile fileURL: URLWrapper) -> URLSessionUploadTaskWrapper {
    let result = wrappedInstance.uploadTask(with: request.wrappedInstance, fromFile: fileURL.wrappedInstance)
    return URLSessionUploadTaskWrapper(result)
  }

  @available(macOS, introduced: 14.0)
  @objc public func uploadTask(withResumeData resumeData: DataWrapper) -> URLSessionUploadTaskWrapper {
    let result = wrappedInstance.uploadTask(withResumeData: resumeData.wrappedInstance)
    return URLSessionUploadTaskWrapper(result)
  }

  @available(macOS, introduced: 10.9)
  @objc public func uploadTask(withStreamedRequest request: URLRequestWrapper) -> URLSessionUploadTaskWrapper {
    let result = wrappedInstance.uploadTask(withStreamedRequest: request.wrappedInstance)
    return URLSessionUploadTaskWrapper(result)
  }

  @available(macOS, introduced: 10.15)
  @objc public func webSocketTask(with url: URLWrapper) -> URLSessionWebSocketTaskWrapper {
    let result = wrappedInstance.webSocketTask(with: url.wrappedInstance)
    return URLSessionWebSocketTaskWrapper(result)
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public func dataTaskPublisher(for request: URLRequestWrapper) -> URLSessionWrapper.DataTaskPublisherWrapper {
    let result = wrappedInstance.dataTaskPublisher(for: request.wrappedInstance)
    return DataTaskPublisherWrapper(result)
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class AsyncBytesWrapper: NSObject {
    var wrappedInstance: URLSession.AsyncBytes

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var characters: AsyncCharacterSequenceWrapper {
      get {
        AsyncCharacterSequenceWrapper(wrappedInstance.characters)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var unicodeScalars: AsyncUnicodeScalarSequenceWrapper {
      get {
        AsyncUnicodeScalarSequenceWrapper(wrappedInstance.unicodeScalars)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var lines: AsyncLineSequenceWrapper {
      get {
        AsyncLineSequenceWrapper(wrappedInstance.lines)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var task: URLSessionDataTaskWrapper {
      get {
        URLSessionDataTaskWrapper(wrappedInstance.task)
      }
    }

    init(_ wrappedInstance: URLSession.AsyncBytes) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func makeAsyncIterator() -> AsyncBytesWrapper.IteratorWrapper {
      let result = wrappedInstance.makeAsyncIterator()
      return IteratorWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class IteratorWrapper: NSObject {
      var wrappedInstance: AsyncBytes.Iterator

      init(_ wrappedInstance: AsyncBytes.Iterator) {
        self.wrappedInstance = wrappedInstance
      }

    }

  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public class DataTaskPublisherWrapper: NSObject {
    var wrappedInstance: URLSession.DataTaskPublisher

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public var request: URLRequestWrapper {
      get {
        URLRequestWrapper(wrappedInstance.request)
      }
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc public var session: URLSessionWrapper {
      get {
        URLSessionWrapper(wrappedInstance.session)
      }
    }

    init(_ wrappedInstance: URLSession.DataTaskPublisher) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc init(request: URLRequestWrapper, session: URLSessionWrapper) {
      wrappedInstance = URLSession.DataTaskPublisher(request: request.wrappedInstance, session: session.wrappedInstance)
    }

  }

}

@available(macOS, introduced: 10.9)
@objc public class URLSessionConfigurationWrapper: NSObject {
  var wrappedInstance: URLSessionConfiguration

  @available(macOS, introduced: 10.9)
  @objc static public var `default`: URLSessionConfigurationWrapper {
    get {
      URLSessionConfigurationWrapper(URLSessionConfiguration.`default`)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var ephemeral: URLSessionConfigurationWrapper {
    get {
      URLSessionConfigurationWrapper(URLSessionConfiguration.ephemeral)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var httpCookieStorage: HTTPCookieStorageWrapper? {
    get {
      wrappedInstance.httpCookieStorage == nil ? nil : HTTPCookieStorageWrapper(wrappedInstance.httpCookieStorage!)
    }
    set {
      wrappedInstance.httpCookieStorage = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var httpMaximumConnectionsPerHost: Int {
    get {
      wrappedInstance.httpMaximumConnectionsPerHost
    }
    set {
      wrappedInstance.httpMaximumConnectionsPerHost = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var httpShouldSetCookies: Bool {
    get {
      wrappedInstance.httpShouldSetCookies
    }
    set {
      wrappedInstance.httpShouldSetCookies = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var httpShouldUsePipelining: Bool {
    get {
      wrappedInstance.httpShouldUsePipelining
    }
    set {
      wrappedInstance.httpShouldUsePipelining = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var urlCache: URLCacheWrapper? {
    get {
      wrappedInstance.urlCache == nil ? nil : URLCacheWrapper(wrappedInstance.urlCache!)
    }
    set {
      wrappedInstance.urlCache = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var urlCredentialStorage: URLCredentialStorageWrapper? {
    get {
      wrappedInstance.urlCredentialStorage == nil ? nil : URLCredentialStorageWrapper(wrappedInstance.urlCredentialStorage!)
    }
    set {
      wrappedInstance.urlCredentialStorage = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var allowsCellularAccess: Bool {
    get {
      wrappedInstance.allowsCellularAccess
    }
    set {
      wrappedInstance.allowsCellularAccess = newValue
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var allowsConstrainedNetworkAccess: Bool {
    get {
      wrappedInstance.allowsConstrainedNetworkAccess
    }
    set {
      wrappedInstance.allowsConstrainedNetworkAccess = newValue
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var allowsExpensiveNetworkAccess: Bool {
    get {
      wrappedInstance.allowsExpensiveNetworkAccess
    }
    set {
      wrappedInstance.allowsExpensiveNetworkAccess = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var isDiscretionary: Bool {
    get {
      wrappedInstance.isDiscretionary
    }
    set {
      wrappedInstance.isDiscretionary = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var identifier: String? {
    get {
      wrappedInstance.identifier
    }
  }

  @available(macOS, introduced: 13.0)
  @objc public var requiresDNSSECValidation: Bool {
    get {
      wrappedInstance.requiresDNSSECValidation
    }
    set {
      wrappedInstance.requiresDNSSECValidation = newValue
    }
  }

  @available(macOS, introduced: 11.0)
  @objc public var sessionSendsLaunchEvents: Bool {
    get {
      wrappedInstance.sessionSendsLaunchEvents
    }
    set {
      wrappedInstance.sessionSendsLaunchEvents = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var sharedContainerIdentifier: String? {
    get {
      wrappedInstance.sharedContainerIdentifier
    }
    set {
      wrappedInstance.sharedContainerIdentifier = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var shouldUseExtendedBackgroundIdleMode: Bool {
    get {
      wrappedInstance.shouldUseExtendedBackgroundIdleMode
    }
    set {
      wrappedInstance.shouldUseExtendedBackgroundIdleMode = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var timeoutIntervalForRequest: TimeInterval {
    get {
      wrappedInstance.timeoutIntervalForRequest
    }
    set {
      wrappedInstance.timeoutIntervalForRequest = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var timeoutIntervalForResource: TimeInterval {
    get {
      wrappedInstance.timeoutIntervalForResource
    }
    set {
      wrappedInstance.timeoutIntervalForResource = newValue
    }
  }

  @available(macOS, introduced: 10.13)
  @objc public var waitsForConnectivity: Bool {
    get {
      wrappedInstance.waitsForConnectivity
    }
    set {
      wrappedInstance.waitsForConnectivity = newValue
    }
  }

  init(_ wrappedInstance: URLSessionConfiguration) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.9, deprecated: 10.15)
  @objc override init() {
    wrappedInstance = URLSessionConfiguration()
  }

  @available(macOS, introduced: 10.9, deprecated: 10.10)
  @objc static public func backgroundSessionConfiguration(_ identifier: String) -> URLSessionConfigurationWrapper {
    let result = URLSessionConfiguration.backgroundSessionConfiguration(identifier)
    return URLSessionConfigurationWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @objc static public func background(withIdentifier identifier: String) -> URLSessionConfigurationWrapper {
    let result = URLSessionConfiguration.background(withIdentifier: identifier)
    return URLSessionConfigurationWrapper(result)
  }

}

@available(macOS, introduced: 10.9)
@objc public class URLSessionDataTaskWrapper: NSObject {
  var wrappedInstance: URLSessionDataTask

  init(_ wrappedInstance: URLSessionDataTask) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.9, deprecated: 10.15)
  @objc override init() {
    wrappedInstance = URLSessionDataTask()
  }

}

@available(macOS, introduced: 10.9)
@objc public class URLSessionDownloadTaskWrapper: NSObject {
  var wrappedInstance: URLSessionDownloadTask

  init(_ wrappedInstance: URLSessionDownloadTask) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.9, deprecated: 10.15)
  @objc override init() {
    wrappedInstance = URLSessionDownloadTask()
  }

}

@available(macOS, introduced: 10.11)
@objc public class URLSessionStreamTaskWrapper: NSObject {
  var wrappedInstance: URLSessionStreamTask

  init(_ wrappedInstance: URLSessionStreamTask) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.9, deprecated: 10.15)
  @objc override init() {
    wrappedInstance = URLSessionStreamTask()
  }

  @available(macOS, introduced: 10.11)
  @objc public func captureStreams() {
    return wrappedInstance.captureStreams()
  }

  @available(macOS, introduced: 10.11)
  @objc public func closeRead() {
    return wrappedInstance.closeRead()
  }

  @available(macOS, introduced: 10.11)
  @objc public func closeWrite() {
    return wrappedInstance.closeWrite()
  }

  @available(macOS, introduced: 10.11)
  @objc public func startSecureConnection() {
    return wrappedInstance.startSecureConnection()
  }

  @available(macOS, introduced: 10.9, deprecated: 10.15)
  @objc public func stopSecureConnection() {
    return wrappedInstance.stopSecureConnection()
  }

}

@available(macOS, introduced: 10.9)
@objc public class URLSessionTaskWrapper: NSObject {
  var wrappedInstance: URLSessionTask

  @available(macOS, introduced: 10.10)
  @objc static public var defaultPriority: Float {
    get {
      URLSessionTask.defaultPriority
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var highPriority: Float {
    get {
      URLSessionTask.highPriority
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var lowPriority: Float {
    get {
      URLSessionTask.lowPriority
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var currentRequest: URLRequestWrapper? {
    get {
      wrappedInstance.currentRequest == nil ? nil : URLRequestWrapper(wrappedInstance.currentRequest!)
    }
  }

  @available(macOS, introduced: 10.13)
  @objc public var earliestBeginDate: DateWrapper? {
    get {
      wrappedInstance.earliestBeginDate == nil ? nil : DateWrapper(wrappedInstance.earliestBeginDate!)
    }
    set {
      wrappedInstance.earliestBeginDate = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var originalRequest: URLRequestWrapper? {
    get {
      wrappedInstance.originalRequest == nil ? nil : URLRequestWrapper(wrappedInstance.originalRequest!)
    }
  }

  @available(macOS, introduced: 11.3)
  @objc public var prefersIncrementalDelivery: Bool {
    get {
      wrappedInstance.prefersIncrementalDelivery
    }
    set {
      wrappedInstance.prefersIncrementalDelivery = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var priority: Float {
    get {
      wrappedInstance.priority
    }
    set {
      wrappedInstance.priority = newValue
    }
  }

  @available(macOS, introduced: 10.13)
  @objc public var progress: ProgressWrapper {
    get {
      ProgressWrapper(wrappedInstance.progress)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var response: URLResponseWrapper? {
    get {
      wrappedInstance.response == nil ? nil : URLResponseWrapper(wrappedInstance.response!)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var taskDescription: String? {
    get {
      wrappedInstance.taskDescription
    }
    set {
      wrappedInstance.taskDescription = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @objc public var taskIdentifier: Int {
    get {
      wrappedInstance.taskIdentifier
    }
  }

  init(_ wrappedInstance: URLSessionTask) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.9, deprecated: 10.15)
  @objc override init() {
    wrappedInstance = URLSessionTask()
  }

  @available(macOS, introduced: 10.9)
  @objc public func cancel() {
    return wrappedInstance.cancel()
  }

  @available(macOS, introduced: 10.9)
  @objc public func resume() {
    return wrappedInstance.resume()
  }

  @available(macOS, introduced: 10.9)
  @objc public func suspend() {
    return wrappedInstance.suspend()
  }

}

@available(macOS, introduced: 10.12)
@objc public class URLSessionTaskMetricsWrapper: NSObject {
  var wrappedInstance: URLSessionTaskMetrics

  @available(macOS, introduced: 10.12)
  @objc public var redirectCount: Int {
    get {
      wrappedInstance.redirectCount
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var taskInterval: DateIntervalWrapper {
    get {
      DateIntervalWrapper(wrappedInstance.taskInterval)
    }
  }

  init(_ wrappedInstance: URLSessionTaskMetrics) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.12, deprecated: 10.15)
  @objc override init() {
    wrappedInstance = URLSessionTaskMetrics()
  }

}

@available(macOS, introduced: 10.12)
@objc public class URLSessionTaskTransactionMetricsWrapper: NSObject {
  var wrappedInstance: URLSessionTaskTransactionMetrics

  @available(macOS, introduced: 10.15)
  @objc public var isCellular: Bool {
    get {
      wrappedInstance.isCellular
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var connectEndDate: DateWrapper? {
    get {
      wrappedInstance.connectEndDate == nil ? nil : DateWrapper(wrappedInstance.connectEndDate!)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var connectStartDate: DateWrapper? {
    get {
      wrappedInstance.connectStartDate == nil ? nil : DateWrapper(wrappedInstance.connectStartDate!)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var isConstrained: Bool {
    get {
      wrappedInstance.isConstrained
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var domainLookupEndDate: DateWrapper? {
    get {
      wrappedInstance.domainLookupEndDate == nil ? nil : DateWrapper(wrappedInstance.domainLookupEndDate!)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var domainLookupStartDate: DateWrapper? {
    get {
      wrappedInstance.domainLookupStartDate == nil ? nil : DateWrapper(wrappedInstance.domainLookupStartDate!)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var isExpensive: Bool {
    get {
      wrappedInstance.isExpensive
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var fetchStartDate: DateWrapper? {
    get {
      wrappedInstance.fetchStartDate == nil ? nil : DateWrapper(wrappedInstance.fetchStartDate!)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var localAddress: String? {
    get {
      wrappedInstance.localAddress
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var isMultipath: Bool {
    get {
      wrappedInstance.isMultipath
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var networkProtocolName: String? {
    get {
      wrappedInstance.networkProtocolName
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var isProxyConnection: Bool {
    get {
      wrappedInstance.isProxyConnection
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var remoteAddress: String? {
    get {
      wrappedInstance.remoteAddress
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var request: URLRequestWrapper {
    get {
      URLRequestWrapper(wrappedInstance.request)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var requestEndDate: DateWrapper? {
    get {
      wrappedInstance.requestEndDate == nil ? nil : DateWrapper(wrappedInstance.requestEndDate!)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var requestStartDate: DateWrapper? {
    get {
      wrappedInstance.requestStartDate == nil ? nil : DateWrapper(wrappedInstance.requestStartDate!)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var response: URLResponseWrapper? {
    get {
      wrappedInstance.response == nil ? nil : URLResponseWrapper(wrappedInstance.response!)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var responseEndDate: DateWrapper? {
    get {
      wrappedInstance.responseEndDate == nil ? nil : DateWrapper(wrappedInstance.responseEndDate!)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var responseStartDate: DateWrapper? {
    get {
      wrappedInstance.responseStartDate == nil ? nil : DateWrapper(wrappedInstance.responseStartDate!)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var isReusedConnection: Bool {
    get {
      wrappedInstance.isReusedConnection
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var secureConnectionEndDate: DateWrapper? {
    get {
      wrappedInstance.secureConnectionEndDate == nil ? nil : DateWrapper(wrappedInstance.secureConnectionEndDate!)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var secureConnectionStartDate: DateWrapper? {
    get {
      wrappedInstance.secureConnectionStartDate == nil ? nil : DateWrapper(wrappedInstance.secureConnectionStartDate!)
    }
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public var remotePort: Int? {
    get {
      wrappedInstance.remotePort
    }
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public var localPort: Int? {
    get {
      wrappedInstance.localPort
    }
  }

  init(_ wrappedInstance: URLSessionTaskTransactionMetrics) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.12, deprecated: 10.15)
  @objc override init() {
    wrappedInstance = URLSessionTaskTransactionMetrics()
  }

}

@available(macOS, introduced: 10.9)
@objc public class URLSessionUploadTaskWrapper: NSObject {
  var wrappedInstance: URLSessionUploadTask

  init(_ wrappedInstance: URLSessionUploadTask) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.9, deprecated: 10.15)
  @objc override init() {
    wrappedInstance = URLSessionUploadTask()
  }

}

@available(macOS, introduced: 10.15)
@objc public class URLSessionWebSocketTaskWrapper: NSObject {
  var wrappedInstance: URLSessionWebSocketTask

  @available(macOS, introduced: 10.15)
  @objc public var closeReason: DataWrapper? {
    get {
      wrappedInstance.closeReason == nil ? nil : DataWrapper(wrappedInstance.closeReason!)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var maximumMessageSize: Int {
    get {
      wrappedInstance.maximumMessageSize
    }
    set {
      wrappedInstance.maximumMessageSize = newValue
    }
  }

  init(_ wrappedInstance: URLSessionWebSocketTask) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.8)
@objc public class NSUUIDWrapper: NSObject {
  var wrappedInstance: NSUUID

  @available(macOS, introduced: 10.8)
  @objc public var uuidString: String {
    get {
      wrappedInstance.uuidString
    }
  }

  init(_ wrappedInstance: NSUUID) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.8)
  @objc override init() {
    wrappedInstance = NSUUID()
  }

  @available(macOS, introduced: 10.8)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSUUID(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.7)
@objc public class NSUbiquitousKeyValueStoreWrapper: NSObject {
  var wrappedInstance: NSUbiquitousKeyValueStore

  @available(macOS, introduced: 10.7)
  @objc static public var didChangeExternallyNotification: NSNotificationWrapper.NameWrapper {
    get {
      NameWrapper(NSUbiquitousKeyValueStore.didChangeExternallyNotification)
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var `default`: NSUbiquitousKeyValueStoreWrapper {
    get {
      NSUbiquitousKeyValueStoreWrapper(NSUbiquitousKeyValueStore.`default`)
    }
  }

  init(_ wrappedInstance: NSUbiquitousKeyValueStore) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.7)
  @objc public func bool(forKey aKey: String) -> Bool {
    return wrappedInstance.bool(forKey: aKey)
  }

  @available(macOS, introduced: 10.7)
  @objc public func data(forKey aKey: String) -> DataWrapper? {
    let result = wrappedInstance.data(forKey: aKey)
    return result == nil ? nil : DataWrapper(result!)
  }

  @available(macOS, introduced: 10.7)
  @objc public func double(forKey aKey: String) -> Double {
    return wrappedInstance.double(forKey: aKey)
  }

  @available(macOS, introduced: 10.7)
  @objc public func removeObject(forKey aKey: String) {
    return wrappedInstance.removeObject(forKey: aKey)
  }

  @available(macOS, introduced: 10.7)
  @objc public func set(_ aString: String?, forKey aKey: String) {
    return wrappedInstance.set(aString, forKey: aKey)
  }

  @available(macOS, introduced: 10.7)
  @objc public func string(forKey aKey: String) -> String? {
    return wrappedInstance.string(forKey: aKey)
  }

  @available(macOS, introduced: 10.7)
  @objc public func synchronize() -> Bool {
    return wrappedInstance.synchronize()
  }

}

@available(macOS, introduced: 10.0, deprecated: 10.13)
@objc public class NSUnarchiverWrapper: NSObject {
  var wrappedInstance: NSUnarchiver

  @available(macOS, introduced: 10.0, deprecated: 10.13)
  @objc public var isAtEnd: Bool {
    get {
      wrappedInstance.isAtEnd
    }
  }

  init(_ wrappedInstance: NSUnarchiver) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.0, deprecated: 10.13)
  @objc init?(forReadingWith data: DataWrapper) {
    if let instance = NSUnarchiver(forReadingWith: data.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.0, deprecated: 10.13)
  @objc static public func classNameDecoded(forArchiveClassName inArchiveName: String) -> String {
    return NSUnarchiver.classNameDecoded(forArchiveClassName: inArchiveName)
  }

  @available(macOS, introduced: 10.0, deprecated: 10.13)
  @objc static public func decodeClassName(_ inArchiveName: String, asClassName trueName: String) {
    return NSUnarchiver.decodeClassName(inArchiveName, asClassName: trueName)
  }

}

@available(macOS, introduced: 10.0)
@objc public class UndoManagerWrapper: NSObject {
  var wrappedInstance: UndoManager

  @available(macOS, introduced: 10.0)
  @objc public var canRedo: Bool {
    get {
      wrappedInstance.canRedo
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var canUndo: Bool {
    get {
      wrappedInstance.canUndo
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var groupingLevel: Int {
    get {
      wrappedInstance.groupingLevel
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var groupsByEvent: Bool {
    get {
      wrappedInstance.groupsByEvent
    }
    set {
      wrappedInstance.groupsByEvent = newValue
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var levelsOfUndo: Int {
    get {
      wrappedInstance.levelsOfUndo
    }
    set {
      wrappedInstance.levelsOfUndo = newValue
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var redoActionIsDiscardable: Bool {
    get {
      wrappedInstance.redoActionIsDiscardable
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var redoActionName: String {
    get {
      wrappedInstance.redoActionName
    }
  }

  @available(macOS, introduced: 14.4)
  @objc public var redoCount: Int {
    get {
      wrappedInstance.redoCount
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var redoMenuItemTitle: String {
    get {
      wrappedInstance.redoMenuItemTitle
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var isRedoing: Bool {
    get {
      wrappedInstance.isRedoing
    }
  }

  @available(macOS, introduced: 10.7)
  @objc public var undoActionIsDiscardable: Bool {
    get {
      wrappedInstance.undoActionIsDiscardable
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var undoActionName: String {
    get {
      wrappedInstance.undoActionName
    }
  }

  @available(macOS, introduced: 14.4)
  @objc public var undoCount: Int {
    get {
      wrappedInstance.undoCount
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var undoMenuItemTitle: String {
    get {
      wrappedInstance.undoMenuItemTitle
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var isUndoRegistrationEnabled: Bool {
    get {
      wrappedInstance.isUndoRegistrationEnabled
    }
  }

  @available(macOS, introduced: 10.0)
  @objc public var isUndoing: Bool {
    get {
      wrappedInstance.isUndoing
    }
  }

  init(_ wrappedInstance: UndoManager) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.0)
  @objc public func beginUndoGrouping() {
    return wrappedInstance.beginUndoGrouping()
  }

  @available(macOS, introduced: 10.0)
  @objc public func disableUndoRegistration() {
    return wrappedInstance.disableUndoRegistration()
  }

  @available(macOS, introduced: 10.0)
  @objc public func enableUndoRegistration() {
    return wrappedInstance.enableUndoRegistration()
  }

  @available(macOS, introduced: 10.0)
  @objc public func endUndoGrouping() {
    return wrappedInstance.endUndoGrouping()
  }

  @available(macOS, introduced: 10.0)
  @objc public func redo() {
    return wrappedInstance.redo()
  }

  @available(macOS, introduced: 10.0)
  @objc public func redoMenuTitle(forUndoActionName actionName: String) -> String {
    return wrappedInstance.redoMenuTitle(forUndoActionName: actionName)
  }

  @available(macOS, introduced: 10.0)
  @objc public func removeAllActions() {
    return wrappedInstance.removeAllActions()
  }

  @available(macOS, introduced: 10.7)
  @objc public func setActionIsDiscardable(_ discardable: Bool) {
    return wrappedInstance.setActionIsDiscardable(discardable)
  }

  @available(macOS, introduced: 10.0)
  @objc public func setActionName(_ actionName: String) {
    return wrappedInstance.setActionName(actionName)
  }

  @available(macOS, introduced: 10.0)
  @objc public func undo() {
    return wrappedInstance.undo()
  }

  @available(macOS, introduced: 10.0)
  @objc public func undoMenuTitle(forUndoActionName actionName: String) -> String {
    return wrappedInstance.undoMenuTitle(forUndoActionName: actionName)
  }

  @available(macOS, introduced: 10.0)
  @objc public func undoNestedGroup() {
    return wrappedInstance.undoNestedGroup()
  }

  @available(macOS, introduced: 15.0)
  @objc public class UserInfoKeyWrapper: NSObject {
    var wrappedInstance: UndoManager.UserInfoKey

    init(_ wrappedInstance: UndoManager.UserInfoKey) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 15.0)
    @objc init(rawValue: String) {
      wrappedInstance = UndoManager.UserInfoKey(rawValue: rawValue)
    }

    @available(macOS, introduced: 15.0)
    @objc init(_ rawValue: String) {
      wrappedInstance = UndoManager.UserInfoKey(rawValue)
    }

  }

}

@objc public class NSUniqueIDSpecifierWrapper: NSObject {
  var wrappedInstance: NSUniqueIDSpecifier

  init(_ wrappedInstance: NSUniqueIDSpecifier) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder inCoder: NSCoderWrapper) {
    if let instance = NSUniqueIDSpecifier(coder: inCoder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitWrapper: NSObject {
  var wrappedInstance: Unit

  @available(macOS, introduced: 10.12)
  @objc public var symbol: String {
    get {
      wrappedInstance.symbol
    }
  }

  init(_ wrappedInstance: Unit) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.12)
  @objc init(symbol: String) {
    wrappedInstance = Unit(symbol: symbol)
  }

  @available(macOS, introduced: 10.12)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = Unit(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitAccelerationWrapper: NSObject {
  var wrappedInstance: UnitAcceleration

  @available(macOS, introduced: 10.12)
  @objc static public var gravity: UnitAccelerationWrapper {
    get {
      UnitAccelerationWrapper(UnitAcceleration.gravity)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var metersPerSecondSquared: UnitAccelerationWrapper {
    get {
      UnitAccelerationWrapper(UnitAcceleration.metersPerSecondSquared)
    }
  }

  init(_ wrappedInstance: UnitAcceleration) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitAngleWrapper: NSObject {
  var wrappedInstance: UnitAngle

  @available(macOS, introduced: 10.12)
  @objc static public var arcMinutes: UnitAngleWrapper {
    get {
      UnitAngleWrapper(UnitAngle.arcMinutes)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var arcSeconds: UnitAngleWrapper {
    get {
      UnitAngleWrapper(UnitAngle.arcSeconds)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var degrees: UnitAngleWrapper {
    get {
      UnitAngleWrapper(UnitAngle.degrees)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var gradians: UnitAngleWrapper {
    get {
      UnitAngleWrapper(UnitAngle.gradians)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var radians: UnitAngleWrapper {
    get {
      UnitAngleWrapper(UnitAngle.radians)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var revolutions: UnitAngleWrapper {
    get {
      UnitAngleWrapper(UnitAngle.revolutions)
    }
  }

  init(_ wrappedInstance: UnitAngle) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitAreaWrapper: NSObject {
  var wrappedInstance: UnitArea

  @available(macOS, introduced: 10.12)
  @objc static public var acres: UnitAreaWrapper {
    get {
      UnitAreaWrapper(UnitArea.acres)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var ares: UnitAreaWrapper {
    get {
      UnitAreaWrapper(UnitArea.ares)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var hectares: UnitAreaWrapper {
    get {
      UnitAreaWrapper(UnitArea.hectares)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var squareCentimeters: UnitAreaWrapper {
    get {
      UnitAreaWrapper(UnitArea.squareCentimeters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var squareFeet: UnitAreaWrapper {
    get {
      UnitAreaWrapper(UnitArea.squareFeet)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var squareInches: UnitAreaWrapper {
    get {
      UnitAreaWrapper(UnitArea.squareInches)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var squareKilometers: UnitAreaWrapper {
    get {
      UnitAreaWrapper(UnitArea.squareKilometers)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var squareMegameters: UnitAreaWrapper {
    get {
      UnitAreaWrapper(UnitArea.squareMegameters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var squareMeters: UnitAreaWrapper {
    get {
      UnitAreaWrapper(UnitArea.squareMeters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var squareMicrometers: UnitAreaWrapper {
    get {
      UnitAreaWrapper(UnitArea.squareMicrometers)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var squareMiles: UnitAreaWrapper {
    get {
      UnitAreaWrapper(UnitArea.squareMiles)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var squareMillimeters: UnitAreaWrapper {
    get {
      UnitAreaWrapper(UnitArea.squareMillimeters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var squareNanometers: UnitAreaWrapper {
    get {
      UnitAreaWrapper(UnitArea.squareNanometers)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var squareYards: UnitAreaWrapper {
    get {
      UnitAreaWrapper(UnitArea.squareYards)
    }
  }

  init(_ wrappedInstance: UnitArea) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitConcentrationMassWrapper: NSObject {
  var wrappedInstance: UnitConcentrationMass

  @available(macOS, introduced: 10.12)
  @objc static public var gramsPerLiter: UnitConcentrationMassWrapper {
    get {
      UnitConcentrationMassWrapper(UnitConcentrationMass.gramsPerLiter)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var milligramsPerDeciliter: UnitConcentrationMassWrapper {
    get {
      UnitConcentrationMassWrapper(UnitConcentrationMass.milligramsPerDeciliter)
    }
  }

  init(_ wrappedInstance: UnitConcentrationMass) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.12)
  @objc static public func millimolesPerLiter(withGramsPerMole gramsPerMole: Double) -> UnitConcentrationMassWrapper {
    let result = UnitConcentrationMass.millimolesPerLiter(withGramsPerMole: gramsPerMole)
    return UnitConcentrationMassWrapper(result)
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitConverterWrapper: NSObject {
  var wrappedInstance: UnitConverter

  init(_ wrappedInstance: UnitConverter) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.12)
  @objc public func baseUnitValue(fromValue value: Double) -> Double {
    return wrappedInstance.baseUnitValue(fromValue: value)
  }

  @available(macOS, introduced: 10.12)
  @objc public func value(fromBaseUnitValue baseUnitValue: Double) -> Double {
    return wrappedInstance.value(fromBaseUnitValue: baseUnitValue)
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitConverterLinearWrapper: NSObject {
  var wrappedInstance: UnitConverterLinear

  @available(macOS, introduced: 10.12)
  @objc public var coefficient: Double {
    get {
      wrappedInstance.coefficient
    }
  }

  @available(macOS, introduced: 10.12)
  @objc public var constant: Double {
    get {
      wrappedInstance.constant
    }
  }

  init(_ wrappedInstance: UnitConverterLinear) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.12)
  @objc init(coefficient: Double, constant: Double) {
    wrappedInstance = UnitConverterLinear(coefficient: coefficient, constant: constant)
  }

  @available(macOS, introduced: 10.12)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = UnitConverterLinear(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitDispersionWrapper: NSObject {
  var wrappedInstance: UnitDispersion

  @available(macOS, introduced: 10.12)
  @objc static public var partsPerMillion: UnitDispersionWrapper {
    get {
      UnitDispersionWrapper(UnitDispersion.partsPerMillion)
    }
  }

  init(_ wrappedInstance: UnitDispersion) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitDurationWrapper: NSObject {
  var wrappedInstance: UnitDuration

  @available(macOS, introduced: 10.12)
  @objc static public var hours: UnitDurationWrapper {
    get {
      UnitDurationWrapper(UnitDuration.hours)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var microseconds: UnitDurationWrapper {
    get {
      UnitDurationWrapper(UnitDuration.microseconds)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var milliseconds: UnitDurationWrapper {
    get {
      UnitDurationWrapper(UnitDuration.milliseconds)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var minutes: UnitDurationWrapper {
    get {
      UnitDurationWrapper(UnitDuration.minutes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var nanoseconds: UnitDurationWrapper {
    get {
      UnitDurationWrapper(UnitDuration.nanoseconds)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var picoseconds: UnitDurationWrapper {
    get {
      UnitDurationWrapper(UnitDuration.picoseconds)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var seconds: UnitDurationWrapper {
    get {
      UnitDurationWrapper(UnitDuration.seconds)
    }
  }

  init(_ wrappedInstance: UnitDuration) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitElectricChargeWrapper: NSObject {
  var wrappedInstance: UnitElectricCharge

  @available(macOS, introduced: 10.12)
  @objc static public var ampereHours: UnitElectricChargeWrapper {
    get {
      UnitElectricChargeWrapper(UnitElectricCharge.ampereHours)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var coulombs: UnitElectricChargeWrapper {
    get {
      UnitElectricChargeWrapper(UnitElectricCharge.coulombs)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var kiloampereHours: UnitElectricChargeWrapper {
    get {
      UnitElectricChargeWrapper(UnitElectricCharge.kiloampereHours)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var megaampereHours: UnitElectricChargeWrapper {
    get {
      UnitElectricChargeWrapper(UnitElectricCharge.megaampereHours)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var microampereHours: UnitElectricChargeWrapper {
    get {
      UnitElectricChargeWrapper(UnitElectricCharge.microampereHours)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var milliampereHours: UnitElectricChargeWrapper {
    get {
      UnitElectricChargeWrapper(UnitElectricCharge.milliampereHours)
    }
  }

  init(_ wrappedInstance: UnitElectricCharge) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitElectricCurrentWrapper: NSObject {
  var wrappedInstance: UnitElectricCurrent

  @available(macOS, introduced: 10.12)
  @objc static public var amperes: UnitElectricCurrentWrapper {
    get {
      UnitElectricCurrentWrapper(UnitElectricCurrent.amperes)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var kiloamperes: UnitElectricCurrentWrapper {
    get {
      UnitElectricCurrentWrapper(UnitElectricCurrent.kiloamperes)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var megaamperes: UnitElectricCurrentWrapper {
    get {
      UnitElectricCurrentWrapper(UnitElectricCurrent.megaamperes)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var microamperes: UnitElectricCurrentWrapper {
    get {
      UnitElectricCurrentWrapper(UnitElectricCurrent.microamperes)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var milliamperes: UnitElectricCurrentWrapper {
    get {
      UnitElectricCurrentWrapper(UnitElectricCurrent.milliamperes)
    }
  }

  init(_ wrappedInstance: UnitElectricCurrent) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitElectricPotentialDifferenceWrapper: NSObject {
  var wrappedInstance: UnitElectricPotentialDifference

  @available(macOS, introduced: 10.12)
  @objc static public var kilovolts: UnitElectricPotentialDifferenceWrapper {
    get {
      UnitElectricPotentialDifferenceWrapper(UnitElectricPotentialDifference.kilovolts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var megavolts: UnitElectricPotentialDifferenceWrapper {
    get {
      UnitElectricPotentialDifferenceWrapper(UnitElectricPotentialDifference.megavolts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var microvolts: UnitElectricPotentialDifferenceWrapper {
    get {
      UnitElectricPotentialDifferenceWrapper(UnitElectricPotentialDifference.microvolts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var millivolts: UnitElectricPotentialDifferenceWrapper {
    get {
      UnitElectricPotentialDifferenceWrapper(UnitElectricPotentialDifference.millivolts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var volts: UnitElectricPotentialDifferenceWrapper {
    get {
      UnitElectricPotentialDifferenceWrapper(UnitElectricPotentialDifference.volts)
    }
  }

  init(_ wrappedInstance: UnitElectricPotentialDifference) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitElectricResistanceWrapper: NSObject {
  var wrappedInstance: UnitElectricResistance

  @available(macOS, introduced: 10.12)
  @objc static public var kiloohms: UnitElectricResistanceWrapper {
    get {
      UnitElectricResistanceWrapper(UnitElectricResistance.kiloohms)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var megaohms: UnitElectricResistanceWrapper {
    get {
      UnitElectricResistanceWrapper(UnitElectricResistance.megaohms)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var microohms: UnitElectricResistanceWrapper {
    get {
      UnitElectricResistanceWrapper(UnitElectricResistance.microohms)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var milliohms: UnitElectricResistanceWrapper {
    get {
      UnitElectricResistanceWrapper(UnitElectricResistance.milliohms)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var ohms: UnitElectricResistanceWrapper {
    get {
      UnitElectricResistanceWrapper(UnitElectricResistance.ohms)
    }
  }

  init(_ wrappedInstance: UnitElectricResistance) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitEnergyWrapper: NSObject {
  var wrappedInstance: UnitEnergy

  @available(macOS, introduced: 10.12)
  @objc static public var calories: UnitEnergyWrapper {
    get {
      UnitEnergyWrapper(UnitEnergy.calories)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var joules: UnitEnergyWrapper {
    get {
      UnitEnergyWrapper(UnitEnergy.joules)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var kilocalories: UnitEnergyWrapper {
    get {
      UnitEnergyWrapper(UnitEnergy.kilocalories)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var kilojoules: UnitEnergyWrapper {
    get {
      UnitEnergyWrapper(UnitEnergy.kilojoules)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var kilowattHours: UnitEnergyWrapper {
    get {
      UnitEnergyWrapper(UnitEnergy.kilowattHours)
    }
  }

  init(_ wrappedInstance: UnitEnergy) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitFrequencyWrapper: NSObject {
  var wrappedInstance: UnitFrequency

  @available(macOS, introduced: 10.15)
  @objc static public var framesPerSecond: UnitFrequencyWrapper {
    get {
      UnitFrequencyWrapper(UnitFrequency.framesPerSecond)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var gigahertz: UnitFrequencyWrapper {
    get {
      UnitFrequencyWrapper(UnitFrequency.gigahertz)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var hertz: UnitFrequencyWrapper {
    get {
      UnitFrequencyWrapper(UnitFrequency.hertz)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var kilohertz: UnitFrequencyWrapper {
    get {
      UnitFrequencyWrapper(UnitFrequency.kilohertz)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var megahertz: UnitFrequencyWrapper {
    get {
      UnitFrequencyWrapper(UnitFrequency.megahertz)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var microhertz: UnitFrequencyWrapper {
    get {
      UnitFrequencyWrapper(UnitFrequency.microhertz)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var millihertz: UnitFrequencyWrapper {
    get {
      UnitFrequencyWrapper(UnitFrequency.millihertz)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var nanohertz: UnitFrequencyWrapper {
    get {
      UnitFrequencyWrapper(UnitFrequency.nanohertz)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var terahertz: UnitFrequencyWrapper {
    get {
      UnitFrequencyWrapper(UnitFrequency.terahertz)
    }
  }

  init(_ wrappedInstance: UnitFrequency) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitFuelEfficiencyWrapper: NSObject {
  var wrappedInstance: UnitFuelEfficiency

  @available(macOS, introduced: 10.12)
  @objc static public var litersPer100Kilometers: UnitFuelEfficiencyWrapper {
    get {
      UnitFuelEfficiencyWrapper(UnitFuelEfficiency.litersPer100Kilometers)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var milesPerGallon: UnitFuelEfficiencyWrapper {
    get {
      UnitFuelEfficiencyWrapper(UnitFuelEfficiency.milesPerGallon)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var milesPerImperialGallon: UnitFuelEfficiencyWrapper {
    get {
      UnitFuelEfficiencyWrapper(UnitFuelEfficiency.milesPerImperialGallon)
    }
  }

  init(_ wrappedInstance: UnitFuelEfficiency) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitIlluminanceWrapper: NSObject {
  var wrappedInstance: UnitIlluminance

  @available(macOS, introduced: 10.12)
  @objc static public var lux: UnitIlluminanceWrapper {
    get {
      UnitIlluminanceWrapper(UnitIlluminance.lux)
    }
  }

  init(_ wrappedInstance: UnitIlluminance) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.15)
@objc public class UnitInformationStorageWrapper: NSObject {
  var wrappedInstance: UnitInformationStorage

  @available(macOS, introduced: 10.15)
  @objc static public var bits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.bits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var bytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.bytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var exabits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.exabits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var exabytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.exabytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var exbibits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.exbibits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var exbibytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.exbibytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var gibibits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.gibibits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var gibibytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.gibibytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var gigabits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.gigabits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var gigabytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.gigabytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var kibibits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.kibibits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var kibibytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.kibibytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var kilobits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.kilobits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var kilobytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.kilobytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var mebibits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.mebibits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var mebibytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.mebibytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var megabits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.megabits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var megabytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.megabytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var nibbles: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.nibbles)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var pebibits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.pebibits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var pebibytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.pebibytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var petabits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.petabits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var petabytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.petabytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var tebibits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.tebibits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var tebibytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.tebibytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var terabits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.terabits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var terabytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.terabytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var yobibits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.yobibits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var yobibytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.yobibytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var yottabits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.yottabits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var yottabytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.yottabytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var zebibits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.zebibits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var zebibytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.zebibytes)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var zettabits: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.zettabits)
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var zettabytes: UnitInformationStorageWrapper {
    get {
      UnitInformationStorageWrapper(UnitInformationStorage.zettabytes)
    }
  }

  init(_ wrappedInstance: UnitInformationStorage) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitLengthWrapper: NSObject {
  var wrappedInstance: UnitLength

  @available(macOS, introduced: 10.12)
  @objc static public var astronomicalUnits: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.astronomicalUnits)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var centimeters: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.centimeters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var decameters: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.decameters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var decimeters: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.decimeters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var fathoms: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.fathoms)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var feet: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.feet)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var furlongs: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.furlongs)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var hectometers: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.hectometers)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var inches: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.inches)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var kilometers: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.kilometers)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var lightyears: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.lightyears)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var megameters: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.megameters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var meters: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.meters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var micrometers: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.micrometers)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var miles: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.miles)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var millimeters: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.millimeters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var nanometers: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.nanometers)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var nauticalMiles: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.nauticalMiles)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var parsecs: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.parsecs)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var picometers: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.picometers)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var scandinavianMiles: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.scandinavianMiles)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var yards: UnitLengthWrapper {
    get {
      UnitLengthWrapper(UnitLength.yards)
    }
  }

  init(_ wrappedInstance: UnitLength) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitMassWrapper: NSObject {
  var wrappedInstance: UnitMass

  @available(macOS, introduced: 10.12)
  @objc static public var carats: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.carats)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var centigrams: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.centigrams)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var decigrams: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.decigrams)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var grams: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.grams)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var kilograms: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.kilograms)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var metricTons: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.metricTons)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var micrograms: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.micrograms)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var milligrams: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.milligrams)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var nanograms: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.nanograms)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var ounces: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.ounces)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var ouncesTroy: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.ouncesTroy)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var picograms: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.picograms)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var pounds: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.pounds)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var shortTons: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.shortTons)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var slugs: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.slugs)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var stones: UnitMassWrapper {
    get {
      UnitMassWrapper(UnitMass.stones)
    }
  }

  init(_ wrappedInstance: UnitMass) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitPowerWrapper: NSObject {
  var wrappedInstance: UnitPower

  @available(macOS, introduced: 10.12)
  @objc static public var femtowatts: UnitPowerWrapper {
    get {
      UnitPowerWrapper(UnitPower.femtowatts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var gigawatts: UnitPowerWrapper {
    get {
      UnitPowerWrapper(UnitPower.gigawatts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var horsepower: UnitPowerWrapper {
    get {
      UnitPowerWrapper(UnitPower.horsepower)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var kilowatts: UnitPowerWrapper {
    get {
      UnitPowerWrapper(UnitPower.kilowatts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var megawatts: UnitPowerWrapper {
    get {
      UnitPowerWrapper(UnitPower.megawatts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var microwatts: UnitPowerWrapper {
    get {
      UnitPowerWrapper(UnitPower.microwatts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var milliwatts: UnitPowerWrapper {
    get {
      UnitPowerWrapper(UnitPower.milliwatts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var nanowatts: UnitPowerWrapper {
    get {
      UnitPowerWrapper(UnitPower.nanowatts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var picowatts: UnitPowerWrapper {
    get {
      UnitPowerWrapper(UnitPower.picowatts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var terawatts: UnitPowerWrapper {
    get {
      UnitPowerWrapper(UnitPower.terawatts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var watts: UnitPowerWrapper {
    get {
      UnitPowerWrapper(UnitPower.watts)
    }
  }

  init(_ wrappedInstance: UnitPower) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitPressureWrapper: NSObject {
  var wrappedInstance: UnitPressure

  @available(macOS, introduced: 10.12)
  @objc static public var bars: UnitPressureWrapper {
    get {
      UnitPressureWrapper(UnitPressure.bars)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var gigapascals: UnitPressureWrapper {
    get {
      UnitPressureWrapper(UnitPressure.gigapascals)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var hectopascals: UnitPressureWrapper {
    get {
      UnitPressureWrapper(UnitPressure.hectopascals)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var inchesOfMercury: UnitPressureWrapper {
    get {
      UnitPressureWrapper(UnitPressure.inchesOfMercury)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var kilopascals: UnitPressureWrapper {
    get {
      UnitPressureWrapper(UnitPressure.kilopascals)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var megapascals: UnitPressureWrapper {
    get {
      UnitPressureWrapper(UnitPressure.megapascals)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var millibars: UnitPressureWrapper {
    get {
      UnitPressureWrapper(UnitPressure.millibars)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var millimetersOfMercury: UnitPressureWrapper {
    get {
      UnitPressureWrapper(UnitPressure.millimetersOfMercury)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var newtonsPerMetersSquared: UnitPressureWrapper {
    get {
      UnitPressureWrapper(UnitPressure.newtonsPerMetersSquared)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var poundsForcePerSquareInch: UnitPressureWrapper {
    get {
      UnitPressureWrapper(UnitPressure.poundsForcePerSquareInch)
    }
  }

  init(_ wrappedInstance: UnitPressure) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitSpeedWrapper: NSObject {
  var wrappedInstance: UnitSpeed

  @available(macOS, introduced: 10.12)
  @objc static public var kilometersPerHour: UnitSpeedWrapper {
    get {
      UnitSpeedWrapper(UnitSpeed.kilometersPerHour)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var knots: UnitSpeedWrapper {
    get {
      UnitSpeedWrapper(UnitSpeed.knots)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var metersPerSecond: UnitSpeedWrapper {
    get {
      UnitSpeedWrapper(UnitSpeed.metersPerSecond)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var milesPerHour: UnitSpeedWrapper {
    get {
      UnitSpeedWrapper(UnitSpeed.milesPerHour)
    }
  }

  init(_ wrappedInstance: UnitSpeed) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitTemperatureWrapper: NSObject {
  var wrappedInstance: UnitTemperature

  @available(macOS, introduced: 10.12)
  @objc static public var celsius: UnitTemperatureWrapper {
    get {
      UnitTemperatureWrapper(UnitTemperature.celsius)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var fahrenheit: UnitTemperatureWrapper {
    get {
      UnitTemperatureWrapper(UnitTemperature.fahrenheit)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var kelvin: UnitTemperatureWrapper {
    get {
      UnitTemperatureWrapper(UnitTemperature.kelvin)
    }
  }

  init(_ wrappedInstance: UnitTemperature) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.12)
@objc public class UnitVolumeWrapper: NSObject {
  var wrappedInstance: UnitVolume

  @available(macOS, introduced: 10.12)
  @objc static public var acreFeet: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.acreFeet)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var bushels: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.bushels)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var centiliters: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.centiliters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var cubicCentimeters: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.cubicCentimeters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var cubicDecimeters: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.cubicDecimeters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var cubicFeet: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.cubicFeet)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var cubicInches: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.cubicInches)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var cubicKilometers: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.cubicKilometers)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var cubicMeters: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.cubicMeters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var cubicMiles: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.cubicMiles)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var cubicMillimeters: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.cubicMillimeters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var cubicYards: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.cubicYards)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var cups: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.cups)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var deciliters: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.deciliters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var fluidOunces: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.fluidOunces)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var gallons: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.gallons)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var imperialFluidOunces: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.imperialFluidOunces)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var imperialGallons: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.imperialGallons)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var imperialPints: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.imperialPints)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var imperialQuarts: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.imperialQuarts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var imperialTablespoons: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.imperialTablespoons)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var imperialTeaspoons: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.imperialTeaspoons)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var kiloliters: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.kiloliters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var liters: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.liters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var megaliters: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.megaliters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var metricCups: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.metricCups)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var milliliters: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.milliliters)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var pints: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.pints)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var quarts: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.quarts)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var tablespoons: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.tablespoons)
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var teaspoons: UnitVolumeWrapper {
    get {
      UnitVolumeWrapper(UnitVolume.teaspoons)
    }
  }

  init(_ wrappedInstance: UnitVolume) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.10)
@objc public class NSUserActivityWrapper: NSObject {
  var wrappedInstance: NSUserActivity

  @available(macOS, introduced: 10.10)
  @objc public var activityType: String {
    get {
      wrappedInstance.activityType
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var isEligibleForHandoff: Bool {
    get {
      wrappedInstance.isEligibleForHandoff
    }
    set {
      wrappedInstance.isEligibleForHandoff = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var isEligibleForPublicIndexing: Bool {
    get {
      wrappedInstance.isEligibleForPublicIndexing
    }
    set {
      wrappedInstance.isEligibleForPublicIndexing = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var isEligibleForSearch: Bool {
    get {
      wrappedInstance.isEligibleForSearch
    }
    set {
      wrappedInstance.isEligibleForSearch = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @objc public var expirationDate: DateWrapper? {
    get {
      wrappedInstance.expirationDate == nil ? nil : DateWrapper(wrappedInstance.expirationDate!)
    }
    set {
      wrappedInstance.expirationDate = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var needsSave: Bool {
    get {
      wrappedInstance.needsSave
    }
    set {
      wrappedInstance.needsSave = newValue
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var persistentIdentifier: NSUserActivityPersistentIdentifier? {
    get {
      wrappedInstance.persistentIdentifier
    }
    set {
      wrappedInstance.persistentIdentifier = newValue
    }
  }

  @available(macOS, introduced: 10.13)
  @objc public var referrerURL: URLWrapper? {
    get {
      wrappedInstance.referrerURL == nil ? nil : URLWrapper(wrappedInstance.referrerURL!)
    }
    set {
      wrappedInstance.referrerURL = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var supportsContinuationStreams: Bool {
    get {
      wrappedInstance.supportsContinuationStreams
    }
    set {
      wrappedInstance.supportsContinuationStreams = newValue
    }
  }

  @available(macOS, introduced: 10.15)
  @objc public var targetContentIdentifier: String? {
    get {
      wrappedInstance.targetContentIdentifier
    }
    set {
      wrappedInstance.targetContentIdentifier = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var title: String? {
    get {
      wrappedInstance.title
    }
    set {
      wrappedInstance.title = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @objc public var webpageURL: URLWrapper? {
    get {
      wrappedInstance.webpageURL == nil ? nil : URLWrapper(wrappedInstance.webpageURL!)
    }
    set {
      wrappedInstance.webpageURL = newValue?.wrappedInstance
    }
  }

  init(_ wrappedInstance: NSUserActivity) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @objc init(activityType: String) {
    wrappedInstance = NSUserActivity(activityType: activityType)
  }

  @available(macOS, introduced: 10.15)
  @objc static public func deleteAllSavedUserActivities() async {
    return await NSUserActivity.deleteAllSavedUserActivities()
  }

  @available(macOS, introduced: 10.10)
  @objc public func becomeCurrent() {
    return wrappedInstance.becomeCurrent()
  }

  @available(macOS, introduced: 10.10)
  @objc public func invalidate() {
    return wrappedInstance.invalidate()
  }

  @available(macOS, introduced: 10.11)
  @objc public func resignCurrent() {
    return wrappedInstance.resignCurrent()
  }

}

@available(macOS, introduced: 10.8)
@objc public class NSUserAppleScriptTaskWrapper: NSObject {
  var wrappedInstance: NSUserAppleScriptTask

  init(_ wrappedInstance: NSUserAppleScriptTask) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.8)
  @objc public func execute(withAppleEvent event: NSAppleEventDescriptorWrapper?) async throws -> NSAppleEventDescriptorWrapper {
    let result = try await wrappedInstance.execute(withAppleEvent: event?.wrappedInstance)
    return NSAppleEventDescriptorWrapper(result)
  }

}

@available(macOS, introduced: 10.8)
@objc public class NSUserAutomatorTaskWrapper: NSObject {
  var wrappedInstance: NSUserAutomatorTask

  init(_ wrappedInstance: NSUserAutomatorTask) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class UserDefaultsWrapper: NSObject {
  var wrappedInstance: UserDefaults

  @objc static public var argumentDomain: String {
    get {
      UserDefaults.argumentDomain
    }
  }

  @objc static public var globalDomain: String {
    get {
      UserDefaults.globalDomain
    }
  }

  @objc static public var registrationDomain: String {
    get {
      UserDefaults.registrationDomain
    }
  }

  @objc static public var didChangeNotification: NSNotificationWrapper.NameWrapper {
    get {
      NameWrapper(UserDefaults.didChangeNotification)
    }
  }

  @objc static public var standard: UserDefaultsWrapper {
    get {
      UserDefaultsWrapper(UserDefaults.standard)
    }
  }

  init(_ wrappedInstance: UserDefaults) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.9)
  @objc init?(suiteName suitename: String?) {
    if let instance = UserDefaults(suiteName: suitename) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc static public func resetStandardUserDefaults() {
    return UserDefaults.resetStandardUserDefaults()
  }

  @available(macOS, introduced: 10.6)
  @objc public func url(forKey defaultName: String) -> URLWrapper? {
    let result = wrappedInstance.url(forKey: defaultName)
    return result == nil ? nil : URLWrapper(result!)
  }

  @objc public func addSuite(named suiteName: String) {
    return wrappedInstance.addSuite(named: suiteName)
  }

  @objc public func bool(forKey defaultName: String) -> Bool {
    return wrappedInstance.bool(forKey: defaultName)
  }

  @objc public func data(forKey defaultName: String) -> DataWrapper? {
    let result = wrappedInstance.data(forKey: defaultName)
    return result == nil ? nil : DataWrapper(result!)
  }

  @objc public func double(forKey defaultName: String) -> Double {
    return wrappedInstance.double(forKey: defaultName)
  }

  @objc public func float(forKey defaultName: String) -> Float {
    return wrappedInstance.float(forKey: defaultName)
  }

  @objc public func integer(forKey defaultName: String) -> Int {
    return wrappedInstance.integer(forKey: defaultName)
  }

  @objc public func objectIsForced(forKey key: String) -> Bool {
    return wrappedInstance.objectIsForced(forKey: key)
  }

  @objc public func objectIsForced(forKey key: String, inDomain domain: String) -> Bool {
    return wrappedInstance.objectIsForced(forKey: key, inDomain: domain)
  }

  @objc public func removeObject(forKey defaultName: String) {
    return wrappedInstance.removeObject(forKey: defaultName)
  }

  @objc public func removePersistentDomain(forName domainName: String) {
    return wrappedInstance.removePersistentDomain(forName: domainName)
  }

  @objc public func removeSuite(named suiteName: String) {
    return wrappedInstance.removeSuite(named: suiteName)
  }

  @objc public func removeVolatileDomain(forName domainName: String) {
    return wrappedInstance.removeVolatileDomain(forName: domainName)
  }

  @objc public func set(_ value: Float, forKey defaultName: String) {
    return wrappedInstance.set(value, forKey: defaultName)
  }

  @objc public func string(forKey defaultName: String) -> String? {
    return wrappedInstance.string(forKey: defaultName)
  }

  @objc public func synchronize() -> Bool {
    return wrappedInstance.synchronize()
  }

}

@available(macOS, introduced: 10.8, deprecated: 11.0)
@objc public class NSUserNotificationWrapper: NSObject {
  var wrappedInstance: NSUserNotification

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public var actionButtonTitle: String {
    get {
      wrappedInstance.actionButtonTitle
    }
    set {
      wrappedInstance.actionButtonTitle = newValue
    }
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public var actualDeliveryDate: DateWrapper? {
    get {
      wrappedInstance.actualDeliveryDate == nil ? nil : DateWrapper(wrappedInstance.actualDeliveryDate!)
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 11.0)
  @objc public var additionalActivationAction: NSUserNotificationActionWrapper? {
    get {
      wrappedInstance.additionalActivationAction == nil ? nil : NSUserNotificationActionWrapper(wrappedInstance.additionalActivationAction!)
    }
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public var deliveryDate: DateWrapper? {
    get {
      wrappedInstance.deliveryDate == nil ? nil : DateWrapper(wrappedInstance.deliveryDate!)
    }
    set {
      wrappedInstance.deliveryDate = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public var deliveryRepeatInterval: DateComponentsWrapper? {
    get {
      wrappedInstance.deliveryRepeatInterval == nil ? nil : DateComponentsWrapper(wrappedInstance.deliveryRepeatInterval!)
    }
    set {
      wrappedInstance.deliveryRepeatInterval = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public var deliveryTimeZone: TimeZoneWrapper? {
    get {
      wrappedInstance.deliveryTimeZone == nil ? nil : TimeZoneWrapper(wrappedInstance.deliveryTimeZone!)
    }
    set {
      wrappedInstance.deliveryTimeZone = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public var hasActionButton: Bool {
    get {
      wrappedInstance.hasActionButton
    }
    set {
      wrappedInstance.hasActionButton = newValue
    }
  }

  @available(macOS, introduced: 10.9, deprecated: 11.0)
  @objc public var hasReplyButton: Bool {
    get {
      wrappedInstance.hasReplyButton
    }
    set {
      wrappedInstance.hasReplyButton = newValue
    }
  }

  @available(macOS, introduced: 10.9, deprecated: 11.0)
  @objc public var identifier: String? {
    get {
      wrappedInstance.identifier
    }
    set {
      wrappedInstance.identifier = newValue
    }
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public var informativeText: String? {
    get {
      wrappedInstance.informativeText
    }
    set {
      wrappedInstance.informativeText = newValue
    }
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public var otherButtonTitle: String {
    get {
      wrappedInstance.otherButtonTitle
    }
    set {
      wrappedInstance.otherButtonTitle = newValue
    }
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public var isPresented: Bool {
    get {
      wrappedInstance.isPresented
    }
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public var isRemote: Bool {
    get {
      wrappedInstance.isRemote
    }
  }

  @available(macOS, introduced: 10.9, deprecated: 11.0)
  @objc public var response: NSAttributedStringWrapper? {
    get {
      wrappedInstance.response == nil ? nil : NSAttributedStringWrapper(wrappedInstance.response!)
    }
  }

  @available(macOS, introduced: 10.9, deprecated: 11.0)
  @objc public var responsePlaceholder: String? {
    get {
      wrappedInstance.responsePlaceholder
    }
    set {
      wrappedInstance.responsePlaceholder = newValue
    }
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public var soundName: String? {
    get {
      wrappedInstance.soundName
    }
    set {
      wrappedInstance.soundName = newValue
    }
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public var subtitle: String? {
    get {
      wrappedInstance.subtitle
    }
    set {
      wrappedInstance.subtitle = newValue
    }
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public var title: String? {
    get {
      wrappedInstance.title
    }
    set {
      wrappedInstance.title = newValue
    }
  }

  init(_ wrappedInstance: NSUserNotification) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc override init() {
    wrappedInstance = NSUserNotification()
  }

}

@available(macOS, introduced: 10.10, deprecated: 11.0)
@objc public class NSUserNotificationActionWrapper: NSObject {
  var wrappedInstance: NSUserNotificationAction

  @available(macOS, introduced: 10.10, deprecated: 11.0)
  @objc public var identifier: String? {
    get {
      wrappedInstance.identifier
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 11.0)
  @objc public var title: String? {
    get {
      wrappedInstance.title
    }
  }

  init(_ wrappedInstance: NSUserNotificationAction) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.8, deprecated: 11.0)
@objc public class NSUserNotificationCenterWrapper: NSObject {
  var wrappedInstance: NSUserNotificationCenter

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc static public var `default`: NSUserNotificationCenterWrapper {
    get {
      NSUserNotificationCenterWrapper(NSUserNotificationCenter.`default`)
    }
  }

  init(_ wrappedInstance: NSUserNotificationCenter) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public func deliver(_ notification: NSUserNotificationWrapper) {
    return wrappedInstance.deliver(notification.wrappedInstance)
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public func removeAllDeliveredNotifications() {
    return wrappedInstance.removeAllDeliveredNotifications()
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public func removeDeliveredNotification(_ notification: NSUserNotificationWrapper) {
    return wrappedInstance.removeDeliveredNotification(notification.wrappedInstance)
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public func removeScheduledNotification(_ notification: NSUserNotificationWrapper) {
    return wrappedInstance.removeScheduledNotification(notification.wrappedInstance)
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc public func scheduleNotification(_ notification: NSUserNotificationWrapper) {
    return wrappedInstance.scheduleNotification(notification.wrappedInstance)
  }

}

@available(macOS, introduced: 10.8)
@objc public class NSUserScriptTaskWrapper: NSObject {
  var wrappedInstance: NSUserScriptTask

  @available(macOS, introduced: 10.8)
  @objc public var scriptURL: URLWrapper {
    get {
      URLWrapper(wrappedInstance.scriptURL)
    }
  }

  init(_ wrappedInstance: NSUserScriptTask) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.8)
  @objc init(url: URLWrapper) throws {
    wrappedInstance = try NSUserScriptTask(url: url.wrappedInstance)
  }

}

@available(macOS, introduced: 10.8)
@objc public class NSUserUnixTaskWrapper: NSObject {
  var wrappedInstance: NSUserUnixTask

  @available(macOS, introduced: 10.8)
  @objc public var standardError: FileHandleWrapper? {
    get {
      wrappedInstance.standardError == nil ? nil : FileHandleWrapper(wrappedInstance.standardError!)
    }
    set {
      wrappedInstance.standardError = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var standardInput: FileHandleWrapper? {
    get {
      wrappedInstance.standardInput == nil ? nil : FileHandleWrapper(wrappedInstance.standardInput!)
    }
    set {
      wrappedInstance.standardInput = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var standardOutput: FileHandleWrapper? {
    get {
      wrappedInstance.standardOutput == nil ? nil : FileHandleWrapper(wrappedInstance.standardOutput!)
    }
    set {
      wrappedInstance.standardOutput = newValue?.wrappedInstance
    }
  }

  init(_ wrappedInstance: NSUserUnixTask) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class NSValueWrapper: NSObject {
  var wrappedInstance: NSValue

  @available(macOS, introduced: 10.10)
  @objc public var edgeInsetsValue: NSEdgeInsetsWrapper {
    get {
      NSEdgeInsetsWrapper(wrappedInstance.edgeInsetsValue)
    }
  }

  init(_ wrappedInstance: NSValue) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @objc init(edgeInsets insets: NSEdgeInsetsWrapper) {
    wrappedInstance = NSValue(edgeInsets: insets.wrappedInstance)
  }

  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSValue(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc public func isEqual(to value: NSValueWrapper) -> Bool {
    return wrappedInstance.isEqual(to: value.wrappedInstance)
  }

}

@available(macOS, introduced: 10.3)
@objc public class ValueTransformerWrapper: NSObject {
  var wrappedInstance: ValueTransformer

  init(_ wrappedInstance: ValueTransformer) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.3)
  @objc init?(forName name: NSValueTransformerNameWrapper) {
    if let instance = ValueTransformer(forName: name.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.3)
  @objc static public func allowsReverseTransformation() -> Bool {
    return ValueTransformer.allowsReverseTransformation()
  }

  @available(macOS, introduced: 10.3)
  @objc static public func setValueTransformer(_ transformer: ValueTransformerWrapper?, forName name: NSValueTransformerNameWrapper) {
    return ValueTransformer.setValueTransformer(transformer?.wrappedInstance, forName: name.wrappedInstance)
  }

}

@objc public class NSWhoseSpecifierWrapper: NSObject {
  var wrappedInstance: NSWhoseSpecifier

  @objc public var endSubelementIndex: Int {
    get {
      wrappedInstance.endSubelementIndex
    }
    set {
      wrappedInstance.endSubelementIndex = newValue
    }
  }

  @objc public var startSubelementIndex: Int {
    get {
      wrappedInstance.startSubelementIndex
    }
    set {
      wrappedInstance.startSubelementIndex = newValue
    }
  }

  @objc public var test: NSScriptWhoseTestWrapper {
    get {
      NSScriptWhoseTestWrapper(wrappedInstance.test)
    }
    set {
      wrappedInstance.test = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: NSWhoseSpecifier) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init?(coder inCoder: NSCoderWrapper) {
    if let instance = NSWhoseSpecifier(coder: inCoder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @objc init(containerClassDescription classDesc: NSScriptClassDescriptionWrapper, containerSpecifier container: NSScriptObjectSpecifierWrapper?, key property: String, test: NSScriptWhoseTestWrapper) {
    wrappedInstance = NSWhoseSpecifier(containerClassDescription: classDesc.wrappedInstance, containerSpecifier: container?.wrappedInstance, key: property, test: test.wrappedInstance)
  }

}

@objc public class XMLDTDWrapper: NSObject {
  var wrappedInstance: XMLDTD

  @objc public var publicID: String? {
    get {
      wrappedInstance.publicID
    }
    set {
      wrappedInstance.publicID = newValue
    }
  }

  @objc public var systemID: String? {
    get {
      wrappedInstance.systemID
    }
    set {
      wrappedInstance.systemID = newValue
    }
  }

  init(_ wrappedInstance: XMLDTD) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = XMLDTD()
  }

  @objc static public func predefinedEntityDeclaration(forName name: String) -> XMLDTDNodeWrapper? {
    let result = XMLDTD.predefinedEntityDeclaration(forName: name)
    return result == nil ? nil : XMLDTDNodeWrapper(result!)
  }

  @objc public func addChild(_ child: XMLNodeWrapper) {
    return wrappedInstance.addChild(child.wrappedInstance)
  }

  @objc public func attributeDeclaration(forName name: String, elementName: String) -> XMLDTDNodeWrapper? {
    let result = wrappedInstance.attributeDeclaration(forName: name, elementName: elementName)
    return result == nil ? nil : XMLDTDNodeWrapper(result!)
  }

  @objc public func elementDeclaration(forName name: String) -> XMLDTDNodeWrapper? {
    let result = wrappedInstance.elementDeclaration(forName: name)
    return result == nil ? nil : XMLDTDNodeWrapper(result!)
  }

  @objc public func entityDeclaration(forName name: String) -> XMLDTDNodeWrapper? {
    let result = wrappedInstance.entityDeclaration(forName: name)
    return result == nil ? nil : XMLDTDNodeWrapper(result!)
  }

  @objc public func insertChild(_ child: XMLNodeWrapper, at index: Int) {
    return wrappedInstance.insertChild(child.wrappedInstance, at: index)
  }

  @objc public func notationDeclaration(forName name: String) -> XMLDTDNodeWrapper? {
    let result = wrappedInstance.notationDeclaration(forName: name)
    return result == nil ? nil : XMLDTDNodeWrapper(result!)
  }

  @objc public func removeChild(at index: Int) {
    return wrappedInstance.removeChild(at: index)
  }

  @objc public func replaceChild(at index: Int, with node: XMLNodeWrapper) {
    return wrappedInstance.replaceChild(at: index, with: node.wrappedInstance)
  }

}

@objc public class XMLDTDNodeWrapper: NSObject {
  var wrappedInstance: XMLDTDNode

  @objc public var isExternal: Bool {
    get {
      wrappedInstance.isExternal
    }
  }

  @objc public var notationName: String? {
    get {
      wrappedInstance.notationName
    }
    set {
      wrappedInstance.notationName = newValue
    }
  }

  @objc public var publicID: String? {
    get {
      wrappedInstance.publicID
    }
    set {
      wrappedInstance.publicID = newValue
    }
  }

  @objc public var systemID: String? {
    get {
      wrappedInstance.systemID
    }
    set {
      wrappedInstance.systemID = newValue
    }
  }

  init(_ wrappedInstance: XMLDTDNode) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = XMLDTDNode()
  }

  @objc init?(xmlString string: String) {
    if let instance = XMLDTDNode(xmlString: string) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@objc public class XMLDocumentWrapper: NSObject {
  var wrappedInstance: XMLDocument

  @objc public var dtd: XMLDTDWrapper? {
    get {
      wrappedInstance.dtd == nil ? nil : XMLDTDWrapper(wrappedInstance.dtd!)
    }
    set {
      wrappedInstance.dtd = newValue?.wrappedInstance
    }
  }

  @objc public var mimeType: String? {
    get {
      wrappedInstance.mimeType
    }
    set {
      wrappedInstance.mimeType = newValue
    }
  }

  @objc public var xmlData: DataWrapper {
    get {
      DataWrapper(wrappedInstance.xmlData)
    }
  }

  @objc public var characterEncoding: String? {
    get {
      wrappedInstance.characterEncoding
    }
    set {
      wrappedInstance.characterEncoding = newValue
    }
  }

  @objc public var isStandalone: Bool {
    get {
      wrappedInstance.isStandalone
    }
    set {
      wrappedInstance.isStandalone = newValue
    }
  }

  @objc public var version: String? {
    get {
      wrappedInstance.version
    }
    set {
      wrappedInstance.version = newValue
    }
  }

  init(_ wrappedInstance: XMLDocument) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = XMLDocument()
  }

  @objc init(rootElement element: XMLElementWrapper?) {
    wrappedInstance = XMLDocument(rootElement: element?.wrappedInstance)
  }

  @objc public func addChild(_ child: XMLNodeWrapper) {
    return wrappedInstance.addChild(child.wrappedInstance)
  }

  @objc public func insertChild(_ child: XMLNodeWrapper, at index: Int) {
    return wrappedInstance.insertChild(child.wrappedInstance, at: index)
  }

  @objc public func removeChild(at index: Int) {
    return wrappedInstance.removeChild(at: index)
  }

  @objc public func replaceChild(at index: Int, with node: XMLNodeWrapper) {
    return wrappedInstance.replaceChild(at: index, with: node.wrappedInstance)
  }

  @objc public func rootElement() -> XMLElementWrapper? {
    let result = wrappedInstance.rootElement()
    return result == nil ? nil : XMLElementWrapper(result!)
  }

  @objc public func setRootElement(_ root: XMLElementWrapper) {
    return wrappedInstance.setRootElement(root.wrappedInstance)
  }

  @objc public func validate() throws {
    return try wrappedInstance.validate()
  }

}

@objc public class XMLElementWrapper: NSObject {
  var wrappedInstance: XMLElement

  init(_ wrappedInstance: XMLElement) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(name: String, uri URI: String?) {
    wrappedInstance = XMLElement(name: name, uri: URI)
  }

  @objc init(xmlString string: String) throws {
    wrappedInstance = try XMLElement(xmlString: string)
  }

  @objc public func addAttribute(_ attribute: XMLNodeWrapper) {
    return wrappedInstance.addAttribute(attribute.wrappedInstance)
  }

  @objc public func addChild(_ child: XMLNodeWrapper) {
    return wrappedInstance.addChild(child.wrappedInstance)
  }

  @objc public func addNamespace(_ aNamespace: XMLNodeWrapper) {
    return wrappedInstance.addNamespace(aNamespace.wrappedInstance)
  }

  @objc public func attribute(forLocalName localName: String, uri URI: String?) -> XMLNodeWrapper? {
    let result = wrappedInstance.attribute(forLocalName: localName, uri: URI)
    return result == nil ? nil : XMLNodeWrapper(result!)
  }

  @objc public func attribute(forName name: String) -> XMLNodeWrapper? {
    let result = wrappedInstance.attribute(forName: name)
    return result == nil ? nil : XMLNodeWrapper(result!)
  }

  @objc public func insertChild(_ child: XMLNodeWrapper, at index: Int) {
    return wrappedInstance.insertChild(child.wrappedInstance, at: index)
  }

  @objc public func namespace(forPrefix name: String) -> XMLNodeWrapper? {
    let result = wrappedInstance.namespace(forPrefix: name)
    return result == nil ? nil : XMLNodeWrapper(result!)
  }

  @objc public func normalizeAdjacentTextNodesPreservingCDATA(_ preserve: Bool) {
    return wrappedInstance.normalizeAdjacentTextNodesPreservingCDATA(preserve)
  }

  @objc public func removeAttribute(forName name: String) {
    return wrappedInstance.removeAttribute(forName: name)
  }

  @objc public func removeChild(at index: Int) {
    return wrappedInstance.removeChild(at: index)
  }

  @objc public func removeNamespace(forPrefix name: String) {
    return wrappedInstance.removeNamespace(forPrefix: name)
  }

  @objc public func replaceChild(at index: Int, with node: XMLNodeWrapper) {
    return wrappedInstance.replaceChild(at: index, with: node.wrappedInstance)
  }

  @objc public func resolveNamespace(forName name: String) -> XMLNodeWrapper? {
    let result = wrappedInstance.resolveNamespace(forName: name)
    return result == nil ? nil : XMLNodeWrapper(result!)
  }

  @objc public func resolvePrefix(forNamespaceURI namespaceURI: String) -> String? {
    return wrappedInstance.resolvePrefix(forNamespaceURI: namespaceURI)
  }

}

@objc public class XMLNodeWrapper: NSObject {
  var wrappedInstance: XMLNode

  @objc public var uri: String? {
    get {
      wrappedInstance.uri
    }
    set {
      wrappedInstance.uri = newValue
    }
  }

  @objc public var xmlString: String {
    get {
      wrappedInstance.xmlString
    }
  }

  @objc public var xPath: String? {
    get {
      wrappedInstance.xPath
    }
  }

  @objc public var childCount: Int {
    get {
      wrappedInstance.childCount
    }
  }

  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @objc public var index: Int {
    get {
      wrappedInstance.index
    }
  }

  @objc public var level: Int {
    get {
      wrappedInstance.level
    }
  }

  @objc public var localName: String? {
    get {
      wrappedInstance.localName
    }
  }

  @objc public var name: String? {
    get {
      wrappedInstance.name
    }
    set {
      wrappedInstance.name = newValue
    }
  }

  @objc public var next: XMLNodeWrapper? {
    get {
      wrappedInstance.next == nil ? nil : XMLNodeWrapper(wrappedInstance.next!)
    }
  }

  @objc public var nextSibling: XMLNodeWrapper? {
    get {
      wrappedInstance.nextSibling == nil ? nil : XMLNodeWrapper(wrappedInstance.nextSibling!)
    }
  }

  @objc public var parent: XMLNodeWrapper? {
    get {
      wrappedInstance.parent == nil ? nil : XMLNodeWrapper(wrappedInstance.parent!)
    }
  }

  @objc public var prefix: String? {
    get {
      wrappedInstance.prefix
    }
  }

  @objc public var previous: XMLNodeWrapper? {
    get {
      wrappedInstance.previous == nil ? nil : XMLNodeWrapper(wrappedInstance.previous!)
    }
  }

  @objc public var previousSibling: XMLNodeWrapper? {
    get {
      wrappedInstance.previousSibling == nil ? nil : XMLNodeWrapper(wrappedInstance.previousSibling!)
    }
  }

  @objc public var rootDocument: XMLDocumentWrapper? {
    get {
      wrappedInstance.rootDocument == nil ? nil : XMLDocumentWrapper(wrappedInstance.rootDocument!)
    }
  }

  @objc public var stringValue: String? {
    get {
      wrappedInstance.stringValue
    }
    set {
      wrappedInstance.stringValue = newValue
    }
  }

  init(_ wrappedInstance: XMLNode) {
    self.wrappedInstance = wrappedInstance
  }

  @objc override init() {
    wrappedInstance = XMLNode()
  }

  @objc static public func localName(forName name: String) -> String {
    return XMLNode.localName(forName: name)
  }

  @objc static public func predefinedNamespace(forPrefix name: String) -> XMLNodeWrapper? {
    let result = XMLNode.predefinedNamespace(forPrefix: name)
    return result == nil ? nil : XMLNodeWrapper(result!)
  }

  @objc static public func prefix(forName name: String) -> String? {
    return XMLNode.prefix(forName: name)
  }

  @objc public func canonicalXMLStringPreservingComments(_ comments: Bool) -> String {
    return wrappedInstance.canonicalXMLStringPreservingComments(comments)
  }

  @objc public func child(at index: Int) -> XMLNodeWrapper? {
    let result = wrappedInstance.child(at: index)
    return result == nil ? nil : XMLNodeWrapper(result!)
  }

  @objc public func detach() {
    return wrappedInstance.detach()
  }

  @objc public func setStringValue(_ string: String, resolvingEntities resolve: Bool) {
    return wrappedInstance.setStringValue(string, resolvingEntities: resolve)
  }

  @objc public class OptionsWrapper: NSObject {
    var wrappedInstance: XMLNode.Options

    @objc static public var documentIncludeContentTypeDeclaration: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.documentIncludeContentTypeDeclaration)
      }
    }

    @objc static public var documentTidyHTML: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.documentTidyHTML)
      }
    }

    @objc static public var documentTidyXML: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.documentTidyXML)
      }
    }

    @objc static public var documentValidate: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.documentValidate)
      }
    }

    @objc static public var documentXInclude: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.documentXInclude)
      }
    }

    @objc static public var nodeCompactEmptyElement: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodeCompactEmptyElement)
      }
    }

    @objc static public var nodeExpandEmptyElement: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodeExpandEmptyElement)
      }
    }

    @objc static public var nodeIsCDATA: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodeIsCDATA)
      }
    }

    @objc static public var nodeLoadExternalEntitiesAlways: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodeLoadExternalEntitiesAlways)
      }
    }

    @objc static public var nodeLoadExternalEntitiesNever: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodeLoadExternalEntitiesNever)
      }
    }

    @objc static public var nodeLoadExternalEntitiesSameOriginOnly: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodeLoadExternalEntitiesSameOriginOnly)
      }
    }

    @objc static public var nodeNeverEscapeContents: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodeNeverEscapeContents)
      }
    }

    @objc static public var nodePreserveAll: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodePreserveAll)
      }
    }

    @objc static public var nodePreserveAttributeOrder: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodePreserveAttributeOrder)
      }
    }

    @objc static public var nodePreserveCDATA: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodePreserveCDATA)
      }
    }

    @objc static public var nodePreserveCharacterReferences: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodePreserveCharacterReferences)
      }
    }

    @objc static public var nodePreserveDTD: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodePreserveDTD)
      }
    }

    @objc static public var nodePreserveEmptyElements: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodePreserveEmptyElements)
      }
    }

    @objc static public var nodePreserveEntities: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodePreserveEntities)
      }
    }

    @objc static public var nodePreserveNamespaceOrder: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodePreserveNamespaceOrder)
      }
    }

    @objc static public var nodePreservePrefixes: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodePreservePrefixes)
      }
    }

    @objc static public var nodePreserveQuotes: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodePreserveQuotes)
      }
    }

    @objc static public var nodePreserveWhitespace: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodePreserveWhitespace)
      }
    }

    @objc static public var nodePrettyPrint: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodePrettyPrint)
      }
    }

    @objc static public var nodePromoteSignificantWhitespace: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodePromoteSignificantWhitespace)
      }
    }

    @objc static public var nodeUseDoubleQuotes: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodeUseDoubleQuotes)
      }
    }

    @objc static public var nodeUseSingleQuotes: XMLNodeWrapper.OptionsWrapper {
      get {
        OptionsWrapper(XMLNode.Options.nodeUseSingleQuotes)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: XMLNode.Options) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = XMLNode.Options()
    }

  }

}

@objc public class XMLParserWrapper: NSObject {
  var wrappedInstance: XMLParser

  @available(macOS, introduced: 10.3)
  @objc static public var errorDomain: String {
    get {
      XMLParser.errorDomain
    }
  }

  @objc public var columnNumber: Int {
    get {
      wrappedInstance.columnNumber
    }
  }

  @objc public var lineNumber: Int {
    get {
      wrappedInstance.lineNumber
    }
  }

  @objc public var publicID: String? {
    get {
      wrappedInstance.publicID
    }
  }

  @objc public var shouldProcessNamespaces: Bool {
    get {
      wrappedInstance.shouldProcessNamespaces
    }
    set {
      wrappedInstance.shouldProcessNamespaces = newValue
    }
  }

  @objc public var shouldReportNamespacePrefixes: Bool {
    get {
      wrappedInstance.shouldReportNamespacePrefixes
    }
    set {
      wrappedInstance.shouldReportNamespacePrefixes = newValue
    }
  }

  @objc public var shouldResolveExternalEntities: Bool {
    get {
      wrappedInstance.shouldResolveExternalEntities
    }
    set {
      wrappedInstance.shouldResolveExternalEntities = newValue
    }
  }

  @objc public var systemID: String? {
    get {
      wrappedInstance.systemID
    }
  }

  init(_ wrappedInstance: XMLParser) {
    self.wrappedInstance = wrappedInstance
  }

  @objc init(data: DataWrapper) {
    wrappedInstance = XMLParser(data: data.wrappedInstance)
  }

  @objc public func abortParsing() {
    return wrappedInstance.abortParsing()
  }

  @objc public func parse() -> Bool {
    return wrappedInstance.parse()
  }

}

@available(macOS, introduced: 10.8)
@objc public class NSXPCCoderWrapper: NSObject {
  var wrappedInstance: NSXPCCoder

  @available(macOS, introduced: 10.12)
  @objc public var connection: NSXPCConnectionWrapper? {
    get {
      wrappedInstance.connection == nil ? nil : NSXPCConnectionWrapper(wrappedInstance.connection!)
    }
  }

  init(_ wrappedInstance: NSXPCCoder) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.8)
@objc public class NSXPCConnectionWrapper: NSObject {
  var wrappedInstance: NSXPCConnection

  @available(macOS, introduced: 10.8)
  @objc public var endpoint: NSXPCListenerEndpointWrapper {
    get {
      NSXPCListenerEndpointWrapper(wrappedInstance.endpoint)
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var exportedInterface: NSXPCInterfaceWrapper? {
    get {
      wrappedInstance.exportedInterface == nil ? nil : NSXPCInterfaceWrapper(wrappedInstance.exportedInterface!)
    }
    set {
      wrappedInstance.exportedInterface = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var remoteObjectInterface: NSXPCInterfaceWrapper? {
    get {
      wrappedInstance.remoteObjectInterface == nil ? nil : NSXPCInterfaceWrapper(wrappedInstance.remoteObjectInterface!)
    }
    set {
      wrappedInstance.remoteObjectInterface = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.8)
  @objc public var serviceName: String? {
    get {
      wrappedInstance.serviceName
    }
  }

  init(_ wrappedInstance: NSXPCConnection) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.8)
  @objc init(listenerEndpoint endpoint: NSXPCListenerEndpointWrapper) {
    wrappedInstance = NSXPCConnection(listenerEndpoint: endpoint.wrappedInstance)
  }

  @available(macOS, introduced: 10.8)
  @objc init(serviceName: String) {
    wrappedInstance = NSXPCConnection(serviceName: serviceName)
  }

  @available(macOS, introduced: 10.8)
  @objc static public func current() -> NSXPCConnectionWrapper? {
    let result = NSXPCConnection.current()
    return result == nil ? nil : NSXPCConnectionWrapper(result!)
  }

  @available(macOS, introduced: 11.0)
  @objc public func activate() {
    return wrappedInstance.activate()
  }

  @available(macOS, introduced: 10.8)
  @objc public func invalidate() {
    return wrappedInstance.invalidate()
  }

  @available(macOS, introduced: 10.8)
  @objc public func resume() {
    return wrappedInstance.resume()
  }

  @available(macOS, introduced: 13.0)
  @objc public func setCodeSigningRequirement(_ requirement: String) {
    return wrappedInstance.setCodeSigningRequirement(requirement)
  }

  @available(macOS, introduced: 10.8)
  @objc public func suspend() {
    return wrappedInstance.suspend()
  }

  @available(macOS, introduced: 10.8)
  @objc public class OptionsWrapper: NSObject {
    var wrappedInstance: NSXPCConnection.Options

    @available(macOS, introduced: 10.8)
    @objc static public var privileged: NSXPCConnectionWrapper.OptionsWrapper {
      get {
        OptionsWrapper(NSXPCConnection.Options.privileged)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: NSXPCConnection.Options) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = NSXPCConnection.Options()
    }

  }

}

@available(macOS, introduced: 10.8)
@objc public class NSXPCInterfaceWrapper: NSObject {
  var wrappedInstance: NSXPCInterface

  init(_ wrappedInstance: NSXPCInterface) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.8)
@objc public class NSXPCListenerWrapper: NSObject {
  var wrappedInstance: NSXPCListener

  @available(macOS, introduced: 10.8)
  @objc public var endpoint: NSXPCListenerEndpointWrapper {
    get {
      NSXPCListenerEndpointWrapper(wrappedInstance.endpoint)
    }
  }

  init(_ wrappedInstance: NSXPCListener) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.8)
  @objc init(machServiceName name: String) {
    wrappedInstance = NSXPCListener(machServiceName: name)
  }

  @available(macOS, introduced: 10.8)
  @objc static public func anonymous() -> NSXPCListenerWrapper {
    let result = NSXPCListener.anonymous()
    return NSXPCListenerWrapper(result)
  }

  @available(macOS, introduced: 10.8)
  @objc static public func service() -> NSXPCListenerWrapper {
    let result = NSXPCListener.service()
    return NSXPCListenerWrapper(result)
  }

  @available(macOS, introduced: 11.0)
  @objc public func activate() {
    return wrappedInstance.activate()
  }

  @available(macOS, introduced: 10.8)
  @objc public func invalidate() {
    return wrappedInstance.invalidate()
  }

  @available(macOS, introduced: 10.8)
  @objc public func resume() {
    return wrappedInstance.resume()
  }

  @available(macOS, introduced: 13.0)
  @objc public func setConnectionCodeSigningRequirement(_ requirement: String) {
    return wrappedInstance.setConnectionCodeSigningRequirement(requirement)
  }

  @available(macOS, introduced: 10.8)
  @objc public func suspend() {
    return wrappedInstance.suspend()
  }

}

@available(macOS, introduced: 10.8)
@objc public class NSXPCListenerEndpointWrapper: NSObject {
  var wrappedInstance: NSXPCListenerEndpoint

  init(_ wrappedInstance: NSXPCListenerEndpoint) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.8)
  @objc init?(coder: NSCoderWrapper) {
    if let instance = NSXPCListenerEndpoint(coder: coder.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

}

@objc public class GlobalsWrapper: NSObject {
  @available(macOS, introduced: 11.0)
  @objc static public var NSBundleExecutableArchitectureARM64Wrapper: Int {
    get {
      NSBundleExecutableArchitectureARM64
    }
  }

  @objc static public var NSBundleExecutableArchitectureI386Wrapper: Int {
    get {
      NSBundleExecutableArchitectureI386
    }
  }

  @objc static public var NSBundleExecutableArchitecturePPCWrapper: Int {
    get {
      NSBundleExecutableArchitecturePPC
    }
  }

  @objc static public var NSBundleExecutableArchitecturePPC64Wrapper: Int {
    get {
      NSBundleExecutableArchitecturePPC64
    }
  }

  @objc static public var NSBundleExecutableArchitectureX86_64Wrapper: Int {
    get {
      NSBundleExecutableArchitectureX86_64
    }
  }

  @objc static public var NSDateComponentUndefinedWrapper: Int {
    get {
      NSDateComponentUndefined
    }
  }

  @available(macOS, introduced: 10.4, deprecated: 10.10)
  @objc static public var NSUndefinedDateComponentWrapper: Int {
    get {
      NSUndefinedDateComponent
    }
  }

  @objc static public var NSArgumentEvaluationScriptErrorWrapper: Int {
    get {
      NSArgumentEvaluationScriptError
    }
  }

  @objc static public var NSArgumentsWrongScriptErrorWrapper: Int {
    get {
      NSArgumentsWrongScriptError
    }
  }

  @objc static public var NSCannotCreateScriptCommandErrorWrapper: Int {
    get {
      NSCannotCreateScriptCommandError
    }
  }

  @objc static public var NSInternalScriptErrorWrapper: Int {
    get {
      NSInternalScriptError
    }
  }

  @objc static public var NSKeySpecifierEvaluationScriptErrorWrapper: Int {
    get {
      NSKeySpecifierEvaluationScriptError
    }
  }

  @objc static public var NSNoScriptErrorWrapper: Int {
    get {
      NSNoScriptError
    }
  }

  @objc static public var NSOperationNotSupportedForKeyScriptErrorWrapper: Int {
    get {
      NSOperationNotSupportedForKeyScriptError
    }
  }

  @objc static public var NSReceiverEvaluationScriptErrorWrapper: Int {
    get {
      NSReceiverEvaluationScriptError
    }
  }

  @objc static public var NSReceiversCantHandleCommandScriptErrorWrapper: Int {
    get {
      NSReceiversCantHandleCommandScriptError
    }
  }

  @objc static public var NSRequiredArgumentsMissingScriptErrorWrapper: Int {
    get {
      NSRequiredArgumentsMissingScriptError
    }
  }

  @objc static public var NSUnknownKeyScriptErrorWrapper: Int {
    get {
      NSUnknownKeyScriptError
    }
  }

  @objc static public var NSContainerSpecifierErrorWrapper: Int {
    get {
      NSContainerSpecifierError
    }
  }

  @objc static public var NSInternalSpecifierErrorWrapper: Int {
    get {
      NSInternalSpecifierError
    }
  }

  @objc static public var NSInvalidIndexSpecifierErrorWrapper: Int {
    get {
      NSInvalidIndexSpecifierError
    }
  }

  @objc static public var NSNoSpecifierErrorWrapper: Int {
    get {
      NSNoSpecifierError
    }
  }

  @objc static public var NSNoTopLevelContainersSpecifierErrorWrapper: Int {
    get {
      NSNoTopLevelContainersSpecifierError
    }
  }

  @objc static public var NSOperationNotSupportedForKeySpecifierErrorWrapper: Int {
    get {
      NSOperationNotSupportedForKeySpecifierError
    }
  }

  @objc static public var NSUnknownKeySpecifierErrorWrapper: Int {
    get {
      NSUnknownKeySpecifierError
    }
  }

  @objc static public var NSOpenStepUnicodeReservedBaseWrapper: Int {
    get {
      NSOpenStepUnicodeReservedBase
    }
  }

  @objc static public var NSCollectorDisabledOptionWrapper: Int {
    get {
      NSCollectorDisabledOption
    }
  }

  @objc static public var NSScannedOptionWrapper: Int {
    get {
      NSScannedOption
    }
  }

  @objc static public var NSURLErrorCancelledReasonBackgroundUpdatesDisabledWrapper: Int {
    get {
      NSURLErrorCancelledReasonBackgroundUpdatesDisabled
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSURLErrorCancelledReasonInsufficientSystemResourcesWrapper: Int {
    get {
      NSURLErrorCancelledReasonInsufficientSystemResources
    }
  }

  @objc static public var NSURLErrorCancelledReasonUserForceQuitApplicationWrapper: Int {
    get {
      NSURLErrorCancelledReasonUserForceQuitApplication
    }
  }

  @available(macOS, introduced: 10.8)
  @objc static public var NSUbiquitousKeyValueStoreAccountChangeWrapper: Int {
    get {
      NSUbiquitousKeyValueStoreAccountChange
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSUbiquitousKeyValueStoreInitialSyncChangeWrapper: Int {
    get {
      NSUbiquitousKeyValueStoreInitialSyncChange
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSUbiquitousKeyValueStoreQuotaViolationChangeWrapper: Int {
    get {
      NSUbiquitousKeyValueStoreQuotaViolationChange
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSUbiquitousKeyValueStoreServerChangeWrapper: Int {
    get {
      NSUbiquitousKeyValueStoreServerChange
    }
  }

  @objc static public var NSHPUXOperatingSystemWrapper: Int {
    get {
      NSHPUXOperatingSystem
    }
  }

  @objc static public var NSMACHOperatingSystemWrapper: Int {
    get {
      NSMACHOperatingSystem
    }
  }

  @objc static public var NSOSF1OperatingSystemWrapper: Int {
    get {
      NSOSF1OperatingSystem
    }
  }

  @objc static public var NSSolarisOperatingSystemWrapper: Int {
    get {
      NSSolarisOperatingSystem
    }
  }

  @objc static public var NSSunOSOperatingSystemWrapper: Int {
    get {
      NSSunOSOperatingSystem
    }
  }

  @objc static public var NSWindows95OperatingSystemWrapper: Int {
    get {
      NSWindows95OperatingSystem
    }
  }

  @objc static public var NSWindowsNTOperatingSystemWrapper: Int {
    get {
      NSWindowsNTOperatingSystem
    }
  }

  @available(macOS, introduced: 10.4, deprecated: 10.10)
  @objc static public var NSWrapCalendarComponentsWrapper: Int {
    get {
      NSWrapCalendarComponents
    }
  }

  @objc static public var NS_BigEndianWrapper: Int {
    get {
      NS_BigEndian
    }
  }

  @objc static public var NS_LittleEndianWrapper: Int {
    get {
      NS_LittleEndian
    }
  }

  @objc static public var NS_UnknownByteOrderWrapper: Int {
    get {
      NS_UnknownByteOrder
    }
  }

  @objc static public var NSAppleEventTimeOutDefaultWrapper: Double {
    get {
      NSAppleEventTimeOutDefault
    }
  }

  @objc static public var NSAppleEventTimeOutNoneWrapper: Double {
    get {
      NSAppleEventTimeOutNone
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var NSAssertionHandlerKeyWrapper: String {
    get {
      NSAssertionHandlerKey
    }
  }

  @available(macOS, introduced: 10.4, deprecated: 10.10)
  @objc static public var NSBuddhistCalendarWrapper: String {
    get {
      NSBuddhistCalendar
    }
  }

  @available(macOS, introduced: 10.4, deprecated: 10.10)
  @objc static public var NSChineseCalendarWrapper: String {
    get {
      NSChineseCalendar
    }
  }

  @objc static public var NSCocoaErrorDomainWrapper: String {
    get {
      NSCocoaErrorDomain
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSDebugDescriptionErrorKeyWrapper: String {
    get {
      NSDebugDescriptionErrorKey
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSEdgeInsetsZeroWrapper: NSEdgeInsetsWrapper {
    get {
      NSEdgeInsetsWrapper(NSEdgeInsetsZero)
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSExtensionItemAttachmentsKeyWrapper: String {
    get {
      NSExtensionItemAttachmentsKey
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSExtensionItemAttributedContentTextKeyWrapper: String {
    get {
      NSExtensionItemAttributedContentTextKey
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSExtensionItemAttributedTitleKeyWrapper: String {
    get {
      NSExtensionItemAttributedTitleKey
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSExtensionItemsAndErrorsKeyWrapper: String {
    get {
      NSExtensionItemsAndErrorsKey
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSExtensionJavaScriptPreprocessingResultsKeyWrapper: String {
    get {
      NSExtensionJavaScriptPreprocessingResultsKey
    }
  }

  @objc static public var NSFileHandleNotificationDataItemWrapper: String {
    get {
      NSFileHandleNotificationDataItem
    }
  }

  @objc static public var NSFileHandleNotificationFileHandleItemWrapper: String {
    get {
      NSFileHandleNotificationFileHandleItem
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSFileManagerUnmountDissentingProcessIdentifierErrorKeyWrapper: String {
    get {
      NSFileManagerUnmountDissentingProcessIdentifierErrorKey
    }
  }

  @objc static public var NSFilePathErrorKeyWrapper: String {
    get {
      NSFilePathErrorKey
    }
  }

  @objc static public var NSFoundationVersionNumberWrapper: Double {
    get {
      NSFoundationVersionNumber
    }
    set {
      NSFoundationVersionNumber = newValue
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSGrammarCorrectionsWrapper: String {
    get {
      NSGrammarCorrections
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSGrammarRangeWrapper: String {
    get {
      NSGrammarRange
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSGrammarUserDescriptionWrapper: String {
    get {
      NSGrammarUserDescription
    }
  }

  @available(macOS, introduced: 10.4, deprecated: 10.10)
  @objc static public var NSGregorianCalendarWrapper: String {
    get {
      NSGregorianCalendar
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSHashTableCopyInWrapper: NSPointerFunctionsWrapper.OptionsWrapper {
    get {
      OptionsWrapper(NSHashTableCopyIn)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSHashTableObjectPointerPersonalityWrapper: NSPointerFunctionsWrapper.OptionsWrapper {
    get {
      OptionsWrapper(NSHashTableObjectPointerPersonality)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSHashTableStrongMemoryWrapper: NSPointerFunctionsWrapper.OptionsWrapper {
    get {
      OptionsWrapper(NSHashTableStrongMemory)
    }
  }

  @available(macOS, introduced: 10.8)
  @objc static public var NSHashTableWeakMemoryWrapper: NSPointerFunctionsWrapper.OptionsWrapper {
    get {
      OptionsWrapper(NSHashTableWeakMemory)
    }
  }

  @available(macOS, introduced: 10.4, deprecated: 10.10)
  @objc static public var NSHebrewCalendarWrapper: String {
    get {
      NSHebrewCalendar
    }
  }

  @objc static public var NSHelpAnchorErrorKeyWrapper: String {
    get {
      NSHelpAnchorErrorKey
    }
  }

  @available(macOS, introduced: 10.6, deprecated: 10.10)
  @objc static public var NSISO8601CalendarWrapper: String {
    get {
      NSISO8601Calendar
    }
  }

  @available(macOS, introduced: 10.6, deprecated: 10.10)
  @objc static public var NSIndianCalendarWrapper: String {
    get {
      NSIndianCalendar
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSIntegerHashCallBacksWrapper: NSHashTableCallBacksWrapper {
    get {
      NSHashTableCallBacksWrapper(NSIntegerHashCallBacks)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSIntegerMapKeyCallBacksWrapper: NSMapTableKeyCallBacksWrapper {
    get {
      NSMapTableKeyCallBacksWrapper(NSIntegerMapKeyCallBacks)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSIntegerMapValueCallBacksWrapper: NSMapTableValueCallBacksWrapper {
    get {
      NSMapTableValueCallBacksWrapper(NSIntegerMapValueCallBacks)
    }
  }

  @available(macOS, introduced: 10.4, deprecated: 10.10)
  @objc static public var NSIslamicCalendarWrapper: String {
    get {
      NSIslamicCalendar
    }
  }

  @available(macOS, introduced: 10.4, deprecated: 10.10)
  @objc static public var NSIslamicCivilCalendarWrapper: String {
    get {
      NSIslamicCivilCalendar
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSItemProviderPreferredImageSizeKeyWrapper: String {
    get {
      NSItemProviderPreferredImageSizeKey
    }
  }

  @available(macOS, introduced: 10.4, deprecated: 10.10)
  @objc static public var NSJapaneseCalendarWrapper: String {
    get {
      NSJapaneseCalendar
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSKeyedArchiveRootObjectKeyWrapper: String {
    get {
      NSKeyedArchiveRootObjectKey
    }
  }

  @objc static public var NSLoadedClassesWrapper: String {
    get {
      NSLoadedClasses
    }
  }

  @objc static public var NSLocalizedDescriptionKeyWrapper: String {
    get {
      NSLocalizedDescriptionKey
    }
  }

  @available(macOS, introduced: 10.13)
  @objc static public var NSLocalizedFailureErrorKeyWrapper: String {
    get {
      NSLocalizedFailureErrorKey
    }
  }

  @objc static public var NSLocalizedFailureReasonErrorKeyWrapper: String {
    get {
      NSLocalizedFailureReasonErrorKey
    }
  }

  @objc static public var NSLocalizedRecoveryOptionsErrorKeyWrapper: String {
    get {
      NSLocalizedRecoveryOptionsErrorKey
    }
  }

  @objc static public var NSLocalizedRecoverySuggestionErrorKeyWrapper: String {
    get {
      NSLocalizedRecoverySuggestionErrorKey
    }
  }

  @objc static public var NSMachErrorDomainWrapper: String {
    get {
      NSMachErrorDomain
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSMapTableCopyInWrapper: NSPointerFunctionsWrapper.OptionsWrapper {
    get {
      OptionsWrapper(NSMapTableCopyIn)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSMapTableObjectPointerPersonalityWrapper: NSPointerFunctionsWrapper.OptionsWrapper {
    get {
      OptionsWrapper(NSMapTableObjectPointerPersonality)
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSMapTableStrongMemoryWrapper: NSPointerFunctionsWrapper.OptionsWrapper {
    get {
      OptionsWrapper(NSMapTableStrongMemory)
    }
  }

  @available(macOS, introduced: 10.8)
  @objc static public var NSMapTableWeakMemoryWrapper: NSPointerFunctionsWrapper.OptionsWrapper {
    get {
      OptionsWrapper(NSMapTableWeakMemory)
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAcquisitionMakeKeyWrapper: String {
    get {
      NSMetadataItemAcquisitionMakeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAcquisitionModelKeyWrapper: String {
    get {
      NSMetadataItemAcquisitionModelKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAlbumKeyWrapper: String {
    get {
      NSMetadataItemAlbumKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAltitudeKeyWrapper: String {
    get {
      NSMetadataItemAltitudeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemApertureKeyWrapper: String {
    get {
      NSMetadataItemApertureKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAppleLoopDescriptorsKeyWrapper: String {
    get {
      NSMetadataItemAppleLoopDescriptorsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAppleLoopsKeyFilterTypeKeyWrapper: String {
    get {
      NSMetadataItemAppleLoopsKeyFilterTypeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAppleLoopsLoopModeKeyWrapper: String {
    get {
      NSMetadataItemAppleLoopsLoopModeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAppleLoopsRootKeyKeyWrapper: String {
    get {
      NSMetadataItemAppleLoopsRootKeyKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemApplicationCategoriesKeyWrapper: String {
    get {
      NSMetadataItemApplicationCategoriesKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAttributeChangeDateKeyWrapper: String {
    get {
      NSMetadataItemAttributeChangeDateKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAudiencesKeyWrapper: String {
    get {
      NSMetadataItemAudiencesKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAudioBitRateKeyWrapper: String {
    get {
      NSMetadataItemAudioBitRateKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAudioChannelCountKeyWrapper: String {
    get {
      NSMetadataItemAudioChannelCountKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAudioEncodingApplicationKeyWrapper: String {
    get {
      NSMetadataItemAudioEncodingApplicationKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAudioSampleRateKeyWrapper: String {
    get {
      NSMetadataItemAudioSampleRateKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAudioTrackNumberKeyWrapper: String {
    get {
      NSMetadataItemAudioTrackNumberKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAuthorAddressesKeyWrapper: String {
    get {
      NSMetadataItemAuthorAddressesKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAuthorEmailAddressesKeyWrapper: String {
    get {
      NSMetadataItemAuthorEmailAddressesKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemAuthorsKeyWrapper: String {
    get {
      NSMetadataItemAuthorsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemBitsPerSampleKeyWrapper: String {
    get {
      NSMetadataItemBitsPerSampleKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemCFBundleIdentifierKeyWrapper: String {
    get {
      NSMetadataItemCFBundleIdentifierKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemCameraOwnerKeyWrapper: String {
    get {
      NSMetadataItemCameraOwnerKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemCityKeyWrapper: String {
    get {
      NSMetadataItemCityKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemCodecsKeyWrapper: String {
    get {
      NSMetadataItemCodecsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemColorSpaceKeyWrapper: String {
    get {
      NSMetadataItemColorSpaceKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemCommentKeyWrapper: String {
    get {
      NSMetadataItemCommentKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemComposerKeyWrapper: String {
    get {
      NSMetadataItemComposerKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemContactKeywordsKeyWrapper: String {
    get {
      NSMetadataItemContactKeywordsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemContentCreationDateKeyWrapper: String {
    get {
      NSMetadataItemContentCreationDateKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemContentModificationDateKeyWrapper: String {
    get {
      NSMetadataItemContentModificationDateKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemContentTypeKeyWrapper: String {
    get {
      NSMetadataItemContentTypeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemContentTypeTreeKeyWrapper: String {
    get {
      NSMetadataItemContentTypeTreeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemContributorsKeyWrapper: String {
    get {
      NSMetadataItemContributorsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemCopyrightKeyWrapper: String {
    get {
      NSMetadataItemCopyrightKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemCountryKeyWrapper: String {
    get {
      NSMetadataItemCountryKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemCoverageKeyWrapper: String {
    get {
      NSMetadataItemCoverageKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemCreatorKeyWrapper: String {
    get {
      NSMetadataItemCreatorKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemDateAddedKeyWrapper: String {
    get {
      NSMetadataItemDateAddedKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemDeliveryTypeKeyWrapper: String {
    get {
      NSMetadataItemDeliveryTypeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemDescriptionKeyWrapper: String {
    get {
      NSMetadataItemDescriptionKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemDirectorKeyWrapper: String {
    get {
      NSMetadataItemDirectorKey
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataItemDisplayNameKeyWrapper: String {
    get {
      NSMetadataItemDisplayNameKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemDownloadedDateKeyWrapper: String {
    get {
      NSMetadataItemDownloadedDateKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemDueDateKeyWrapper: String {
    get {
      NSMetadataItemDueDateKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemDurationSecondsKeyWrapper: String {
    get {
      NSMetadataItemDurationSecondsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemEXIFGPSVersionKeyWrapper: String {
    get {
      NSMetadataItemEXIFGPSVersionKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemEXIFVersionKeyWrapper: String {
    get {
      NSMetadataItemEXIFVersionKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemEditorsKeyWrapper: String {
    get {
      NSMetadataItemEditorsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemEmailAddressesKeyWrapper: String {
    get {
      NSMetadataItemEmailAddressesKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemEncodingApplicationsKeyWrapper: String {
    get {
      NSMetadataItemEncodingApplicationsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemExecutableArchitecturesKeyWrapper: String {
    get {
      NSMetadataItemExecutableArchitecturesKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemExecutablePlatformKeyWrapper: String {
    get {
      NSMetadataItemExecutablePlatformKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemExposureModeKeyWrapper: String {
    get {
      NSMetadataItemExposureModeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemExposureProgramKeyWrapper: String {
    get {
      NSMetadataItemExposureProgramKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemExposureTimeSecondsKeyWrapper: String {
    get {
      NSMetadataItemExposureTimeSecondsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemExposureTimeStringKeyWrapper: String {
    get {
      NSMetadataItemExposureTimeStringKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemFNumberKeyWrapper: String {
    get {
      NSMetadataItemFNumberKey
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataItemFSContentChangeDateKeyWrapper: String {
    get {
      NSMetadataItemFSContentChangeDateKey
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataItemFSCreationDateKeyWrapper: String {
    get {
      NSMetadataItemFSCreationDateKey
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataItemFSNameKeyWrapper: String {
    get {
      NSMetadataItemFSNameKey
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataItemFSSizeKeyWrapper: String {
    get {
      NSMetadataItemFSSizeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemFinderCommentKeyWrapper: String {
    get {
      NSMetadataItemFinderCommentKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemFlashOnOffKeyWrapper: String {
    get {
      NSMetadataItemFlashOnOffKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemFocalLength35mmKeyWrapper: String {
    get {
      NSMetadataItemFocalLength35mmKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemFocalLengthKeyWrapper: String {
    get {
      NSMetadataItemFocalLengthKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemFontsKeyWrapper: String {
    get {
      NSMetadataItemFontsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemGPSAreaInformationKeyWrapper: String {
    get {
      NSMetadataItemGPSAreaInformationKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemGPSDOPKeyWrapper: String {
    get {
      NSMetadataItemGPSDOPKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemGPSDateStampKeyWrapper: String {
    get {
      NSMetadataItemGPSDateStampKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemGPSDestBearingKeyWrapper: String {
    get {
      NSMetadataItemGPSDestBearingKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemGPSDestDistanceKeyWrapper: String {
    get {
      NSMetadataItemGPSDestDistanceKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemGPSDestLatitudeKeyWrapper: String {
    get {
      NSMetadataItemGPSDestLatitudeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemGPSDestLongitudeKeyWrapper: String {
    get {
      NSMetadataItemGPSDestLongitudeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemGPSDifferentalKeyWrapper: String {
    get {
      NSMetadataItemGPSDifferentalKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemGPSMapDatumKeyWrapper: String {
    get {
      NSMetadataItemGPSMapDatumKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemGPSMeasureModeKeyWrapper: String {
    get {
      NSMetadataItemGPSMeasureModeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemGPSProcessingMethodKeyWrapper: String {
    get {
      NSMetadataItemGPSProcessingMethodKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemGPSStatusKeyWrapper: String {
    get {
      NSMetadataItemGPSStatusKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemGPSTrackKeyWrapper: String {
    get {
      NSMetadataItemGPSTrackKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemGenreKeyWrapper: String {
    get {
      NSMetadataItemGenreKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemHasAlphaChannelKeyWrapper: String {
    get {
      NSMetadataItemHasAlphaChannelKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemHeadlineKeyWrapper: String {
    get {
      NSMetadataItemHeadlineKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemISOSpeedKeyWrapper: String {
    get {
      NSMetadataItemISOSpeedKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemIdentifierKeyWrapper: String {
    get {
      NSMetadataItemIdentifierKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemImageDirectionKeyWrapper: String {
    get {
      NSMetadataItemImageDirectionKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemInformationKeyWrapper: String {
    get {
      NSMetadataItemInformationKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemInstantMessageAddressesKeyWrapper: String {
    get {
      NSMetadataItemInstantMessageAddressesKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemInstructionsKeyWrapper: String {
    get {
      NSMetadataItemInstructionsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemIsApplicationManagedKeyWrapper: String {
    get {
      NSMetadataItemIsApplicationManagedKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemIsGeneralMIDISequenceKeyWrapper: String {
    get {
      NSMetadataItemIsGeneralMIDISequenceKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemIsLikelyJunkKeyWrapper: String {
    get {
      NSMetadataItemIsLikelyJunkKey
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataItemIsUbiquitousKeyWrapper: String {
    get {
      NSMetadataItemIsUbiquitousKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemKeySignatureKeyWrapper: String {
    get {
      NSMetadataItemKeySignatureKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemKeywordsKeyWrapper: String {
    get {
      NSMetadataItemKeywordsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemKindKeyWrapper: String {
    get {
      NSMetadataItemKindKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemLanguagesKeyWrapper: String {
    get {
      NSMetadataItemLanguagesKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemLastUsedDateKeyWrapper: String {
    get {
      NSMetadataItemLastUsedDateKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemLatitudeKeyWrapper: String {
    get {
      NSMetadataItemLatitudeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemLayerNamesKeyWrapper: String {
    get {
      NSMetadataItemLayerNamesKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemLensModelKeyWrapper: String {
    get {
      NSMetadataItemLensModelKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemLongitudeKeyWrapper: String {
    get {
      NSMetadataItemLongitudeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemLyricistKeyWrapper: String {
    get {
      NSMetadataItemLyricistKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemMaxApertureKeyWrapper: String {
    get {
      NSMetadataItemMaxApertureKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemMediaTypesKeyWrapper: String {
    get {
      NSMetadataItemMediaTypesKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemMeteringModeKeyWrapper: String {
    get {
      NSMetadataItemMeteringModeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemMusicalGenreKeyWrapper: String {
    get {
      NSMetadataItemMusicalGenreKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemMusicalInstrumentCategoryKeyWrapper: String {
    get {
      NSMetadataItemMusicalInstrumentCategoryKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemMusicalInstrumentNameKeyWrapper: String {
    get {
      NSMetadataItemMusicalInstrumentNameKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemNamedLocationKeyWrapper: String {
    get {
      NSMetadataItemNamedLocationKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemNumberOfPagesKeyWrapper: String {
    get {
      NSMetadataItemNumberOfPagesKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemOrganizationsKeyWrapper: String {
    get {
      NSMetadataItemOrganizationsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemOrientationKeyWrapper: String {
    get {
      NSMetadataItemOrientationKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemOriginalFormatKeyWrapper: String {
    get {
      NSMetadataItemOriginalFormatKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemOriginalSourceKeyWrapper: String {
    get {
      NSMetadataItemOriginalSourceKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemPageHeightKeyWrapper: String {
    get {
      NSMetadataItemPageHeightKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemPageWidthKeyWrapper: String {
    get {
      NSMetadataItemPageWidthKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemParticipantsKeyWrapper: String {
    get {
      NSMetadataItemParticipantsKey
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataItemPathKeyWrapper: String {
    get {
      NSMetadataItemPathKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemPerformersKeyWrapper: String {
    get {
      NSMetadataItemPerformersKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemPhoneNumbersKeyWrapper: String {
    get {
      NSMetadataItemPhoneNumbersKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemPixelCountKeyWrapper: String {
    get {
      NSMetadataItemPixelCountKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemPixelHeightKeyWrapper: String {
    get {
      NSMetadataItemPixelHeightKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemPixelWidthKeyWrapper: String {
    get {
      NSMetadataItemPixelWidthKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemProducerKeyWrapper: String {
    get {
      NSMetadataItemProducerKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemProfileNameKeyWrapper: String {
    get {
      NSMetadataItemProfileNameKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemProjectsKeyWrapper: String {
    get {
      NSMetadataItemProjectsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemPublishersKeyWrapper: String {
    get {
      NSMetadataItemPublishersKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemRecipientAddressesKeyWrapper: String {
    get {
      NSMetadataItemRecipientAddressesKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemRecipientEmailAddressesKeyWrapper: String {
    get {
      NSMetadataItemRecipientEmailAddressesKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemRecipientsKeyWrapper: String {
    get {
      NSMetadataItemRecipientsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemRecordingDateKeyWrapper: String {
    get {
      NSMetadataItemRecordingDateKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemRecordingYearKeyWrapper: String {
    get {
      NSMetadataItemRecordingYearKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemRedEyeOnOffKeyWrapper: String {
    get {
      NSMetadataItemRedEyeOnOffKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemResolutionHeightDPIKeyWrapper: String {
    get {
      NSMetadataItemResolutionHeightDPIKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemResolutionWidthDPIKeyWrapper: String {
    get {
      NSMetadataItemResolutionWidthDPIKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemRightsKeyWrapper: String {
    get {
      NSMetadataItemRightsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemSecurityMethodKeyWrapper: String {
    get {
      NSMetadataItemSecurityMethodKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemSpeedKeyWrapper: String {
    get {
      NSMetadataItemSpeedKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemStarRatingKeyWrapper: String {
    get {
      NSMetadataItemStarRatingKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemStateOrProvinceKeyWrapper: String {
    get {
      NSMetadataItemStateOrProvinceKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemStreamableKeyWrapper: String {
    get {
      NSMetadataItemStreamableKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemSubjectKeyWrapper: String {
    get {
      NSMetadataItemSubjectKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemTempoKeyWrapper: String {
    get {
      NSMetadataItemTempoKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemTextContentKeyWrapper: String {
    get {
      NSMetadataItemTextContentKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemThemeKeyWrapper: String {
    get {
      NSMetadataItemThemeKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemTimeSignatureKeyWrapper: String {
    get {
      NSMetadataItemTimeSignatureKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemTimestampKeyWrapper: String {
    get {
      NSMetadataItemTimestampKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemTitleKeyWrapper: String {
    get {
      NSMetadataItemTitleKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemTotalBitRateKeyWrapper: String {
    get {
      NSMetadataItemTotalBitRateKey
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataItemURLKeyWrapper: String {
    get {
      NSMetadataItemURLKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemVersionKeyWrapper: String {
    get {
      NSMetadataItemVersionKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemVideoBitRateKeyWrapper: String {
    get {
      NSMetadataItemVideoBitRateKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemWhereFromsKeyWrapper: String {
    get {
      NSMetadataItemWhereFromsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataItemWhiteBalanceKeyWrapper: String {
    get {
      NSMetadataItemWhiteBalanceKey
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSMetadataQueryAccessibleUbiquitousExternalDocumentsScopeWrapper: String {
    get {
      NSMetadataQueryAccessibleUbiquitousExternalDocumentsScope
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataQueryIndexedLocalComputerScopeWrapper: String {
    get {
      NSMetadataQueryIndexedLocalComputerScope
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataQueryIndexedNetworkScopeWrapper: String {
    get {
      NSMetadataQueryIndexedNetworkScope
    }
  }

  @available(macOS, introduced: 10.4)
  @objc static public var NSMetadataQueryLocalComputerScopeWrapper: String {
    get {
      NSMetadataQueryLocalComputerScope
    }
  }

  @available(macOS, introduced: 10.4)
  @objc static public var NSMetadataQueryNetworkScopeWrapper: String {
    get {
      NSMetadataQueryNetworkScope
    }
  }

  @available(macOS, introduced: 10.4)
  @objc static public var NSMetadataQueryResultContentRelevanceAttributeWrapper: String {
    get {
      NSMetadataQueryResultContentRelevanceAttribute
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataQueryUbiquitousDataScopeWrapper: String {
    get {
      NSMetadataQueryUbiquitousDataScope
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataQueryUbiquitousDocumentsScopeWrapper: String {
    get {
      NSMetadataQueryUbiquitousDocumentsScope
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataQueryUpdateAddedItemsKeyWrapper: String {
    get {
      NSMetadataQueryUpdateAddedItemsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataQueryUpdateChangedItemsKeyWrapper: String {
    get {
      NSMetadataQueryUpdateChangedItemsKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataQueryUpdateRemovedItemsKeyWrapper: String {
    get {
      NSMetadataQueryUpdateRemovedItemsKey
    }
  }

  @available(macOS, introduced: 10.4)
  @objc static public var NSMetadataQueryUserHomeScopeWrapper: String {
    get {
      NSMetadataQueryUserHomeScope
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSMetadataUbiquitousItemContainerDisplayNameKeyWrapper: String {
    get {
      NSMetadataUbiquitousItemContainerDisplayNameKey
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSMetadataUbiquitousItemDownloadRequestedKeyWrapper: String {
    get {
      NSMetadataUbiquitousItemDownloadRequestedKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataUbiquitousItemDownloadingErrorKeyWrapper: String {
    get {
      NSMetadataUbiquitousItemDownloadingErrorKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataUbiquitousItemDownloadingStatusCurrentWrapper: String {
    get {
      NSMetadataUbiquitousItemDownloadingStatusCurrent
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataUbiquitousItemDownloadingStatusDownloadedWrapper: String {
    get {
      NSMetadataUbiquitousItemDownloadingStatusDownloaded
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataUbiquitousItemDownloadingStatusKeyWrapper: String {
    get {
      NSMetadataUbiquitousItemDownloadingStatusKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataUbiquitousItemDownloadingStatusNotDownloadedWrapper: String {
    get {
      NSMetadataUbiquitousItemDownloadingStatusNotDownloaded
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataUbiquitousItemHasUnresolvedConflictsKeyWrapper: String {
    get {
      NSMetadataUbiquitousItemHasUnresolvedConflictsKey
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataUbiquitousItemIsDownloadingKeyWrapper: String {
    get {
      NSMetadataUbiquitousItemIsDownloadingKey
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSMetadataUbiquitousItemIsExternalDocumentKeyWrapper: String {
    get {
      NSMetadataUbiquitousItemIsExternalDocumentKey
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSMetadataUbiquitousItemIsSharedKeyWrapper: String {
    get {
      NSMetadataUbiquitousItemIsSharedKey
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataUbiquitousItemIsUploadedKeyWrapper: String {
    get {
      NSMetadataUbiquitousItemIsUploadedKey
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataUbiquitousItemIsUploadingKeyWrapper: String {
    get {
      NSMetadataUbiquitousItemIsUploadingKey
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataUbiquitousItemPercentDownloadedKeyWrapper: String {
    get {
      NSMetadataUbiquitousItemPercentDownloadedKey
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSMetadataUbiquitousItemPercentUploadedKeyWrapper: String {
    get {
      NSMetadataUbiquitousItemPercentUploadedKey
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSMetadataUbiquitousItemURLInLocalContainerKeyWrapper: String {
    get {
      NSMetadataUbiquitousItemURLInLocalContainerKey
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSMetadataUbiquitousItemUploadingErrorKeyWrapper: String {
    get {
      NSMetadataUbiquitousItemUploadingErrorKey
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSMetadataUbiquitousSharedItemCurrentUserPermissionsKeyWrapper: String {
    get {
      NSMetadataUbiquitousSharedItemCurrentUserPermissionsKey
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSMetadataUbiquitousSharedItemCurrentUserRoleKeyWrapper: String {
    get {
      NSMetadataUbiquitousSharedItemCurrentUserRoleKey
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSMetadataUbiquitousSharedItemMostRecentEditorNameComponentsKeyWrapper: String {
    get {
      NSMetadataUbiquitousSharedItemMostRecentEditorNameComponentsKey
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSMetadataUbiquitousSharedItemOwnerNameComponentsKeyWrapper: String {
    get {
      NSMetadataUbiquitousSharedItemOwnerNameComponentsKey
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSMetadataUbiquitousSharedItemPermissionsReadOnlyWrapper: String {
    get {
      NSMetadataUbiquitousSharedItemPermissionsReadOnly
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSMetadataUbiquitousSharedItemPermissionsReadWriteWrapper: String {
    get {
      NSMetadataUbiquitousSharedItemPermissionsReadWrite
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSMetadataUbiquitousSharedItemRoleOwnerWrapper: String {
    get {
      NSMetadataUbiquitousSharedItemRoleOwner
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSMetadataUbiquitousSharedItemRoleParticipantWrapper: String {
    get {
      NSMetadataUbiquitousSharedItemRoleParticipant
    }
  }

  @available(macOS, introduced: 11.3)
  @objc static public var NSMultipleUnderlyingErrorsKeyWrapper: String {
    get {
      NSMultipleUnderlyingErrorsKey
    }
  }

  @objc static public var NSNonOwnedPointerHashCallBacksWrapper: NSHashTableCallBacksWrapper {
    get {
      NSHashTableCallBacksWrapper(NSNonOwnedPointerHashCallBacks)
    }
  }

  @objc static public var NSNonOwnedPointerMapKeyCallBacksWrapper: NSMapTableKeyCallBacksWrapper {
    get {
      NSMapTableKeyCallBacksWrapper(NSNonOwnedPointerMapKeyCallBacks)
    }
  }

  @objc static public var NSNonOwnedPointerMapValueCallBacksWrapper: NSMapTableValueCallBacksWrapper {
    get {
      NSMapTableValueCallBacksWrapper(NSNonOwnedPointerMapValueCallBacks)
    }
  }

  @objc static public var NSNonOwnedPointerOrNullMapKeyCallBacksWrapper: NSMapTableKeyCallBacksWrapper {
    get {
      NSMapTableKeyCallBacksWrapper(NSNonOwnedPointerOrNullMapKeyCallBacks)
    }
  }

  @objc static public var NSNonRetainedObjectHashCallBacksWrapper: NSHashTableCallBacksWrapper {
    get {
      NSHashTableCallBacksWrapper(NSNonRetainedObjectHashCallBacks)
    }
  }

  @objc static public var NSNonRetainedObjectMapKeyCallBacksWrapper: NSMapTableKeyCallBacksWrapper {
    get {
      NSMapTableKeyCallBacksWrapper(NSNonRetainedObjectMapKeyCallBacks)
    }
  }

  @objc static public var NSNonRetainedObjectMapValueCallBacksWrapper: NSMapTableValueCallBacksWrapper {
    get {
      NSMapTableValueCallBacksWrapper(NSNonRetainedObjectMapValueCallBacks)
    }
  }

  @objc static public var NSNotFoundWrapper: Int {
    get {
      NSNotFound
    }
  }

  @objc static public var NSNotificationDeliverImmediatelyWrapper: DistributedNotificationCenterWrapper.OptionsWrapper {
    get {
      OptionsWrapper(NSNotificationDeliverImmediately)
    }
  }

  @objc static public var NSNotificationPostToAllSessionsWrapper: DistributedNotificationCenterWrapper.OptionsWrapper {
    get {
      OptionsWrapper(NSNotificationPostToAllSessions)
    }
  }

  @objc static public var NSOSStatusErrorDomainWrapper: String {
    get {
      NSOSStatusErrorDomain
    }
  }

  @objc static public var NSObjectHashCallBacksWrapper: NSHashTableCallBacksWrapper {
    get {
      NSHashTableCallBacksWrapper(NSObjectHashCallBacks)
    }
  }

  @objc static public var NSObjectMapKeyCallBacksWrapper: NSMapTableKeyCallBacksWrapper {
    get {
      NSMapTableKeyCallBacksWrapper(NSObjectMapKeyCallBacks)
    }
  }

  @objc static public var NSObjectMapValueCallBacksWrapper: NSMapTableValueCallBacksWrapper {
    get {
      NSMapTableValueCallBacksWrapper(NSObjectMapValueCallBacks)
    }
  }

  @objc static public var NSOperationNotSupportedForKeyExceptionWrapper: String {
    get {
      NSOperationNotSupportedForKeyException
    }
  }

  @objc static public var NSOwnedObjectIdentityHashCallBacksWrapper: NSHashTableCallBacksWrapper {
    get {
      NSHashTableCallBacksWrapper(NSOwnedObjectIdentityHashCallBacks)
    }
  }

  @objc static public var NSOwnedPointerHashCallBacksWrapper: NSHashTableCallBacksWrapper {
    get {
      NSHashTableCallBacksWrapper(NSOwnedPointerHashCallBacks)
    }
  }

  @objc static public var NSOwnedPointerMapKeyCallBacksWrapper: NSMapTableKeyCallBacksWrapper {
    get {
      NSMapTableKeyCallBacksWrapper(NSOwnedPointerMapKeyCallBacks)
    }
  }

  @objc static public var NSOwnedPointerMapValueCallBacksWrapper: NSMapTableValueCallBacksWrapper {
    get {
      NSMapTableValueCallBacksWrapper(NSOwnedPointerMapValueCallBacks)
    }
  }

  @objc static public var NSPOSIXErrorDomainWrapper: String {
    get {
      NSPOSIXErrorDomain
    }
  }

  @available(macOS, introduced: 10.6, deprecated: 10.10)
  @objc static public var NSPersianCalendarWrapper: String {
    get {
      NSPersianCalendar
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSPersonNameComponentDelimiterWrapper: String {
    get {
      NSPersonNameComponentDelimiter
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSPersonNameComponentFamilyNameWrapper: String {
    get {
      NSPersonNameComponentFamilyName
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSPersonNameComponentGivenNameWrapper: String {
    get {
      NSPersonNameComponentGivenName
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSPersonNameComponentKeyWrapper: String {
    get {
      NSPersonNameComponentKey
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSPersonNameComponentMiddleNameWrapper: String {
    get {
      NSPersonNameComponentMiddleName
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSPersonNameComponentNicknameWrapper: String {
    get {
      NSPersonNameComponentNickname
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSPersonNameComponentPrefixWrapper: String {
    get {
      NSPersonNameComponentPrefix
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSPersonNameComponentSuffixWrapper: String {
    get {
      NSPersonNameComponentSuffix
    }
  }

  @objc static public var NSPointerToStructHashCallBacksWrapper: NSHashTableCallBacksWrapper {
    get {
      NSHashTableCallBacksWrapper(NSPointerToStructHashCallBacks)
    }
  }

  @objc static public var NSRecoveryAttempterErrorKeyWrapper: String {
    get {
      NSRecoveryAttempterErrorKey
    }
  }

  @available(macOS, introduced: 10.6, deprecated: 10.10)
  @objc static public var NSRepublicOfChinaCalendarWrapper: String {
    get {
      NSRepublicOfChinaCalendar
    }
  }

  @available(macOS, introduced: 10.3)
  @objc static public var NSStreamSOCKSErrorDomainWrapper: String {
    get {
      NSStreamSOCKSErrorDomain
    }
  }

  @available(macOS, introduced: 10.3)
  @objc static public var NSStreamSocketSSLErrorDomainWrapper: String {
    get {
      NSStreamSocketSSLErrorDomain
    }
  }

  @objc static public var NSStringEncodingErrorKeyWrapper: String {
    get {
      NSStringEncodingErrorKey
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var NSURLAuthenticationMethodClientCertificateWrapper: String {
    get {
      NSURLAuthenticationMethodClientCertificate
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var NSURLAuthenticationMethodDefaultWrapper: String {
    get {
      NSURLAuthenticationMethodDefault
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var NSURLAuthenticationMethodHTMLFormWrapper: String {
    get {
      NSURLAuthenticationMethodHTMLForm
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var NSURLAuthenticationMethodHTTPBasicWrapper: String {
    get {
      NSURLAuthenticationMethodHTTPBasic
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var NSURLAuthenticationMethodHTTPDigestWrapper: String {
    get {
      NSURLAuthenticationMethodHTTPDigest
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSURLAuthenticationMethodNTLMWrapper: String {
    get {
      NSURLAuthenticationMethodNTLM
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSURLAuthenticationMethodNegotiateWrapper: String {
    get {
      NSURLAuthenticationMethodNegotiate
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var NSURLAuthenticationMethodServerTrustWrapper: String {
    get {
      NSURLAuthenticationMethodServerTrust
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSURLCredentialStorageRemoveSynchronizableCredentialsWrapper: String {
    get {
      NSURLCredentialStorageRemoveSynchronizableCredentials
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSURLErrorBackgroundTaskCancelledReasonKeyWrapper: String {
    get {
      NSURLErrorBackgroundTaskCancelledReasonKey
    }
  }

  @objc static public var NSURLErrorDomainWrapper: String {
    get {
      NSURLErrorDomain
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var NSURLErrorFailingURLErrorKeyWrapper: String {
    get {
      NSURLErrorFailingURLErrorKey
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var NSURLErrorFailingURLPeerTrustErrorKeyWrapper: String {
    get {
      NSURLErrorFailingURLPeerTrustErrorKey
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var NSURLErrorFailingURLStringErrorKeyWrapper: String {
    get {
      NSURLErrorFailingURLStringErrorKey
    }
  }

  @objc static public var NSURLErrorKeyWrapper: String {
    get {
      NSURLErrorKey
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var NSURLErrorNetworkUnavailableReasonKeyWrapper: String {
    get {
      NSURLErrorNetworkUnavailableReasonKey
    }
  }

  @objc static public var NSURLFileSchemeWrapper: String {
    get {
      NSURLFileScheme
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSURLProtectionSpaceFTPWrapper: String {
    get {
      NSURLProtectionSpaceFTP
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var NSURLProtectionSpaceFTPProxyWrapper: String {
    get {
      NSURLProtectionSpaceFTPProxy
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSURLProtectionSpaceHTTPWrapper: String {
    get {
      NSURLProtectionSpaceHTTP
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var NSURLProtectionSpaceHTTPProxyWrapper: String {
    get {
      NSURLProtectionSpaceHTTPProxy
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSURLProtectionSpaceHTTPSWrapper: String {
    get {
      NSURLProtectionSpaceHTTPS
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var NSURLProtectionSpaceHTTPSProxyWrapper: String {
    get {
      NSURLProtectionSpaceHTTPSProxy
    }
  }

  @available(macOS, introduced: 10.2)
  @objc static public var NSURLProtectionSpaceSOCKSProxyWrapper: String {
    get {
      NSURLProtectionSpaceSOCKSProxy
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSURLSessionDownloadTaskResumeDataWrapper: String {
    get {
      NSURLSessionDownloadTaskResumeData
    }
  }

  @available(macOS, introduced: 14.0)
  @objc static public var NSURLSessionUploadTaskResumeDataWrapper: String {
    get {
      NSURLSessionUploadTaskResumeData
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSUbiquitousKeyValueStoreChangeReasonKeyWrapper: String {
    get {
      NSUbiquitousKeyValueStoreChangeReasonKey
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSUbiquitousKeyValueStoreChangedKeysKeyWrapper: String {
    get {
      NSUbiquitousKeyValueStoreChangedKeysKey
    }
  }

  @objc static public var NSUnderlyingErrorKeyWrapper: String {
    get {
      NSUnderlyingErrorKey
    }
  }

  @objc static public var NSUndoCloseGroupingRunLoopOrderingWrapper: Int {
    get {
      NSUndoCloseGroupingRunLoopOrdering
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSUndoManagerGroupIsDiscardableKeyWrapper: String {
    get {
      NSUndoManagerGroupIsDiscardableKey
    }
  }

  @objc static public var NSUserActivityTypeBrowsingWebWrapper: String {
    get {
      NSUserActivityTypeBrowsingWeb
    }
  }

  @available(macOS, introduced: 10.8, deprecated: 11.0)
  @objc static public var NSUserNotificationDefaultSoundNameWrapper: String {
    get {
      NSUserNotificationDefaultSoundName
    }
  }

  @objc static public var NSFoundationVersionNumber10_0Wrapper: Double {
    get {
      NSFoundationVersionNumber10_0
    }
  }

  @objc static public var NSFoundationVersionNumber10_1Wrapper: Double {
    get {
      NSFoundationVersionNumber10_1
    }
  }

  @objc static public var NSFoundationVersionNumber10_10Wrapper: Double {
    get {
      NSFoundationVersionNumber10_10
    }
  }

  @objc static public var NSFoundationVersionNumber10_10_1Wrapper: Double {
    get {
      NSFoundationVersionNumber10_10_1
    }
  }

  @objc static public var NSFoundationVersionNumber10_10_2Wrapper: Double {
    get {
      NSFoundationVersionNumber10_10_2
    }
  }

  @objc static public var NSFoundationVersionNumber10_10_3Wrapper: Double {
    get {
      NSFoundationVersionNumber10_10_3
    }
  }

  @objc static public var NSFoundationVersionNumber10_10_4Wrapper: Double {
    get {
      NSFoundationVersionNumber10_10_4
    }
  }

  @objc static public var NSFoundationVersionNumber10_11_1Wrapper: Double {
    get {
      NSFoundationVersionNumber10_11_1
    }
  }

  @objc static public var NSFoundationVersionNumber10_11_2Wrapper: Double {
    get {
      NSFoundationVersionNumber10_11_2
    }
  }

  @objc static public var NSFoundationVersionNumber10_11_3Wrapper: Double {
    get {
      NSFoundationVersionNumber10_11_3
    }
  }

  @objc static public var NSFoundationVersionNumber10_1_1Wrapper: Double {
    get {
      NSFoundationVersionNumber10_1_1
    }
  }

  @objc static public var NSFoundationVersionNumber10_1_2Wrapper: Double {
    get {
      NSFoundationVersionNumber10_1_2
    }
  }

  @objc static public var NSFoundationVersionNumber10_1_3Wrapper: Double {
    get {
      NSFoundationVersionNumber10_1_3
    }
  }

  @objc static public var NSFoundationVersionNumber10_1_4Wrapper: Double {
    get {
      NSFoundationVersionNumber10_1_4
    }
  }

  @objc static public var NSFoundationVersionNumber10_2Wrapper: Double {
    get {
      NSFoundationVersionNumber10_2
    }
  }

  @objc static public var NSFoundationVersionNumber10_2_1Wrapper: Double {
    get {
      NSFoundationVersionNumber10_2_1
    }
  }

  @objc static public var NSFoundationVersionNumber10_2_2Wrapper: Double {
    get {
      NSFoundationVersionNumber10_2_2
    }
  }

  @objc static public var NSFoundationVersionNumber10_2_3Wrapper: Double {
    get {
      NSFoundationVersionNumber10_2_3
    }
  }

  @objc static public var NSFoundationVersionNumber10_2_4Wrapper: Double {
    get {
      NSFoundationVersionNumber10_2_4
    }
  }

  @objc static public var NSFoundationVersionNumber10_2_5Wrapper: Double {
    get {
      NSFoundationVersionNumber10_2_5
    }
  }

  @objc static public var NSFoundationVersionNumber10_2_6Wrapper: Double {
    get {
      NSFoundationVersionNumber10_2_6
    }
  }

  @objc static public var NSFoundationVersionNumber10_2_7Wrapper: Double {
    get {
      NSFoundationVersionNumber10_2_7
    }
  }

  @objc static public var NSFoundationVersionNumber10_2_8Wrapper: Double {
    get {
      NSFoundationVersionNumber10_2_8
    }
  }

  @objc static public var NSFoundationVersionNumber10_3Wrapper: Double {
    get {
      NSFoundationVersionNumber10_3
    }
  }

  @objc static public var NSFoundationVersionNumber10_3_1Wrapper: Double {
    get {
      NSFoundationVersionNumber10_3_1
    }
  }

  @objc static public var NSFoundationVersionNumber10_3_2Wrapper: Double {
    get {
      NSFoundationVersionNumber10_3_2
    }
  }

  @objc static public var NSFoundationVersionNumber10_3_3Wrapper: Double {
    get {
      NSFoundationVersionNumber10_3_3
    }
  }

  @objc static public var NSFoundationVersionNumber10_3_4Wrapper: Double {
    get {
      NSFoundationVersionNumber10_3_4
    }
  }

  @objc static public var NSFoundationVersionNumber10_3_5Wrapper: Double {
    get {
      NSFoundationVersionNumber10_3_5
    }
  }

  @objc static public var NSFoundationVersionNumber10_3_6Wrapper: Double {
    get {
      NSFoundationVersionNumber10_3_6
    }
  }

  @objc static public var NSFoundationVersionNumber10_3_7Wrapper: Double {
    get {
      NSFoundationVersionNumber10_3_7
    }
  }

  @objc static public var NSFoundationVersionNumber10_3_8Wrapper: Double {
    get {
      NSFoundationVersionNumber10_3_8
    }
  }

  @objc static public var NSFoundationVersionNumber10_3_9Wrapper: Double {
    get {
      NSFoundationVersionNumber10_3_9
    }
  }

  @objc static public var NSFoundationVersionNumber10_4Wrapper: Double {
    get {
      NSFoundationVersionNumber10_4
    }
  }

  @objc static public var NSFoundationVersionNumber10_4_1Wrapper: Double {
    get {
      NSFoundationVersionNumber10_4_1
    }
  }

  @objc static public var NSFoundationVersionNumber10_4_10Wrapper: Double {
    get {
      NSFoundationVersionNumber10_4_10
    }
  }

  @objc static public var NSFoundationVersionNumber10_4_11Wrapper: Double {
    get {
      NSFoundationVersionNumber10_4_11
    }
  }

  @objc static public var NSFoundationVersionNumber10_4_2Wrapper: Double {
    get {
      NSFoundationVersionNumber10_4_2
    }
  }

  @objc static public var NSFoundationVersionNumber10_4_3Wrapper: Double {
    get {
      NSFoundationVersionNumber10_4_3
    }
  }

  @objc static public var NSFoundationVersionNumber10_4_4_IntelWrapper: Double {
    get {
      NSFoundationVersionNumber10_4_4_Intel
    }
  }

  @objc static public var NSFoundationVersionNumber10_4_4_PowerPCWrapper: Double {
    get {
      NSFoundationVersionNumber10_4_4_PowerPC
    }
  }

  @objc static public var NSFoundationVersionNumber10_4_5Wrapper: Double {
    get {
      NSFoundationVersionNumber10_4_5
    }
  }

  @objc static public var NSFoundationVersionNumber10_4_6Wrapper: Double {
    get {
      NSFoundationVersionNumber10_4_6
    }
  }

  @objc static public var NSFoundationVersionNumber10_4_7Wrapper: Double {
    get {
      NSFoundationVersionNumber10_4_7
    }
  }

  @objc static public var NSFoundationVersionNumber10_4_8Wrapper: Double {
    get {
      NSFoundationVersionNumber10_4_8
    }
  }

  @objc static public var NSFoundationVersionNumber10_4_9Wrapper: Double {
    get {
      NSFoundationVersionNumber10_4_9
    }
  }

  @objc static public var NSFoundationVersionNumber10_5Wrapper: Double {
    get {
      NSFoundationVersionNumber10_5
    }
  }

  @objc static public var NSFoundationVersionNumber10_5_1Wrapper: Double {
    get {
      NSFoundationVersionNumber10_5_1
    }
  }

  @objc static public var NSFoundationVersionNumber10_5_2Wrapper: Double {
    get {
      NSFoundationVersionNumber10_5_2
    }
  }

  @objc static public var NSFoundationVersionNumber10_5_3Wrapper: Double {
    get {
      NSFoundationVersionNumber10_5_3
    }
  }

  @objc static public var NSFoundationVersionNumber10_5_4Wrapper: Double {
    get {
      NSFoundationVersionNumber10_5_4
    }
  }

  @objc static public var NSFoundationVersionNumber10_5_5Wrapper: Double {
    get {
      NSFoundationVersionNumber10_5_5
    }
  }

  @objc static public var NSFoundationVersionNumber10_5_6Wrapper: Double {
    get {
      NSFoundationVersionNumber10_5_6
    }
  }

  @objc static public var NSFoundationVersionNumber10_5_7Wrapper: Double {
    get {
      NSFoundationVersionNumber10_5_7
    }
  }

  @objc static public var NSFoundationVersionNumber10_5_8Wrapper: Double {
    get {
      NSFoundationVersionNumber10_5_8
    }
  }

  @objc static public var NSFoundationVersionNumber10_6Wrapper: Double {
    get {
      NSFoundationVersionNumber10_6
    }
  }

  @objc static public var NSFoundationVersionNumber10_6_1Wrapper: Double {
    get {
      NSFoundationVersionNumber10_6_1
    }
  }

  @objc static public var NSFoundationVersionNumber10_6_2Wrapper: Double {
    get {
      NSFoundationVersionNumber10_6_2
    }
  }

  @objc static public var NSFoundationVersionNumber10_6_3Wrapper: Double {
    get {
      NSFoundationVersionNumber10_6_3
    }
  }

  @objc static public var NSFoundationVersionNumber10_6_4Wrapper: Double {
    get {
      NSFoundationVersionNumber10_6_4
    }
  }

  @objc static public var NSFoundationVersionNumber10_6_5Wrapper: Double {
    get {
      NSFoundationVersionNumber10_6_5
    }
  }

  @objc static public var NSFoundationVersionNumber10_6_6Wrapper: Double {
    get {
      NSFoundationVersionNumber10_6_6
    }
  }

  @objc static public var NSFoundationVersionNumber10_6_7Wrapper: Double {
    get {
      NSFoundationVersionNumber10_6_7
    }
  }

  @objc static public var NSFoundationVersionNumber10_6_8Wrapper: Double {
    get {
      NSFoundationVersionNumber10_6_8
    }
  }

  @objc static public var NSFoundationVersionNumber10_7Wrapper: Double {
    get {
      NSFoundationVersionNumber10_7
    }
  }

  @objc static public var NSFoundationVersionNumber10_7_1Wrapper: Double {
    get {
      NSFoundationVersionNumber10_7_1
    }
  }

  @objc static public var NSFoundationVersionNumber10_7_2Wrapper: Double {
    get {
      NSFoundationVersionNumber10_7_2
    }
  }

  @objc static public var NSFoundationVersionNumber10_7_3Wrapper: Double {
    get {
      NSFoundationVersionNumber10_7_3
    }
  }

  @objc static public var NSFoundationVersionNumber10_7_4Wrapper: Double {
    get {
      NSFoundationVersionNumber10_7_4
    }
  }

  @objc static public var NSFoundationVersionNumber10_8Wrapper: Double {
    get {
      NSFoundationVersionNumber10_8
    }
  }

  @objc static public var NSFoundationVersionNumber10_8_1Wrapper: Double {
    get {
      NSFoundationVersionNumber10_8_1
    }
  }

  @objc static public var NSFoundationVersionNumber10_8_2Wrapper: Double {
    get {
      NSFoundationVersionNumber10_8_2
    }
  }

  @objc static public var NSFoundationVersionNumber10_8_3Wrapper: Double {
    get {
      NSFoundationVersionNumber10_8_3
    }
  }

  @objc static public var NSFoundationVersionNumber10_8_4Wrapper: Double {
    get {
      NSFoundationVersionNumber10_8_4
    }
  }

  @objc static public var NSFoundationVersionNumber10_9_2Wrapper: Double {
    get {
      NSFoundationVersionNumber10_9_2
    }
  }

  @objc static public var NSTimeIntervalSince1970Wrapper: Double {
    get {
      NSTimeIntervalSince1970
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var NSNotFoundWrapper1: Int {
    get {
      NSNotFound
    }
  }

  @objc static public var NSURLErrorBadURLWrapper: Int {
    get {
      NSURLErrorBadURL
    }
  }

  @objc static public var NSFormattingErrorWrapper: Int {
    get {
      NSFormattingError
    }
  }

  @objc static public var NSURLErrorUnknownWrapper: Int {
    get {
      NSURLErrorUnknown
    }
  }

  @objc static public var NSFileErrorMaximumWrapper: Int {
    get {
      NSFileErrorMaximum
    }
  }

  @objc static public var NSFileErrorMinimumWrapper: Int {
    get {
      NSFileErrorMinimum
    }
  }

  @objc static public var NSFileLockingErrorWrapper: Int {
    get {
      NSFileLockingError
    }
  }

  @objc static public var NSURLErrorTimedOutWrapper: Int {
    get {
      NSURLErrorTimedOut
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSCoderErrorMaximumWrapper: Int {
    get {
      NSCoderErrorMaximum
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSCoderErrorMinimumWrapper: Int {
    get {
      NSCoderErrorMinimum
    }
  }

  @objc static public var NSURLErrorCancelledWrapper: Int {
    get {
      NSURLErrorCancelled
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSBundleErrorMaximumWrapper: Int {
    get {
      NSBundleErrorMaximum
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSBundleErrorMinimumWrapper: Int {
    get {
      NSBundleErrorMinimum
    }
  }

  @objc static public var NSUserCancelledErrorWrapper: Int {
    get {
      NSUserCancelledError
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSExecutableLinkErrorWrapper: Int {
    get {
      NSExecutableLinkError
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSExecutableLoadErrorWrapper: Int {
    get {
      NSExecutableLoadError
    }
  }

  @objc static public var NSFileNoSuchFileErrorWrapper: Int {
    get {
      NSFileNoSuchFileError
    }
  }

  @objc static public var NSFileReadUnknownErrorWrapper: Int {
    get {
      NSFileReadUnknownError
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSURLErrorCallIsActiveWrapper: Int {
    get {
      NSURLErrorCallIsActive
    }
  }

  @available(macOS, introduced: 10.8)
  @objc static public var NSXPCConnectionInvalidWrapper: Int {
    get {
      NSXPCConnectionInvalid
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSCoderReadCorruptErrorWrapper: Int {
    get {
      NSCoderReadCorruptError
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSFileReadTooLargeErrorWrapper: Int {
    get {
      NSFileReadTooLargeError
    }
  }

  @objc static public var NSFileWriteUnknownErrorWrapper: Int {
    get {
      NSFileWriteUnknownError
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSCloudSharingOtherErrorWrapper: Int {
    get {
      NSCloudSharingOtherError
    }
  }

  @available(macOS, introduced: 10.13)
  @objc static public var NSCoderInvalidValueErrorWrapper: Int {
    get {
      NSCoderInvalidValueError
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var NSCompressionFailedErrorWrapper: Int {
    get {
      NSCompressionFailedError
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSExecutableErrorMaximumWrapper: Int {
    get {
      NSExecutableErrorMaximum
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSExecutableErrorMinimumWrapper: Int {
    get {
      NSExecutableErrorMinimum
    }
  }

  @objc static public var NSFormattingErrorMaximumWrapper: Int {
    get {
      NSFormattingErrorMaximum
    }
  }

  @objc static public var NSFormattingErrorMinimumWrapper: Int {
    get {
      NSFormattingErrorMinimum
    }
  }

  @objc static public var NSURLErrorCannotFindHostWrapper: Int {
    get {
      NSURLErrorCannotFindHost
    }
  }

  @objc static public var NSURLErrorCannotMoveFileWrapper: Int {
    get {
      NSURLErrorCannotMoveFile
    }
  }

  @objc static public var NSURLErrorCannotOpenFileWrapper: Int {
    get {
      NSURLErrorCannotOpenFile
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSURLErrorDataNotAllowedWrapper: Int {
    get {
      NSURLErrorDataNotAllowed
    }
  }

  @objc static public var NSURLErrorUnsupportedURLWrapper: Int {
    get {
      NSURLErrorUnsupportedURL
    }
  }

  @objc static public var NSValidationErrorMaximumWrapper: Int {
    get {
      NSValidationErrorMaximum
    }
  }

  @objc static public var NSValidationErrorMinimumWrapper: Int {
    get {
      NSValidationErrorMinimum
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSCoderValueNotFoundErrorWrapper: Int {
    get {
      NSCoderValueNotFoundError
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var NSCompressionErrorMaximumWrapper: Int {
    get {
      NSCompressionErrorMaximum
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var NSCompressionErrorMinimumWrapper: Int {
    get {
      NSCompressionErrorMinimum
    }
  }

  @available(macOS, introduced: 10.8)
  @objc static public var NSFeatureUnsupportedErrorWrapper: Int {
    get {
      NSFeatureUnsupportedError
    }
  }

  @objc static public var NSFileReadNoSuchFileErrorWrapper: Int {
    get {
      NSFileReadNoSuchFileError
    }
  }

  @objc static public var NSKeyValueValidationErrorWrapper: Int {
    get {
      NSKeyValueValidationError
    }
  }

  @objc static public var NSURLErrorCannotCloseFileWrapper: Int {
    get {
      NSURLErrorCannotCloseFile
    }
  }

  @objc static public var NSURLErrorDNSLookupFailedWrapper: Int {
    get {
      NSURLErrorDNSLookupFailed
    }
  }

  @objc static public var NSURLErrorFileIsDirectoryWrapper: Int {
    get {
      NSURLErrorFileIsDirectory
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSCloudSharingErrorMaximumWrapper: Int {
    get {
      NSCloudSharingErrorMaximum
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSCloudSharingErrorMinimumWrapper: Int {
    get {
      NSCloudSharingErrorMinimum
    }
  }

  @available(macOS, introduced: 10.15)
  @objc static public var NSDecompressionFailedErrorWrapper: Int {
    get {
      NSDecompressionFailedError
    }
  }

  @objc static public var NSFileReadCorruptFileErrorWrapper: Int {
    get {
      NSFileReadCorruptFileError
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSFileWriteFileExistsErrorWrapper: Int {
    get {
      NSFileWriteFileExistsError
    }
  }

  @objc static public var NSFileWriteOutOfSpaceErrorWrapper: Int {
    get {
      NSFileWriteOutOfSpaceError
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var NSPropertyListErrorMaximumWrapper: Int {
    get {
      NSPropertyListErrorMaximum
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var NSPropertyListErrorMinimumWrapper: Int {
    get {
      NSPropertyListErrorMinimum
    }
  }

  @objc static public var NSURLErrorCannotCreateFileWrapper: Int {
    get {
      NSURLErrorCannotCreateFile
    }
  }

  @objc static public var NSURLErrorCannotRemoveFileWrapper: Int {
    get {
      NSURLErrorCannotRemoveFile
    }
  }

  @objc static public var NSURLErrorFileDoesNotExistWrapper: Int {
    get {
      NSURLErrorFileDoesNotExist
    }
  }

  @objc static public var NSURLErrorZeroByteResourceWrapper: Int {
    get {
      NSURLErrorZeroByteResource
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSUserActivityErrorMaximumWrapper: Int {
    get {
      NSUserActivityErrorMaximum
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSUserActivityErrorMinimumWrapper: Int {
    get {
      NSUserActivityErrorMinimum
    }
  }

  @available(macOS, introduced: 10.8)
  @objc static public var NSXPCConnectionInterruptedWrapper: Int {
    get {
      NSXPCConnectionInterrupted
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSCloudSharingConflictErrorWrapper: Int {
    get {
      NSCloudSharingConflictError
    }
  }

  @objc static public var NSFileReadNoPermissionErrorWrapper: Int {
    get {
      NSFileReadNoPermissionError
    }
  }

  @objc static public var NSURLErrorBadServerResponseWrapper: Int {
    get {
      NSURLErrorBadServerResponse
    }
  }

  @objc static public var NSURLErrorCannotWriteToFileWrapper: Int {
    get {
      NSURLErrorCannotWriteToFile
    }
  }

  @available(macOS, introduced: 10.8)
  @objc static public var NSXPCConnectionErrorMaximumWrapper: Int {
    get {
      NSXPCConnectionErrorMaximum
    }
  }

  @available(macOS, introduced: 10.8)
  @objc static public var NSXPCConnectionErrorMinimumWrapper: Int {
    get {
      NSXPCConnectionErrorMinimum
    }
  }

  @available(macOS, introduced: 10.8)
  @objc static public var NSXPCConnectionReplyInvalidWrapper: Int {
    get {
      NSXPCConnectionReplyInvalid
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSExecutableNotLoadableErrorWrapper: Int {
    get {
      NSExecutableNotLoadableError
    }
  }

  @objc static public var NSFileWriteNoPermissionErrorWrapper: Int {
    get {
      NSFileWriteNoPermissionError
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSUbiquitousFileErrorMaximumWrapper: Int {
    get {
      NSUbiquitousFileErrorMaximum
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSUbiquitousFileErrorMinimumWrapper: Int {
    get {
      NSUbiquitousFileErrorMinimum
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSFileManagerUnmountBusyErrorWrapper: Int {
    get {
      NSFileManagerUnmountBusyError
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var NSPropertyListReadStreamErrorWrapper: Int {
    get {
      NSPropertyListReadStreamError
    }
  }

  @objc static public var NSURLErrorCannotConnectToHostWrapper: Int {
    get {
      NSURLErrorCannotConnectToHost
    }
  }

  @objc static public var NSURLErrorCannotDecodeRawDataWrapper: Int {
    get {
      NSURLErrorCannotDecodeRawData
    }
  }

  @objc static public var NSURLErrorCannotParseResponseWrapper: Int {
    get {
      NSURLErrorCannotParseResponse
    }
  }

  @available(macOS, introduced: 10.12.4)
  @objc static public var NSURLErrorFileOutsideSafeAreaWrapper: Int {
    get {
      NSURLErrorFileOutsideSafeArea
    }
  }

  @objc static public var NSURLErrorResourceUnavailableWrapper: Int {
    get {
      NSURLErrorResourceUnavailable
    }
  }

  @objc static public var NSFileReadInvalidFileNameErrorWrapper: Int {
    get {
      NSFileReadInvalidFileNameError
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var NSFileWriteVolumeReadOnlyErrorWrapper: Int {
    get {
      NSFileWriteVolumeReadOnlyError
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var NSPropertyListReadCorruptErrorWrapper: Int {
    get {
      NSPropertyListReadCorruptError
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var NSPropertyListWriteStreamErrorWrapper: Int {
    get {
      NSPropertyListWriteStreamError
    }
  }

  @objc static public var NSURLErrorHTTPTooManyRedirectsWrapper: Int {
    get {
      NSURLErrorHTTPTooManyRedirects
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSCloudSharingNoPermissionErrorWrapper: Int {
    get {
      NSCloudSharingNoPermissionError
    }
  }

  @objc static public var NSFileWriteInvalidFileNameErrorWrapper: Int {
    get {
      NSFileWriteInvalidFileNameError
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSPropertyListWriteInvalidErrorWrapper: Int {
    get {
      NSPropertyListWriteInvalidError
    }
  }

  @objc static public var NSURLErrorCannotLoadFromNetworkWrapper: Int {
    get {
      NSURLErrorCannotLoadFromNetwork
    }
  }

  @objc static public var NSURLErrorNetworkConnectionLostWrapper: Int {
    get {
      NSURLErrorNetworkConnectionLost
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSCloudSharingQuotaExceededErrorWrapper: Int {
    get {
      NSCloudSharingQuotaExceededError
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSExecutableRuntimeMismatchErrorWrapper: Int {
    get {
      NSExecutableRuntimeMismatchError
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSFileManagerUnmountUnknownErrorWrapper: Int {
    get {
      NSFileManagerUnmountUnknownError
    }
  }

  @objc static public var NSFileReadUnsupportedSchemeErrorWrapper: Int {
    get {
      NSFileReadUnsupportedSchemeError
    }
  }

  @objc static public var NSURLErrorNotConnectedToInternetWrapper: Int {
    get {
      NSURLErrorNotConnectedToInternet
    }
  }

  @objc static public var NSURLErrorSecureConnectionFailedWrapper: Int {
    get {
      NSURLErrorSecureConnectionFailed
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSUbiquitousFileUnavailableErrorWrapper: Int {
    get {
      NSUbiquitousFileUnavailableError
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSUserActivityHandoffFailedErrorWrapper: Int {
    get {
      NSUserActivityHandoffFailedError
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSCloudSharingNetworkFailureErrorWrapper: Int {
    get {
      NSCloudSharingNetworkFailureError
    }
  }

  @objc static public var NSFileWriteUnsupportedSchemeErrorWrapper: Int {
    get {
      NSFileWriteUnsupportedSchemeError
    }
  }

  @objc static public var NSURLErrorCannotDecodeContentDataWrapper: Int {
    get {
      NSURLErrorCannotDecodeContentData
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSURLErrorInternationalRoamingOffWrapper: Int {
    get {
      NSURLErrorInternationalRoamingOff
    }
  }

  @objc static public var NSURLErrorNoPermissionsToReadFileWrapper: Int {
    get {
      NSURLErrorNoPermissionsToReadFile
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSURLErrorDataLengthExceedsMaximumWrapper: Int {
    get {
      NSURLErrorDataLengthExceedsMaximum
    }
  }

  @objc static public var NSURLErrorClientCertificateRejectedWrapper: Int {
    get {
      NSURLErrorClientCertificateRejected
    }
  }

  @objc static public var NSURLErrorClientCertificateRequiredWrapper: Int {
    get {
      NSURLErrorClientCertificateRequired
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSFileReadUnknownStringEncodingErrorWrapper: Int {
    get {
      NSFileReadUnknownStringEncodingError
    }
  }

  @available(macOS, introduced: 10.7)
  @objc static public var NSURLErrorRequestBodyStreamExhaustedWrapper: Int {
    get {
      NSURLErrorRequestBodyStreamExhausted
    }
  }

  @objc static public var NSURLErrorServerCertificateUntrustedWrapper: Int {
    get {
      NSURLErrorServerCertificateUntrusted
    }
  }

  @objc static public var NSURLErrorUserAuthenticationRequiredWrapper: Int {
    get {
      NSURLErrorUserAuthenticationRequired
    }
  }

  @available(macOS, introduced: 10.5)
  @objc static public var NSExecutableArchitectureMismatchErrorWrapper: Int {
    get {
      NSExecutableArchitectureMismatchError
    }
  }

  @available(macOS, introduced: 10.6)
  @objc static public var NSPropertyListReadUnknownVersionErrorWrapper: Int {
    get {
      NSPropertyListReadUnknownVersionError
    }
  }

  @objc static public var NSURLErrorServerCertificateHasBadDateWrapper: Int {
    get {
      NSURLErrorServerCertificateHasBadDate
    }
  }

  @objc static public var NSURLErrorUserCancelledAuthenticationWrapper: Int {
    get {
      NSURLErrorUserCancelledAuthentication
    }
  }

  @available(macOS, introduced: 10.12)
  @objc static public var NSCloudSharingTooManyParticipantsErrorWrapper: Int {
    get {
      NSCloudSharingTooManyParticipantsError
    }
  }

  @objc static public var NSURLErrorServerCertificateNotYetValidWrapper: Int {
    get {
      NSURLErrorServerCertificateNotYetValid
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSBundleOnDemandResourceInvalidTagErrorWrapper: Int {
    get {
      NSBundleOnDemandResourceInvalidTagError
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSBundleOnDemandResourceOutOfSpaceErrorWrapper: Int {
    get {
      NSBundleOnDemandResourceOutOfSpaceError
    }
  }

  @objc static public var NSURLErrorRedirectToNonExistentLocationWrapper: Int {
    get {
      NSURLErrorRedirectToNonExistentLocation
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSUserActivityConnectionUnavailableErrorWrapper: Int {
    get {
      NSUserActivityConnectionUnavailableError
    }
  }

  @objc static public var NSFileReadInapplicableStringEncodingErrorWrapper: Int {
    get {
      NSFileReadInapplicableStringEncodingError
    }
  }

  @objc static public var NSURLErrorDownloadDecodingFailedMidStreamWrapper: Int {
    get {
      NSURLErrorDownloadDecodingFailedMidStream
    }
  }

  @objc static public var NSURLErrorServerCertificateHasUnknownRootWrapper: Int {
    get {
      NSURLErrorServerCertificateHasUnknownRoot
    }
  }

  @objc static public var NSFileWriteInapplicableStringEncodingErrorWrapper: Int {
    get {
      NSFileWriteInapplicableStringEncodingError
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSURLErrorBackgroundSessionWasDisconnectedWrapper: Int {
    get {
      NSURLErrorBackgroundSessionWasDisconnected
    }
  }

  @objc static public var NSURLErrorDownloadDecodingFailedToCompleteWrapper: Int {
    get {
      NSURLErrorDownloadDecodingFailedToComplete
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSUbiquitousFileNotUploadedDueToQuotaErrorWrapper: Int {
    get {
      NSUbiquitousFileNotUploadedDueToQuotaError
    }
  }

  @available(macOS, introduced: 10.9)
  @objc static public var NSUbiquitousFileUbiquityServerNotAvailableWrapper: Int {
    get {
      NSUbiquitousFileUbiquityServerNotAvailable
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSUserActivityHandoffUserInfoTooLargeErrorWrapper: Int {
    get {
      NSUserActivityHandoffUserInfoTooLargeError
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSUserActivityRemoteApplicationTimedOutErrorWrapper: Int {
    get {
      NSUserActivityRemoteApplicationTimedOutError
    }
  }

  @available(macOS, introduced: 13.0)
  @objc static public var NSXPCConnectionCodeSigningRequirementFailureWrapper: Int {
    get {
      NSXPCConnectionCodeSigningRequirementFailure
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSBundleOnDemandResourceExceededMaximumSizeErrorWrapper: Int {
    get {
      NSBundleOnDemandResourceExceededMaximumSizeError
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSURLErrorBackgroundSessionInUseByAnotherProcessWrapper: Int {
    get {
      NSURLErrorBackgroundSessionInUseByAnotherProcess
    }
  }

  @available(macOS, introduced: 10.10)
  @objc static public var NSURLErrorBackgroundSessionRequiresSharedContainerWrapper: Int {
    get {
      NSURLErrorBackgroundSessionRequiresSharedContainer
    }
  }

  @available(macOS, introduced: 10.11)
  @objc static public var NSURLErrorAppTransportSecurityRequiresSecureConnectionWrapper: Int {
    get {
      NSURLErrorAppTransportSecurityRequiresSecureConnection
    }
  }

  @objc static public func NSConvertHostDoubleToSwappedWrapper(_ x: Double) -> NSSwappedDoubleWrapper {
    let result = NSConvertHostDoubleToSwapped(x)
    return NSSwappedDoubleWrapper(result)
  }

  @objc static public func NSConvertHostFloatToSwappedWrapper(_ x: Float) -> NSSwappedFloatWrapper {
    let result = NSConvertHostFloatToSwapped(x)
    return NSSwappedFloatWrapper(result)
  }

  @objc static public func NSConvertSwappedDoubleToHostWrapper(_ x: NSSwappedDoubleWrapper) -> Double {
    return NSConvertSwappedDoubleToHost(x.wrappedInstance)
  }

  @objc static public func NSConvertSwappedFloatToHostWrapper(_ x: NSSwappedFloatWrapper) -> Float {
    return NSConvertSwappedFloatToHost(x.wrappedInstance)
  }

  @objc static public func NSCreateHashTableWrapper(_ callBacks: NSHashTableCallBacksWrapper, _ capacity: Int) -> NSHashTableWrapper {
    let result = NSCreateHashTable(callBacks.wrappedInstance, capacity)
    return NSHashTableWrapper(result)
  }

  @objc static public func NSCreateMapTableWrapper(_ keyCallBacks: NSMapTableKeyCallBacksWrapper, _ valueCallBacks: NSMapTableValueCallBacksWrapper, _ capacity: Int) -> NSMapTableWrapper {
    let result = NSCreateMapTable(keyCallBacks.wrappedInstance, valueCallBacks.wrappedInstance, capacity)
    return NSMapTableWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @objc static public func NSEdgeInsetsEqualWrapper(_ aInsets: NSEdgeInsetsWrapper, _ bInsets: NSEdgeInsetsWrapper) -> Bool {
    return NSEdgeInsetsEqual(aInsets.wrappedInstance, bInsets.wrappedInstance)
  }

  @objc static public func NSEdgeInsetsMakeWrapper(_ top: Double, _ left: Double, _ bottom: Double, _ right: Double) -> NSEdgeInsetsWrapper {
    let result = NSEdgeInsetsMake(top, left, bottom, right)
    return NSEdgeInsetsWrapper(result)
  }

  @objc static public func NSFullUserNameWrapper() -> String {
    return NSFullUserName()
  }

  @objc static public func NSHomeDirectoryWrapper() -> String {
    return NSHomeDirectory()
  }

  @objc static public func NSHomeDirectoryForUserWrapper(_ userName: String?) -> String? {
    return NSHomeDirectoryForUser(userName)
  }

  @objc static public func NSHostByteOrderWrapper() -> Int {
    return NSHostByteOrder()
  }

  @objc static public func NSLogPageSizeWrapper() -> Int {
    return NSLogPageSize()
  }

  @objc static public func NSOpenStepRootDirectoryWrapper() -> String {
    return NSOpenStepRootDirectory()
  }

  @objc static public func NSPageSizeWrapper() -> Int {
    return NSPageSize()
  }

  @objc static public func NSRoundDownToMultipleOfPageSizeWrapper(_ bytes: Int) -> Int {
    return NSRoundDownToMultipleOfPageSize(bytes)
  }

  @objc static public func NSRoundUpToMultipleOfPageSizeWrapper(_ bytes: Int) -> Int {
    return NSRoundUpToMultipleOfPageSize(bytes)
  }

  @objc static public func NSSwapBigDoubleToHostWrapper(_ x: NSSwappedDoubleWrapper) -> Double {
    return NSSwapBigDoubleToHost(x.wrappedInstance)
  }

  @objc static public func NSSwapBigFloatToHostWrapper(_ x: NSSwappedFloatWrapper) -> Float {
    return NSSwapBigFloatToHost(x.wrappedInstance)
  }

  @objc static public func NSSwapDoubleWrapper(_ x: NSSwappedDoubleWrapper) -> NSSwappedDoubleWrapper {
    let result = NSSwapDouble(x.wrappedInstance)
    return NSSwappedDoubleWrapper(result)
  }

  @objc static public func NSSwapFloatWrapper(_ x: NSSwappedFloatWrapper) -> NSSwappedFloatWrapper {
    let result = NSSwapFloat(x.wrappedInstance)
    return NSSwappedFloatWrapper(result)
  }

  @objc static public func NSSwapHostDoubleToBigWrapper(_ x: Double) -> NSSwappedDoubleWrapper {
    let result = NSSwapHostDoubleToBig(x)
    return NSSwappedDoubleWrapper(result)
  }

  @objc static public func NSSwapHostDoubleToLittleWrapper(_ x: Double) -> NSSwappedDoubleWrapper {
    let result = NSSwapHostDoubleToLittle(x)
    return NSSwappedDoubleWrapper(result)
  }

  @objc static public func NSSwapHostFloatToBigWrapper(_ x: Float) -> NSSwappedFloatWrapper {
    let result = NSSwapHostFloatToBig(x)
    return NSSwappedFloatWrapper(result)
  }

  @objc static public func NSSwapHostFloatToLittleWrapper(_ x: Float) -> NSSwappedFloatWrapper {
    let result = NSSwapHostFloatToLittle(x)
    return NSSwappedFloatWrapper(result)
  }

  @objc static public func NSSwapLittleDoubleToHostWrapper(_ x: NSSwappedDoubleWrapper) -> Double {
    return NSSwapLittleDoubleToHost(x.wrappedInstance)
  }

  @objc static public func NSSwapLittleFloatToHostWrapper(_ x: NSSwappedFloatWrapper) -> Float {
    return NSSwapLittleFloatToHost(x.wrappedInstance)
  }

  @objc static public func NSTemporaryDirectoryWrapper() -> String {
    return NSTemporaryDirectory()
  }

  @objc static public func NSUserNameWrapper() -> String {
    return NSUserName()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public func powWrapper(_ x: DecimalWrapper, _ y: Int) -> DecimalWrapper {
    let result = pow(x.wrappedInstance, y)
    return DecimalWrapper(result)
  }

  @objc static public func urlFuncWrapper(url: NSURLWrapper) -> NSURLWrapper {
    let result = urlFunc(url: url.wrappedInstance)
    return NSURLWrapper(result)
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class CocoaErrorWrapper: NSObject {
  var wrappedInstance: CocoaError

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var formattingError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.formattingError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileLockingError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileLockingError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isExecutableError: Bool {
    get {
      wrappedInstance.isExecutableError
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isFormattingError: Bool {
    get {
      wrappedInstance.isFormattingError
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isValidationError: Bool {
    get {
      wrappedInstance.isValidationError
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var userCancelledError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.userCancelledError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var executableLinkError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.executableLinkError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var executableLoadError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.executableLoadError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileNoSuchFileError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileNoSuchFileError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isPropertyListError: Bool {
    get {
      wrappedInstance.isPropertyListError
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isUserActivityError: Bool {
    get {
      wrappedInstance.isUserActivityError
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadUnknownError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadUnknownError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isXPCConnectionError: Bool {
    get {
      wrappedInstance.isXPCConnectionError
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var coderReadCorruptError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.coderReadCorruptError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadTooLargeError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadTooLargeError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteUnknownError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteUnknownError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isUbiquitousFileError: Bool {
    get {
      wrappedInstance.isUbiquitousFileError
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var coderValueNotFoundError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.coderValueNotFoundError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var featureUnsupportedError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.featureUnsupportedError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadNoSuchFileError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadNoSuchFileError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var keyValueValidationError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.keyValueValidationError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadCorruptFileError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadCorruptFileError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteFileExistsError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteFileExistsError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteOutOfSpaceError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteOutOfSpaceError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadNoPermissionError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadNoPermissionError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var executableNotLoadableError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.executableNotLoadableError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteNoPermissionError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteNoPermissionError)
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, unavailable, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileManagerUnmountBusyError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileManagerUnmountBusyError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var propertyListReadStreamError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.propertyListReadStreamError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadInvalidFileNameError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadInvalidFileNameError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteVolumeReadOnlyError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteVolumeReadOnlyError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var propertyListReadCorruptError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.propertyListReadCorruptError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var propertyListWriteStreamError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.propertyListWriteStreamError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteInvalidFileNameError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteInvalidFileNameError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var propertyListWriteInvalidError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.propertyListWriteInvalidError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var executableRuntimeMismatchError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.executableRuntimeMismatchError)
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, unavailable, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileManagerUnmountUnknownError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileManagerUnmountUnknownError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadUnsupportedSchemeError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadUnsupportedSchemeError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var ubiquitousFileUnavailableError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.ubiquitousFileUnavailableError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var userActivityHandoffFailedError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.userActivityHandoffFailedError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteUnsupportedSchemeError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteUnsupportedSchemeError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadUnknownStringEncodingError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadUnknownStringEncodingError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var executableArchitectureMismatchError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.executableArchitectureMismatchError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var propertyListReadUnknownVersionError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.propertyListReadUnknownVersionError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var userActivityConnectionUnavailableError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.userActivityConnectionUnavailableError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadInapplicableStringEncodingError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadInapplicableStringEncodingError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteInapplicableStringEncodingError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteInapplicableStringEncodingError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var ubiquitousFileNotUploadedDueToQuotaError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.ubiquitousFileNotUploadedDueToQuotaError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var userActivityHandoffUserInfoTooLargeError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.userActivityHandoffUserInfoTooLargeError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var userActivityRemoteApplicationTimedOutError: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.userActivityRemoteApplicationTimedOutError)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isFileError: Bool {
    get {
      wrappedInstance.isFileError
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isCoderError: Bool {
    get {
      wrappedInstance.isCoderError
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var formatting: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.formatting)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var errorDomain: String {
    get {
      CocoaError.errorDomain
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileLocking: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileLocking)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var userCancelled: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.userCancelled)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var executableLink: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.executableLink)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var executableLoad: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.executableLoad)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileNoSuchFile: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileNoSuchFile)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadUnknown: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadUnknown)
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var coderReadCorrupt: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.coderReadCorrupt)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadTooLarge: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadTooLarge)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteUnknown: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteUnknown)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var coderInvalidValue: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.coderInvalidValue)
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var coderValueNotFound: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.coderValueNotFound)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var featureUnsupported: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.featureUnsupported)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadNoSuchFile: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadNoSuchFile)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var keyValueValidation: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.keyValueValidation)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadCorruptFile: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadCorruptFile)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteFileExists: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteFileExists)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteOutOfSpace: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteOutOfSpace)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadNoPermission: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadNoPermission)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var xpcConnectionInvalid: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.xpcConnectionInvalid)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var executableNotLoadable: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.executableNotLoadable)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteNoPermission: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteNoPermission)
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, unavailable, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileManagerUnmountBusy: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileManagerUnmountBusy)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var propertyListReadStream: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.propertyListReadStream)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadInvalidFileName: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadInvalidFileName)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteVolumeReadOnly: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteVolumeReadOnly)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var propertyListReadCorrupt: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.propertyListReadCorrupt)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var propertyListWriteStream: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.propertyListWriteStream)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteInvalidFileName: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteInvalidFileName)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var propertyListWriteInvalid: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.propertyListWriteInvalid)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var xpcConnectionInterrupted: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.xpcConnectionInterrupted)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var executableRuntimeMismatch: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.executableRuntimeMismatch)
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, unavailable, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileManagerUnmountUnknown: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileManagerUnmountUnknown)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadUnsupportedScheme: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadUnsupportedScheme)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var ubiquitousFileUnavailable: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.ubiquitousFileUnavailable)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var userActivityHandoffFailed: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.userActivityHandoffFailed)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var xpcConnectionReplyInvalid: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.xpcConnectionReplyInvalid)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteUnsupportedScheme: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteUnsupportedScheme)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadUnknownStringEncoding: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadUnknownStringEncoding)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var executableArchitectureMismatch: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.executableArchitectureMismatch)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var propertyListReadUnknownVersion: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.propertyListReadUnknownVersion)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var userActivityConnectionUnavailable: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.userActivityConnectionUnavailable)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileReadInapplicableStringEncoding: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileReadInapplicableStringEncoding)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileWriteInapplicableStringEncoding: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.fileWriteInapplicableStringEncoding)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var ubiquitousFileNotUploadedDueToQuota: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.ubiquitousFileNotUploadedDueToQuota)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var userActivityHandoffUserInfoTooLarge: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.userActivityHandoffUserInfoTooLarge)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var userActivityRemoteApplicationTimedOut: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.userActivityRemoteApplicationTimedOut)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var url: URLWrapper? {
    get {
      wrappedInstance.url == nil ? nil : URLWrapper(wrappedInstance.url!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var ubiquitousFileUbiquityServerNotAvailable: CocoaErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(CocoaError.ubiquitousFileUbiquityServerNotAvailable)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var filePath: String? {
    get {
      wrappedInstance.filePath
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var errorDomain: String {
    get {
      CocoaError.errorDomain
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var localizedDescription: String {
    get {
      wrappedInstance.localizedDescription
    }
  }

  init(_ wrappedInstance: CocoaError) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public class CodeWrapper: NSObject {
    var wrappedInstance: CocoaError.Code

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var formattingError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.formattingError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileLockingError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileLockingError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var userCancelledError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.userCancelledError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var executableLinkError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.executableLinkError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var executableLoadError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.executableLoadError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileNoSuchFileError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileNoSuchFileError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadUnknownError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadUnknownError)
      }
    }

    @available(macOS, introduced: 10.11)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 9.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var coderReadCorruptError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.coderReadCorruptError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadTooLargeError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadTooLargeError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteUnknownError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteUnknownError)
      }
    }

    @available(macOS, introduced: 10.11)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 9.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var coderValueNotFoundError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.coderValueNotFoundError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var featureUnsupportedError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.featureUnsupportedError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadNoSuchFileError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadNoSuchFileError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var keyValueValidationError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.keyValueValidationError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadCorruptFileError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadCorruptFileError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteFileExistsError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteFileExistsError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteOutOfSpaceError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteOutOfSpaceError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadNoPermissionError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadNoPermissionError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var executableNotLoadableError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.executableNotLoadableError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteNoPermissionError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteNoPermissionError)
      }
    }

    @available(macOS, introduced: 10.11)
    @available(watchOS, introduced: 2.0)
    @available(iOS, unavailable, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileManagerUnmountBusyError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileManagerUnmountBusyError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var propertyListReadStreamError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.propertyListReadStreamError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadInvalidFileNameError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadInvalidFileNameError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteVolumeReadOnlyError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteVolumeReadOnlyError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var propertyListReadCorruptError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.propertyListReadCorruptError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var propertyListWriteStreamError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.propertyListWriteStreamError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteInvalidFileNameError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteInvalidFileNameError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var propertyListWriteInvalidError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.propertyListWriteInvalidError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var executableRuntimeMismatchError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.executableRuntimeMismatchError)
      }
    }

    @available(macOS, introduced: 10.11)
    @available(watchOS, introduced: 2.0)
    @available(iOS, unavailable, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileManagerUnmountUnknownError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileManagerUnmountUnknownError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadUnsupportedSchemeError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadUnsupportedSchemeError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var ubiquitousFileUnavailableError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.ubiquitousFileUnavailableError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var userActivityHandoffFailedError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.userActivityHandoffFailedError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteUnsupportedSchemeError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteUnsupportedSchemeError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadUnknownStringEncodingError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadUnknownStringEncodingError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var executableArchitectureMismatchError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.executableArchitectureMismatchError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var propertyListReadUnknownVersionError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.propertyListReadUnknownVersionError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var userActivityConnectionUnavailableError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.userActivityConnectionUnavailableError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadInapplicableStringEncodingError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadInapplicableStringEncodingError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteInapplicableStringEncodingError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteInapplicableStringEncodingError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var ubiquitousFileNotUploadedDueToQuotaError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.ubiquitousFileNotUploadedDueToQuotaError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var userActivityHandoffUserInfoTooLargeError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.userActivityHandoffUserInfoTooLargeError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(*)
    @available(tvOS, introduced: 9.0)
    @objc static public var userActivityRemoteApplicationTimedOutError: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.userActivityRemoteApplicationTimedOutError)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var formatting: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.formatting)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileLocking: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileLocking)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var userCancelled: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.userCancelled)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var executableLink: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.executableLink)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var executableLoad: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.executableLoad)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileNoSuchFile: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileNoSuchFile)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadUnknown: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadUnknown)
      }
    }

    @available(macOS, introduced: 10.11)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 9.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var coderReadCorrupt: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.coderReadCorrupt)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadTooLarge: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadTooLarge)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteUnknown: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteUnknown)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var coderInvalidValue: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.coderInvalidValue)
      }
    }

    @available(macOS, introduced: 10.11)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 9.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var coderValueNotFound: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.coderValueNotFound)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var featureUnsupported: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.featureUnsupported)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadNoSuchFile: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadNoSuchFile)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var keyValueValidation: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.keyValueValidation)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadCorruptFile: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadCorruptFile)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteFileExists: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteFileExists)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteOutOfSpace: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteOutOfSpace)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadNoPermission: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadNoPermission)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var xpcConnectionInvalid: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.xpcConnectionInvalid)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var executableNotLoadable: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.executableNotLoadable)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteNoPermission: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteNoPermission)
      }
    }

    @available(macOS, introduced: 10.11)
    @available(watchOS, introduced: 2.0)
    @available(iOS, unavailable, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileManagerUnmountBusy: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileManagerUnmountBusy)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var propertyListReadStream: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.propertyListReadStream)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadInvalidFileName: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadInvalidFileName)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteVolumeReadOnly: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteVolumeReadOnly)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var propertyListReadCorrupt: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.propertyListReadCorrupt)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var propertyListWriteStream: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.propertyListWriteStream)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteInvalidFileName: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteInvalidFileName)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var propertyListWriteInvalid: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.propertyListWriteInvalid)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var xpcConnectionInterrupted: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.xpcConnectionInterrupted)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var executableRuntimeMismatch: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.executableRuntimeMismatch)
      }
    }

    @available(macOS, introduced: 10.11)
    @available(watchOS, introduced: 2.0)
    @available(iOS, unavailable, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileManagerUnmountUnknown: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileManagerUnmountUnknown)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadUnsupportedScheme: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadUnsupportedScheme)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var ubiquitousFileUnavailable: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.ubiquitousFileUnavailable)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var userActivityHandoffFailed: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.userActivityHandoffFailed)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var xpcConnectionReplyInvalid: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.xpcConnectionReplyInvalid)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteUnsupportedScheme: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteUnsupportedScheme)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadUnknownStringEncoding: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadUnknownStringEncoding)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var executableArchitectureMismatch: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.executableArchitectureMismatch)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var propertyListReadUnknownVersion: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.propertyListReadUnknownVersion)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var userActivityConnectionUnavailable: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.userActivityConnectionUnavailable)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileReadInapplicableStringEncoding: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileReadInapplicableStringEncoding)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileWriteInapplicableStringEncoding: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.fileWriteInapplicableStringEncoding)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var ubiquitousFileNotUploadedDueToQuota: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.ubiquitousFileNotUploadedDueToQuota)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var userActivityHandoffUserInfoTooLarge: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.userActivityHandoffUserInfoTooLarge)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var userActivityRemoteApplicationTimedOut: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.userActivityRemoteApplicationTimedOut)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var ubiquitousFileUbiquityServerNotAvailable: CocoaErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(CocoaError.Code.ubiquitousFileUbiquityServerNotAvailable)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc public var rawValue: Int {
      get {
        wrappedInstance.rawValue
      }
    }

    init(_ wrappedInstance: CocoaError.Code) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc init(rawValue: Int) {
      wrappedInstance = CocoaError.Code(rawValue: rawValue)
    }

  }

}

@available(macOS, introduced: 15)
@available(watchOS, introduced: 11)
@available(iOS, introduced: 18)
@available(tvOS, introduced: 18)
@objc public class ExpressionWrapper: NSObject {
  var wrappedInstance: Expression

  @available(macOS, introduced: 15)
  @available(watchOS, introduced: 11)
  @available(iOS, introduced: 18)
  @available(tvOS, introduced: 18)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 15)
  @available(watchOS, introduced: 11)
  @available(iOS, introduced: 18)
  @available(tvOS, introduced: 18)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  init(_ wrappedInstance: Expression) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class MorphologyWrapper: NSObject {
  var wrappedInstance: Morphology

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var isUnspecified: Bool {
    get {
      wrappedInstance.isUnspecified
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc static public var user: MorphologyWrapper {
    get {
      MorphologyWrapper(Morphology.user)
    }
  }

  init(_ wrappedInstance: Morphology) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc override init() {
    wrappedInstance = Morphology()
  }

  @available(macOS, introduced: 12.0, deprecated: 14.0)
  @available(watchOS, introduced: 8.0, deprecated: 10.0)
  @available(iOS, introduced: 15.0, deprecated: 17.0)
  @available(tvOS, introduced: 15.0, deprecated: 17.0)
  @objc public func customPronoun(forLanguage language: String) -> MorphologyWrapper.CustomPronounWrapper? {
    let result = wrappedInstance.customPronoun(forLanguage: language)
    return result == nil ? nil : CustomPronounWrapper(result!)
  }

  @available(macOS, introduced: 12.0, deprecated: 14.0)
  @available(watchOS, introduced: 8.0, deprecated: 10.0)
  @available(iOS, introduced: 15.0, deprecated: 17.0)
  @available(tvOS, introduced: 15.0, deprecated: 17.0)
  @objc public func setCustomPronoun(_ pronoun: MorphologyWrapper.CustomPronounWrapper?, forLanguage language: String) throws {
    return try wrappedInstance.setCustomPronoun(pronoun?.wrappedInstance, forLanguage: language)
  }

  @available(macOS, introduced: 12.0, deprecated: 14.0)
  @available(watchOS, introduced: 8.0, deprecated: 10.0)
  @available(iOS, introduced: 15.0, deprecated: 17.0)
  @available(tvOS, introduced: 15.0, deprecated: 17.0)
  @objc public class CustomPronounWrapper: NSObject {
    var wrappedInstance: Morphology.CustomPronoun

    @available(macOS, introduced: 12.0, deprecated: 14.0)
    @available(watchOS, introduced: 8.0, deprecated: 10.0)
    @available(iOS, introduced: 15.0, deprecated: 17.0)
    @available(tvOS, introduced: 15.0, deprecated: 17.0)
    @objc public var objectForm: String? {
      get {
        wrappedInstance.objectForm
      }
      set {
        wrappedInstance.objectForm = newValue
      }
    }

    @available(macOS, introduced: 12.0, deprecated: 14.0)
    @available(watchOS, introduced: 8.0, deprecated: 10.0)
    @available(iOS, introduced: 15.0, deprecated: 17.0)
    @available(tvOS, introduced: 15.0, deprecated: 17.0)
    @objc public var subjectForm: String? {
      get {
        wrappedInstance.subjectForm
      }
      set {
        wrappedInstance.subjectForm = newValue
      }
    }

    @available(macOS, introduced: 12.0, deprecated: 14.0)
    @available(watchOS, introduced: 8.0, deprecated: 10.0)
    @available(iOS, introduced: 15.0, deprecated: 17.0)
    @available(tvOS, introduced: 15.0, deprecated: 17.0)
    @objc public var reflexiveForm: String? {
      get {
        wrappedInstance.reflexiveForm
      }
      set {
        wrappedInstance.reflexiveForm = newValue
      }
    }

    @available(macOS, introduced: 12.0, deprecated: 14.0)
    @available(watchOS, introduced: 8.0, deprecated: 10.0)
    @available(iOS, introduced: 15.0, deprecated: 17.0)
    @available(tvOS, introduced: 15.0, deprecated: 17.0)
    @objc public var possessiveForm: String? {
      get {
        wrappedInstance.possessiveForm
      }
      set {
        wrappedInstance.possessiveForm = newValue
      }
    }

    @available(macOS, introduced: 12.0, deprecated: 14.0)
    @available(watchOS, introduced: 8.0, deprecated: 10.0)
    @available(iOS, introduced: 15.0, deprecated: 17.0)
    @available(tvOS, introduced: 15.0, deprecated: 17.0)
    @objc public var possessiveAdjectiveForm: String? {
      get {
        wrappedInstance.possessiveAdjectiveForm
      }
      set {
        wrappedInstance.possessiveAdjectiveForm = newValue
      }
    }

    init(_ wrappedInstance: Morphology.CustomPronoun) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0, deprecated: 14.0)
    @available(watchOS, introduced: 8.0, deprecated: 10.0)
    @available(iOS, introduced: 15.0, deprecated: 17.0)
    @available(tvOS, introduced: 15.0, deprecated: 17.0)
    @objc override init() {
      wrappedInstance = Morphology.CustomPronoun()
    }

    @available(macOS, introduced: 12.0, deprecated: 14.0)
    @available(watchOS, introduced: 8.0, deprecated: 10.0)
    @available(iOS, introduced: 15.0, deprecated: 17.0)
    @available(tvOS, introduced: 15.0, deprecated: 17.0)
    @objc static public func isSupported(forLanguage language: String) -> Bool {
      return Morphology.CustomPronoun.isSupported(forLanguage: language)
    }

  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc public class PronounWrapper: NSObject {
    var wrappedInstance: Morphology.Pronoun

    @available(macOS, introduced: 14)
    @available(watchOS, introduced: 10)
    @available(iOS, introduced: 17)
    @available(tvOS, introduced: 17)
    @objc public var dependentMorphology: MorphologyWrapper? {
      get {
        wrappedInstance.dependentMorphology == nil ? nil : MorphologyWrapper(wrappedInstance.dependentMorphology!)
      }
      set {
        wrappedInstance.dependentMorphology = newValue?.wrappedInstance
      }
    }

    @available(macOS, introduced: 14)
    @available(watchOS, introduced: 10)
    @available(iOS, introduced: 17)
    @available(tvOS, introduced: 17)
    @objc public var morphology: MorphologyWrapper {
      get {
        MorphologyWrapper(wrappedInstance.morphology)
      }
      set {
        wrappedInstance.morphology = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 14)
    @available(watchOS, introduced: 10)
    @available(iOS, introduced: 17)
    @available(tvOS, introduced: 17)
    @objc public var pronoun: String {
      get {
        wrappedInstance.pronoun
      }
      set {
        wrappedInstance.pronoun = newValue
      }
    }

    init(_ wrappedInstance: Morphology.Pronoun) {
      self.wrappedInstance = wrappedInstance
    }

  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class POSIXErrorWrapper: NSObject {
  var wrappedInstance: POSIXError

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var errorDomain: String {
    get {
      POSIXError.errorDomain
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var errorDomain: String {
    get {
      POSIXError.errorDomain
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var localizedDescription: String {
    get {
      wrappedInstance.localizedDescription
    }
  }

  init(_ wrappedInstance: POSIXError) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class URLRequestWrapper: NSObject {
  var wrappedInstance: URLRequest

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var httpMethod: String? {
    get {
      wrappedInstance.httpMethod
    }
    set {
      wrappedInstance.httpMethod = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var httpBodyStream: InputStreamWrapper? {
    get {
      wrappedInstance.httpBodyStream == nil ? nil : InputStreamWrapper(wrappedInstance.httpBodyStream!)
    }
    set {
      wrappedInstance.httpBodyStream = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var mainDocumentURL: URLWrapper? {
    get {
      wrappedInstance.mainDocumentURL == nil ? nil : URLWrapper(wrappedInstance.mainDocumentURL!)
    }
    set {
      wrappedInstance.mainDocumentURL = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var timeoutInterval: TimeInterval {
    get {
      wrappedInstance.timeoutInterval
    }
    set {
      wrappedInstance.timeoutInterval = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var allHTTPHeaderFields: String {
    get {
      wrappedInstance.allHTTPHeaderFields
    }
    set {
      wrappedInstance.allHTTPHeaderFields = newValue
    }
  }

  @available(macOS, introduced: 15.0)
  @available(watchOS, introduced: 11.0)
  @available(iOS, introduced: 18.0)
  @available(visionOS, introduced: 2.0)
  @available(tvOS, introduced: 18.0)
  @objc public var allowsPersistentDNS: Bool {
    get {
      wrappedInstance.allowsPersistentDNS
    }
    set {
      wrappedInstance.allowsPersistentDNS = newValue
    }
  }

  @available(macOS, introduced: 11.3)
  @available(watchOS, introduced: 7.4)
  @available(iOS, introduced: 14.5)
  @available(tvOS, introduced: 14.5)
  @objc public var assumesHTTP3Capable: Bool {
    get {
      wrappedInstance.assumesHTTP3Capable
    }
    set {
      wrappedInstance.assumesHTTP3Capable = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var allowsCellularAccess: Bool {
    get {
      wrappedInstance.allowsCellularAccess
    }
    set {
      wrappedInstance.allowsCellularAccess = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var httpShouldHandleCookies: Bool {
    get {
      wrappedInstance.httpShouldHandleCookies
    }
    set {
      wrappedInstance.httpShouldHandleCookies = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var httpShouldUsePipelining: Bool {
    get {
      wrappedInstance.httpShouldUsePipelining
    }
    set {
      wrappedInstance.httpShouldUsePipelining = newValue
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.1)
  @available(iOS, introduced: 16.1)
  @available(tvOS, introduced: 16.1)
  @objc public var requiresDNSSECValidation: Bool {
    get {
      wrappedInstance.requiresDNSSECValidation
    }
    set {
      wrappedInstance.requiresDNSSECValidation = newValue
    }
  }

  @available(macOS, introduced: 15.2)
  @available(watchOS, introduced: 11.2)
  @available(iOS, introduced: 18.2)
  @available(visionOS, introduced: 2.2)
  @available(tvOS, introduced: 18.2)
  @objc public var cookiePartitionIdentifier: String? {
    get {
      wrappedInstance.cookiePartitionIdentifier
    }
    set {
      wrappedInstance.cookiePartitionIdentifier = newValue
    }
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public var allowsExpensiveNetworkAccess: Bool {
    get {
      wrappedInstance.allowsExpensiveNetworkAccess
    }
    set {
      wrappedInstance.allowsExpensiveNetworkAccess = newValue
    }
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public var allowsConstrainedNetworkAccess: Bool {
    get {
      wrappedInstance.allowsConstrainedNetworkAccess
    }
    set {
      wrappedInstance.allowsConstrainedNetworkAccess = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var url: URLWrapper? {
    get {
      wrappedInstance.url == nil ? nil : URLWrapper(wrappedInstance.url!)
    }
    set {
      wrappedInstance.url = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var httpBody: DataWrapper? {
    get {
      wrappedInstance.httpBody == nil ? nil : DataWrapper(wrappedInstance.httpBody!)
    }
    set {
      wrappedInstance.httpBody = newValue?.wrappedInstance
    }
  }

  init(_ wrappedInstance: URLRequest) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func value(forHTTPHeaderField field: String) -> String? {
    return wrappedInstance.value(forHTTPHeaderField: field)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func addValue(_ value: String, forHTTPHeaderField field: String) {
    return wrappedInstance.addValue(value, forHTTPHeaderField: field)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func setValue(_ value: String?, forHTTPHeaderField field: String) {
    return wrappedInstance.setValue(value, forHTTPHeaderField: field)
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class JSONDecoderWrapper: NSObject {
  var wrappedInstance: JSONDecoder

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var allowsJSON5: Bool {
    get {
      wrappedInstance.allowsJSON5
    }
    set {
      wrappedInstance.allowsJSON5 = newValue
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var assumesTopLevelDictionary: Bool {
    get {
      wrappedInstance.assumesTopLevelDictionary
    }
    set {
      wrappedInstance.assumesTopLevelDictionary = newValue
    }
  }

  init(_ wrappedInstance: JSONDecoder) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc override init() {
    wrappedInstance = JSONDecoder()
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class JSONEncoderWrapper: NSObject {
  var wrappedInstance: JSONEncoder

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var outputFormatting: JSONEncoderWrapper.OutputFormattingWrapper {
    get {
      OutputFormattingWrapper(wrappedInstance.outputFormatting)
    }
    set {
      wrappedInstance.outputFormatting = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: JSONEncoder) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc override init() {
    wrappedInstance = JSONEncoder()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public class OutputFormattingWrapper: NSObject {
    var wrappedInstance: JSONEncoder.OutputFormatting

    @available(macOS, introduced: 10.13)
    @available(watchOS, introduced: 4.0)
    @available(iOS, introduced: 11.0)
    @available(tvOS, introduced: 11.0)
    @objc static public var sortedKeys: JSONEncoderWrapper.OutputFormattingWrapper {
      get {
        OutputFormattingWrapper(JSONEncoder.OutputFormatting.sortedKeys)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var prettyPrinted: JSONEncoderWrapper.OutputFormattingWrapper {
      get {
        OutputFormattingWrapper(JSONEncoder.OutputFormatting.prettyPrinted)
      }
    }

    @available(macOS, introduced: 10.15)
    @available(watchOS, introduced: 6.0)
    @available(iOS, introduced: 13.0)
    @available(tvOS, introduced: 13.0)
    @objc static public var withoutEscapingSlashes: JSONEncoderWrapper.OutputFormattingWrapper {
      get {
        OutputFormattingWrapper(JSONEncoder.OutputFormatting.withoutEscapingSlashes)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: JSONEncoder.OutputFormatting) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = JSONEncoder.OutputFormatting()
    }

  }

}

@available(macOS, introduced: 10.12)
@available(watchOS, introduced: 3.0)
@available(iOS, introduced: 10.0)
@available(tvOS, introduced: 10.0)
@objc public class MeasurementWrapper: NSObject {
  var wrappedInstance: Measurement

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var value: Double {
    get {
      wrappedInstance.value
    }
    set {
      wrappedInstance.value = newValue
    }
  }

  init(_ wrappedInstance: Measurement) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func formatted() -> String {
    return wrappedInstance.formatted()
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class FormatStyleWrapper: NSObject {
    var wrappedInstance: Measurement.FormatStyle

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var numberFormatStyle: FloatingPointFormatStyleWrapper {
      get {
        FloatingPointFormatStyleWrapper(wrappedInstance.numberFormatStyle)
      }
      set {
        wrappedInstance.numberFormatStyle = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var attributed: MeasurementWrapper {
      get {
        MeasurementWrapper(wrappedInstance.attributed)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var usage: MeasurementFormatUnitUsageWrapper {
      get {
        MeasurementFormatUnitUsageWrapper(wrappedInstance.usage)
      }
      set {
        wrappedInstance.usage = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var width: MeasurementWrapper {
      get {
        MeasurementWrapper(wrappedInstance.width)
      }
      set {
        wrappedInstance.width = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper {
      get {
        LocaleWrapper(wrappedInstance.locale)
      }
      set {
        wrappedInstance.locale = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var hidesScaleName: Bool {
      get {
        wrappedInstance.hidesScaleName
      }
      set {
        wrappedInstance.hidesScaleName = newValue
      }
    }

    init(_ wrappedInstance: Measurement.FormatStyle) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> MeasurementWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return MeasurementWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class UnitWidthWrapper: NSObject {
      var wrappedInstance: FormatStyle.UnitWidth

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var abbreviated: MeasurementWrapper {
        get {
          MeasurementWrapper(FormatStyle.UnitWidth.abbreviated)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var wide: MeasurementWrapper {
        get {
          MeasurementWrapper(FormatStyle.UnitWidth.wide)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var narrow: MeasurementWrapper {
        get {
          MeasurementWrapper(FormatStyle.UnitWidth.narrow)
        }
      }

      init(_ wrappedInstance: FormatStyle.UnitWidth) {
        self.wrappedInstance = wrappedInstance
      }

    }

    @available(macOS, introduced: 13.0)
    @available(watchOS, introduced: 9.0)
    @available(iOS, introduced: 16.0)
    @available(tvOS, introduced: 16.0)
    @objc public class ByteCountWrapper: NSObject {
      var wrappedInstance: FormatStyle.ByteCount

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public var includesActualByteCount: Bool {
        get {
          wrappedInstance.includesActualByteCount
        }
        set {
          wrappedInstance.includesActualByteCount = newValue
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public var attributed: MeasurementWrapper {
        get {
          MeasurementWrapper(wrappedInstance.attributed)
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public var allowedUnits: MeasurementWrapper {
        get {
          MeasurementWrapper(wrappedInstance.allowedUnits)
        }
        set {
          wrappedInstance.allowedUnits = newValue.wrappedInstance
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public var spellsOutZero: Bool {
        get {
          wrappedInstance.spellsOutZero
        }
        set {
          wrappedInstance.spellsOutZero = newValue
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public var style: MeasurementWrapper {
        get {
          MeasurementWrapper(wrappedInstance.style)
        }
        set {
          wrappedInstance.style = newValue.wrappedInstance
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public var locale: LocaleWrapper {
        get {
          LocaleWrapper(wrappedInstance.locale)
        }
        set {
          wrappedInstance.locale = newValue.wrappedInstance
        }
      }

      init(_ wrappedInstance: FormatStyle.ByteCount) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public func locale(_ locale: LocaleWrapper) -> MeasurementWrapper {
        let result = wrappedInstance.locale(locale.wrappedInstance)
        return MeasurementWrapper(result)
      }

    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class AttributedStyleWrapper: NSObject {
    var wrappedInstance: Measurement.AttributedStyle

    init(_ wrappedInstance: Measurement.AttributedStyle) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> MeasurementWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return MeasurementWrapper(result)
    }

    @available(macOS, introduced: 13.0)
    @available(watchOS, introduced: 9.0)
    @available(iOS, introduced: 16.0)
    @available(tvOS, introduced: 16.0)
    @objc public class ByteCountWrapper: NSObject {
      var wrappedInstance: AttributedStyle.ByteCount

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public var includesActualByteCount: Bool {
        get {
          wrappedInstance.includesActualByteCount
        }
        set {
          wrappedInstance.includesActualByteCount = newValue
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public var allowedUnits: MeasurementWrapper {
        get {
          MeasurementWrapper(wrappedInstance.allowedUnits)
        }
        set {
          wrappedInstance.allowedUnits = newValue.wrappedInstance
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public var spellsOutZero: Bool {
        get {
          wrappedInstance.spellsOutZero
        }
        set {
          wrappedInstance.spellsOutZero = newValue
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public var style: MeasurementWrapper {
        get {
          MeasurementWrapper(wrappedInstance.style)
        }
        set {
          wrappedInstance.style = newValue.wrappedInstance
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public var locale: LocaleWrapper {
        get {
          LocaleWrapper(wrappedInstance.locale)
        }
        set {
          wrappedInstance.locale = newValue.wrappedInstance
        }
      }

      init(_ wrappedInstance: AttributedStyle.ByteCount) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public func locale(_ locale: LocaleWrapper) -> MeasurementWrapper {
        let result = wrappedInstance.locale(locale.wrappedInstance)
        return MeasurementWrapper(result)
      }

    }

  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class StringStyleWrapper: NSObject {
  var wrappedInstance: StringStyle

  init(_ wrappedInstance: StringStyle) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func format(_ value: String) -> String {
    return wrappedInstance.format(value)
  }

}

@available(macOS, introduced: 13)
@available(watchOS, introduced: 9)
@available(iOS, introduced: 16)
@available(tvOS, introduced: 16)
@objc public class URLResourceWrapper: NSObject {
  var wrappedInstance: URLResource

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var subdirectory: String? {
    get {
      wrappedInstance.subdirectory
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var name: String {
    get {
      wrappedInstance.name
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var bundle: BundleWrapper {
    get {
      BundleWrapper(wrappedInstance.bundle)
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var locale: LocaleWrapper {
    get {
      LocaleWrapper(wrappedInstance.locale)
    }
    set {
      wrappedInstance.locale = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: URLResource) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class CharacterSetWrapper: NSObject {
  var wrappedInstance: CharacterSet

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var whitespaces: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.whitespaces)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var alphanumerics: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.alphanumerics)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var decimalDigits: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.decimalDigits)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var decomposables: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.decomposables)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var urlHostAllowed: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.urlHostAllowed)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var urlPathAllowed: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.urlPathAllowed)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var urlUserAllowed: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.urlUserAllowed)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var urlQueryAllowed: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.urlQueryAllowed)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var lowercaseLetters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.lowercaseLetters)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var uppercaseLetters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.uppercaseLetters)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var controlCharacters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.controlCharacters)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var illegalCharacters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.illegalCharacters)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var nonBaseCharacters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.nonBaseCharacters)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var capitalizedLetters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.capitalizedLetters)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var urlFragmentAllowed: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.urlFragmentAllowed)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var urlPasswordAllowed: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.urlPasswordAllowed)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var bitmapRepresentation: DataWrapper {
    get {
      DataWrapper(wrappedInstance.bitmapRepresentation)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var punctuationCharacters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.punctuationCharacters)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var whitespacesAndNewlines: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.whitespacesAndNewlines)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var letters: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.letters)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var symbols: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.symbols)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var inverted: CharacterSetWrapper {
    get {
      CharacterSetWrapper(wrappedInstance.inverted)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var newlines: CharacterSetWrapper {
    get {
      CharacterSetWrapper(CharacterSet.newlines)
    }
  }

  @objc public var isEmpty: Bool {
    get {
      wrappedInstance.isEmpty
    }
  }

  init(_ wrappedInstance: CharacterSet) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(charactersIn string: String) {
    wrappedInstance = CharacterSet(charactersIn: string)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init?(contentsOfFile file: String) {
    if let instance = CharacterSet(contentsOfFile: file) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(bitmapRepresentation data: DataWrapper) {
    wrappedInstance = CharacterSet(bitmapRepresentation: data.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc override init() {
    wrappedInstance = CharacterSet()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func isSuperset(of other: CharacterSetWrapper) -> Bool {
    return wrappedInstance.isSuperset(of: other.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func subtracting(_ other: CharacterSetWrapper) -> CharacterSetWrapper {
    let result = wrappedInstance.subtracting(other.wrappedInstance)
    return CharacterSetWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func intersection(_ other: CharacterSetWrapper) -> CharacterSetWrapper {
    let result = wrappedInstance.intersection(other.wrappedInstance)
    return CharacterSetWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func formIntersection(_ other: CharacterSetWrapper) {
    return wrappedInstance.formIntersection(other.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func symmetricDifference(_ other: CharacterSetWrapper) -> CharacterSetWrapper {
    let result = wrappedInstance.symmetricDifference(other.wrappedInstance)
    return CharacterSetWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func formSymmetricDifference(_ other: CharacterSetWrapper) {
    return wrappedInstance.formSymmetricDifference(other.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func union(_ other: CharacterSetWrapper) -> CharacterSetWrapper {
    let result = wrappedInstance.union(other.wrappedInstance)
    return CharacterSetWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func insert(charactersIn string: String) {
    return wrappedInstance.insert(charactersIn: string)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func invert() {
    return wrappedInstance.invert()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func remove(charactersIn string: String) {
    return wrappedInstance.remove(charactersIn: string)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func subtract(_ other: CharacterSetWrapper) {
    return wrappedInstance.subtract(other.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func formUnion(_ other: CharacterSetWrapper) {
    return wrappedInstance.formUnion(other.wrappedInstance)
  }

}

@available(macOS, introduced: 10.12)
@available(watchOS, introduced: 3.0)
@available(iOS, introduced: 10.0)
@available(tvOS, introduced: 10.0)
@objc public class DateIntervalWrapper: NSObject {
  var wrappedInstance: DateInterval

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var end: DateWrapper {
    get {
      DateWrapper(wrappedInstance.end)
    }
    set {
      wrappedInstance.end = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var start: DateWrapper {
    get {
      DateWrapper(wrappedInstance.start)
    }
    set {
      wrappedInstance.start = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var duration: TimeInterval {
    get {
      wrappedInstance.duration
    }
    set {
      wrappedInstance.duration = newValue
    }
  }

  init(_ wrappedInstance: DateInterval) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc init(start: DateWrapper, end: DateWrapper) {
    wrappedInstance = DateInterval(start: start.wrappedInstance, end: end.wrappedInstance)
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc init(start: DateWrapper, duration: TimeInterval) {
    wrappedInstance = DateInterval(start: start.wrappedInstance, duration: duration)
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc override init() {
    wrappedInstance = DateInterval()
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public func intersects(_ dateInterval: DateIntervalWrapper) -> Bool {
    return wrappedInstance.intersects(dateInterval.wrappedInstance)
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public func intersection(with dateInterval: DateIntervalWrapper) -> DateIntervalWrapper? {
    let result = wrappedInstance.intersection(with: dateInterval.wrappedInstance)
    return result == nil ? nil : DateIntervalWrapper(result!)
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public func contains(_ date: DateWrapper) -> Bool {
    return wrappedInstance.contains(date.wrappedInstance)
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class NotificationWrapper: NSObject {
  var wrappedInstance: Notification

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var name: NSNotificationWrapper.NameWrapper {
    get {
      NameWrapper(wrappedInstance.name)
    }
    set {
      wrappedInstance.name = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: Notification) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class URLQueryItemWrapper: NSObject {
  var wrappedInstance: URLQueryItem

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var name: String {
    get {
      wrappedInstance.name
    }
    set {
      wrappedInstance.name = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var value: String? {
    get {
      wrappedInstance.value
    }
    set {
      wrappedInstance.value = newValue
    }
  }

  init(_ wrappedInstance: URLQueryItem) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(name: String, value: String?) {
    wrappedInstance = URLQueryItem(name: name, value: value)
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class TermOfAddressWrapper: NSObject {
  var wrappedInstance: TermOfAddress

  @available(macOS, introduced: 15)
  @available(watchOS, introduced: 11)
  @available(iOS, introduced: 18)
  @available(visionOS, introduced: 2)
  @available(tvOS, introduced: 18)
  @objc static public var currentUser: TermOfAddressWrapper {
    get {
      TermOfAddressWrapper(TermOfAddress.currentUser)
    }
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc static public var neutral: TermOfAddressWrapper {
    get {
      TermOfAddressWrapper(TermOfAddress.neutral)
    }
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc static public var feminine: TermOfAddressWrapper {
    get {
      TermOfAddressWrapper(TermOfAddress.feminine)
    }
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc public var language: LocaleWrapper.LanguageWrapper? {
    get {
      wrappedInstance.language == nil ? nil : LanguageWrapper(wrappedInstance.language!)
    }
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc static public var masculine: TermOfAddressWrapper {
    get {
      TermOfAddressWrapper(TermOfAddress.masculine)
    }
  }

  init(_ wrappedInstance: TermOfAddress) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class URLComponentsWrapper: NSObject {
  var wrappedInstance: URLComponents

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc public var encodedHost: String? {
    get {
      wrappedInstance.encodedHost
    }
    set {
      wrappedInstance.encodedHost = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc public var percentEncodedHost: String? {
    get {
      wrappedInstance.percentEncodedHost
    }
    set {
      wrappedInstance.percentEncodedHost = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var percentEncodedPath: String {
    get {
      wrappedInstance.percentEncodedPath
    }
    set {
      wrappedInstance.percentEncodedPath = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var percentEncodedUser: String? {
    get {
      wrappedInstance.percentEncodedUser
    }
    set {
      wrappedInstance.percentEncodedUser = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var percentEncodedQuery: String? {
    get {
      wrappedInstance.percentEncodedQuery
    }
    set {
      wrappedInstance.percentEncodedQuery = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var percentEncodedFragment: String? {
    get {
      wrappedInstance.percentEncodedFragment
    }
    set {
      wrappedInstance.percentEncodedFragment = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var percentEncodedPassword: String? {
    get {
      wrappedInstance.percentEncodedPassword
    }
    set {
      wrappedInstance.percentEncodedPassword = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var url: URLWrapper? {
    get {
      wrappedInstance.url == nil ? nil : URLWrapper(wrappedInstance.url!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var host: String? {
    get {
      wrappedInstance.host
    }
    set {
      wrappedInstance.host = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var path: String {
    get {
      wrappedInstance.path
    }
    set {
      wrappedInstance.path = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var port: Int? {
    get {
      wrappedInstance.port
    }
    set {
      wrappedInstance.port = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var user: String? {
    get {
      wrappedInstance.user
    }
    set {
      wrappedInstance.user = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var query: String? {
    get {
      wrappedInstance.query
    }
    set {
      wrappedInstance.query = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var scheme: String? {
    get {
      wrappedInstance.scheme
    }
    set {
      wrappedInstance.scheme = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var string: String? {
    get {
      wrappedInstance.string
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var fragment: String? {
    get {
      wrappedInstance.fragment
    }
    set {
      wrappedInstance.fragment = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var password: String? {
    get {
      wrappedInstance.password
    }
    set {
      wrappedInstance.password = newValue
    }
  }

  init(_ wrappedInstance: URLComponents) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init?(url: URLWrapper, resolvingAgainstBaseURL resolve: Bool) {
    if let instance = URLComponents(url: url.wrappedInstance, resolvingAgainstBaseURL: resolve) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 14.0)
  @available(watchOS, introduced: 10.0)
  @available(iOS, introduced: 17.0)
  @available(tvOS, introduced: 17.0)
  @objc init?(string: String, encodingInvalidCharacters: Bool) {
    if let instance = URLComponents(string: string, encodingInvalidCharacters: encodingInvalidCharacters) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init?(string: String) {
    if let instance = URLComponents(string: string) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc override init() {
    wrappedInstance = URLComponents()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func url(relativeTo base: URLWrapper?) -> URLWrapper? {
    let result = wrappedInstance.url(relativeTo: base?.wrappedInstance)
    return result == nil ? nil : URLWrapper(result!)
  }

}

@available(macOS, introduced: 10.9)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class DateComponentsWrapper: NSObject {
  var wrappedInstance: DateComponents

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isValidDate: Bool {
    get {
      wrappedInstance.isValidDate
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var nanosecond: Int? {
    get {
      wrappedInstance.nanosecond
    }
    set {
      wrappedInstance.nanosecond = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var weekOfYear: Int? {
    get {
      wrappedInstance.weekOfYear
    }
    set {
      wrappedInstance.weekOfYear = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isLeapMonth: Bool? {
    get {
      wrappedInstance.isLeapMonth
    }
    set {
      wrappedInstance.isLeapMonth = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var weekOfMonth: Int? {
    get {
      wrappedInstance.weekOfMonth
    }
    set {
      wrappedInstance.weekOfMonth = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var weekdayOrdinal: Int? {
    get {
      wrappedInstance.weekdayOrdinal
    }
    set {
      wrappedInstance.weekdayOrdinal = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var yearForWeekOfYear: Int? {
    get {
      wrappedInstance.yearForWeekOfYear
    }
    set {
      wrappedInstance.yearForWeekOfYear = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var day: Int? {
    get {
      wrappedInstance.day
    }
    set {
      wrappedInstance.day = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var era: Int? {
    get {
      wrappedInstance.era
    }
    set {
      wrappedInstance.era = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var date: DateWrapper? {
    get {
      wrappedInstance.date == nil ? nil : DateWrapper(wrappedInstance.date!)
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var hour: Int? {
    get {
      wrappedInstance.hour
    }
    set {
      wrappedInstance.hour = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var year: Int? {
    get {
      wrappedInstance.year
    }
    set {
      wrappedInstance.year = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var month: Int? {
    get {
      wrappedInstance.month
    }
    set {
      wrappedInstance.month = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var minute: Int? {
    get {
      wrappedInstance.minute
    }
    set {
      wrappedInstance.minute = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var second: Int? {
    get {
      wrappedInstance.second
    }
    set {
      wrappedInstance.second = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var quarter: Int? {
    get {
      wrappedInstance.quarter
    }
    set {
      wrappedInstance.quarter = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var weekday: Int? {
    get {
      wrappedInstance.weekday
    }
    set {
      wrappedInstance.weekday = newValue
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var calendar: CalendarWrapper? {
    get {
      wrappedInstance.calendar == nil ? nil : CalendarWrapper(wrappedInstance.calendar!)
    }
    set {
      wrappedInstance.calendar = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var timeZone: TimeZoneWrapper? {
    get {
      wrappedInstance.timeZone == nil ? nil : TimeZoneWrapper(wrappedInstance.timeZone!)
    }
    set {
      wrappedInstance.timeZone = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 15)
  @available(watchOS, introduced: 11)
  @available(iOS, introduced: 18)
  @available(tvOS, introduced: 18)
  @objc public var dayOfYear: Int? {
    get {
      wrappedInstance.dayOfYear
    }
    set {
      wrappedInstance.dayOfYear = newValue
    }
  }

  init(_ wrappedInstance: DateComponents) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.9)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func isValidDate(in calendar: CalendarWrapper) -> Bool {
    return wrappedInstance.isValidDate(in: calendar.wrappedInstance)
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class PredicateErrorWrapper: NSObject {
  var wrappedInstance: PredicateError

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc static public var invalidInput: PredicateErrorWrapper {
    get {
      PredicateErrorWrapper(PredicateError.invalidInput)
    }
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc static public var forceCastFailure: PredicateErrorWrapper {
    get {
      PredicateErrorWrapper(PredicateError.forceCastFailure)
    }
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc static public var undefinedVariable: PredicateErrorWrapper {
    get {
      PredicateErrorWrapper(PredicateError.undefinedVariable)
    }
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc static public var forceUnwrapFailure: PredicateErrorWrapper {
    get {
      PredicateErrorWrapper(PredicateError.forceUnwrapFailure)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var localizedDescription: String {
    get {
      wrappedInstance.localizedDescription
    }
  }

  init(_ wrappedInstance: PredicateError) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class SortDescriptorWrapper: NSObject {
  var wrappedInstance: SortDescriptor

  init(_ wrappedInstance: SortDescriptor) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class AffineTransformWrapper: NSObject {
  var wrappedInstance: AffineTransform

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var identity: AffineTransformWrapper {
    get {
      AffineTransformWrapper(AffineTransform.identity)
    }
  }

  init(_ wrappedInstance: AffineTransform) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc override init() {
    wrappedInstance = AffineTransform()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func append(_ transform: AffineTransformWrapper) {
    return wrappedInstance.append(transform.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func invert() {
    return wrappedInstance.invert()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func prepend(_ transform: AffineTransformWrapper) {
    return wrappedInstance.prepend(transform.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func inverted() -> AffineTransformWrapper? {
    let result = wrappedInstance.inverted()
    return result == nil ? nil : AffineTransformWrapper(result!)
  }

}

@available(macOS, introduced: 12)
@available(watchOS, introduced: 8)
@available(iOS, introduced: 15)
@available(tvOS, introduced: 15)
@objc public class FoundationAttributesWrapper: NSObject {
  var wrappedInstance: FoundationAttributes

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc static public var decodingConfiguration: AttributeScopeCodableConfigurationWrapper {
    get {
      AttributeScopeCodableConfigurationWrapper(FoundationAttributes.decodingConfiguration)
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc static public var encodingConfiguration: AttributeScopeCodableConfigurationWrapper {
    get {
      AttributeScopeCodableConfigurationWrapper(FoundationAttributes.encodingConfiguration)
    }
  }

  init(_ wrappedInstance: FoundationAttributes) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public class MeasurementAttributeWrapper: NSObject {
    var wrappedInstance: FoundationAttributes.MeasurementAttribute

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc static public var name: String {
      get {
        FoundationAttributes.MeasurementAttribute.name
      }
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public var description: String {
      get {
        wrappedInstance.description
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var inheritedByAddedText: Bool {
      get {
        FoundationAttributes.MeasurementAttribute.inheritedByAddedText
      }
    }

    init(_ wrappedInstance: FoundationAttributes.MeasurementAttribute) {
      self.wrappedInstance = wrappedInstance
    }

  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public class NumberFormatAttributesWrapper: NSObject {
    var wrappedInstance: FoundationAttributes.NumberFormatAttributes

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc static public var decodingConfiguration: AttributeScopeCodableConfigurationWrapper {
      get {
        AttributeScopeCodableConfigurationWrapper(FoundationAttributes.NumberFormatAttributes.decodingConfiguration)
      }
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc static public var encodingConfiguration: AttributeScopeCodableConfigurationWrapper {
      get {
        AttributeScopeCodableConfigurationWrapper(FoundationAttributes.NumberFormatAttributes.encodingConfiguration)
      }
    }

    init(_ wrappedInstance: FoundationAttributes.NumberFormatAttributes) {
      self.wrappedInstance = wrappedInstance
    }

  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class LocalizedStringArgumentAttributesWrapper: NSObject {
    var wrappedInstance: FoundationAttributes.LocalizedStringArgumentAttributes

    init(_ wrappedInstance: FoundationAttributes.LocalizedStringArgumentAttributes) {
      self.wrappedInstance = wrappedInstance
    }

  }

}

@available(macOS, introduced: 15)
@available(watchOS, introduced: 11)
@available(iOS, introduced: 18)
@available(tvOS, introduced: 18)
@objc public class ValueWrapper: NSObject {
  var wrappedInstance: Value

  init(_ wrappedInstance: Value) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class ListFormatStyleWrapper: NSObject {
  var wrappedInstance: ListFormatStyle

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var width: ListFormatStyleWrapper {
    get {
      ListFormatStyleWrapper(wrappedInstance.width)
    }
    set {
      wrappedInstance.width = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var locale: LocaleWrapper {
    get {
      LocaleWrapper(wrappedInstance.locale)
    }
    set {
      wrappedInstance.locale = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var listType: ListFormatStyleWrapper {
    get {
      ListFormatStyleWrapper(wrappedInstance.listType)
    }
    set {
      wrappedInstance.listType = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: ListFormatStyle) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func locale(_ locale: LocaleWrapper) -> ListFormatStyleWrapper {
    let result = wrappedInstance.locale(locale.wrappedInstance)
    return ListFormatStyleWrapper(result)
  }

}

@available(macOS, introduced: 12)
@available(watchOS, introduced: 8)
@available(iOS, introduced: 15)
@available(tvOS, introduced: 15)
@objc public class AttributedStringWrapper: NSObject {
  var wrappedInstance: AttributedString

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var characters: AttributedStringWrapper.CharacterViewWrapper {
    get {
      CharacterViewWrapper(wrappedInstance.characters)
    }
    set {
      wrappedInstance.characters = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var startIndex: AttributedStringWrapper.IndexWrapper {
    get {
      IndexWrapper(wrappedInstance.startIndex)
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var unicodeScalars: AttributedStringWrapper.UnicodeScalarViewWrapper {
    get {
      UnicodeScalarViewWrapper(wrappedInstance.unicodeScalars)
    }
    set {
      wrappedInstance.unicodeScalars = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var runs: AttributedStringWrapper.RunsWrapper {
    get {
      RunsWrapper(wrappedInstance.runs)
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var endIndex: AttributedStringWrapper.IndexWrapper {
    get {
      IndexWrapper(wrappedInstance.endIndex)
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: AttributedString) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc init(stringLiteral value: String) {
    wrappedInstance = AttributedString(stringLiteral: value)
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc init(localized resource: LocalizedStringResourceWrapper, options: AttributedStringWrapper.LocalizationOptionsWrapper) {
    wrappedInstance = AttributedString(localized: resource.wrappedInstance, options: options.wrappedInstance)
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc init(localized resource: LocalizedStringResourceWrapper) {
    wrappedInstance = AttributedString(localized: resource.wrappedInstance)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc override init() {
    wrappedInstance = AttributedString()
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc init(_ nsStr: NSAttributedStringWrapper) {
    wrappedInstance = AttributedString(nsStr.wrappedInstance)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func setAttributes(_ attributes: AttributeContainerWrapper) {
    return wrappedInstance.setAttributes(attributes.wrappedInstance)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func replaceAttributes(_ attributes: AttributeContainerWrapper, with others: AttributeContainerWrapper) {
    return wrappedInstance.replaceAttributes(attributes.wrappedInstance, with: others.wrappedInstance)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func inflected() -> AttributedStringWrapper {
    let result = wrappedInstance.inflected()
    return AttributedStringWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func settingAttributes(_ attributes: AttributeContainerWrapper) -> AttributedStringWrapper {
    let result = wrappedInstance.settingAttributes(attributes.wrappedInstance)
    return AttributedStringWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func replacingAttributes(_ attributes: AttributeContainerWrapper, with others: AttributeContainerWrapper) -> AttributedStringWrapper {
    let result = wrappedInstance.replacingAttributes(attributes.wrappedInstance, with: others.wrappedInstance)
    return AttributedStringWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(afterCharacter i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(afterCharacter: i.wrappedInstance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(beforeCharacter i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(beforeCharacter: i.wrappedInstance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(afterUnicodeScalar i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(afterUnicodeScalar: i.wrappedInstance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(beforeUnicodeScalar i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(beforeUnicodeScalar: i.wrappedInstance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(afterRun i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(afterRun: i.wrappedInstance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(beforeRun i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(beforeRun: i.wrappedInstance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(_ i: AttributedStringWrapper.IndexWrapper, offsetByRuns distance: Int) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(i.wrappedInstance, offsetByRuns: distance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(_ i: AttributedStringWrapper.IndexWrapper, offsetByCharacters distance: Int) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(i.wrappedInstance, offsetByCharacters: distance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(_ i: AttributedStringWrapper.IndexWrapper, offsetByUnicodeScalars distance: Int) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(i.wrappedInstance, offsetByUnicodeScalars: distance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public class CharacterViewWrapper: NSObject {
    var wrappedInstance: AttributedString.CharacterView

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public var startIndex: AttributedStringWrapper.IndexWrapper {
      get {
        IndexWrapper(wrappedInstance.startIndex)
      }
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public var count: Int {
      get {
        wrappedInstance.count
      }
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public var endIndex: AttributedStringWrapper.IndexWrapper {
      get {
        IndexWrapper(wrappedInstance.endIndex)
      }
    }

    @objc public var underestimatedCount: Int {
      get {
        wrappedInstance.underestimatedCount
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: AttributedString.CharacterView) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc override init() {
      wrappedInstance = AttributedString.CharacterView()
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func index(after i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
      let result = wrappedInstance.index(after: i.wrappedInstance)
      return IndexWrapper(result)
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func index(before i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
      let result = wrappedInstance.index(before: i.wrappedInstance)
      return IndexWrapper(result)
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func index(_ i: AttributedStringWrapper.IndexWrapper, offsetBy distance: Int, limitedBy limit: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper? {
      let result = wrappedInstance.index(i.wrappedInstance, offsetBy: distance, limitedBy: limit.wrappedInstance)
      return result == nil ? nil : IndexWrapper(result!)
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func index(_ i: AttributedStringWrapper.IndexWrapper, offsetBy distance: Int) -> AttributedStringWrapper.IndexWrapper {
      let result = wrappedInstance.index(i.wrappedInstance, offsetBy: distance)
      return IndexWrapper(result)
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func distance(from start: AttributedStringWrapper.IndexWrapper, to end: AttributedStringWrapper.IndexWrapper) -> Int {
      return wrappedInstance.distance(from: start.wrappedInstance, to: end.wrappedInstance)
    }

    @objc public func removeFirst(_ k: Int) {
      return wrappedInstance.removeFirst(k)
    }

    @objc public func reserveCapacity(_ n: Int) {
      return wrappedInstance.reserveCapacity(n)
    }

    @objc public func removeLast(_ k: Int) {
      return wrappedInstance.removeLast(k)
    }

  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public class FormattingOptionsWrapper: NSObject {
    var wrappedInstance: AttributedString.FormattingOptions

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc static public var applyReplacementIndexAttribute: AttributedStringWrapper.FormattingOptionsWrapper {
      get {
        FormattingOptionsWrapper(AttributedString.FormattingOptions.applyReplacementIndexAttribute)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: AttributedString.FormattingOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = AttributedString.FormattingOptions()
    }

  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public class UnicodeScalarViewWrapper: NSObject {
    var wrappedInstance: AttributedString.UnicodeScalarView

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public var startIndex: AttributedStringWrapper.IndexWrapper {
      get {
        IndexWrapper(wrappedInstance.startIndex)
      }
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public var count: Int {
      get {
        wrappedInstance.count
      }
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public var endIndex: AttributedStringWrapper.IndexWrapper {
      get {
        IndexWrapper(wrappedInstance.endIndex)
      }
    }

    @objc public var underestimatedCount: Int {
      get {
        wrappedInstance.underestimatedCount
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: AttributedString.UnicodeScalarView) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc override init() {
      wrappedInstance = AttributedString.UnicodeScalarView()
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func index(after i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
      let result = wrappedInstance.index(after: i.wrappedInstance)
      return IndexWrapper(result)
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func index(before i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
      let result = wrappedInstance.index(before: i.wrappedInstance)
      return IndexWrapper(result)
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func index(_ i: AttributedStringWrapper.IndexWrapper, offsetBy distance: Int, limitedBy limit: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper? {
      let result = wrappedInstance.index(i.wrappedInstance, offsetBy: distance, limitedBy: limit.wrappedInstance)
      return result == nil ? nil : IndexWrapper(result!)
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func index(_ i: AttributedStringWrapper.IndexWrapper, offsetBy distance: Int) -> AttributedStringWrapper.IndexWrapper {
      let result = wrappedInstance.index(i.wrappedInstance, offsetBy: distance)
      return IndexWrapper(result)
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func distance(from start: AttributedStringWrapper.IndexWrapper, to end: AttributedStringWrapper.IndexWrapper) -> Int {
      return wrappedInstance.distance(from: start.wrappedInstance, to: end.wrappedInstance)
    }

    @objc public func removeFirst(_ k: Int) {
      return wrappedInstance.removeFirst(k)
    }

    @objc public func reserveCapacity(_ n: Int) {
      return wrappedInstance.reserveCapacity(n)
    }

    @objc public func removeLast(_ k: Int) {
      return wrappedInstance.removeLast(k)
    }

  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class LocalizationOptionsWrapper: NSObject {
    var wrappedInstance: AttributedString.LocalizationOptions

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var applyReplacementIndexAttribute: Bool {
      get {
        wrappedInstance.applyReplacementIndexAttribute
      }
      set {
        wrappedInstance.applyReplacementIndexAttribute = newValue
      }
    }

    @available(macOS, introduced: 15.0)
    @available(watchOS, introduced: 11.0)
    @available(iOS, introduced: 18.0)
    @available(visionOS, introduced: 2.0)
    @available(tvOS, introduced: 18.0)
    @objc public var inflect: Bool {
      get {
        wrappedInstance.inflect
      }
      set {
        wrappedInstance.inflect = newValue
      }
    }

    init(_ wrappedInstance: AttributedString.LocalizationOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc override init() {
      wrappedInstance = AttributedString.LocalizationOptions()
    }

    @available(macOS, introduced: 15.0)
    @available(watchOS, introduced: 11.0)
    @available(iOS, introduced: 18.0)
    @available(tvOS, introduced: 18.0)
    @objc static public func localizedPhraseConcept(_ phrase: String) -> AttributedStringWrapper.LocalizationOptionsWrapper {
      let result = AttributedString.LocalizationOptions.localizedPhraseConcept(phrase)
      return LocalizationOptionsWrapper(result)
    }

  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public class InterpolationOptionsWrapper: NSObject {
    var wrappedInstance: AttributedString.InterpolationOptions

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc static public var insertAttributesWithoutMerging: AttributedStringWrapper.InterpolationOptionsWrapper {
      get {
        InterpolationOptionsWrapper(AttributedString.InterpolationOptions.insertAttributesWithoutMerging)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: AttributedString.InterpolationOptions) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = AttributedString.InterpolationOptions()
    }

  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public class MarkdownParsingOptionsWrapper: NSObject {
    var wrappedInstance: AttributedString.MarkdownParsingOptions

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public var languageCode: String? {
      get {
        wrappedInstance.languageCode
      }
      set {
        wrappedInstance.languageCode = newValue
      }
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public var allowsExtendedAttributes: Bool {
      get {
        wrappedInstance.allowsExtendedAttributes
      }
      set {
        wrappedInstance.allowsExtendedAttributes = newValue
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var appliesSourcePositionAttributes: Bool {
      get {
        wrappedInstance.appliesSourcePositionAttributes
      }
      set {
        wrappedInstance.appliesSourcePositionAttributes = newValue
      }
    }

    init(_ wrappedInstance: AttributedString.MarkdownParsingOptions) {
      self.wrappedInstance = wrappedInstance
    }

  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class MarkdownSourcePositionWrapper: NSObject {
    var wrappedInstance: AttributedString.MarkdownSourcePosition

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var startColumn: Int {
      get {
        wrappedInstance.startColumn
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var endLine: Int {
      get {
        wrappedInstance.endLine
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var endColumn: Int {
      get {
        wrappedInstance.endColumn
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var startLine: Int {
      get {
        wrappedInstance.startLine
      }
    }

    init(_ wrappedInstance: AttributedString.MarkdownSourcePosition) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(startLine: Int, startColumn: Int, endLine: Int, endColumn: Int) {
      wrappedInstance = AttributedString.MarkdownSourcePosition(startLine: startLine, startColumn: startColumn, endLine: endLine, endColumn: endColumn)
    }

  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public class SingleAttributeTransformerWrapper: NSObject {
    var wrappedInstance: AttributedString.SingleAttributeTransformer

    init(_ wrappedInstance: AttributedString.SingleAttributeTransformer) {
      self.wrappedInstance = wrappedInstance
    }

  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class AttributeInvalidationConditionWrapper: NSObject {
    var wrappedInstance: AttributedString.AttributeInvalidationCondition

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var textChanged: AttributedStringWrapper.AttributeInvalidationConditionWrapper {
      get {
        AttributeInvalidationConditionWrapper(AttributedString.AttributeInvalidationCondition.textChanged)
      }
    }

    init(_ wrappedInstance: AttributedString.AttributeInvalidationCondition) {
      self.wrappedInstance = wrappedInstance
    }

  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public class RunsWrapper: NSObject {
    var wrappedInstance: AttributedString.Runs

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public var startIndex: RunsWrapper.IndexWrapper {
      get {
        IndexWrapper(wrappedInstance.startIndex)
      }
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public var description: String {
      get {
        wrappedInstance.description
      }
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public var endIndex: RunsWrapper.IndexWrapper {
      get {
        IndexWrapper(wrappedInstance.endIndex)
      }
    }

    @objc public var underestimatedCount: Int {
      get {
        wrappedInstance.underestimatedCount
      }
    }

    @objc public var count: Int {
      get {
        wrappedInstance.count
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: AttributedString.Runs) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func index(after i: RunsWrapper.IndexWrapper) -> RunsWrapper.IndexWrapper {
      let result = wrappedInstance.index(after: i.wrappedInstance)
      return IndexWrapper(result)
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func index(before i: RunsWrapper.IndexWrapper) -> RunsWrapper.IndexWrapper {
      let result = wrappedInstance.index(before: i.wrappedInstance)
      return IndexWrapper(result)
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func index(_ i: RunsWrapper.IndexWrapper, offsetBy distance: Int, limitedBy limit: RunsWrapper.IndexWrapper) -> RunsWrapper.IndexWrapper? {
      let result = wrappedInstance.index(i.wrappedInstance, offsetBy: distance, limitedBy: limit.wrappedInstance)
      return result == nil ? nil : IndexWrapper(result!)
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func index(_ i: RunsWrapper.IndexWrapper, offsetBy distance: Int) -> RunsWrapper.IndexWrapper {
      let result = wrappedInstance.index(i.wrappedInstance, offsetBy: distance)
      return IndexWrapper(result)
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public func distance(from start: RunsWrapper.IndexWrapper, to end: RunsWrapper.IndexWrapper) -> Int {
      return wrappedInstance.distance(from: start.wrappedInstance, to: end.wrappedInstance)
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public class AttributesSlice1Wrapper: NSObject {
      var wrappedInstance: Runs.AttributesSlice1

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public var startIndex: RunsWrapper.AttributesSlice1Wrapper {
        get {
          AttributesSlice1Wrapper(wrappedInstance.startIndex)
        }
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public var endIndex: RunsWrapper.AttributesSlice1Wrapper {
        get {
          AttributesSlice1Wrapper(wrappedInstance.endIndex)
        }
      }

      @objc public var underestimatedCount: Int {
        get {
          wrappedInstance.underestimatedCount
        }
      }

      @objc public var count: Int {
        get {
          wrappedInstance.count
        }
      }

      @objc public var isEmpty: Bool {
        get {
          wrappedInstance.isEmpty
        }
      }

      init(_ wrappedInstance: Runs.AttributesSlice1) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public func makeIterator() -> RunsWrapper.AttributesSlice1Wrapper {
        let result = wrappedInstance.makeIterator()
        return AttributesSlice1Wrapper(result)
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public class IteratorWrapper: NSObject {
        var wrappedInstance: AttributesSlice1.Iterator

        init(_ wrappedInstance: AttributesSlice1.Iterator) {
          self.wrappedInstance = wrappedInstance
        }

        @available(macOS, introduced: 12)
        @available(watchOS, introduced: 8)
        @available(iOS, introduced: 15)
        @available(tvOS, introduced: 15)
        @objc public func next() -> RunsWrapper.AttributesSlice1Wrapper {
          let result = wrappedInstance.next()
          return AttributesSlice1Wrapper(result)
        }

      }

    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public class AttributesSlice2Wrapper: NSObject {
      var wrappedInstance: Runs.AttributesSlice2

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public var startIndex: RunsWrapper.AttributesSlice2Wrapper {
        get {
          AttributesSlice2Wrapper(wrappedInstance.startIndex)
        }
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public var endIndex: RunsWrapper.AttributesSlice2Wrapper {
        get {
          AttributesSlice2Wrapper(wrappedInstance.endIndex)
        }
      }

      @objc public var underestimatedCount: Int {
        get {
          wrappedInstance.underestimatedCount
        }
      }

      @objc public var count: Int {
        get {
          wrappedInstance.count
        }
      }

      @objc public var isEmpty: Bool {
        get {
          wrappedInstance.isEmpty
        }
      }

      init(_ wrappedInstance: Runs.AttributesSlice2) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public func makeIterator() -> RunsWrapper.AttributesSlice2Wrapper {
        let result = wrappedInstance.makeIterator()
        return AttributesSlice2Wrapper(result)
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public class IteratorWrapper: NSObject {
        var wrappedInstance: AttributesSlice2.Iterator

        init(_ wrappedInstance: AttributesSlice2.Iterator) {
          self.wrappedInstance = wrappedInstance
        }

        @available(macOS, introduced: 12)
        @available(watchOS, introduced: 8)
        @available(iOS, introduced: 15)
        @available(tvOS, introduced: 15)
        @objc public func next() -> RunsWrapper.AttributesSlice2Wrapper {
          let result = wrappedInstance.next()
          return AttributesSlice2Wrapper(result)
        }

      }

    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public class AttributesSlice3Wrapper: NSObject {
      var wrappedInstance: Runs.AttributesSlice3

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public var startIndex: RunsWrapper.AttributesSlice3Wrapper {
        get {
          AttributesSlice3Wrapper(wrappedInstance.startIndex)
        }
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public var endIndex: RunsWrapper.AttributesSlice3Wrapper {
        get {
          AttributesSlice3Wrapper(wrappedInstance.endIndex)
        }
      }

      @objc public var underestimatedCount: Int {
        get {
          wrappedInstance.underestimatedCount
        }
      }

      @objc public var count: Int {
        get {
          wrappedInstance.count
        }
      }

      @objc public var isEmpty: Bool {
        get {
          wrappedInstance.isEmpty
        }
      }

      init(_ wrappedInstance: Runs.AttributesSlice3) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public func makeIterator() -> RunsWrapper.AttributesSlice3Wrapper {
        let result = wrappedInstance.makeIterator()
        return AttributesSlice3Wrapper(result)
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public class IteratorWrapper: NSObject {
        var wrappedInstance: AttributesSlice3.Iterator

        init(_ wrappedInstance: AttributesSlice3.Iterator) {
          self.wrappedInstance = wrappedInstance
        }

        @available(macOS, introduced: 12)
        @available(watchOS, introduced: 8)
        @available(iOS, introduced: 15)
        @available(tvOS, introduced: 15)
        @objc public func next() -> RunsWrapper.AttributesSlice3Wrapper {
          let result = wrappedInstance.next()
          return AttributesSlice3Wrapper(result)
        }

      }

    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public class AttributesSlice4Wrapper: NSObject {
      var wrappedInstance: Runs.AttributesSlice4

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public var startIndex: RunsWrapper.AttributesSlice4Wrapper {
        get {
          AttributesSlice4Wrapper(wrappedInstance.startIndex)
        }
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public var endIndex: RunsWrapper.AttributesSlice4Wrapper {
        get {
          AttributesSlice4Wrapper(wrappedInstance.endIndex)
        }
      }

      @objc public var underestimatedCount: Int {
        get {
          wrappedInstance.underestimatedCount
        }
      }

      @objc public var count: Int {
        get {
          wrappedInstance.count
        }
      }

      @objc public var isEmpty: Bool {
        get {
          wrappedInstance.isEmpty
        }
      }

      init(_ wrappedInstance: Runs.AttributesSlice4) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public func makeIterator() -> RunsWrapper.AttributesSlice4Wrapper {
        let result = wrappedInstance.makeIterator()
        return AttributesSlice4Wrapper(result)
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public class IteratorWrapper: NSObject {
        var wrappedInstance: AttributesSlice4.Iterator

        init(_ wrappedInstance: AttributesSlice4.Iterator) {
          self.wrappedInstance = wrappedInstance
        }

        @available(macOS, introduced: 12)
        @available(watchOS, introduced: 8)
        @available(iOS, introduced: 15)
        @available(tvOS, introduced: 15)
        @objc public func next() -> RunsWrapper.AttributesSlice4Wrapper {
          let result = wrappedInstance.next()
          return AttributesSlice4Wrapper(result)
        }

      }

    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public class AttributesSlice5Wrapper: NSObject {
      var wrappedInstance: Runs.AttributesSlice5

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public var startIndex: RunsWrapper.AttributesSlice5Wrapper {
        get {
          AttributesSlice5Wrapper(wrappedInstance.startIndex)
        }
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public var endIndex: RunsWrapper.AttributesSlice5Wrapper {
        get {
          AttributesSlice5Wrapper(wrappedInstance.endIndex)
        }
      }

      @objc public var underestimatedCount: Int {
        get {
          wrappedInstance.underestimatedCount
        }
      }

      @objc public var count: Int {
        get {
          wrappedInstance.count
        }
      }

      @objc public var isEmpty: Bool {
        get {
          wrappedInstance.isEmpty
        }
      }

      init(_ wrappedInstance: Runs.AttributesSlice5) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public func makeIterator() -> RunsWrapper.AttributesSlice5Wrapper {
        let result = wrappedInstance.makeIterator()
        return AttributesSlice5Wrapper(result)
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public class IteratorWrapper: NSObject {
        var wrappedInstance: AttributesSlice5.Iterator

        init(_ wrappedInstance: AttributesSlice5.Iterator) {
          self.wrappedInstance = wrappedInstance
        }

        @available(macOS, introduced: 12)
        @available(watchOS, introduced: 8)
        @available(iOS, introduced: 15)
        @available(tvOS, introduced: 15)
        @objc public func next() -> RunsWrapper.AttributesSlice5Wrapper {
          let result = wrappedInstance.next()
          return AttributesSlice5Wrapper(result)
        }

      }

    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public class RunWrapper: NSObject {
      var wrappedInstance: Runs.Run

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public var attributes: AttributeContainerWrapper {
        get {
          AttributeContainerWrapper(wrappedInstance.attributes)
        }
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public var description: String {
        get {
          wrappedInstance.description
        }
      }

      init(_ wrappedInstance: Runs.Run) {
        self.wrappedInstance = wrappedInstance
      }

    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public class IndexWrapper: NSObject {
      var wrappedInstance: Runs.Index

      init(_ wrappedInstance: Runs.Index) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public func advanced(by n: Int) -> RunsWrapper.IndexWrapper {
        let result = wrappedInstance.advanced(by: n)
        return IndexWrapper(result)
      }

      @available(macOS, introduced: 12)
      @available(watchOS, introduced: 8)
      @available(iOS, introduced: 15)
      @available(tvOS, introduced: 15)
      @objc public func distance(to other: RunsWrapper.IndexWrapper) -> Int {
        return wrappedInstance.distance(to: other.wrappedInstance)
      }

    }

  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public class IndexWrapper: NSObject {
    var wrappedInstance: AttributedString.Index

    init(_ wrappedInstance: AttributedString.Index) {
      self.wrappedInstance = wrappedInstance
    }

  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class ErrorUserInfoKeyWrapper: NSObject {
  var wrappedInstance: ErrorUserInfoKey

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var NSURLErrorKey: ErrorUserInfoKeyWrapper {
    get {
      ErrorUserInfoKeyWrapper(ErrorUserInfoKey.NSURLErrorKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var helpAnchorErrorKey: ErrorUserInfoKeyWrapper {
    get {
      ErrorUserInfoKeyWrapper(ErrorUserInfoKey.helpAnchorErrorKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var underlyingErrorKey: ErrorUserInfoKeyWrapper {
    get {
      ErrorUserInfoKeyWrapper(ErrorUserInfoKey.underlyingErrorKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var stringEncodingErrorKey: ErrorUserInfoKeyWrapper {
    get {
      ErrorUserInfoKeyWrapper(ErrorUserInfoKey.stringEncodingErrorKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var recoveryAttempterErrorKey: ErrorUserInfoKeyWrapper {
    get {
      ErrorUserInfoKeyWrapper(ErrorUserInfoKey.recoveryAttempterErrorKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var localizedDescriptionKey: ErrorUserInfoKeyWrapper {
    get {
      ErrorUserInfoKeyWrapper(ErrorUserInfoKey.localizedDescriptionKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var localizedFailureReasonErrorKey: ErrorUserInfoKeyWrapper {
    get {
      ErrorUserInfoKeyWrapper(ErrorUserInfoKey.localizedFailureReasonErrorKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var localizedRecoveryOptionsErrorKey: ErrorUserInfoKeyWrapper {
    get {
      ErrorUserInfoKeyWrapper(ErrorUserInfoKey.localizedRecoveryOptionsErrorKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var localizedRecoverySuggestionErrorKey: ErrorUserInfoKeyWrapper {
    get {
      ErrorUserInfoKeyWrapper(ErrorUserInfoKey.localizedRecoverySuggestionErrorKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(*)
  @available(tvOS, introduced: 9.0)
  @objc static public var filePathErrorKey: ErrorUserInfoKeyWrapper {
    get {
      ErrorUserInfoKeyWrapper(ErrorUserInfoKey.filePathErrorKey)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var rawValue: String {
    get {
      wrappedInstance.rawValue
    }
    set {
      wrappedInstance.rawValue = newValue
    }
  }

  init(_ wrappedInstance: ErrorUserInfoKey) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(rawValue: String) {
    wrappedInstance = ErrorUserInfoKey(rawValue: rawValue)
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class AsyncLineSequenceWrapper: NSObject {
  var wrappedInstance: AsyncLineSequence

  init(_ wrappedInstance: AsyncLineSequence) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func makeAsyncIterator() -> AsyncLineSequenceWrapper {
    let result = wrappedInstance.makeAsyncIterator()
    return AsyncLineSequenceWrapper(result)
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class AsyncIteratorWrapper: NSObject {
    var wrappedInstance: AsyncLineSequence.AsyncIterator

    init(_ wrappedInstance: AsyncLineSequence.AsyncIterator) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func next() async -> String? {
      return await wrappedInstance.next()
    }

  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class KeyPathComparatorWrapper: NSObject {
  var wrappedInstance: KeyPathComparator

  init(_ wrappedInstance: KeyPathComparator) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class PredicateBindingsWrapper: NSObject {
  var wrappedInstance: PredicateBindings

  init(_ wrappedInstance: PredicateBindings) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class URLResourceValuesWrapper: NSObject {
  var wrappedInstance: URLResourceValues

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isReadable: Bool? {
    get {
      wrappedInstance.isReadable
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isWritable: Bool? {
    get {
      wrappedInstance.isWritable
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeName: String? {
    get {
      wrappedInstance.volumeName
    }
    set {
      wrappedInstance.volumeName = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isAliasFile: Bool? {
    get {
      wrappedInstance.isAliasFile
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isDirectory: Bool? {
    get {
      wrappedInstance.isDirectory
    }
  }

  @available(macOS, introduced: 11.0)
  @available(watchOS, introduced: 7.0)
  @available(iOS, introduced: 14.0)
  @available(tvOS, introduced: 14.0)
  @objc public var isPurgeable: Bool? {
    get {
      wrappedInstance.isPurgeable
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var labelNumber: Int? {
    get {
      wrappedInstance.labelNumber
    }
    set {
      wrappedInstance.labelNumber = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var creationDate: DateWrapper? {
    get {
      wrappedInstance.creationDate == nil ? nil : DateWrapper(wrappedInstance.creationDate!)
    }
    set {
      wrappedInstance.creationDate = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var fileSecurity: NSFileSecurityWrapper? {
    get {
      wrappedInstance.fileSecurity == nil ? nil : NSFileSecurityWrapper(wrappedInstance.fileSecurity!)
    }
    set {
      wrappedInstance.fileSecurity = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isExecutable: Bool? {
    get {
      wrappedInstance.isExecutable
    }
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var canonicalPath: String? {
    get {
      wrappedInstance.canonicalPath
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isApplication: Bool? {
    get {
      wrappedInstance.isApplication
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isRegularFile: Bool? {
    get {
      wrappedInstance.isRegularFile
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var localizedName: String? {
    get {
      wrappedInstance.localizedName
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var totalFileSize: Int? {
    get {
      wrappedInstance.totalFileSize
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeIsLocal: Bool? {
    get {
      wrappedInstance.volumeIsLocal
    }
  }

  @available(macOS, introduced: 13.3)
  @available(watchOS, introduced: 9.4)
  @available(iOS, introduced: 16.4)
  @available(tvOS, introduced: 16.4)
  @objc public var volumeSubtype: Int? {
    get {
      wrappedInstance.volumeSubtype
    }
  }

  @available(macOS, introduced: 11.0)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc public var fileProtection: URLFileProtectionWrapper? {
    get {
      wrappedInstance.fileProtection == nil ? nil : URLFileProtectionWrapper(wrappedInstance.fileProtection!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isMountTrigger: Bool? {
    get {
      wrappedInstance.isMountTrigger
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isSymbolicLink: Bool? {
    get {
      wrappedInstance.isSymbolicLink
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var localizedLabel: String? {
    get {
      wrappedInstance.localizedLabel
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc public var typeIdentifier: String? {
    get {
      wrappedInstance.typeIdentifier
    }
  }

  @available(macOS, introduced: 13.3)
  @available(watchOS, introduced: 9.4)
  @available(iOS, introduced: 16.4)
  @available(tvOS, introduced: 16.4)
  @objc public var volumeTypeName: String? {
    get {
      wrappedInstance.volumeTypeName
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isUserImmutable: Bool? {
    get {
      wrappedInstance.isUserImmutable
    }
    set {
      wrappedInstance.isUserImmutable = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var parentDirectory: URLWrapper? {
    get {
      wrappedInstance.parentDirectory == nil ? nil : URLWrapper(wrappedInstance.parentDirectory!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var fileResourceType: URLFileResourceTypeWrapper? {
    get {
      wrappedInstance.fileResourceType == nil ? nil : URLFileResourceTypeWrapper(wrappedInstance.fileResourceType!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isUbiquitousItem: Bool? {
    get {
      wrappedInstance.isUbiquitousItem
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeIsInternal: Bool? {
    get {
      wrappedInstance.volumeIsInternal
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeIsReadOnly: Bool? {
    get {
      wrappedInstance.volumeIsReadOnly
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeUUIDString: String? {
    get {
      wrappedInstance.volumeUUIDString
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var contentAccessDate: DateWrapper? {
    get {
      wrappedInstance.contentAccessDate == nil ? nil : DateWrapper(wrappedInstance.contentAccessDate!)
    }
    set {
      wrappedInstance.contentAccessDate = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var fileAllocatedSize: Int? {
    get {
      wrappedInstance.fileAllocatedSize
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isSystemImmutable: Bool? {
    get {
      wrappedInstance.isSystemImmutable
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeIsBrowsable: Bool? {
    get {
      wrappedInstance.volumeIsBrowsable
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeIsEjectable: Bool? {
    get {
      wrappedInstance.volumeIsEjectable
    }
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var volumeIsEncrypted: Bool? {
    get {
      wrappedInstance.volumeIsEncrypted
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeIsRemovable: Bool? {
    get {
      wrappedInstance.volumeIsRemovable
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var documentIdentifier: Int? {
    get {
      wrappedInstance.documentIdentifier
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var hasHiddenExtension: Bool? {
    get {
      wrappedInstance.hasHiddenExtension
    }
    set {
      wrappedInstance.hasHiddenExtension = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeCreationDate: DateWrapper? {
    get {
      wrappedInstance.volumeCreationDate == nil ? nil : DateWrapper(wrappedInstance.volumeCreationDate!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeIsJournaling: Bool? {
    get {
      wrappedInstance.volumeIsJournaling
    }
  }

  @available(macOS, introduced: 14.0)
  @available(watchOS, introduced: 10.0)
  @available(iOS, introduced: 17.0)
  @available(tvOS, introduced: 17.0)
  @objc public var directoryEntryCount: Int? {
    get {
      wrappedInstance.directoryEntryCount
    }
  }

  @available(macOS, introduced: 11.0)
  @available(watchOS, introduced: 7.0)
  @available(iOS, introduced: 14.0)
  @available(tvOS, introduced: 14.0)
  @objc public var mayShareFileContent: Bool? {
    get {
      wrappedInstance.mayShareFileContent
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeIsAutomounted: Bool? {
    get {
      wrappedInstance.volumeIsAutomounted
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeLocalizedName: String? {
    get {
      wrappedInstance.volumeLocalizedName
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeResourceCount: Int? {
    get {
      wrappedInstance.volumeResourceCount
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeTotalCapacity: Int? {
    get {
      wrappedInstance.volumeTotalCapacity
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var addedToDirectoryDate: DateWrapper? {
    get {
      wrappedInstance.addedToDirectoryDate == nil ? nil : DateWrapper(wrappedInstance.addedToDirectoryDate!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isExcludedFromBackup: Bool? {
    get {
      wrappedInstance.isExcludedFromBackup
    }
    set {
      wrappedInstance.isExcludedFromBackup = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var preferredIOBlockSize: Int? {
    get {
      wrappedInstance.preferredIOBlockSize
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeMaximumFileSize: Int? {
    get {
      wrappedInstance.volumeMaximumFileSize
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var totalFileAllocatedSize: Int? {
    get {
      wrappedInstance.totalFileAllocatedSize
    }
  }

  @available(macOS, introduced: 10.13)
  @available(watchOS, unavailable, introduced: 2.0)
  @available(iOS, introduced: 11.0)
  @available(tvOS, unavailable, introduced: 9.0)
  @objc public var ubiquitousItemIsShared: Bool? {
    get {
      wrappedInstance.ubiquitousItemIsShared
    }
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var volumeIsRootFileSystem: Bool? {
    get {
      wrappedInstance.volumeIsRootFileSystem
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeSupportsRenaming: Bool? {
    get {
      wrappedInstance.volumeSupportsRenaming
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeSupportsZeroRuns: Bool? {
    get {
      wrappedInstance.volumeSupportsZeroRuns
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeURLForRemounting: URLWrapper? {
    get {
      wrappedInstance.volumeURLForRemounting == nil ? nil : URLWrapper(wrappedInstance.volumeURLForRemounting!)
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var applicationIsScriptable: Bool? {
    get {
      wrappedInstance.applicationIsScriptable
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var contentModificationDate: DateWrapper? {
    get {
      wrappedInstance.contentModificationDate == nil ? nil : DateWrapper(wrappedInstance.contentModificationDate!)
    }
    set {
      wrappedInstance.contentModificationDate = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeAvailableCapacity: Int? {
    get {
      wrappedInstance.volumeAvailableCapacity
    }
  }

  @available(macOS, introduced: 13.3)
  @available(watchOS, introduced: 9.4)
  @available(iOS, introduced: 16.4)
  @available(tvOS, introduced: 16.4)
  @objc public var volumeMountFromLocation: String? {
    get {
      wrappedInstance.volumeMountFromLocation
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeSupportsHardLinks: Bool? {
    get {
      wrappedInstance.volumeSupportsHardLinks
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var localizedTypeDescription: String? {
    get {
      wrappedInstance.localizedTypeDescription
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var ubiquitousItemIsUploaded: Bool? {
    get {
      wrappedInstance.ubiquitousItemIsUploaded
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeSupportsJournaling: Bool? {
    get {
      wrappedInstance.volumeSupportsJournaling
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var attributeModificationDate: DateWrapper? {
    get {
      wrappedInstance.attributeModificationDate == nil ? nil : DateWrapper(wrappedInstance.attributeModificationDate!)
    }
  }

  @available(macOS, introduced: 11.0)
  @available(watchOS, introduced: 7.0)
  @available(iOS, introduced: 14.0)
  @available(tvOS, introduced: 14.0)
  @objc public var mayHaveExtendedAttributes: Bool? {
    get {
      wrappedInstance.mayHaveExtendedAttributes
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var ubiquitousItemIsUploading: Bool? {
    get {
      wrappedInstance.ubiquitousItemIsUploading
    }
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var volumeSupportsCompression: Bool? {
    get {
      wrappedInstance.volumeSupportsCompression
    }
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var volumeSupportsFileCloning: Bool? {
    get {
      wrappedInstance.volumeSupportsFileCloning
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeSupportsSparseFiles: Bool? {
    get {
      wrappedInstance.volumeSupportsSparseFiles
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeSupportsVolumeSizes: Bool? {
    get {
      wrappedInstance.volumeSupportsVolumeSizes
    }
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var volumeSupportsSwapRenaming: Bool? {
    get {
      wrappedInstance.volumeSupportsSwapRenaming
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var ubiquitousItemIsDownloading: Bool? {
    get {
      wrappedInstance.ubiquitousItemIsDownloading
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeSupportsPersistentIDs: Bool? {
    get {
      wrappedInstance.volumeSupportsPersistentIDs
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeSupportsSymbolicLinks: Bool? {
    get {
      wrappedInstance.volumeSupportsSymbolicLinks
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var ubiquitousItemUploadingError: NSErrorWrapper? {
    get {
      wrappedInstance.ubiquitousItemUploadingError == nil ? nil : NSErrorWrapper(wrappedInstance.ubiquitousItemUploadingError!)
    }
  }

  @available(macOS, introduced: 10.13)
  @available(watchOS, introduced: 4.0)
  @available(iOS, introduced: 11.0)
  @available(tvOS, introduced: 11.0)
  @objc public var volumeSupportsImmutableFiles: Bool? {
    get {
      wrappedInstance.volumeSupportsImmutableFiles
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var ubiquitousItemDownloadingError: NSErrorWrapper? {
    get {
      wrappedInstance.ubiquitousItemDownloadingError == nil ? nil : NSErrorWrapper(wrappedInstance.ubiquitousItemDownloadingError!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeSupportsExtendedSecurity: Bool? {
    get {
      wrappedInstance.volumeSupportsExtendedSecurity
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var ubiquitousItemDownloadRequested: Bool? {
    get {
      wrappedInstance.ubiquitousItemDownloadRequested
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var ubiquitousItemDownloadingStatus: URLUbiquitousItemDownloadingStatusWrapper? {
    get {
      wrappedInstance.ubiquitousItemDownloadingStatus == nil ? nil : URLUbiquitousItemDownloadingStatusWrapper(wrappedInstance.ubiquitousItemDownloadingStatus!)
    }
  }

  @available(macOS, introduced: 10.13)
  @available(watchOS, introduced: 4.0)
  @available(iOS, introduced: 11.0)
  @available(tvOS, introduced: 11.0)
  @objc public var volumeSupportsAccessPermissions: Bool? {
    get {
      wrappedInstance.volumeSupportsAccessPermissions
    }
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public var volumeSupportsExclusiveRenaming: Bool? {
    get {
      wrappedInstance.volumeSupportsExclusiveRenaming
    }
  }

  @available(macOS, introduced: 11.3)
  @available(watchOS, introduced: 7.4)
  @available(iOS, introduced: 14.5)
  @available(tvOS, introduced: 14.5)
  @objc public var ubiquitousItemIsExcludedFromSync: Bool? {
    get {
      wrappedInstance.ubiquitousItemIsExcludedFromSync
    }
    set {
      wrappedInstance.ubiquitousItemIsExcludedFromSync = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeLocalizedFormatDescription: String? {
    get {
      wrappedInstance.volumeLocalizedFormatDescription
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeSupportsCasePreservedNames: Bool? {
    get {
      wrappedInstance.volumeSupportsCasePreservedNames
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeSupportsCaseSensitiveNames: Bool? {
    get {
      wrappedInstance.volumeSupportsCaseSensitiveNames
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeSupportsRootDirectoryDates: Bool? {
    get {
      wrappedInstance.volumeSupportsRootDirectoryDates
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volumeSupportsAdvisoryFileLocking: Bool? {
    get {
      wrappedInstance.volumeSupportsAdvisoryFileLocking
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var ubiquitousItemContainerDisplayName: String? {
    get {
      wrappedInstance.ubiquitousItemContainerDisplayName
    }
  }

  @available(macOS, introduced: 10.13)
  @available(watchOS, unavailable, introduced: 2.0)
  @available(iOS, introduced: 11.0)
  @available(tvOS, unavailable, introduced: 9.0)
  @objc public var ubiquitousSharedItemCurrentUserRole: URLUbiquitousSharedItemRoleWrapper? {
    get {
      wrappedInstance.ubiquitousSharedItemCurrentUserRole == nil ? nil : URLUbiquitousSharedItemRoleWrapper(wrappedInstance.ubiquitousSharedItemCurrentUserRole!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var ubiquitousItemHasUnresolvedConflicts: Bool? {
    get {
      wrappedInstance.ubiquitousItemHasUnresolvedConflicts
    }
  }

  @available(macOS, introduced: 10.13)
  @available(watchOS, unavailable, introduced: 2.0)
  @available(iOS, introduced: 11.0)
  @available(tvOS, unavailable, introduced: 9.0)
  @objc public var ubiquitousSharedItemOwnerNameComponents: PersonNameComponentsWrapper? {
    get {
      wrappedInstance.ubiquitousSharedItemOwnerNameComponents == nil ? nil : PersonNameComponentsWrapper(wrappedInstance.ubiquitousSharedItemOwnerNameComponents!)
    }
  }

  @available(macOS, introduced: 10.13)
  @available(watchOS, unavailable, introduced: 2.0)
  @available(iOS, introduced: 11.0)
  @available(tvOS, unavailable, introduced: 9.0)
  @objc public var ubiquitousSharedItemCurrentUserPermissions: URLUbiquitousSharedItemPermissionsWrapper? {
    get {
      wrappedInstance.ubiquitousSharedItemCurrentUserPermissions == nil ? nil : URLUbiquitousSharedItemPermissionsWrapper(wrappedInstance.ubiquitousSharedItemCurrentUserPermissions!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var name: String? {
    get {
      wrappedInstance.name
    }
    set {
      wrappedInstance.name = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var path: String? {
    get {
      wrappedInstance.path
    }
  }

  @available(macOS, introduced: 10.13)
  @available(watchOS, unavailable, introduced: 2.0)
  @available(iOS, introduced: 11.0)
  @available(tvOS, unavailable, introduced: 9.0)
  @objc public var ubiquitousSharedItemMostRecentEditorNameComponents: PersonNameComponentsWrapper? {
    get {
      wrappedInstance.ubiquitousSharedItemMostRecentEditorNameComponents == nil ? nil : PersonNameComponentsWrapper(wrappedInstance.ubiquitousSharedItemMostRecentEditorNameComponents!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var volume: URLWrapper? {
    get {
      wrappedInstance.volume == nil ? nil : URLWrapper(wrappedInstance.volume!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var fileSize: Int? {
    get {
      wrappedInstance.fileSize
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isHidden: Bool? {
    get {
      wrappedInstance.isHidden
    }
    set {
      wrappedInstance.isHidden = newValue
    }
  }

  @available(macOS, introduced: 11.0)
  @available(watchOS, introduced: 7.0)
  @available(iOS, introduced: 14.0)
  @available(tvOS, introduced: 14.0)
  @objc public var isSparse: Bool? {
    get {
      wrappedInstance.isSparse
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isVolume: Bool? {
    get {
      wrappedInstance.isVolume
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isPackage: Bool? {
    get {
      wrappedInstance.isPackage
    }
    set {
      wrappedInstance.isPackage = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var linkCount: Int? {
    get {
      wrappedInstance.linkCount
    }
  }

  init(_ wrappedInstance: URLResourceValues) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc override init() {
    wrappedInstance = URLResourceValues()
  }

}

@available(macOS, introduced: 12)
@available(watchOS, introduced: 8)
@available(iOS, introduced: 15)
@available(tvOS, introduced: 15)
@objc public class AttributeContainerWrapper: NSObject {
  var wrappedInstance: AttributeContainer

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: AttributeContainer) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc override init() {
    wrappedInstance = AttributeContainer()
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public class BuilderWrapper: NSObject {
    var wrappedInstance: AttributeContainer.Builder

    init(_ wrappedInstance: AttributeContainer.Builder) {
      self.wrappedInstance = wrappedInstance
    }

  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class IntegerFormatStyleWrapper: NSObject {
  var wrappedInstance: IntegerFormatStyle

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var number: IntegerFormatStyleWrapper {
    get {
      IntegerFormatStyleWrapper(IntegerFormatStyle.number)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var number: IntegerFormatStyleWrapper {
    get {
      IntegerFormatStyleWrapper(IntegerFormatStyle.number)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var number: IntegerFormatStyleWrapper {
    get {
      IntegerFormatStyleWrapper(IntegerFormatStyle.number)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var number: IntegerFormatStyleWrapper {
    get {
      IntegerFormatStyleWrapper(IntegerFormatStyle.number)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var number: IntegerFormatStyleWrapper {
    get {
      IntegerFormatStyleWrapper(IntegerFormatStyle.number)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var number: IntegerFormatStyleWrapper {
    get {
      IntegerFormatStyleWrapper(IntegerFormatStyle.number)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var number: IntegerFormatStyleWrapper {
    get {
      IntegerFormatStyleWrapper(IntegerFormatStyle.number)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var number: IntegerFormatStyleWrapper {
    get {
      IntegerFormatStyleWrapper(IntegerFormatStyle.number)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var number: IntegerFormatStyleWrapper {
    get {
      IntegerFormatStyleWrapper(IntegerFormatStyle.number)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var number: IntegerFormatStyleWrapper {
    get {
      IntegerFormatStyleWrapper(IntegerFormatStyle.number)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var attributed: IntegerFormatStyleWrapper {
    get {
      IntegerFormatStyleWrapper(wrappedInstance.attributed)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var parseStrategy: IntegerParseStrategyWrapper {
    get {
      IntegerParseStrategyWrapper(wrappedInstance.parseStrategy)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var locale: LocaleWrapper {
    get {
      LocaleWrapper(wrappedInstance.locale)
    }
    set {
      wrappedInstance.locale = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: IntegerFormatStyle) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func scale(_ multiplicand: Double) -> IntegerFormatStyleWrapper {
    let result = wrappedInstance.scale(multiplicand)
    return IntegerFormatStyleWrapper(result)
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func locale(_ locale: LocaleWrapper) -> IntegerFormatStyleWrapper {
    let result = wrappedInstance.locale(locale.wrappedInstance)
    return IntegerFormatStyleWrapper(result)
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class AttributedWrapper: NSObject {
    var wrappedInstance: IntegerFormatStyle.Attributed

    init(_ wrappedInstance: IntegerFormatStyle.Attributed) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> IntegerFormatStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return IntegerFormatStyleWrapper(result)
    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class PercentWrapper: NSObject {
    var wrappedInstance: IntegerFormatStyle.Percent

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var percent: IntegerFormatStyleWrapper {
      get {
        IntegerFormatStyleWrapper(IntegerFormatStyle.Percent.percent)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var percent: IntegerFormatStyleWrapper {
      get {
        IntegerFormatStyleWrapper(IntegerFormatStyle.Percent.percent)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var percent: IntegerFormatStyleWrapper {
      get {
        IntegerFormatStyleWrapper(IntegerFormatStyle.Percent.percent)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var percent: IntegerFormatStyleWrapper {
      get {
        IntegerFormatStyleWrapper(IntegerFormatStyle.Percent.percent)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var percent: IntegerFormatStyleWrapper {
      get {
        IntegerFormatStyleWrapper(IntegerFormatStyle.Percent.percent)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var percent: IntegerFormatStyleWrapper {
      get {
        IntegerFormatStyleWrapper(IntegerFormatStyle.Percent.percent)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var percent: IntegerFormatStyleWrapper {
      get {
        IntegerFormatStyleWrapper(IntegerFormatStyle.Percent.percent)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var percent: IntegerFormatStyleWrapper {
      get {
        IntegerFormatStyleWrapper(IntegerFormatStyle.Percent.percent)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var percent: IntegerFormatStyleWrapper {
      get {
        IntegerFormatStyleWrapper(IntegerFormatStyle.Percent.percent)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var percent: IntegerFormatStyleWrapper {
      get {
        IntegerFormatStyleWrapper(IntegerFormatStyle.Percent.percent)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var attributed: IntegerFormatStyleWrapper {
      get {
        IntegerFormatStyleWrapper(wrappedInstance.attributed)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var parseStrategy: IntegerParseStrategyWrapper {
      get {
        IntegerParseStrategyWrapper(wrappedInstance.parseStrategy)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper {
      get {
        LocaleWrapper(wrappedInstance.locale)
      }
      set {
        wrappedInstance.locale = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: IntegerFormatStyle.Percent) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func scale(_ multiplicand: Double) -> IntegerFormatStyleWrapper {
      let result = wrappedInstance.scale(multiplicand)
      return IntegerFormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> IntegerFormatStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return IntegerFormatStyleWrapper(result)
    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class CurrencyWrapper: NSObject {
    var wrappedInstance: IntegerFormatStyle.Currency

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var attributed: IntegerFormatStyleWrapper {
      get {
        IntegerFormatStyleWrapper(wrappedInstance.attributed)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var currencyCode: String {
      get {
        wrappedInstance.currencyCode
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var parseStrategy: IntegerParseStrategyWrapper {
      get {
        IntegerParseStrategyWrapper(wrappedInstance.parseStrategy)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper {
      get {
        LocaleWrapper(wrappedInstance.locale)
      }
      set {
        wrappedInstance.locale = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: IntegerFormatStyle.Currency) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func scale(_ multiplicand: Double) -> IntegerFormatStyleWrapper {
      let result = wrappedInstance.scale(multiplicand)
      return IntegerFormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> IntegerFormatStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return IntegerFormatStyleWrapper(result)
    }

  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class NSIndexSetIteratorWrapper: NSObject {
  var wrappedInstance: NSIndexSetIterator

  init(_ wrappedInstance: NSIndexSetIterator) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func next() -> Int? {
    return wrappedInstance.next()
  }

}

@available(macOS, introduced: 12)
@available(watchOS, introduced: 8)
@available(iOS, introduced: 15)
@available(tvOS, introduced: 15)
@objc public class PresentationIntentWrapper: NSObject {
  var wrappedInstance: PresentationIntent

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var indentationLevel: Int {
    get {
      wrappedInstance.indentationLevel
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var count: Int {
    get {
      wrappedInstance.count
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var isValid: Bool {
    get {
      wrappedInstance.isValid
    }
  }

  init(_ wrappedInstance: PresentationIntent) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public class IntentTypeWrapper: NSObject {
    var wrappedInstance: PresentationIntent.IntentType

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public var debugDescription: String {
      get {
        wrappedInstance.debugDescription
      }
    }

    @available(macOS, introduced: 12)
    @available(watchOS, introduced: 8)
    @available(iOS, introduced: 15)
    @available(tvOS, introduced: 15)
    @objc public var identity: Int {
      get {
        wrappedInstance.identity
      }
      set {
        wrappedInstance.identity = newValue
      }
    }

    init(_ wrappedInstance: PresentationIntent.IntentType) {
      self.wrappedInstance = wrappedInstance
    }

  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public class TableColumnWrapper: NSObject {
    var wrappedInstance: PresentationIntent.TableColumn

    init(_ wrappedInstance: PresentationIntent.TableColumn) {
      self.wrappedInstance = wrappedInstance
    }

  }

}

@available(macOS, introduced: 12)
@available(watchOS, introduced: 8)
@available(iOS, introduced: 15)
@available(tvOS, introduced: 15)
@objc public class AttributedSubstringWrapper: NSObject {
  var wrappedInstance: AttributedSubstring

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var characters: AttributedStringWrapper.CharacterViewWrapper {
    get {
      CharacterViewWrapper(wrappedInstance.characters)
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var startIndex: AttributedStringWrapper.IndexWrapper {
    get {
      IndexWrapper(wrappedInstance.startIndex)
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var unicodeScalars: AttributedStringWrapper.UnicodeScalarViewWrapper {
    get {
      UnicodeScalarViewWrapper(wrappedInstance.unicodeScalars)
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var base: AttributedStringWrapper {
    get {
      AttributedStringWrapper(wrappedInstance.base)
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var runs: AttributedStringWrapper.RunsWrapper {
    get {
      RunsWrapper(wrappedInstance.runs)
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public var endIndex: AttributedStringWrapper.IndexWrapper {
    get {
      IndexWrapper(wrappedInstance.endIndex)
    }
  }

  init(_ wrappedInstance: AttributedSubstring) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc override init() {
    wrappedInstance = AttributedSubstring()
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func setAttributes(_ attributes: AttributeContainerWrapper) {
    return wrappedInstance.setAttributes(attributes.wrappedInstance)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func replaceAttributes(_ attributes: AttributeContainerWrapper, with others: AttributeContainerWrapper) {
    return wrappedInstance.replaceAttributes(attributes.wrappedInstance, with: others.wrappedInstance)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func settingAttributes(_ attributes: AttributeContainerWrapper) -> AttributedStringWrapper {
    let result = wrappedInstance.settingAttributes(attributes.wrappedInstance)
    return AttributedStringWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func replacingAttributes(_ attributes: AttributeContainerWrapper, with others: AttributeContainerWrapper) -> AttributedStringWrapper {
    let result = wrappedInstance.replacingAttributes(attributes.wrappedInstance, with: others.wrappedInstance)
    return AttributedStringWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(afterCharacter i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(afterCharacter: i.wrappedInstance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(beforeCharacter i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(beforeCharacter: i.wrappedInstance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(afterUnicodeScalar i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(afterUnicodeScalar: i.wrappedInstance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(beforeUnicodeScalar i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(beforeUnicodeScalar: i.wrappedInstance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(afterRun i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(afterRun: i.wrappedInstance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(beforeRun i: AttributedStringWrapper.IndexWrapper) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(beforeRun: i.wrappedInstance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(_ i: AttributedStringWrapper.IndexWrapper, offsetByRuns distance: Int) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(i.wrappedInstance, offsetByRuns: distance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(_ i: AttributedStringWrapper.IndexWrapper, offsetByCharacters distance: Int) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(i.wrappedInstance, offsetByCharacters: distance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc public func index(_ i: AttributedStringWrapper.IndexWrapper, offsetByUnicodeScalars distance: Int) -> AttributedStringWrapper.IndexWrapper {
    let result = wrappedInstance.index(i.wrappedInstance, offsetByUnicodeScalars: distance)
    return IndexWrapper(result)
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class PropertyListDecoderWrapper: NSObject {
  var wrappedInstance: PropertyListDecoder

  init(_ wrappedInstance: PropertyListDecoder) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc override init() {
    wrappedInstance = PropertyListDecoder()
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class PropertyListEncoderWrapper: NSObject {
  var wrappedInstance: PropertyListEncoder

  init(_ wrappedInstance: PropertyListEncoder) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc override init() {
    wrappedInstance = PropertyListEncoder()
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class ByteCountFormatStyleWrapper: NSObject {
  var wrappedInstance: ByteCountFormatStyle

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var includesActualByteCount: Bool {
    get {
      wrappedInstance.includesActualByteCount
    }
    set {
      wrappedInstance.includesActualByteCount = newValue
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var attributed: ByteCountFormatStyleWrapper.AttributedWrapper {
    get {
      AttributedWrapper(wrappedInstance.attributed)
    }
    set {
      wrappedInstance.attributed = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var allowedUnits: ByteCountFormatStyleWrapper.UnitsWrapper {
    get {
      UnitsWrapper(wrappedInstance.allowedUnits)
    }
    set {
      wrappedInstance.allowedUnits = newValue.wrappedInstance
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var spellsOutZero: Bool {
    get {
      wrappedInstance.spellsOutZero
    }
    set {
      wrappedInstance.spellsOutZero = newValue
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var locale: LocaleWrapper {
    get {
      LocaleWrapper(wrappedInstance.locale)
    }
    set {
      wrappedInstance.locale = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: ByteCountFormatStyle) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func locale(_ locale: LocaleWrapper) -> ByteCountFormatStyleWrapper {
    let result = wrappedInstance.locale(locale.wrappedInstance)
    return ByteCountFormatStyleWrapper(result)
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class AttributedWrapper: NSObject {
    var wrappedInstance: ByteCountFormatStyle.Attributed

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var includesActualByteCount: Bool {
      get {
        wrappedInstance.includesActualByteCount
      }
      set {
        wrappedInstance.includesActualByteCount = newValue
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var allowedUnits: ByteCountFormatStyleWrapper.UnitsWrapper {
      get {
        UnitsWrapper(wrappedInstance.allowedUnits)
      }
      set {
        wrappedInstance.allowedUnits = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var spellsOutZero: Bool {
      get {
        wrappedInstance.spellsOutZero
      }
      set {
        wrappedInstance.spellsOutZero = newValue
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper {
      get {
        LocaleWrapper(wrappedInstance.locale)
      }
      set {
        wrappedInstance.locale = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: ByteCountFormatStyle.Attributed) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> ByteCountFormatStyleWrapper.AttributedWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return AttributedWrapper(result)
    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class UnitsWrapper: NSObject {
    var wrappedInstance: ByteCountFormatStyle.Units

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var ybOrHigher: ByteCountFormatStyleWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatStyle.Units.ybOrHigher)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var eb: ByteCountFormatStyleWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatStyle.Units.eb)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var gb: ByteCountFormatStyleWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatStyle.Units.gb)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var kb: ByteCountFormatStyleWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatStyle.Units.kb)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var mb: ByteCountFormatStyleWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatStyle.Units.mb)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var pb: ByteCountFormatStyleWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatStyle.Units.pb)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var tb: ByteCountFormatStyleWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatStyle.Units.tb)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var zb: ByteCountFormatStyleWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatStyle.Units.zb)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var all: ByteCountFormatStyleWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatStyle.Units.all)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var bytes: ByteCountFormatStyleWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatStyle.Units.bytes)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var `default`: ByteCountFormatStyleWrapper.UnitsWrapper {
      get {
        UnitsWrapper(ByteCountFormatStyle.Units.`default`)
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: ByteCountFormatStyle.Units) {
      self.wrappedInstance = wrappedInstance
    }

    @objc override init() {
      wrappedInstance = ByteCountFormatStyle.Units()
    }

  }

}

@available(macOS, introduced: 12)
@available(watchOS, introduced: 8)
@available(iOS, introduced: 15)
@available(tvOS, introduced: 15)
@objc public class CodableConfigurationWrapper: NSObject {
  var wrappedInstance: CodableConfiguration

  init(_ wrappedInstance: CodableConfiguration) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class ComparableComparatorWrapper: NSObject {
  var wrappedInstance: ComparableComparator

  init(_ wrappedInstance: ComparableComparator) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class IntegerParseStrategyWrapper: NSObject {
  var wrappedInstance: IntegerParseStrategy

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var lenient: Bool {
    get {
      wrappedInstance.lenient
    }
    set {
      wrappedInstance.lenient = newValue
    }
  }

  init(_ wrappedInstance: IntegerParseStrategy) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.11)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 9.0)
@available(tvOS, introduced: 9.0)
@objc public class PersonNameComponentsWrapper: NSObject {
  var wrappedInstance: PersonNameComponents

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc public var givenName: String? {
    get {
      wrappedInstance.givenName
    }
    set {
      wrappedInstance.givenName = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc public var familyName: String? {
    get {
      wrappedInstance.familyName
    }
    set {
      wrappedInstance.familyName = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc public var middleName: String? {
    get {
      wrappedInstance.middleName
    }
    set {
      wrappedInstance.middleName = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc public var namePrefix: String? {
    get {
      wrappedInstance.namePrefix
    }
    set {
      wrappedInstance.namePrefix = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc public var nameSuffix: String? {
    get {
      wrappedInstance.nameSuffix
    }
    set {
      wrappedInstance.nameSuffix = newValue
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc public var phoneticRepresentation: PersonNameComponentsWrapper? {
    get {
      wrappedInstance.phoneticRepresentation == nil ? nil : PersonNameComponentsWrapper(wrappedInstance.phoneticRepresentation!)
    }
    set {
      wrappedInstance.phoneticRepresentation = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc public var nickname: String? {
    get {
      wrappedInstance.nickname
    }
    set {
      wrappedInstance.nickname = newValue
    }
  }

  init(_ wrappedInstance: PersonNameComponents) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc override init() {
    wrappedInstance = PersonNameComponents()
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc init(_ value: String) throws {
    wrappedInstance = try PersonNameComponents(value)
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func formatted() -> String {
    return wrappedInstance.formatted()
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class FormatStyleWrapper: NSObject {
    var wrappedInstance: PersonNameComponents.FormatStyle

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var attributed: PersonNameComponentsWrapper.AttributedStyleWrapper {
      get {
        AttributedStyleWrapper(wrappedInstance.attributed)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var parseStrategy: PersonNameComponentsWrapper.ParseStrategyWrapper {
      get {
        ParseStrategyWrapper(wrappedInstance.parseStrategy)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper {
      get {
        LocaleWrapper(wrappedInstance.locale)
      }
      set {
        wrappedInstance.locale = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: PersonNameComponents.FormatStyle) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func format(_ value: PersonNameComponentsWrapper) -> String {
      return wrappedInstance.format(value.wrappedInstance)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> PersonNameComponentsWrapper.FormatStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return FormatStyleWrapper(result)
    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class ParseStrategyWrapper: NSObject {
    var wrappedInstance: PersonNameComponents.ParseStrategy

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var name: PersonNameComponentsWrapper.ParseStrategyWrapper {
      get {
        ParseStrategyWrapper(PersonNameComponents.ParseStrategy.name)
      }
    }

    init(_ wrappedInstance: PersonNameComponents.ParseStrategy) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc override init() {
      wrappedInstance = PersonNameComponents.ParseStrategy()
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func parse(_ value: String) throws -> PersonNameComponentsWrapper {
      let result = try wrappedInstance.parse(value)
      return PersonNameComponentsWrapper(result)
    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class AttributedStyleWrapper: NSObject {
    var wrappedInstance: PersonNameComponents.AttributedStyle

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper {
      get {
        LocaleWrapper(wrappedInstance.locale)
      }
      set {
        wrappedInstance.locale = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: PersonNameComponents.AttributedStyle) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func format(_ value: PersonNameComponentsWrapper) -> AttributedStringWrapper {
      let result = wrappedInstance.format(value.wrappedInstance)
      return AttributedStringWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> PersonNameComponentsWrapper.AttributedStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return AttributedStyleWrapper(result)
    }

  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class CollectionContainsCollectionWrapper: NSObject {
  var wrappedInstance: CollectionContainsCollection

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: CollectionContainsCollection) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc public func evaluate(_ bindings: PredicateBindingsWrapper) throws -> BoolWrapper {
    let result = try wrappedInstance.evaluate(bindings.wrappedInstance)
    return BoolWrapper(result)
  }

}

@available(macOS, introduced: 15)
@available(watchOS, introduced: 11)
@available(iOS, introduced: 18)
@available(tvOS, introduced: 18)
@objc public class PredicateRegexWrapper: NSObject {
  var wrappedInstance: PredicateRegex

  @available(macOS, introduced: 15)
  @available(watchOS, introduced: 11)
  @available(iOS, introduced: 18)
  @available(tvOS, introduced: 18)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 15)
  @available(watchOS, introduced: 11)
  @available(iOS, introduced: 18)
  @available(tvOS, introduced: 18)
  @objc public var stringRepresentation: String {
    get {
      wrappedInstance.stringRepresentation
    }
  }

  init(_ wrappedInstance: PredicateRegex) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14.4)
@available(watchOS, introduced: 10.4)
@available(iOS, introduced: 17.4)
@available(tvOS, introduced: 17.4)
@objc public class PredicateEvaluateWrapper: NSObject {
  var wrappedInstance: PredicateEvaluate

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: PredicateEvaluate) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class ArithmeticWrapper: NSObject {
  var wrappedInstance: Arithmetic

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: Arithmetic) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class ComparisonWrapper: NSObject {
  var wrappedInstance: Comparison

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: Comparison) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc public func evaluate(_ bindings: PredicateBindingsWrapper) throws -> BoolWrapper {
    let result = try wrappedInstance.evaluate(bindings.wrappedInstance)
    return BoolWrapper(result)
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class NilLiteralWrapper: NSObject {
  var wrappedInstance: NilLiteral

  init(_ wrappedInstance: NilLiteral) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc override init() {
    wrappedInstance = NilLiteral()
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class UnaryMinusWrapper: NSObject {
  var wrappedInstance: UnaryMinus

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: UnaryMinus) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class VariableIDWrapper: NSObject {
  var wrappedInstance: VariableID

  init(_ wrappedInstance: VariableID) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class ClosedRangeWrapper: NSObject {
  var wrappedInstance: ClosedRange

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: ClosedRange) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class ConditionalWrapper: NSObject {
  var wrappedInstance: Conditional

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: Conditional) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class ConjunctionWrapper: NSObject {
  var wrappedInstance: Conjunction

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: Conjunction) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc public func evaluate(_ bindings: PredicateBindingsWrapper) throws -> BoolWrapper {
    let result = try wrappedInstance.evaluate(bindings.wrappedInstance)
    return BoolWrapper(result)
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class DisjunctionWrapper: NSObject {
  var wrappedInstance: Disjunction

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: Disjunction) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc public func evaluate(_ bindings: PredicateBindingsWrapper) throws -> BoolWrapper {
    let result = try wrappedInstance.evaluate(bindings.wrappedInstance)
    return BoolWrapper(result)
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class IntDivisionWrapper: NSObject {
  var wrappedInstance: IntDivision

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: IntDivision) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class NilCoalesceWrapper: NSObject {
  var wrappedInstance: NilCoalesce

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: NilCoalesce) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class ForcedUnwrapWrapper: NSObject {
  var wrappedInstance: ForcedUnwrap

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: ForcedUnwrap) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class IntRemainderWrapper: NSObject {
  var wrappedInstance: IntRemainder

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: IntRemainder) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class FloatDivisionWrapper: NSObject {
  var wrappedInstance: FloatDivision

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: FloatDivision) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class ConditionalCastWrapper: NSObject {
  var wrappedInstance: ConditionalCast

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: ConditionalCast) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class OptionalFlatMapWrapper: NSObject {
  var wrappedInstance: OptionalFlatMap

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: OptionalFlatMap) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class SequenceMaximumWrapper: NSObject {
  var wrappedInstance: SequenceMaximum

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: SequenceMaximum) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class SequenceMinimumWrapper: NSObject {
  var wrappedInstance: SequenceMinimum

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: SequenceMinimum) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class SequenceContainsWrapper: NSObject {
  var wrappedInstance: SequenceContains

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: SequenceContains) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc public func evaluate(_ bindings: PredicateBindingsWrapper) throws -> BoolWrapper {
    let result = try wrappedInstance.evaluate(bindings.wrappedInstance)
    return BoolWrapper(result)
  }

}

@available(macOS, introduced: 15)
@available(watchOS, introduced: 11)
@available(iOS, introduced: 18)
@available(tvOS, introduced: 18)
@objc public class ExpressionEvaluateWrapper: NSObject {
  var wrappedInstance: ExpressionEvaluate

  @available(macOS, introduced: 15)
  @available(watchOS, introduced: 11)
  @available(iOS, introduced: 18)
  @available(tvOS, introduced: 18)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: ExpressionEvaluate) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class SequenceAllSatisfyWrapper: NSObject {
  var wrappedInstance: SequenceAllSatisfy

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: SequenceAllSatisfy) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class SequenceStartsWithWrapper: NSObject {
  var wrappedInstance: SequenceStartsWith

  init(_ wrappedInstance: SequenceStartsWith) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc public func evaluate(_ bindings: PredicateBindingsWrapper) throws -> BoolWrapper {
    let result = try wrappedInstance.evaluate(bindings.wrappedInstance)
    return BoolWrapper(result)
  }

}

@available(macOS, introduced: 15)
@available(watchOS, introduced: 11)
@available(iOS, introduced: 18)
@available(tvOS, introduced: 18)
@objc public class StringContainsRegexWrapper: NSObject {
  var wrappedInstance: StringContainsRegex

  @available(macOS, introduced: 15)
  @available(watchOS, introduced: 11)
  @available(iOS, introduced: 18)
  @available(tvOS, introduced: 18)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: StringContainsRegex) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 15)
  @available(watchOS, introduced: 11)
  @available(iOS, introduced: 18)
  @available(tvOS, introduced: 18)
  @objc public func evaluate(_ bindings: PredicateBindingsWrapper) throws -> BoolWrapper {
    let result = try wrappedInstance.evaluate(bindings.wrappedInstance)
    return BoolWrapper(result)
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class SequenceContainsWhereWrapper: NSObject {
  var wrappedInstance: SequenceContainsWhere

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: SequenceContainsWhere) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class DictionaryKeySubscriptWrapper: NSObject {
  var wrappedInstance: DictionaryKeySubscript

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: DictionaryKeySubscript) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class StringLocalizedCompareWrapper: NSObject {
  var wrappedInstance: StringLocalizedCompare

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: StringLocalizedCompare) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class RangeExpressionContainsWrapper: NSObject {
  var wrappedInstance: RangeExpressionContains

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: RangeExpressionContains) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class CollectionIndexSubscriptWrapper: NSObject {
  var wrappedInstance: CollectionIndexSubscript

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: CollectionIndexSubscript) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class CollectionRangeSubscriptWrapper: NSObject {
  var wrappedInstance: CollectionRangeSubscript

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: CollectionRangeSubscript) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class StringCaseInsensitiveCompareWrapper: NSObject {
  var wrappedInstance: StringCaseInsensitiveCompare

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: StringCaseInsensitiveCompare) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class StringLocalizedStandardContainsWrapper: NSObject {
  var wrappedInstance: StringLocalizedStandardContains

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: StringLocalizedStandardContains) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class DictionaryKeyDefaultValueSubscriptWrapper: NSObject {
  var wrappedInstance: DictionaryKeyDefaultValueSubscript

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: DictionaryKeyDefaultValueSubscript) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class EqualWrapper: NSObject {
  var wrappedInstance: Equal

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: Equal) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc public func evaluate(_ bindings: PredicateBindingsWrapper) throws -> BoolWrapper {
    let result = try wrappedInstance.evaluate(bindings.wrappedInstance)
    return BoolWrapper(result)
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class RangeWrapper: NSObject {
  var wrappedInstance: Range

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: Range) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class ValueWrapper1: NSObject {
  var wrappedInstance: Value

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: Value) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class FilterWrapper: NSObject {
  var wrappedInstance: Filter

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: Filter) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class KeyPathWrapper: NSObject {
  var wrappedInstance: KeyPath

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: KeyPath) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class NegationWrapper: NSObject {
  var wrappedInstance: Negation

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: Negation) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc public func evaluate(_ bindings: PredicateBindingsWrapper) throws -> BoolWrapper {
    let result = try wrappedInstance.evaluate(bindings.wrappedInstance)
    return BoolWrapper(result)
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class NotEqualWrapper: NSObject {
  var wrappedInstance: NotEqual

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: NotEqual) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc public func evaluate(_ bindings: PredicateBindingsWrapper) throws -> BoolWrapper {
    let result = try wrappedInstance.evaluate(bindings.wrappedInstance)
    return BoolWrapper(result)
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class VariableWrapper: NSObject {
  var wrappedInstance: Variable

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: Variable) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc override init() {
    wrappedInstance = Variable()
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class ForceCastWrapper: NSObject {
  var wrappedInstance: ForceCast

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: ForceCast) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class TypeCheckWrapper: NSObject {
  var wrappedInstance: TypeCheck

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: TypeCheck) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class AsyncCharacterSequenceWrapper: NSObject {
  var wrappedInstance: AsyncCharacterSequence

  init(_ wrappedInstance: AsyncCharacterSequence) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func makeAsyncIterator() -> AsyncCharacterSequenceWrapper {
    let result = wrappedInstance.makeAsyncIterator()
    return AsyncCharacterSequenceWrapper(result)
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class AsyncIteratorWrapper: NSObject {
    var wrappedInstance: AsyncCharacterSequence.AsyncIterator

    init(_ wrappedInstance: AsyncCharacterSequence.AsyncIterator) {
      self.wrappedInstance = wrappedInstance
    }

  }

}

@available(macOS, introduced: 13)
@available(watchOS, introduced: 9)
@available(iOS, introduced: 16)
@available(tvOS, introduced: 16)
@objc public class LocalizedStringResourceWrapper: NSObject {
  var wrappedInstance: LocalizedStringResource

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var localizedStringResource: LocalizedStringResourceWrapper {
    get {
      LocalizedStringResourceWrapper(wrappedInstance.localizedStringResource)
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var key: String {
    get {
      wrappedInstance.key
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var table: String? {
    get {
      wrappedInstance.table
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var locale: LocaleWrapper {
    get {
      LocaleWrapper(wrappedInstance.locale)
    }
    set {
      wrappedInstance.locale = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: LocalizedStringResource) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc init(stringLiteral value: String) {
    wrappedInstance = LocalizedStringResource(stringLiteral: value)
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class FloatingPointFormatStyleWrapper: NSObject {
  var wrappedInstance: FloatingPointFormatStyle

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var number: FloatingPointFormatStyleWrapper {
    get {
      FloatingPointFormatStyleWrapper(FloatingPointFormatStyle.number)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var number: FloatingPointFormatStyleWrapper {
    get {
      FloatingPointFormatStyleWrapper(FloatingPointFormatStyle.number)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var attributed: FloatingPointFormatStyleWrapper {
    get {
      FloatingPointFormatStyleWrapper(wrappedInstance.attributed)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var parseStrategy: FloatingPointParseStrategyWrapper {
    get {
      FloatingPointParseStrategyWrapper(wrappedInstance.parseStrategy)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var locale: LocaleWrapper {
    get {
      LocaleWrapper(wrappedInstance.locale)
    }
    set {
      wrappedInstance.locale = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: FloatingPointFormatStyle) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func scale(_ multiplicand: Double) -> FloatingPointFormatStyleWrapper {
    let result = wrappedInstance.scale(multiplicand)
    return FloatingPointFormatStyleWrapper(result)
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func locale(_ locale: LocaleWrapper) -> FloatingPointFormatStyleWrapper {
    let result = wrappedInstance.locale(locale.wrappedInstance)
    return FloatingPointFormatStyleWrapper(result)
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class AttributedWrapper: NSObject {
    var wrappedInstance: FloatingPointFormatStyle.Attributed

    init(_ wrappedInstance: FloatingPointFormatStyle.Attributed) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> FloatingPointFormatStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return FloatingPointFormatStyleWrapper(result)
    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class PercentWrapper: NSObject {
    var wrappedInstance: FloatingPointFormatStyle.Percent

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var percent: FloatingPointFormatStyleWrapper {
      get {
        FloatingPointFormatStyleWrapper(FloatingPointFormatStyle.Percent.percent)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var percent: FloatingPointFormatStyleWrapper {
      get {
        FloatingPointFormatStyleWrapper(FloatingPointFormatStyle.Percent.percent)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var attributed: FloatingPointFormatStyleWrapper {
      get {
        FloatingPointFormatStyleWrapper(wrappedInstance.attributed)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var parseStrategy: FloatingPointParseStrategyWrapper {
      get {
        FloatingPointParseStrategyWrapper(wrappedInstance.parseStrategy)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper {
      get {
        LocaleWrapper(wrappedInstance.locale)
      }
      set {
        wrappedInstance.locale = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: FloatingPointFormatStyle.Percent) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func scale(_ multiplicand: Double) -> FloatingPointFormatStyleWrapper {
      let result = wrappedInstance.scale(multiplicand)
      return FloatingPointFormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> FloatingPointFormatStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return FloatingPointFormatStyleWrapper(result)
    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class CurrencyWrapper: NSObject {
    var wrappedInstance: FloatingPointFormatStyle.Currency

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var attributed: FloatingPointFormatStyleWrapper {
      get {
        FloatingPointFormatStyleWrapper(wrappedInstance.attributed)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var currencyCode: String {
      get {
        wrappedInstance.currencyCode
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var parseStrategy: FloatingPointParseStrategyWrapper {
      get {
        FloatingPointParseStrategyWrapper(wrappedInstance.parseStrategy)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper {
      get {
        LocaleWrapper(wrappedInstance.locale)
      }
      set {
        wrappedInstance.locale = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: FloatingPointFormatStyle.Currency) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func scale(_ multiplicand: Double) -> FloatingPointFormatStyleWrapper {
      let result = wrappedInstance.scale(multiplicand)
      return FloatingPointFormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> FloatingPointFormatStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return FloatingPointFormatStyleWrapper(result)
    }

  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class NSKeyValueObservedChangeWrapper: NSObject {
  var wrappedInstance: NSKeyValueObservedChange

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var kind: NSKeyValueObservedChangeWrapper {
    get {
      NSKeyValueObservedChangeWrapper(wrappedInstance.kind)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var indexes: IndexSetWrapper? {
    get {
      wrappedInstance.indexes == nil ? nil : IndexSetWrapper(wrappedInstance.indexes!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isPrior: Bool {
    get {
      wrappedInstance.isPrior
    }
  }

  init(_ wrappedInstance: NSKeyValueObservedChange) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12)
@available(watchOS, introduced: 8)
@available(iOS, introduced: 15)
@available(tvOS, introduced: 15)
@objc public class ScopedAttributeContainerWrapper: NSObject {
  var wrappedInstance: ScopedAttributeContainer

  init(_ wrappedInstance: ScopedAttributeContainer) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class NSFastEnumerationIteratorWrapper: NSObject {
  var wrappedInstance: NSFastEnumerationIterator

  init(_ wrappedInstance: NSFastEnumerationIterator) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class AsyncUnicodeScalarSequenceWrapper: NSObject {
  var wrappedInstance: AsyncUnicodeScalarSequence

  init(_ wrappedInstance: AsyncUnicodeScalarSequence) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func makeAsyncIterator() -> AsyncUnicodeScalarSequenceWrapper {
    let result = wrappedInstance.makeAsyncIterator()
    return AsyncUnicodeScalarSequenceWrapper(result)
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class AsyncIteratorWrapper: NSObject {
    var wrappedInstance: AsyncUnicodeScalarSequence.AsyncIterator

    init(_ wrappedInstance: AsyncUnicodeScalarSequence.AsyncIterator) {
      self.wrappedInstance = wrappedInstance
    }

  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class FloatingPointParseStrategyWrapper: NSObject {
  var wrappedInstance: FloatingPointParseStrategy

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var lenient: Bool {
    get {
      wrappedInstance.lenient
    }
    set {
      wrappedInstance.lenient = newValue
    }
  }

  init(_ wrappedInstance: FloatingPointParseStrategy) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class MeasurementFormatUnitUsageWrapper: NSObject {
  var wrappedInstance: MeasurementFormatUnitUsage

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var asProvided: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.asProvided)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var general: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.general)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var personWeight: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.personWeight)
    }
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 17)
  @objc static public var wind: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.wind)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var food: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.food)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var workout: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.workout)
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var focalLength: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.focalLength)
    }
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 17)
  @objc static public var visibility: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.visibility)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var personHeight: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.personHeight)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var road: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.road)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var person: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.person)
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var rainfall: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.rainfall)
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var snowfall: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.snowfall)
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var liquid: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.liquid)
    }
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 17)
  @objc static public var barometric: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.barometric)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var person: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.person)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var weather: MeasurementFormatUnitUsageWrapper {
    get {
      MeasurementFormatUnitUsageWrapper(MeasurementFormatUnitUsage.weather)
    }
  }

  init(_ wrappedInstance: MeasurementFormatUnitUsage) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class PredicateCodableConfigurationWrapper: NSObject {
  var wrappedInstance: PredicateCodableConfiguration

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc static public var standardConfiguration: PredicateCodableConfigurationWrapper {
    get {
      PredicateCodableConfigurationWrapper(PredicateCodableConfiguration.standardConfiguration)
    }
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  init(_ wrappedInstance: PredicateCodableConfiguration) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc override init() {
    wrappedInstance = PredicateCodableConfiguration()
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc public func allow(_ other: PredicateCodableConfigurationWrapper) {
    return wrappedInstance.allow(other.wrappedInstance)
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class SignDisplayStrategyWrapper1: NSObject {
  var wrappedInstance: SignDisplayStrategy

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: SignDisplayStrategy) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class DecimalSeparatorDisplayStrategyWrapper: NSObject {
  var wrappedInstance: DecimalSeparatorDisplayStrategy

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: DecimalSeparatorDisplayStrategy) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class GroupingWrapper: NSObject {
  var wrappedInstance: Grouping

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: Grouping) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class NotationWrapper: NSObject {
  var wrappedInstance: Notation

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  init(_ wrappedInstance: Notation) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class PrecisionWrapper: NSObject {
  var wrappedInstance: Precision

  init(_ wrappedInstance: Precision) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class PresentationWrapper: NSObject {
  var wrappedInstance: Presentation

  init(_ wrappedInstance: Presentation) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class SignDisplayStrategyWrapper: NSObject {
  var wrappedInstance: SignDisplayStrategy

  init(_ wrappedInstance: SignDisplayStrategy) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class FormatStyleCapitalizationContextWrapper: NSObject {
  var wrappedInstance: FormatStyleCapitalizationContext

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var standalone: FormatStyleCapitalizationContextWrapper {
    get {
      FormatStyleCapitalizationContextWrapper(FormatStyleCapitalizationContext.standalone)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var middleOfSentence: FormatStyleCapitalizationContextWrapper {
    get {
      FormatStyleCapitalizationContextWrapper(FormatStyleCapitalizationContext.middleOfSentence)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var beginningOfSentence: FormatStyleCapitalizationContextWrapper {
    get {
      FormatStyleCapitalizationContextWrapper(FormatStyleCapitalizationContext.beginningOfSentence)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var unknown: FormatStyleCapitalizationContextWrapper {
    get {
      FormatStyleCapitalizationContextWrapper(FormatStyleCapitalizationContext.unknown)
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc static public var listItem: FormatStyleCapitalizationContextWrapper {
    get {
      FormatStyleCapitalizationContextWrapper(FormatStyleCapitalizationContext.listItem)
    }
  }

  init(_ wrappedInstance: FormatStyleCapitalizationContext) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12)
@available(watchOS, introduced: 8)
@available(iOS, introduced: 15)
@available(tvOS, introduced: 15)
@objc public class AttributeScopeCodableConfigurationWrapper: NSObject {
  var wrappedInstance: AttributeScopeCodableConfiguration

  init(_ wrappedInstance: AttributeScopeCodableConfiguration) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 12.0)
@available(watchOS, introduced: 8.0)
@available(iOS, introduced: 15.0)
@available(tvOS, introduced: 15.0)
@objc public class PresentationWrapper1: NSObject {
  var wrappedInstance: Presentation

  init(_ wrappedInstance: Presentation) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class URLWrapper: NSObject {
  var wrappedInstance: URL

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var standardizedFileURL: URLWrapper {
    get {
      URLWrapper(wrappedInstance.standardizedFileURL)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var baseURL: URLWrapper? {
    get {
      wrappedInstance.baseURL == nil ? nil : URLWrapper(wrappedInstance.baseURL!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isFileURL: Bool {
    get {
      wrappedInstance.isFileURL
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var absoluteURL: URLWrapper {
    get {
      URLWrapper(wrappedInstance.absoluteURL)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var relativePath: String {
    get {
      wrappedInstance.relativePath
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var standardized: URLWrapper {
    get {
      URLWrapper(wrappedInstance.standardized)
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var homeDirectory: URLWrapper {
    get {
      URLWrapper(URL.homeDirectory)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var pathExtension: String {
    get {
      wrappedInstance.pathExtension
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var resourceBytes: URLWrapper.AsyncBytesWrapper {
    get {
      AsyncBytesWrapper(wrappedInstance.resourceBytes)
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var userDirectory: URLWrapper {
    get {
      URLWrapper(URL.userDirectory)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var absoluteString: String {
    get {
      wrappedInstance.absoluteString
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var musicDirectory: URLWrapper {
    get {
      URLWrapper(URL.musicDirectory)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var relativeString: String {
    get {
      wrappedInstance.relativeString
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, unavailable)
  @available(iOS, introduced: 16.0)
  @available(tvOS, unavailable)
  @objc static public var trashDirectory: URLWrapper {
    get {
      URLWrapper(URL.trashDirectory)
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var cachesDirectory: URLWrapper {
    get {
      URLWrapper(URL.cachesDirectory)
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var moviesDirectory: URLWrapper {
    get {
      URLWrapper(URL.moviesDirectory)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var desktopDirectory: URLWrapper {
    get {
      URLWrapper(URL.desktopDirectory)
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc public var hasDirectoryPath: Bool {
    get {
      wrappedInstance.hasDirectoryPath
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var libraryDirectory: URLWrapper {
    get {
      URLWrapper(URL.libraryDirectory)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var lastPathComponent: String {
    get {
      wrappedInstance.lastPathComponent
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var picturesDirectory: URLWrapper {
    get {
      URLWrapper(URL.picturesDirectory)
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc public var dataRepresentation: DataWrapper {
    get {
      DataWrapper(wrappedInstance.dataRepresentation)
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var documentsDirectory: URLWrapper {
    get {
      URLWrapper(URL.documentsDirectory)
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var downloadsDirectory: URLWrapper {
    get {
      URLWrapper(URL.downloadsDirectory)
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var temporaryDirectory: URLWrapper {
    get {
      URLWrapper(URL.temporaryDirectory)
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var applicationDirectory: URLWrapper {
    get {
      URLWrapper(URL.applicationDirectory)
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var sharedPublicDirectory: URLWrapper {
    get {
      URLWrapper(URL.sharedPublicDirectory)
    }
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public var applicationSupportDirectory: URLWrapper {
    get {
      URLWrapper(URL.applicationSupportDirectory)
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc public var host: String? {
    get {
      wrappedInstance.host
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc public var path: String {
    get {
      wrappedInstance.path
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var port: Int? {
    get {
      wrappedInstance.port
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc public var user: String? {
    get {
      wrappedInstance.user
    }
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public var lines: AsyncLineSequenceWrapper {
    get {
      AsyncLineSequenceWrapper(wrappedInstance.lines)
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc public var query: String? {
    get {
      wrappedInstance.query
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var scheme: String? {
    get {
      wrappedInstance.scheme
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc public var fragment: String? {
    get {
      wrappedInstance.fragment
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc public var password: String? {
    get {
      wrappedInstance.password
    }
  }

  init(_ wrappedInstance: URL) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc init(fileURLWithPath path: String, relativeTo base: URLWrapper?) {
    wrappedInstance = URL(fileURLWithPath: path, relativeTo: base?.wrappedInstance)
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc init(fileURLWithPath path: String, isDirectory: Bool, relativeTo base: URLWrapper?) {
    wrappedInstance = URL(fileURLWithPath: path, isDirectory: isDirectory, relativeTo: base?.wrappedInstance)
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc init(fileURLWithPath path: String, isDirectory: Bool) {
    wrappedInstance = URL(fileURLWithPath: path, isDirectory: isDirectory)
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc init(fileURLWithPath path: String) {
    wrappedInstance = URL(fileURLWithPath: path)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(fileReferenceLiteralResourceName name: String) {
    wrappedInstance = URL(fileReferenceLiteralResourceName: name)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init?(string: String, relativeTo url: URLWrapper?) {
    if let instance = URL(string: string, relativeTo: url?.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 14.0)
  @available(watchOS, introduced: 10.0)
  @available(iOS, introduced: 17.0)
  @available(tvOS, introduced: 17.0)
  @objc init?(string: String, encodingInvalidCharacters: Bool) {
    if let instance = URL(string: string, encodingInvalidCharacters: encodingInvalidCharacters) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init?(string: String) {
    if let instance = URL(string: string) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc init?(resource: URLResourceWrapper) {
    if let instance = URL(resource: resource.wrappedInstance) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func standardize() {
    return wrappedInstance.standardize()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public func bookmarkData(withContentsOf url: URLWrapper) throws -> DataWrapper {
    let result = try URL.bookmarkData(withContentsOf: url.wrappedInstance)
    return DataWrapper(result)
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public func homeDirectory(forUser user: String) -> URLWrapper? {
    let result = URL.homeDirectory(forUser: user)
    return result == nil ? nil : URLWrapper(result!)
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc static public func currentDirectory() -> URLWrapper {
    let result = URL.currentDirectory()
    return URLWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func setResourceValues(_ values: URLResourceValuesWrapper) throws {
    return try wrappedInstance.setResourceValues(values.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public func writeBookmarkData(_ data: DataWrapper, to url: URLWrapper) throws {
    return try URL.writeBookmarkData(data.wrappedInstance, to: url.wrappedInstance)
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc public func appendPathComponent(_ pathComponent: String, isDirectory: Bool) {
    return wrappedInstance.appendPathComponent(pathComponent, isDirectory: isDirectory)
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc public func appendPathComponent(_ pathComponent: String) {
    return wrappedInstance.appendPathComponent(pathComponent)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func appendPathExtension(_ pathExtension: String) {
    return wrappedInstance.appendPathExtension(pathExtension)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func deletePathExtension() {
    return wrappedInstance.deletePathExtension()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func deletingPathExtension() -> URLWrapper {
    let result = wrappedInstance.deletingPathExtension()
    return URLWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func resolveSymlinksInPath() {
    return wrappedInstance.resolveSymlinksInPath()
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc public func appendingPathComponent(_ pathComponent: String, isDirectory: Bool) -> URLWrapper {
    let result = wrappedInstance.appendingPathComponent(pathComponent, isDirectory: isDirectory)
    return URLWrapper(result)
  }

  @available(macOS, introduced: 10.10, deprecated: 100000.0)
  @available(watchOS, introduced: 2.0, deprecated: 100000.0)
  @available(iOS, introduced: 8.0, deprecated: 100000.0)
  @available(visionOS, introduced: 1.0, deprecated: 100000.0)
  @available(tvOS, introduced: 9.0, deprecated: 100000.0)
  @objc public func appendingPathComponent(_ pathComponent: String) -> URLWrapper {
    let result = wrappedInstance.appendingPathComponent(pathComponent)
    return URLWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func appendingPathExtension(_ pathExtension: String) -> URLWrapper {
    let result = wrappedInstance.appendingPathExtension(pathExtension)
    return URLWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func deleteLastPathComponent() {
    return wrappedInstance.deleteLastPathComponent()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func resolvingSymlinksInPath() -> URLWrapper {
    let result = wrappedInstance.resolvingSymlinksInPath()
    return URLWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func checkResourceIsReachable() throws -> BoolWrapper {
    let result = try wrappedInstance.checkResourceIsReachable()
    return BoolWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func deletingLastPathComponent() -> URLWrapper {
    let result = wrappedInstance.deletingLastPathComponent()
    return URLWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func removeCachedResourceValue(forKey key: URLResourceKeyWrapper) {
    return wrappedInstance.removeCachedResourceValue(forKey: key.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func checkPromisedItemIsReachable() throws -> BoolWrapper {
    let result = try wrappedInstance.checkPromisedItemIsReachable()
    return BoolWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func removeAllCachedResourceValues() {
    return wrappedInstance.removeAllCachedResourceValues()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func stopAccessingSecurityScopedResource() {
    return wrappedInstance.stopAccessingSecurityScopedResource()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func startAccessingSecurityScopedResource() -> Bool {
    return wrappedInstance.startAccessingSecurityScopedResource()
  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc public func formatted() -> String {
    return wrappedInstance.formatted()
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class AsyncBytesWrapper: NSObject {
    var wrappedInstance: URL.AsyncBytes

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var characters: AsyncCharacterSequenceWrapper {
      get {
        AsyncCharacterSequenceWrapper(wrappedInstance.characters)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var unicodeScalars: AsyncUnicodeScalarSequenceWrapper {
      get {
        AsyncUnicodeScalarSequenceWrapper(wrappedInstance.unicodeScalars)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var lines: AsyncLineSequenceWrapper {
      get {
        AsyncLineSequenceWrapper(wrappedInstance.lines)
      }
    }

    init(_ wrappedInstance: URL.AsyncBytes) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func makeAsyncIterator() -> AsyncBytesWrapper.AsyncIteratorWrapper {
      let result = wrappedInstance.makeAsyncIterator()
      return AsyncIteratorWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class AsyncIteratorWrapper: NSObject {
      var wrappedInstance: AsyncBytes.AsyncIterator

      init(_ wrappedInstance: AsyncBytes.AsyncIterator) {
        self.wrappedInstance = wrappedInstance
      }

    }

  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc public class FormatStyleWrapper: NSObject {
    var wrappedInstance: URL.FormatStyle

    @available(macOS, introduced: 13.0)
    @available(watchOS, introduced: 9.0)
    @available(iOS, introduced: 16.0)
    @available(tvOS, introduced: 16.0)
    @objc static public var url: URLWrapper.FormatStyleWrapper {
      get {
        FormatStyleWrapper(URL.FormatStyle.url)
      }
    }

    @available(macOS, introduced: 13.0)
    @available(watchOS, introduced: 9.0)
    @available(iOS, introduced: 16.0)
    @available(tvOS, introduced: 16.0)
    @objc static public var url: URLWrapper.FormatStyleWrapper {
      get {
        FormatStyleWrapper(URL.FormatStyle.url)
      }
    }

    @available(macOS, introduced: 13.0)
    @available(watchOS, introduced: 9.0)
    @available(iOS, introduced: 16.0)
    @available(tvOS, introduced: 16.0)
    @objc public var parseStrategy: URLWrapper.ParseStrategyWrapper {
      get {
        ParseStrategyWrapper(wrappedInstance.parseStrategy)
      }
    }

    init(_ wrappedInstance: URL.FormatStyle) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13.0)
    @available(watchOS, introduced: 9.0)
    @available(iOS, introduced: 16.0)
    @available(tvOS, introduced: 16.0)
    @objc public func format(_ value: URLWrapper) -> String {
      return wrappedInstance.format(value.wrappedInstance)
    }

    @available(macOS, introduced: 13.0)
    @available(watchOS, introduced: 9.0)
    @available(iOS, introduced: 16.0)
    @available(tvOS, introduced: 16.0)
    @objc public class HostDisplayOptionWrapper: NSObject {
      var wrappedInstance: FormatStyle.HostDisplayOption

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public var description: String {
        get {
          wrappedInstance.description
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc static public var omitIfHTTPFamily: FormatStyleWrapper.HostDisplayOptionWrapper {
        get {
          HostDisplayOptionWrapper(FormatStyle.HostDisplayOption.omitIfHTTPFamily)
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc static public var never: FormatStyleWrapper.HostDisplayOptionWrapper {
        get {
          HostDisplayOptionWrapper(FormatStyle.HostDisplayOption.never)
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc static public var always: FormatStyleWrapper.HostDisplayOptionWrapper {
        get {
          HostDisplayOptionWrapper(FormatStyle.HostDisplayOption.always)
        }
      }

      init(_ wrappedInstance: FormatStyle.HostDisplayOption) {
        self.wrappedInstance = wrappedInstance
      }

    }

    @available(macOS, introduced: 13.0)
    @available(watchOS, introduced: 9.0)
    @available(iOS, introduced: 16.0)
    @available(tvOS, introduced: 16.0)
    @objc public class ComponentDisplayOptionWrapper: NSObject {
      var wrappedInstance: FormatStyle.ComponentDisplayOption

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc public var description: String {
        get {
          wrappedInstance.description
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc static public var omitIfHTTPFamily: FormatStyleWrapper.ComponentDisplayOptionWrapper {
        get {
          ComponentDisplayOptionWrapper(FormatStyle.ComponentDisplayOption.omitIfHTTPFamily)
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc static public var never: FormatStyleWrapper.ComponentDisplayOptionWrapper {
        get {
          ComponentDisplayOptionWrapper(FormatStyle.ComponentDisplayOption.never)
        }
      }

      @available(macOS, introduced: 13.0)
      @available(watchOS, introduced: 9.0)
      @available(iOS, introduced: 16.0)
      @available(tvOS, introduced: 16.0)
      @objc static public var always: FormatStyleWrapper.ComponentDisplayOptionWrapper {
        get {
          ComponentDisplayOptionWrapper(FormatStyle.ComponentDisplayOption.always)
        }
      }

      init(_ wrappedInstance: FormatStyle.ComponentDisplayOption) {
        self.wrappedInstance = wrappedInstance
      }

    }

  }

  @available(macOS, introduced: 13.0)
  @available(watchOS, introduced: 9.0)
  @available(iOS, introduced: 16.0)
  @available(tvOS, introduced: 16.0)
  @objc public class ParseStrategyWrapper: NSObject {
    var wrappedInstance: URL.ParseStrategy

    @available(macOS, introduced: 13.0)
    @available(watchOS, introduced: 9.0)
    @available(iOS, introduced: 16.0)
    @available(tvOS, introduced: 16.0)
    @objc static public var url: URLWrapper.ParseStrategyWrapper {
      get {
        ParseStrategyWrapper(URL.ParseStrategy.url)
      }
    }

    init(_ wrappedInstance: URL.ParseStrategy) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13.0)
    @available(watchOS, introduced: 9.0)
    @available(iOS, introduced: 16.0)
    @available(tvOS, introduced: 16.0)
    @objc public func parse(_ value: String) throws -> URLWrapper {
      let result = try wrappedInstance.parse(value)
      return URLWrapper(result)
    }

  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class DataWrapper: NSObject {
  var wrappedInstance: Data

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var startIndex: Data.Index {
    get {
      wrappedInstance.startIndex
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var count: Int {
    get {
      wrappedInstance.count
    }
    set {
      wrappedInstance.count = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var endIndex: Data.Index {
    get {
      wrappedInstance.endIndex
    }
  }

  @objc public var underestimatedCount: Int {
    get {
      wrappedInstance.underestimatedCount
    }
  }

  @objc public var isEmpty: Bool {
    get {
      wrappedInstance.isEmpty
    }
  }

  init(_ wrappedInstance: Data) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(referencing reference: NSDataWrapper) {
    wrappedInstance = Data(referencing: reference.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(count: Int) {
    wrappedInstance = Data(count: count)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(capacity: Int) {
    wrappedInstance = Data(capacity: capacity)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc override init() {
    wrappedInstance = Data()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func makeIterator() -> DataWrapper.IteratorWrapper {
    let result = wrappedInstance.makeIterator()
    return IteratorWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func reserveCapacity(_ minimumCapacity: Int) {
    return wrappedInstance.reserveCapacity(minimumCapacity)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func index(after i: Data.Index) -> Data.Index {
    return wrappedInstance.index(after: i)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func index(before i: Data.Index) -> Data.Index {
    return wrappedInstance.index(before: i)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func append(_ other: DataWrapper) {
    return wrappedInstance.append(other.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func advanced(by amount: Int) -> DataWrapper {
    let result = wrappedInstance.advanced(by: amount)
    return DataWrapper(result)
  }

  @objc public func removeLast(_ k: Int) {
    return wrappedInstance.removeLast(k)
  }

  @objc public func reverse() {
    return wrappedInstance.reverse()
  }

  @objc public func sort() {
    return wrappedInstance.sort()
  }

  @objc public func shuffle() {
    return wrappedInstance.shuffle()
  }

  @objc public func removeFirst(_ k: Int) {
    return wrappedInstance.removeFirst(k)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public class IteratorWrapper: NSObject {
    var wrappedInstance: Data.Iterator

    init(_ wrappedInstance: Data.Iterator) {
      self.wrappedInstance = wrappedInstance
    }

  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class DateWrapper: NSObject {
  var wrappedInstance: Date

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var timeIntervalSinceReferenceDate: TimeInterval {
    get {
      wrappedInstance.timeIntervalSinceReferenceDate
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var timeIntervalSinceReferenceDate: TimeInterval {
    get {
      Date.timeIntervalSinceReferenceDate
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var timeIntervalBetween1970AndReferenceDate: Double {
    get {
      Date.timeIntervalBetween1970AndReferenceDate
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var distantPast: DateWrapper {
    get {
      DateWrapper(Date.distantPast)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var distantFuture: DateWrapper {
    get {
      DateWrapper(Date.distantFuture)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var timeIntervalSinceNow: TimeInterval {
    get {
      wrappedInstance.timeIntervalSinceNow
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var timeIntervalSince1970: TimeInterval {
    get {
      wrappedInstance.timeIntervalSince1970
    }
  }

  @available(macOS, introduced: 12)
  @available(watchOS, introduced: 8)
  @available(iOS, introduced: 15)
  @available(tvOS, introduced: 15)
  @objc static public var now: DateWrapper {
    get {
      DateWrapper(Date.now)
    }
  }

  init(_ wrappedInstance: Date) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(timeIntervalSinceReferenceDate ti: TimeInterval) {
    wrappedInstance = Date(timeIntervalSinceReferenceDate: ti)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(timeInterval: TimeInterval, since date: DateWrapper) {
    wrappedInstance = Date(timeInterval: timeInterval, since: date.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(timeIntervalSinceNow: TimeInterval) {
    wrappedInstance = Date(timeIntervalSinceNow: timeIntervalSinceNow)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(timeIntervalSince1970: TimeInterval) {
    wrappedInstance = Date(timeIntervalSince1970: timeIntervalSince1970)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc override init() {
    wrappedInstance = Date()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func description(with locale: LocaleWrapper?) -> String {
    return wrappedInstance.description(with: locale?.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func addTimeInterval(_ timeInterval: TimeInterval) {
    return wrappedInstance.addTimeInterval(timeInterval)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func timeIntervalSince(_ date: DateWrapper) -> TimeInterval {
    return wrappedInstance.timeIntervalSince(date.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func addingTimeInterval(_ timeInterval: TimeInterval) -> DateWrapper {
    let result = wrappedInstance.addingTimeInterval(timeInterval)
    return DateWrapper(result)
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public func advanced(by n: TimeInterval) -> DateWrapper {
    let result = wrappedInstance.advanced(by: n)
    return DateWrapper(result)
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public func distance(to other: DateWrapper) -> TimeInterval {
    return wrappedInstance.distance(to: other.wrappedInstance)
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func formatted(date: FormatStyleWrapper.DateStyleWrapper, time: FormatStyleWrapper.TimeStyleWrapper) -> String {
    return wrappedInstance.formatted(date: date.wrappedInstance, time: time.wrappedInstance)
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public func formatted() -> String {
    return wrappedInstance.formatted()
  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class FormatStyleWrapper: NSObject {
    var wrappedInstance: Date.FormatStyle

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var dateTime: DateWrapper.FormatStyleWrapper {
      get {
        FormatStyleWrapper(Date.FormatStyle.dateTime)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var dateTime: DateWrapper.FormatStyleWrapper {
      get {
        FormatStyleWrapper(Date.FormatStyle.dateTime)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var dateTime: DateWrapper.FormatStyleWrapper {
      get {
        FormatStyleWrapper(Date.FormatStyle.dateTime)
      }
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public var attributedStyle: FormatStyleWrapper.AttributedWrapper {
      get {
        AttributedWrapper(wrappedInstance.attributedStyle)
      }
    }

    @available(macOS, introduced: 12, deprecated: 15)
    @available(watchOS, introduced: 8, deprecated: 11)
    @available(iOS, introduced: 15, deprecated: 18)
    @available(tvOS, introduced: 15, deprecated: 18)
    @objc public var attributed: DateWrapper.AttributedStyleWrapper {
      get {
        AttributedStyleWrapper(wrappedInstance.attributed)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var parseStrategy: DateWrapper.FormatStyleWrapper {
      get {
        FormatStyleWrapper(wrappedInstance.parseStrategy)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var capitalizationContext: FormatStyleCapitalizationContextWrapper {
      get {
        FormatStyleCapitalizationContextWrapper(wrappedInstance.capitalizationContext)
      }
      set {
        wrappedInstance.capitalizationContext = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper {
      get {
        LocaleWrapper(wrappedInstance.locale)
      }
      set {
        wrappedInstance.locale = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var calendar: CalendarWrapper {
      get {
        CalendarWrapper(wrappedInstance.calendar)
      }
      set {
        wrappedInstance.calendar = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var timeZone: TimeZoneWrapper {
      get {
        TimeZoneWrapper(wrappedInstance.timeZone)
      }
      set {
        wrappedInstance.timeZone = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: Date.FormatStyle) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public func discreteInput(after input: DateWrapper) -> DateWrapper? {
      let result = wrappedInstance.discreteInput(after: input.wrappedInstance)
      return result == nil ? nil : DateWrapper(result!)
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public func discreteInput(before input: DateWrapper) -> DateWrapper? {
      let result = wrappedInstance.discreteInput(before: input.wrappedInstance)
      return result == nil ? nil : DateWrapper(result!)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func secondFraction(_ format: SymbolWrapper.SecondFractionWrapper) -> DateWrapper.FormatStyleWrapper {
      let result = wrappedInstance.secondFraction(format.wrappedInstance)
      return FormatStyleWrapper(result)
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public func input(after input: DateWrapper) -> DateWrapper? {
      let result = wrappedInstance.input(after: input.wrappedInstance)
      return result == nil ? nil : DateWrapper(result!)
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public func input(before input: DateWrapper) -> DateWrapper? {
      let result = wrappedInstance.input(before: input.wrappedInstance)
      return result == nil ? nil : DateWrapper(result!)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func parse(_ value: String) throws -> DateWrapper {
      let result = try wrappedInstance.parse(value)
      return DateWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func format(_ value: DateWrapper) -> String {
      return wrappedInstance.format(value.wrappedInstance)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> DateWrapper.FormatStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return FormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class TimeStyleWrapper: NSObject {
      var wrappedInstance: FormatStyle.TimeStyle

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var omitted: FormatStyleWrapper.TimeStyleWrapper {
        get {
          TimeStyleWrapper(FormatStyle.TimeStyle.omitted)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var complete: FormatStyleWrapper.TimeStyleWrapper {
        get {
          TimeStyleWrapper(FormatStyle.TimeStyle.complete)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var standard: FormatStyleWrapper.TimeStyleWrapper {
        get {
          TimeStyleWrapper(FormatStyle.TimeStyle.standard)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var shortened: FormatStyleWrapper.TimeStyleWrapper {
        get {
          TimeStyleWrapper(FormatStyle.TimeStyle.shortened)
        }
      }

      init(_ wrappedInstance: FormatStyle.TimeStyle) {
        self.wrappedInstance = wrappedInstance
      }

    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class DateStyleWrapper: NSObject {
      var wrappedInstance: FormatStyle.DateStyle

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var abbreviated: FormatStyleWrapper.DateStyleWrapper {
        get {
          DateStyleWrapper(FormatStyle.DateStyle.abbreviated)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var long: FormatStyleWrapper.DateStyleWrapper {
        get {
          DateStyleWrapper(FormatStyle.DateStyle.long)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var numeric: FormatStyleWrapper.DateStyleWrapper {
        get {
          DateStyleWrapper(FormatStyle.DateStyle.numeric)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var omitted: FormatStyleWrapper.DateStyleWrapper {
        get {
          DateStyleWrapper(FormatStyle.DateStyle.omitted)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var complete: FormatStyleWrapper.DateStyleWrapper {
        get {
          DateStyleWrapper(FormatStyle.DateStyle.complete)
        }
      }

      init(_ wrappedInstance: FormatStyle.DateStyle) {
        self.wrappedInstance = wrappedInstance
      }

    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public class AttributedWrapper: NSObject {
      var wrappedInstance: FormatStyle.Attributed

      init(_ wrappedInstance: FormatStyle.Attributed) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public func discreteInput(after input: DateWrapper) -> DateWrapper? {
        let result = wrappedInstance.discreteInput(after: input.wrappedInstance)
        return result == nil ? nil : DateWrapper(result!)
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public func discreteInput(before input: DateWrapper) -> DateWrapper? {
        let result = wrappedInstance.discreteInput(before: input.wrappedInstance)
        return result == nil ? nil : DateWrapper(result!)
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public func secondFraction(_ format: SymbolWrapper.SecondFractionWrapper) -> FormatStyleWrapper.AttributedWrapper {
        let result = wrappedInstance.secondFraction(format.wrappedInstance)
        return AttributedWrapper(result)
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public func input(after input: DateWrapper) -> DateWrapper? {
        let result = wrappedInstance.input(after: input.wrappedInstance)
        return result == nil ? nil : DateWrapper(result!)
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public func input(before input: DateWrapper) -> DateWrapper? {
        let result = wrappedInstance.input(before: input.wrappedInstance)
        return result == nil ? nil : DateWrapper(result!)
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public func format(_ value: DateWrapper) -> AttributedStringWrapper {
        let result = wrappedInstance.format(value.wrappedInstance)
        return AttributedStringWrapper(result)
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public func locale(_ locale: LocaleWrapper) -> FormatStyleWrapper.AttributedWrapper {
        let result = wrappedInstance.locale(locale.wrappedInstance)
        return AttributedWrapper(result)
      }

    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class SymbolWrapper: NSObject {
      var wrappedInstance: FormatStyle.Symbol

      init(_ wrappedInstance: FormatStyle.Symbol) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class YearForWeekOfYearWrapper: NSObject {
        var wrappedInstance: Symbol.YearForWeekOfYear

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var defaultDigits: SymbolWrapper.YearForWeekOfYearWrapper {
          get {
            YearForWeekOfYearWrapper(Symbol.YearForWeekOfYear.defaultDigits)
          }
        }

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.YearForWeekOfYearWrapper {
          get {
            YearForWeekOfYearWrapper(Symbol.YearForWeekOfYear.omitted)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var twoDigits: SymbolWrapper.YearForWeekOfYearWrapper {
          get {
            YearForWeekOfYearWrapper(Symbol.YearForWeekOfYear.twoDigits)
          }
        }

        init(_ wrappedInstance: Symbol.YearForWeekOfYear) {
          self.wrappedInstance = wrappedInstance
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public func padded(_ length: Int) -> SymbolWrapper.YearForWeekOfYearWrapper {
          let result = Symbol.YearForWeekOfYear.padded(length)
          return YearForWeekOfYearWrapper(result)
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class CyclicYearWrapper: NSObject {
        var wrappedInstance: Symbol.CyclicYear

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var abbreviated: SymbolWrapper.CyclicYearWrapper {
          get {
            CyclicYearWrapper(Symbol.CyclicYear.abbreviated)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var wide: SymbolWrapper.CyclicYearWrapper {
          get {
            CyclicYearWrapper(Symbol.CyclicYear.wide)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var narrow: SymbolWrapper.CyclicYearWrapper {
          get {
            CyclicYearWrapper(Symbol.CyclicYear.narrow)
          }
        }

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.CyclicYearWrapper {
          get {
            CyclicYearWrapper(Symbol.CyclicYear.omitted)
          }
        }

        init(_ wrappedInstance: Symbol.CyclicYear) {
          self.wrappedInstance = wrappedInstance
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class VerbatimHourWrapper: NSObject {
        var wrappedInstance: Symbol.VerbatimHour

        init(_ wrappedInstance: Symbol.VerbatimHour) {
          self.wrappedInstance = wrappedInstance
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public func defaultDigits(clock: VerbatimHourWrapper.ClockWrapper, hourCycle: VerbatimHourWrapper.HourCycleWrapper) -> SymbolWrapper.VerbatimHourWrapper {
          let result = Symbol.VerbatimHour.defaultDigits(clock: clock.wrappedInstance, hourCycle: hourCycle.wrappedInstance)
          return VerbatimHourWrapper(result)
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public func twoDigits(clock: VerbatimHourWrapper.ClockWrapper, hourCycle: VerbatimHourWrapper.HourCycleWrapper) -> SymbolWrapper.VerbatimHourWrapper {
          let result = Symbol.VerbatimHour.twoDigits(clock: clock.wrappedInstance, hourCycle: hourCycle.wrappedInstance)
          return VerbatimHourWrapper(result)
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc public class HourCycleWrapper: NSObject {
          var wrappedInstance: VerbatimHour.HourCycle

          @available(macOS, introduced: 12.0)
          @available(watchOS, introduced: 8.0)
          @available(iOS, introduced: 15.0)
          @available(tvOS, introduced: 15.0)
          @objc static public var oneBased: VerbatimHourWrapper.HourCycleWrapper {
            get {
              HourCycleWrapper(VerbatimHour.HourCycle.oneBased)
            }
          }

          @available(macOS, introduced: 12.0)
          @available(watchOS, introduced: 8.0)
          @available(iOS, introduced: 15.0)
          @available(tvOS, introduced: 15.0)
          @objc static public var zeroBased: VerbatimHourWrapper.HourCycleWrapper {
            get {
              HourCycleWrapper(VerbatimHour.HourCycle.zeroBased)
            }
          }

          init(_ wrappedInstance: VerbatimHour.HourCycle) {
            self.wrappedInstance = wrappedInstance
          }

        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc public class ClockWrapper: NSObject {
          var wrappedInstance: VerbatimHour.Clock

          @available(macOS, introduced: 12.0)
          @available(watchOS, introduced: 8.0)
          @available(iOS, introduced: 15.0)
          @available(tvOS, introduced: 15.0)
          @objc static public var twentyFourHour: VerbatimHourWrapper.ClockWrapper {
            get {
              ClockWrapper(VerbatimHour.Clock.twentyFourHour)
            }
          }

          @available(macOS, introduced: 12.0)
          @available(watchOS, introduced: 8.0)
          @available(iOS, introduced: 15.0)
          @available(tvOS, introduced: 15.0)
          @objc static public var twelveHour: VerbatimHourWrapper.ClockWrapper {
            get {
              ClockWrapper(VerbatimHour.Clock.twelveHour)
            }
          }

          init(_ wrappedInstance: VerbatimHour.Clock) {
            self.wrappedInstance = wrappedInstance
          }

        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class SecondFractionWrapper: NSObject {
        var wrappedInstance: Symbol.SecondFraction

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.SecondFractionWrapper {
          get {
            SecondFractionWrapper(Symbol.SecondFraction.omitted)
          }
        }

        init(_ wrappedInstance: Symbol.SecondFraction) {
          self.wrappedInstance = wrappedInstance
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public func fractional(_ val: Int) -> SymbolWrapper.SecondFractionWrapper {
          let result = Symbol.SecondFraction.fractional(val)
          return SecondFractionWrapper(result)
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public func milliseconds(_ val: Int) -> SymbolWrapper.SecondFractionWrapper {
          let result = Symbol.SecondFraction.milliseconds(val)
          return SecondFractionWrapper(result)
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class StandaloneMonthWrapper: NSObject {
        var wrappedInstance: Symbol.StandaloneMonth

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var abbreviated: SymbolWrapper.StandaloneMonthWrapper {
          get {
            StandaloneMonthWrapper(Symbol.StandaloneMonth.abbreviated)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var defaultDigits: SymbolWrapper.StandaloneMonthWrapper {
          get {
            StandaloneMonthWrapper(Symbol.StandaloneMonth.defaultDigits)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var wide: SymbolWrapper.StandaloneMonthWrapper {
          get {
            StandaloneMonthWrapper(Symbol.StandaloneMonth.wide)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var narrow: SymbolWrapper.StandaloneMonthWrapper {
          get {
            StandaloneMonthWrapper(Symbol.StandaloneMonth.narrow)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var twoDigits: SymbolWrapper.StandaloneMonthWrapper {
          get {
            StandaloneMonthWrapper(Symbol.StandaloneMonth.twoDigits)
          }
        }

        init(_ wrappedInstance: Symbol.StandaloneMonth) {
          self.wrappedInstance = wrappedInstance
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class StandaloneQuarterWrapper: NSObject {
        var wrappedInstance: Symbol.StandaloneQuarter

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var abbreviated: SymbolWrapper.StandaloneQuarterWrapper {
          get {
            StandaloneQuarterWrapper(Symbol.StandaloneQuarter.abbreviated)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var wide: SymbolWrapper.StandaloneQuarterWrapper {
          get {
            StandaloneQuarterWrapper(Symbol.StandaloneQuarter.wide)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var narrow: SymbolWrapper.StandaloneQuarterWrapper {
          get {
            StandaloneQuarterWrapper(Symbol.StandaloneQuarter.narrow)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var oneDigit: SymbolWrapper.StandaloneQuarterWrapper {
          get {
            StandaloneQuarterWrapper(Symbol.StandaloneQuarter.oneDigit)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var twoDigits: SymbolWrapper.StandaloneQuarterWrapper {
          get {
            StandaloneQuarterWrapper(Symbol.StandaloneQuarter.twoDigits)
          }
        }

        init(_ wrappedInstance: Symbol.StandaloneQuarter) {
          self.wrappedInstance = wrappedInstance
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class StandaloneWeekdayWrapper: NSObject {
        var wrappedInstance: Symbol.StandaloneWeekday

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var abbreviated: SymbolWrapper.StandaloneWeekdayWrapper {
          get {
            StandaloneWeekdayWrapper(Symbol.StandaloneWeekday.abbreviated)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var wide: SymbolWrapper.StandaloneWeekdayWrapper {
          get {
            StandaloneWeekdayWrapper(Symbol.StandaloneWeekday.wide)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var short: SymbolWrapper.StandaloneWeekdayWrapper {
          get {
            StandaloneWeekdayWrapper(Symbol.StandaloneWeekday.short)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var narrow: SymbolWrapper.StandaloneWeekdayWrapper {
          get {
            StandaloneWeekdayWrapper(Symbol.StandaloneWeekday.narrow)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var oneDigit: SymbolWrapper.StandaloneWeekdayWrapper {
          get {
            StandaloneWeekdayWrapper(Symbol.StandaloneWeekday.oneDigit)
          }
        }

        init(_ wrappedInstance: Symbol.StandaloneWeekday) {
          self.wrappedInstance = wrappedInstance
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class DayWrapper: NSObject {
        var wrappedInstance: Symbol.Day

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var ordinalOfDayInMonth: SymbolWrapper.DayWrapper {
          get {
            DayWrapper(Symbol.Day.ordinalOfDayInMonth)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var defaultDigits: SymbolWrapper.DayWrapper {
          get {
            DayWrapper(Symbol.Day.defaultDigits)
          }
        }

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.DayWrapper {
          get {
            DayWrapper(Symbol.Day.omitted)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var twoDigits: SymbolWrapper.DayWrapper {
          get {
            DayWrapper(Symbol.Day.twoDigits)
          }
        }

        init(_ wrappedInstance: Symbol.Day) {
          self.wrappedInstance = wrappedInstance
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class EraWrapper: NSObject {
        var wrappedInstance: Symbol.Era

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var abbreviated: SymbolWrapper.EraWrapper {
          get {
            EraWrapper(Symbol.Era.abbreviated)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var wide: SymbolWrapper.EraWrapper {
          get {
            EraWrapper(Symbol.Era.wide)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var narrow: SymbolWrapper.EraWrapper {
          get {
            EraWrapper(Symbol.Era.narrow)
          }
        }

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.EraWrapper {
          get {
            EraWrapper(Symbol.Era.omitted)
          }
        }

        init(_ wrappedInstance: Symbol.Era) {
          self.wrappedInstance = wrappedInstance
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class HourWrapper: NSObject {
        var wrappedInstance: Symbol.Hour

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(*)
        @available(tvOS, introduced: 15.0)
        @objc static public var twoDigitsNoAMPM: SymbolWrapper.HourWrapper {
          get {
            HourWrapper(Symbol.Hour.twoDigitsNoAMPM)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(*)
        @available(tvOS, introduced: 15.0)
        @objc static public var defaultDigitsNoAMPM: SymbolWrapper.HourWrapper {
          get {
            HourWrapper(Symbol.Hour.defaultDigitsNoAMPM)
          }
        }

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.HourWrapper {
          get {
            HourWrapper(Symbol.Hour.omitted)
          }
        }

        init(_ wrappedInstance: Symbol.Hour) {
          self.wrappedInstance = wrappedInstance
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public func defaultDigits(amPM: HourWrapper.AMPMStyleWrapper) -> SymbolWrapper.HourWrapper {
          let result = Symbol.Hour.defaultDigits(amPM: amPM.wrappedInstance)
          return HourWrapper(result)
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public func conversationalTwoDigits(amPM: HourWrapper.AMPMStyleWrapper) -> SymbolWrapper.HourWrapper {
          let result = Symbol.Hour.conversationalTwoDigits(amPM: amPM.wrappedInstance)
          return HourWrapper(result)
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public func conversationalDefaultDigits(amPM: HourWrapper.AMPMStyleWrapper) -> SymbolWrapper.HourWrapper {
          let result = Symbol.Hour.conversationalDefaultDigits(amPM: amPM.wrappedInstance)
          return HourWrapper(result)
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public func twoDigits(amPM: HourWrapper.AMPMStyleWrapper) -> SymbolWrapper.HourWrapper {
          let result = Symbol.Hour.twoDigits(amPM: amPM.wrappedInstance)
          return HourWrapper(result)
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc public class AMPMStyleWrapper: NSObject {
          var wrappedInstance: Hour.AMPMStyle

          @available(macOS, introduced: 12.0)
          @available(watchOS, introduced: 8.0)
          @available(iOS, introduced: 15.0)
          @available(tvOS, introduced: 15.0)
          @objc static public var abbreviated: HourWrapper.AMPMStyleWrapper {
            get {
              AMPMStyleWrapper(Hour.AMPMStyle.abbreviated)
            }
          }

          @available(macOS, introduced: 12.0)
          @available(watchOS, introduced: 8.0)
          @available(iOS, introduced: 15.0)
          @available(tvOS, introduced: 15.0)
          @objc static public var wide: HourWrapper.AMPMStyleWrapper {
            get {
              AMPMStyleWrapper(Hour.AMPMStyle.wide)
            }
          }

          @available(macOS, introduced: 12.0)
          @available(watchOS, introduced: 8.0)
          @available(iOS, introduced: 15.0)
          @available(tvOS, introduced: 15.0)
          @objc static public var narrow: HourWrapper.AMPMStyleWrapper {
            get {
              AMPMStyleWrapper(Hour.AMPMStyle.narrow)
            }
          }

          @available(macOS, introduced: 12.0)
          @available(watchOS, introduced: 8.0)
          @available(iOS, introduced: 15.0)
          @available(tvOS, introduced: 15.0)
          @objc static public var omitted: HourWrapper.AMPMStyleWrapper {
            get {
              AMPMStyleWrapper(Hour.AMPMStyle.omitted)
            }
          }

          init(_ wrappedInstance: Hour.AMPMStyle) {
            self.wrappedInstance = wrappedInstance
          }

        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class WeekWrapper: NSObject {
        var wrappedInstance: Symbol.Week

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var weekOfMonth: SymbolWrapper.WeekWrapper {
          get {
            WeekWrapper(Symbol.Week.weekOfMonth)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var defaultDigits: SymbolWrapper.WeekWrapper {
          get {
            WeekWrapper(Symbol.Week.defaultDigits)
          }
        }

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.WeekWrapper {
          get {
            WeekWrapper(Symbol.Week.omitted)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var twoDigits: SymbolWrapper.WeekWrapper {
          get {
            WeekWrapper(Symbol.Week.twoDigits)
          }
        }

        init(_ wrappedInstance: Symbol.Week) {
          self.wrappedInstance = wrappedInstance
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class YearWrapper: NSObject {
        var wrappedInstance: Symbol.Year

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var defaultDigits: SymbolWrapper.YearWrapper {
          get {
            YearWrapper(Symbol.Year.defaultDigits)
          }
        }

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.YearWrapper {
          get {
            YearWrapper(Symbol.Year.omitted)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var twoDigits: SymbolWrapper.YearWrapper {
          get {
            YearWrapper(Symbol.Year.twoDigits)
          }
        }

        init(_ wrappedInstance: Symbol.Year) {
          self.wrappedInstance = wrappedInstance
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public func padded(_ length: Int) -> SymbolWrapper.YearWrapper {
          let result = Symbol.Year.padded(length)
          return YearWrapper(result)
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class MonthWrapper: NSObject {
        var wrappedInstance: Symbol.Month

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var abbreviated: SymbolWrapper.MonthWrapper {
          get {
            MonthWrapper(Symbol.Month.abbreviated)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var defaultDigits: SymbolWrapper.MonthWrapper {
          get {
            MonthWrapper(Symbol.Month.defaultDigits)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var wide: SymbolWrapper.MonthWrapper {
          get {
            MonthWrapper(Symbol.Month.wide)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var narrow: SymbolWrapper.MonthWrapper {
          get {
            MonthWrapper(Symbol.Month.narrow)
          }
        }

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.MonthWrapper {
          get {
            MonthWrapper(Symbol.Month.omitted)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var twoDigits: SymbolWrapper.MonthWrapper {
          get {
            MonthWrapper(Symbol.Month.twoDigits)
          }
        }

        init(_ wrappedInstance: Symbol.Month) {
          self.wrappedInstance = wrappedInstance
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class MinuteWrapper: NSObject {
        var wrappedInstance: Symbol.Minute

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var defaultDigits: SymbolWrapper.MinuteWrapper {
          get {
            MinuteWrapper(Symbol.Minute.defaultDigits)
          }
        }

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.MinuteWrapper {
          get {
            MinuteWrapper(Symbol.Minute.omitted)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var twoDigits: SymbolWrapper.MinuteWrapper {
          get {
            MinuteWrapper(Symbol.Minute.twoDigits)
          }
        }

        init(_ wrappedInstance: Symbol.Minute) {
          self.wrappedInstance = wrappedInstance
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class SecondWrapper: NSObject {
        var wrappedInstance: Symbol.Second

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var defaultDigits: SymbolWrapper.SecondWrapper {
          get {
            SecondWrapper(Symbol.Second.defaultDigits)
          }
        }

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.SecondWrapper {
          get {
            SecondWrapper(Symbol.Second.omitted)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var twoDigits: SymbolWrapper.SecondWrapper {
          get {
            SecondWrapper(Symbol.Second.twoDigits)
          }
        }

        init(_ wrappedInstance: Symbol.Second) {
          self.wrappedInstance = wrappedInstance
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class QuarterWrapper: NSObject {
        var wrappedInstance: Symbol.Quarter

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var abbreviated: SymbolWrapper.QuarterWrapper {
          get {
            QuarterWrapper(Symbol.Quarter.abbreviated)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var wide: SymbolWrapper.QuarterWrapper {
          get {
            QuarterWrapper(Symbol.Quarter.wide)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var narrow: SymbolWrapper.QuarterWrapper {
          get {
            QuarterWrapper(Symbol.Quarter.narrow)
          }
        }

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.QuarterWrapper {
          get {
            QuarterWrapper(Symbol.Quarter.omitted)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var oneDigit: SymbolWrapper.QuarterWrapper {
          get {
            QuarterWrapper(Symbol.Quarter.oneDigit)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var twoDigits: SymbolWrapper.QuarterWrapper {
          get {
            QuarterWrapper(Symbol.Quarter.twoDigits)
          }
        }

        init(_ wrappedInstance: Symbol.Quarter) {
          self.wrappedInstance = wrappedInstance
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class WeekdayWrapper: NSObject {
        var wrappedInstance: Symbol.Weekday

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var abbreviated: SymbolWrapper.WeekdayWrapper {
          get {
            WeekdayWrapper(Symbol.Weekday.abbreviated)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var wide: SymbolWrapper.WeekdayWrapper {
          get {
            WeekdayWrapper(Symbol.Weekday.wide)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var short: SymbolWrapper.WeekdayWrapper {
          get {
            WeekdayWrapper(Symbol.Weekday.short)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var narrow: SymbolWrapper.WeekdayWrapper {
          get {
            WeekdayWrapper(Symbol.Weekday.narrow)
          }
        }

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.WeekdayWrapper {
          get {
            WeekdayWrapper(Symbol.Weekday.omitted)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var oneDigit: SymbolWrapper.WeekdayWrapper {
          get {
            WeekdayWrapper(Symbol.Weekday.oneDigit)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var twoDigits: SymbolWrapper.WeekdayWrapper {
          get {
            WeekdayWrapper(Symbol.Weekday.twoDigits)
          }
        }

        init(_ wrappedInstance: Symbol.Weekday) {
          self.wrappedInstance = wrappedInstance
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class TimeZoneWrapper: NSObject {
        var wrappedInstance: Symbol.TimeZone

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var genericLocation: SymbolWrapper.TimeZoneWrapper {
          get {
            TimeZoneWrapper(Symbol.TimeZone.genericLocation)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var exemplarLocation: SymbolWrapper.TimeZoneWrapper {
          get {
            TimeZoneWrapper(Symbol.TimeZone.exemplarLocation)
          }
        }

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.TimeZoneWrapper {
          get {
            TimeZoneWrapper(Symbol.TimeZone.omitted)
          }
        }

        init(_ wrappedInstance: Symbol.TimeZone) {
          self.wrappedInstance = wrappedInstance
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class DayOfYearWrapper: NSObject {
        var wrappedInstance: Symbol.DayOfYear

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var threeDigits: SymbolWrapper.DayOfYearWrapper {
          get {
            DayOfYearWrapper(Symbol.DayOfYear.threeDigits)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var defaultDigits: SymbolWrapper.DayOfYearWrapper {
          get {
            DayOfYearWrapper(Symbol.DayOfYear.defaultDigits)
          }
        }

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.DayOfYearWrapper {
          get {
            DayOfYearWrapper(Symbol.DayOfYear.omitted)
          }
        }

        @available(macOS, introduced: 12.0)
        @available(watchOS, introduced: 8.0)
        @available(iOS, introduced: 15.0)
        @available(tvOS, introduced: 15.0)
        @objc static public var twoDigits: SymbolWrapper.DayOfYearWrapper {
          get {
            DayOfYearWrapper(Symbol.DayOfYear.twoDigits)
          }
        }

        init(_ wrappedInstance: Symbol.DayOfYear) {
          self.wrappedInstance = wrappedInstance
        }

      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public class DayPeriodWrapper: NSObject {
        var wrappedInstance: Symbol.DayPeriod

        @available(macOS, introduced: 15)
        @available(watchOS, introduced: 11)
        @available(iOS, introduced: 18)
        @available(tvOS, introduced: 18)
        @objc static public var omitted: SymbolWrapper.DayPeriodWrapper {
          get {
            DayPeriodWrapper(Symbol.DayPeriod.omitted)
          }
        }

        init(_ wrappedInstance: Symbol.DayPeriod) {
          self.wrappedInstance = wrappedInstance
        }

      }

    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class FormatStringWrapper: NSObject {
    var wrappedInstance: Date.FormatString

    init(_ wrappedInstance: Date.FormatString) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc init(stringLiteral value: String) {
      wrappedInstance = Date.FormatString(stringLiteral: value)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc init(stringInterpolation: FormatStringWrapper.StringInterpolationWrapper) {
      wrappedInstance = Date.FormatString(stringInterpolation: stringInterpolation.wrappedInstance)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class StringInterpolationWrapper: NSObject {
      var wrappedInstance: FormatString.StringInterpolation

      init(_ wrappedInstance: FormatString.StringInterpolation) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc init(literalCapacity: Int, interpolationCount: Int) {
        wrappedInstance = FormatString.StringInterpolation(literalCapacity: literalCapacity, interpolationCount: interpolationCount)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(cyclicYear: SymbolWrapper.CyclicYearWrapper) {
        return wrappedInstance.appendInterpolation(cyclicYear: cyclicYear.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(secondFraction: SymbolWrapper.SecondFractionWrapper) {
        return wrappedInstance.appendInterpolation(secondFraction: secondFraction.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(standaloneMonth: SymbolWrapper.StandaloneMonthWrapper) {
        return wrappedInstance.appendInterpolation(standaloneMonth: standaloneMonth.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(standaloneQuarter: SymbolWrapper.StandaloneQuarterWrapper) {
        return wrappedInstance.appendInterpolation(standaloneQuarter: standaloneQuarter.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(standaloneWeekday: SymbolWrapper.StandaloneWeekdayWrapper) {
        return wrappedInstance.appendInterpolation(standaloneWeekday: standaloneWeekday.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(yearForWeekOfYear: SymbolWrapper.YearForWeekOfYearWrapper) {
        return wrappedInstance.appendInterpolation(yearForWeekOfYear: yearForWeekOfYear.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(day: SymbolWrapper.DayWrapper) {
        return wrappedInstance.appendInterpolation(day: day.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(era: SymbolWrapper.EraWrapper) {
        return wrappedInstance.appendInterpolation(era: era.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(hour: SymbolWrapper.VerbatimHourWrapper) {
        return wrappedInstance.appendInterpolation(hour: hour.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(week: SymbolWrapper.WeekWrapper) {
        return wrappedInstance.appendInterpolation(week: week.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(year: SymbolWrapper.YearWrapper) {
        return wrappedInstance.appendInterpolation(year: year.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(month: SymbolWrapper.MonthWrapper) {
        return wrappedInstance.appendInterpolation(month: month.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(minute: SymbolWrapper.MinuteWrapper) {
        return wrappedInstance.appendInterpolation(minute: minute.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(second: SymbolWrapper.SecondWrapper) {
        return wrappedInstance.appendInterpolation(second: second.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(quarter: SymbolWrapper.QuarterWrapper) {
        return wrappedInstance.appendInterpolation(quarter: quarter.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(weekday: SymbolWrapper.WeekdayWrapper) {
        return wrappedInstance.appendInterpolation(weekday: weekday.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(timeZone: SymbolWrapper.TimeZoneWrapper) {
        return wrappedInstance.appendInterpolation(timeZone: timeZone.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(dayOfYear: SymbolWrapper.DayOfYearWrapper) {
        return wrappedInstance.appendInterpolation(dayOfYear: dayOfYear.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendInterpolation(dayPeriod: SymbolWrapper.DayPeriodWrapper) {
        return wrappedInstance.appendInterpolation(dayPeriod: dayPeriod.wrappedInstance)
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc public func appendLiteral(_ literal: String) {
        return wrappedInstance.appendLiteral(literal)
      }

    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class ParseStrategyWrapper: NSObject {
    var wrappedInstance: Date.ParseStrategy

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var twoDigitStartDate: DateWrapper {
      get {
        DateWrapper(wrappedInstance.twoDigitStartDate)
      }
      set {
        wrappedInstance.twoDigitStartDate = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var format: String {
      get {
        wrappedInstance.format
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper? {
      get {
        wrappedInstance.locale == nil ? nil : LocaleWrapper(wrappedInstance.locale!)
      }
      set {
        wrappedInstance.locale = newValue?.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var calendar: CalendarWrapper {
      get {
        CalendarWrapper(wrappedInstance.calendar)
      }
      set {
        wrappedInstance.calendar = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var timeZone: TimeZoneWrapper {
      get {
        TimeZoneWrapper(wrappedInstance.timeZone)
      }
      set {
        wrappedInstance.timeZone = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var isLenient: Bool {
      get {
        wrappedInstance.isLenient
      }
      set {
        wrappedInstance.isLenient = newValue
      }
    }

    init(_ wrappedInstance: Date.ParseStrategy) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func parse(_ value: String) throws -> DateWrapper {
      let result = try wrappedInstance.parse(value)
      return DateWrapper(result)
    }

  }

  @available(macOS, introduced: 12, deprecated: 15)
  @available(watchOS, introduced: 8, deprecated: 11)
  @available(iOS, introduced: 15, deprecated: 18)
  @available(tvOS, introduced: 15, deprecated: 18)
  @objc public class AttributedStyleWrapper: NSObject {
    var wrappedInstance: Date.AttributedStyle

    init(_ wrappedInstance: Date.AttributedStyle) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12, deprecated: 15)
    @available(watchOS, introduced: 8, deprecated: 11)
    @available(iOS, introduced: 15, deprecated: 18)
    @available(tvOS, introduced: 15, deprecated: 18)
    @objc public func format(_ value: DateWrapper) -> AttributedStringWrapper {
      let result = wrappedInstance.format(value.wrappedInstance)
      return AttributedStringWrapper(result)
    }

    @available(macOS, introduced: 12, deprecated: 15)
    @available(watchOS, introduced: 8, deprecated: 11)
    @available(iOS, introduced: 15, deprecated: 18)
    @available(tvOS, introduced: 15, deprecated: 18)
    @objc public func locale(_ locale: LocaleWrapper) -> DateWrapper.AttributedStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return AttributedStyleWrapper(result)
    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class ISO8601FormatStyleWrapper: NSObject {
    var wrappedInstance: Date.ISO8601FormatStyle

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var iso8601: DateWrapper.ISO8601FormatStyleWrapper {
      get {
        ISO8601FormatStyleWrapper(Date.ISO8601FormatStyle.iso8601)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var iso8601: DateWrapper.ISO8601FormatStyleWrapper {
      get {
        ISO8601FormatStyleWrapper(Date.ISO8601FormatStyle.iso8601)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var iso8601: DateWrapper.ISO8601FormatStyleWrapper {
      get {
        ISO8601FormatStyleWrapper(Date.ISO8601FormatStyle.iso8601)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var parseStrategy: DateWrapper.ISO8601FormatStyleWrapper {
      get {
        ISO8601FormatStyleWrapper(wrappedInstance.parseStrategy)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var includingFractionalSeconds: Bool {
      get {
        wrappedInstance.includingFractionalSeconds
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var timeZone: TimeZoneWrapper {
      get {
        TimeZoneWrapper(wrappedInstance.timeZone)
      }
      set {
        wrappedInstance.timeZone = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 13.0)
    @available(watchOS, introduced: 9.0)
    @available(iOS, introduced: 16.0)
    @available(tvOS, introduced: 16.0)
    @objc static public var iso8601: DateWrapper.ISO8601FormatStyleWrapper {
      get {
        ISO8601FormatStyleWrapper(Date.ISO8601FormatStyle.iso8601)
      }
    }

    init(_ wrappedInstance: Date.ISO8601FormatStyle) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func weekOfYear() -> DateWrapper.ISO8601FormatStyleWrapper {
      let result = wrappedInstance.weekOfYear()
      return ISO8601FormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func day() -> DateWrapper.ISO8601FormatStyleWrapper {
      let result = wrappedInstance.day()
      return ISO8601FormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func time(includingFractionalSeconds: Bool) -> DateWrapper.ISO8601FormatStyleWrapper {
      let result = wrappedInstance.time(includingFractionalSeconds: includingFractionalSeconds)
      return ISO8601FormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func year() -> DateWrapper.ISO8601FormatStyleWrapper {
      let result = wrappedInstance.year()
      return ISO8601FormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func month() -> DateWrapper.ISO8601FormatStyleWrapper {
      let result = wrappedInstance.month()
      return ISO8601FormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func parse(_ value: String) throws -> DateWrapper {
      let result = try wrappedInstance.parse(value)
      return DateWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func format(_ value: DateWrapper) -> String {
      return wrappedInstance.format(value.wrappedInstance)
    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class IntervalFormatStyleWrapper: NSObject {
    var wrappedInstance: Date.IntervalFormatStyle

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var interval: DateWrapper.IntervalFormatStyleWrapper {
      get {
        IntervalFormatStyleWrapper(Date.IntervalFormatStyle.interval)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper {
      get {
        LocaleWrapper(wrappedInstance.locale)
      }
      set {
        wrappedInstance.locale = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var calendar: CalendarWrapper {
      get {
        CalendarWrapper(wrappedInstance.calendar)
      }
      set {
        wrappedInstance.calendar = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var timeZone: TimeZoneWrapper {
      get {
        TimeZoneWrapper(wrappedInstance.timeZone)
      }
      set {
        wrappedInstance.timeZone = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: Date.IntervalFormatStyle) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func day() -> DateWrapper.IntervalFormatStyleWrapper {
      let result = wrappedInstance.day()
      return IntervalFormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func year() -> DateWrapper.IntervalFormatStyleWrapper {
      let result = wrappedInstance.year()
      return IntervalFormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> DateWrapper.IntervalFormatStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return IntervalFormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func minute() -> DateWrapper.IntervalFormatStyleWrapper {
      let result = wrappedInstance.minute()
      return IntervalFormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func second() -> DateWrapper.IntervalFormatStyleWrapper {
      let result = wrappedInstance.second()
      return IntervalFormatStyleWrapper(result)
    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class RelativeFormatStyleWrapper: NSObject {
    var wrappedInstance: Date.RelativeFormatStyle

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var unitsStyle: RelativeFormatStyleWrapper.UnitsStyleWrapper {
      get {
        UnitsStyleWrapper(wrappedInstance.unitsStyle)
      }
      set {
        wrappedInstance.unitsStyle = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var presentation: RelativeFormatStyleWrapper.PresentationWrapper {
      get {
        PresentationWrapper(wrappedInstance.presentation)
      }
      set {
        wrappedInstance.presentation = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var capitalizationContext: FormatStyleCapitalizationContextWrapper {
      get {
        FormatStyleCapitalizationContextWrapper(wrappedInstance.capitalizationContext)
      }
      set {
        wrappedInstance.capitalizationContext = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper {
      get {
        LocaleWrapper(wrappedInstance.locale)
      }
      set {
        wrappedInstance.locale = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var calendar: CalendarWrapper {
      get {
        CalendarWrapper(wrappedInstance.calendar)
      }
      set {
        wrappedInstance.calendar = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: Date.RelativeFormatStyle) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func format(_ destDate: DateWrapper) -> String {
      return wrappedInstance.format(destDate.wrappedInstance)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> DateWrapper.RelativeFormatStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return RelativeFormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class UnitsStyleWrapper: NSObject {
      var wrappedInstance: RelativeFormatStyle.UnitsStyle

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var abbreviated: RelativeFormatStyleWrapper.UnitsStyleWrapper {
        get {
          UnitsStyleWrapper(RelativeFormatStyle.UnitsStyle.abbreviated)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var wide: RelativeFormatStyleWrapper.UnitsStyleWrapper {
        get {
          UnitsStyleWrapper(RelativeFormatStyle.UnitsStyle.wide)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var narrow: RelativeFormatStyleWrapper.UnitsStyleWrapper {
        get {
          UnitsStyleWrapper(RelativeFormatStyle.UnitsStyle.narrow)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var spellOut: RelativeFormatStyleWrapper.UnitsStyleWrapper {
        get {
          UnitsStyleWrapper(RelativeFormatStyle.UnitsStyle.spellOut)
        }
      }

      init(_ wrappedInstance: RelativeFormatStyle.UnitsStyle) {
        self.wrappedInstance = wrappedInstance
      }

    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class PresentationWrapper: NSObject {
      var wrappedInstance: RelativeFormatStyle.Presentation

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var named: RelativeFormatStyleWrapper.PresentationWrapper {
        get {
          PresentationWrapper(RelativeFormatStyle.Presentation.named)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var numeric: RelativeFormatStyleWrapper.PresentationWrapper {
        get {
          PresentationWrapper(RelativeFormatStyle.Presentation.numeric)
        }
      }

      init(_ wrappedInstance: RelativeFormatStyle.Presentation) {
        self.wrappedInstance = wrappedInstance
      }

    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class VerbatimFormatStyleWrapper: NSObject {
    var wrappedInstance: Date.VerbatimFormatStyle

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public var attributedStyle: VerbatimFormatStyleWrapper.AttributedWrapper {
      get {
        AttributedWrapper(wrappedInstance.attributedStyle)
      }
    }

    @available(macOS, introduced: 12, deprecated: 15)
    @available(watchOS, introduced: 8, deprecated: 11)
    @available(iOS, introduced: 15, deprecated: 18)
    @available(tvOS, introduced: 15, deprecated: 18)
    @objc public var attributed: DateWrapper.AttributedStyleWrapper {
      get {
        AttributedStyleWrapper(wrappedInstance.attributed)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var parseStrategy: DateWrapper.ParseStrategyWrapper {
      get {
        ParseStrategyWrapper(wrappedInstance.parseStrategy)
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper? {
      get {
        wrappedInstance.locale == nil ? nil : LocaleWrapper(wrappedInstance.locale!)
      }
      set {
        wrappedInstance.locale = newValue?.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var calendar: CalendarWrapper {
      get {
        CalendarWrapper(wrappedInstance.calendar)
      }
      set {
        wrappedInstance.calendar = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var timeZone: TimeZoneWrapper {
      get {
        TimeZoneWrapper(wrappedInstance.timeZone)
      }
      set {
        wrappedInstance.timeZone = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: Date.VerbatimFormatStyle) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public func discreteInput(after input: DateWrapper) -> DateWrapper? {
      let result = wrappedInstance.discreteInput(after: input.wrappedInstance)
      return result == nil ? nil : DateWrapper(result!)
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public func discreteInput(before input: DateWrapper) -> DateWrapper? {
      let result = wrappedInstance.discreteInput(before: input.wrappedInstance)
      return result == nil ? nil : DateWrapper(result!)
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public func input(after input: DateWrapper) -> DateWrapper? {
      let result = wrappedInstance.input(after: input.wrappedInstance)
      return result == nil ? nil : DateWrapper(result!)
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public func input(before input: DateWrapper) -> DateWrapper? {
      let result = wrappedInstance.input(before: input.wrappedInstance)
      return result == nil ? nil : DateWrapper(result!)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func format(_ value: DateWrapper) -> String {
      return wrappedInstance.format(value.wrappedInstance)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> DateWrapper.VerbatimFormatStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return VerbatimFormatStyleWrapper(result)
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public class AttributedWrapper: NSObject {
      var wrappedInstance: VerbatimFormatStyle.Attributed

      init(_ wrappedInstance: VerbatimFormatStyle.Attributed) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public func discreteInput(after input: DateWrapper) -> DateWrapper? {
        let result = wrappedInstance.discreteInput(after: input.wrappedInstance)
        return result == nil ? nil : DateWrapper(result!)
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public func discreteInput(before input: DateWrapper) -> DateWrapper? {
        let result = wrappedInstance.discreteInput(before: input.wrappedInstance)
        return result == nil ? nil : DateWrapper(result!)
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public func input(after input: DateWrapper) -> DateWrapper? {
        let result = wrappedInstance.input(after: input.wrappedInstance)
        return result == nil ? nil : DateWrapper(result!)
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public func input(before input: DateWrapper) -> DateWrapper? {
        let result = wrappedInstance.input(before: input.wrappedInstance)
        return result == nil ? nil : DateWrapper(result!)
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public func format(_ value: DateWrapper) -> AttributedStringWrapper {
        let result = wrappedInstance.format(value.wrappedInstance)
        return AttributedStringWrapper(result)
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public func locale(_ locale: LocaleWrapper) -> VerbatimFormatStyleWrapper.AttributedWrapper {
        let result = wrappedInstance.locale(locale.wrappedInstance)
        return AttributedWrapper(result)
      }

    }

  }

  @available(macOS, introduced: 12.0)
  @available(watchOS, introduced: 8.0)
  @available(iOS, introduced: 15.0)
  @available(tvOS, introduced: 15.0)
  @objc public class ComponentsFormatStyleWrapper: NSObject {
    var wrappedInstance: Date.ComponentsFormatStyle

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc static public var timeDuration: DateWrapper.ComponentsFormatStyleWrapper {
      get {
        ComponentsFormatStyleWrapper(Date.ComponentsFormatStyle.timeDuration)
      }
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public var isPositive: Bool {
      get {
        wrappedInstance.isPositive
      }
      set {
        wrappedInstance.isPositive = newValue
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var style: ComponentsFormatStyleWrapper.StyleWrapper {
      get {
        StyleWrapper(wrappedInstance.style)
      }
      set {
        wrappedInstance.style = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var locale: LocaleWrapper {
      get {
        LocaleWrapper(wrappedInstance.locale)
      }
      set {
        wrappedInstance.locale = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public var calendar: CalendarWrapper {
      get {
        CalendarWrapper(wrappedInstance.calendar)
      }
      set {
        wrappedInstance.calendar = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: Date.ComponentsFormatStyle) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func locale(_ locale: LocaleWrapper) -> DateWrapper.ComponentsFormatStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return ComponentsFormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public func calendar(_ calendar: CalendarWrapper) -> DateWrapper.ComponentsFormatStyleWrapper {
      let result = wrappedInstance.calendar(calendar.wrappedInstance)
      return ComponentsFormatStyleWrapper(result)
    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class StyleWrapper: NSObject {
      var wrappedInstance: ComponentsFormatStyle.Style

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var abbreviated: ComponentsFormatStyleWrapper.StyleWrapper {
        get {
          StyleWrapper(ComponentsFormatStyle.Style.abbreviated)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var condensedAbbreviated: ComponentsFormatStyleWrapper.StyleWrapper {
        get {
          StyleWrapper(ComponentsFormatStyle.Style.condensedAbbreviated)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var wide: ComponentsFormatStyleWrapper.StyleWrapper {
        get {
          StyleWrapper(ComponentsFormatStyle.Style.wide)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var narrow: ComponentsFormatStyleWrapper.StyleWrapper {
        get {
          StyleWrapper(ComponentsFormatStyle.Style.narrow)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var spellOut: ComponentsFormatStyleWrapper.StyleWrapper {
        get {
          StyleWrapper(ComponentsFormatStyle.Style.spellOut)
        }
      }

      init(_ wrappedInstance: ComponentsFormatStyle.Style) {
        self.wrappedInstance = wrappedInstance
      }

    }

    @available(macOS, introduced: 12.0)
    @available(watchOS, introduced: 8.0)
    @available(iOS, introduced: 15.0)
    @available(tvOS, introduced: 15.0)
    @objc public class FieldWrapper: NSObject {
      var wrappedInstance: ComponentsFormatStyle.Field

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var day: ComponentsFormatStyleWrapper.FieldWrapper {
        get {
          FieldWrapper(ComponentsFormatStyle.Field.day)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var hour: ComponentsFormatStyleWrapper.FieldWrapper {
        get {
          FieldWrapper(ComponentsFormatStyle.Field.hour)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var week: ComponentsFormatStyleWrapper.FieldWrapper {
        get {
          FieldWrapper(ComponentsFormatStyle.Field.week)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var year: ComponentsFormatStyleWrapper.FieldWrapper {
        get {
          FieldWrapper(ComponentsFormatStyle.Field.year)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var month: ComponentsFormatStyleWrapper.FieldWrapper {
        get {
          FieldWrapper(ComponentsFormatStyle.Field.month)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var minute: ComponentsFormatStyleWrapper.FieldWrapper {
        get {
          FieldWrapper(ComponentsFormatStyle.Field.minute)
        }
      }

      @available(macOS, introduced: 12.0)
      @available(watchOS, introduced: 8.0)
      @available(iOS, introduced: 15.0)
      @available(tvOS, introduced: 15.0)
      @objc static public var second: ComponentsFormatStyleWrapper.FieldWrapper {
        get {
          FieldWrapper(ComponentsFormatStyle.Field.second)
        }
      }

      init(_ wrappedInstance: ComponentsFormatStyle.Field) {
        self.wrappedInstance = wrappedInstance
      }

    }

  }

  @available(macOS, introduced: 15)
  @available(watchOS, introduced: 11)
  @available(iOS, introduced: 18)
  @available(tvOS, introduced: 18)
  @objc public class AnchoredRelativeFormatStyleWrapper: NSObject {
    var wrappedInstance: Date.AnchoredRelativeFormatStyle

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public var unitsStyle: RelativeFormatStyleWrapper.UnitsStyleWrapper {
      get {
        UnitsStyleWrapper(wrappedInstance.unitsStyle)
      }
      set {
        wrappedInstance.unitsStyle = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public var presentation: RelativeFormatStyleWrapper.PresentationWrapper {
      get {
        PresentationWrapper(wrappedInstance.presentation)
      }
      set {
        wrappedInstance.presentation = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public var capitalizationContext: FormatStyleCapitalizationContextWrapper {
      get {
        FormatStyleCapitalizationContextWrapper(wrappedInstance.capitalizationContext)
      }
      set {
        wrappedInstance.capitalizationContext = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public var anchor: DateWrapper {
      get {
        DateWrapper(wrappedInstance.anchor)
      }
      set {
        wrappedInstance.anchor = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public var locale: LocaleWrapper {
      get {
        LocaleWrapper(wrappedInstance.locale)
      }
      set {
        wrappedInstance.locale = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public var calendar: CalendarWrapper {
      get {
        CalendarWrapper(wrappedInstance.calendar)
      }
      set {
        wrappedInstance.calendar = newValue.wrappedInstance
      }
    }

    init(_ wrappedInstance: Date.AnchoredRelativeFormatStyle) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public func discreteInput(after input: DateWrapper) -> DateWrapper? {
      let result = wrappedInstance.discreteInput(after: input.wrappedInstance)
      return result == nil ? nil : DateWrapper(result!)
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public func discreteInput(before input: DateWrapper) -> DateWrapper? {
      let result = wrappedInstance.discreteInput(before: input.wrappedInstance)
      return result == nil ? nil : DateWrapper(result!)
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public func input(after input: DateWrapper) -> DateWrapper? {
      let result = wrappedInstance.input(after: input.wrappedInstance)
      return result == nil ? nil : DateWrapper(result!)
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public func input(before input: DateWrapper) -> DateWrapper? {
      let result = wrappedInstance.input(before: input.wrappedInstance)
      return result == nil ? nil : DateWrapper(result!)
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public func format(_ input: DateWrapper) -> String {
      return wrappedInstance.format(input.wrappedInstance)
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public func locale(_ locale: LocaleWrapper) -> DateWrapper.AnchoredRelativeFormatStyleWrapper {
      let result = wrappedInstance.locale(locale.wrappedInstance)
      return AnchoredRelativeFormatStyleWrapper(result)
    }

  }

}

@available(macOS, introduced: 10.8)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 6.0)
@available(tvOS, introduced: 9.0)
@objc public class UUIDWrapper: NSObject {
  var wrappedInstance: UUID

  @available(macOS, introduced: 10.8)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 6.0)
  @available(tvOS, introduced: 9.0)
  @objc public var uuidString: String {
    get {
      wrappedInstance.uuidString
    }
  }

  @available(macOS, introduced: 10.8)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 6.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.8)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 6.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  init(_ wrappedInstance: UUID) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.8)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 6.0)
  @available(tvOS, introduced: 9.0)
  @objc init?(uuidString string: String) {
    if let instance = UUID(uuidString: string) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.8)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 6.0)
  @available(tvOS, introduced: 9.0)
  @objc override init() {
    wrappedInstance = UUID()
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class LocaleWrapper: NSObject {
  var wrappedInstance: Locale

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var identifier: String {
    get {
      wrappedInstance.identifier
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 13)
  @available(watchOS, introduced: 2.0, deprecated: 9)
  @available(iOS, introduced: 8.0, deprecated: 16)
  @available(tvOS, introduced: 9.0, deprecated: 16)
  @objc public var regionCode: String? {
    get {
      wrappedInstance.regionCode
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 13)
  @available(watchOS, introduced: 2.0, deprecated: 9)
  @available(iOS, introduced: 8.0, deprecated: 16)
  @available(tvOS, introduced: 9.0, deprecated: 16)
  @objc public var scriptCode: String? {
    get {
      wrappedInstance.scriptCode
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var subdivision: LocaleWrapper.SubdivisionWrapper? {
    get {
      wrappedInstance.subdivision == nil ? nil : SubdivisionWrapper(wrappedInstance.subdivision!)
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 13)
  @available(watchOS, introduced: 2.0, deprecated: 9)
  @available(iOS, introduced: 8.0, deprecated: 16)
  @available(tvOS, introduced: 9.0, deprecated: 16)
  @objc public var variantCode: String? {
    get {
      wrappedInstance.variantCode
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 13)
  @available(watchOS, introduced: 2.0, deprecated: 9)
  @available(iOS, introduced: 8.0, deprecated: 16)
  @available(tvOS, introduced: 9.0, deprecated: 16)
  @objc public var currencyCode: String? {
    get {
      wrappedInstance.currencyCode
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 13)
  @available(watchOS, introduced: 2.0, deprecated: 9)
  @available(iOS, introduced: 8.0, deprecated: 16)
  @available(tvOS, introduced: 9.0, deprecated: 16)
  @objc public var languageCode: String? {
    get {
      wrappedInstance.languageCode
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var currencySymbol: String? {
    get {
      wrappedInstance.currencySymbol
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var numberingSystem: LocaleWrapper.NumberingSystemWrapper {
    get {
      NumberingSystemWrapper(wrappedInstance.numberingSystem)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var decimalSeparator: String? {
    get {
      wrappedInstance.decimalSeparator
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 13)
  @available(watchOS, introduced: 2.0, deprecated: 9)
  @available(iOS, introduced: 8.0, deprecated: 16)
  @available(tvOS, introduced: 9.0, deprecated: 16)
  @objc public var usesMetricSystem: Bool {
    get {
      wrappedInstance.usesMetricSystem
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var groupingSeparator: String? {
    get {
      wrappedInstance.groupingSeparator
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var measurementSystem: LocaleWrapper.MeasurementSystemWrapper {
    get {
      MeasurementSystemWrapper(wrappedInstance.measurementSystem)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var collatorIdentifier: String? {
    get {
      wrappedInstance.collatorIdentifier
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var autoupdatingCurrent: LocaleWrapper {
    get {
      LocaleWrapper(Locale.autoupdatingCurrent)
    }
  }

  @available(macOS, introduced: 10.10, deprecated: 13)
  @available(watchOS, introduced: 2.0, deprecated: 9)
  @available(iOS, introduced: 8.0, deprecated: 16)
  @available(tvOS, introduced: 9.0, deprecated: 16)
  @objc public var collationIdentifier: String? {
    get {
      wrappedInstance.collationIdentifier
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var exemplarCharacterSet: CharacterSetWrapper? {
    get {
      wrappedInstance.exemplarCharacterSet == nil ? nil : CharacterSetWrapper(wrappedInstance.exemplarCharacterSet!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var quotationEndDelimiter: String? {
    get {
      wrappedInstance.quotationEndDelimiter
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var quotationBeginDelimiter: String? {
    get {
      wrappedInstance.quotationBeginDelimiter
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var alternateQuotationEndDelimiter: String? {
    get {
      wrappedInstance.alternateQuotationEndDelimiter
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var alternateQuotationBeginDelimiter: String? {
    get {
      wrappedInstance.alternateQuotationBeginDelimiter
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var region: LocaleWrapper.RegionWrapper? {
    get {
      wrappedInstance.region == nil ? nil : RegionWrapper(wrappedInstance.region!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var current: LocaleWrapper {
    get {
      LocaleWrapper(Locale.current)
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var variant: LocaleWrapper.VariantWrapper? {
    get {
      wrappedInstance.variant == nil ? nil : VariantWrapper(wrappedInstance.variant!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var calendar: CalendarWrapper {
    get {
      CalendarWrapper(wrappedInstance.calendar)
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var currency: LocaleWrapper.CurrencyWrapper? {
    get {
      wrappedInstance.currency == nil ? nil : CurrencyWrapper(wrappedInstance.currency!)
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var language: LocaleWrapper.LanguageWrapper {
    get {
      LanguageWrapper(wrappedInstance.language)
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var timeZone: TimeZoneWrapper? {
    get {
      wrappedInstance.timeZone == nil ? nil : TimeZoneWrapper(wrappedInstance.timeZone!)
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public var collation: LocaleWrapper.CollationWrapper {
    get {
      CollationWrapper(wrappedInstance.collation)
    }
  }

  init(_ wrappedInstance: Locale) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc init(components: LocaleWrapper.ComponentsWrapper) {
    wrappedInstance = Locale(components: components.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(identifier: String) {
    wrappedInstance = Locale(identifier: identifier)
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc init(languageComponents: LanguageWrapper.ComponentsWrapper1) {
    wrappedInstance = Locale(languageComponents: languageComponents.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public func windowsLocaleCode(fromIdentifier identifier: String) -> Int? {
    return Locale.windowsLocaleCode(fromIdentifier: identifier)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public func identifier(fromWindowsLocaleCode code: Int) -> String? {
    return Locale.identifier(fromWindowsLocaleCode: code)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func localizedString(forIdentifier identifier: String) -> String? {
    return wrappedInstance.localizedString(forIdentifier: identifier)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func localizedString(forRegionCode regionCode: String) -> String? {
    return wrappedInstance.localizedString(forRegionCode: regionCode)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func localizedString(forScriptCode scriptCode: String) -> String? {
    return wrappedInstance.localizedString(forScriptCode: scriptCode)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func localizedString(forVariantCode variantCode: String) -> String? {
    return wrappedInstance.localizedString(forVariantCode: variantCode)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func localizedString(forCurrencyCode currencyCode: String) -> String? {
    return wrappedInstance.localizedString(forCurrencyCode: currencyCode)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func localizedString(forLanguageCode languageCode: String) -> String? {
    return wrappedInstance.localizedString(forLanguageCode: languageCode)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func localizedString(forCollatorIdentifier collatorIdentifier: String) -> String? {
    return wrappedInstance.localizedString(forCollatorIdentifier: collatorIdentifier)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func localizedString(forCollationIdentifier collationIdentifier: String) -> String? {
    return wrappedInstance.localizedString(forCollationIdentifier: collationIdentifier)
  }

  @available(macOS, introduced: 10.10, deprecated: 13)
  @available(watchOS, introduced: 2.0, deprecated: 9)
  @available(iOS, introduced: 8.0, deprecated: 16)
  @available(tvOS, introduced: 9.0, deprecated: 16)
  @objc static public func canonicalIdentifier(from string: String) -> String {
    return Locale.canonicalIdentifier(from: string)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public func canonicalLanguageIdentifier(from string: String) -> String {
    return Locale.canonicalLanguageIdentifier(from: string)
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class ComponentsWrapper: NSObject {
    var wrappedInstance: Locale.Components

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var languageComponents: LanguageWrapper.ComponentsWrapper1 {
      get {
        ComponentsWrapper1(wrappedInstance.languageComponents)
      }
      set {
        wrappedInstance.languageComponents = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var subdivision: LocaleWrapper.SubdivisionWrapper? {
      get {
        wrappedInstance.subdivision == nil ? nil : SubdivisionWrapper(wrappedInstance.subdivision!)
      }
      set {
        wrappedInstance.subdivision = newValue?.wrappedInstance
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var numberingSystem: LocaleWrapper.NumberingSystemWrapper? {
      get {
        wrappedInstance.numberingSystem == nil ? nil : NumberingSystemWrapper(wrappedInstance.numberingSystem!)
      }
      set {
        wrappedInstance.numberingSystem = newValue?.wrappedInstance
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var measurementSystem: LocaleWrapper.MeasurementSystemWrapper? {
      get {
        wrappedInstance.measurementSystem == nil ? nil : MeasurementSystemWrapper(wrappedInstance.measurementSystem!)
      }
      set {
        wrappedInstance.measurementSystem = newValue?.wrappedInstance
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var region: LocaleWrapper.RegionWrapper? {
      get {
        wrappedInstance.region == nil ? nil : RegionWrapper(wrappedInstance.region!)
      }
      set {
        wrappedInstance.region = newValue?.wrappedInstance
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var variant: LocaleWrapper.VariantWrapper? {
      get {
        wrappedInstance.variant == nil ? nil : VariantWrapper(wrappedInstance.variant!)
      }
      set {
        wrappedInstance.variant = newValue?.wrappedInstance
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var currency: LocaleWrapper.CurrencyWrapper? {
      get {
        wrappedInstance.currency == nil ? nil : CurrencyWrapper(wrappedInstance.currency!)
      }
      set {
        wrappedInstance.currency = newValue?.wrappedInstance
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var timeZone: TimeZoneWrapper? {
      get {
        wrappedInstance.timeZone == nil ? nil : TimeZoneWrapper(wrappedInstance.timeZone!)
      }
      set {
        wrappedInstance.timeZone = newValue?.wrappedInstance
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var collation: LocaleWrapper.CollationWrapper? {
      get {
        wrappedInstance.collation == nil ? nil : CollationWrapper(wrappedInstance.collation!)
      }
      set {
        wrappedInstance.collation = newValue?.wrappedInstance
      }
    }

    init(_ wrappedInstance: Locale.Components) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(identifier: String) {
      wrappedInstance = Locale.Components(identifier: identifier)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(locale: LocaleWrapper) {
      wrappedInstance = Locale.Components(locale: locale.wrappedInstance)
    }

  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class SubdivisionWrapper: NSObject {
    var wrappedInstance: Locale.Subdivision

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var identifier: String {
      get {
        wrappedInstance.identifier
      }
      set {
        wrappedInstance.identifier = newValue
      }
    }

    @available(macOS, introduced: 14)
    @available(watchOS, introduced: 10)
    @available(iOS, introduced: 17)
    @available(tvOS, introduced: 17)
    @objc public var debugDescription: String {
      get {
        wrappedInstance.debugDescription
      }
    }

    init(_ wrappedInstance: Locale.Subdivision) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(stringLiteral value: String) {
      wrappedInstance = Locale.Subdivision(stringLiteral: value)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(_ identifier: String) {
      wrappedInstance = Locale.Subdivision(identifier)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public func subdivision(for region: LocaleWrapper.RegionWrapper) -> LocaleWrapper.SubdivisionWrapper {
      let result = Locale.Subdivision.subdivision(for: region.wrappedInstance)
      return SubdivisionWrapper(result)
    }

  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class LanguageCodeWrapper: NSObject {
    var wrappedInstance: Locale.LanguageCode

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var norwegianBokml: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.norwegianBokml)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var mori: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.mori)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var belarusian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.belarusian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var identifier: String {
      get {
        wrappedInstance.identifier
      }
      set {
        wrappedInstance.identifier = newValue
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var indonesian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.indonesian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var lithuanian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.lithuanian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var macedonian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.macedonian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var portuguese: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.portuguese)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var vietnamese: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.vietnamese)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var azerbaijani: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.azerbaijani)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var unavailable: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.unavailable)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var unidentified: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.unidentified)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var apacheWestern: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.apacheWestern)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var isISOLanguage: Bool {
      get {
        wrappedInstance.isISOLanguage
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var kurdishSorani: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.kurdishSorani)
      }
    }

    @available(macOS, introduced: 14)
    @available(watchOS, introduced: 10)
    @available(iOS, introduced: 17)
    @available(tvOS, introduced: 17)
    @objc public var debugDescription: String {
      get {
        wrappedInstance.debugDescription
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var norwegianNynorsk: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.norwegianNynorsk)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var lao: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.lao)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var ainu: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.ainu)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var bodo: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.bodo)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var fula: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.fula)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var igbo: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.igbo)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var odia: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.odia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var thai: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.thai)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var urdu: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.urdu)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var czech: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.czech)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var dogri: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.dogri)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var dutch: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.dutch)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var greek: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.greek)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var hindi: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.hindi)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var irish: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.irish)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var khmer: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.khmer)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var malay: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.malay)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var tajik: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.tajik)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var tamil: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.tamil)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var uzbek: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.uzbek)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var welsh: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.welsh)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var arabic: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.arabic)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var bangla: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.bangla)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var danish: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.danish)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var french: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.french)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var german: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.german)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var hebrew: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.hebrew)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var kazakh: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.kazakh)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var korean: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.korean)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var kyrgyz: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.kyrgyz)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var navajo: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.navajo)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var nepali: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.nepali)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var pashto: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.pashto)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var polish: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.polish)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var samoan: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.samoan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var sindhi: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.sindhi)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var slovak: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.slovak)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var telugu: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.telugu)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var tongan: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.tongan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var uyghur: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.uyghur)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var amharic: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.amharic)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var burmese: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.burmese)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var catalan: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.catalan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var chinese: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.chinese)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var dhivehi: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.dhivehi)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var english: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.english)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var faroese: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.faroese)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var finnish: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.finnish)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var italian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.italian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var kannada: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.kannada)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var konkani: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.konkani)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var kurdish: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.kurdish)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var latvian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.latvian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var maltese: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.maltese)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var marathi: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.marathi)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var persian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.persian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var punjabi: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.punjabi)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var russian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.russian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var santali: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.santali)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var serbian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.serbian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var sinhala: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.sinhala)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var spanish: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.spanish)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var swahili: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.swahili)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var swedish: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.swedish)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var tagalog: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.tagalog)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var tibetan: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.tibetan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var turkish: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.turkish)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var turkmen: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.turkmen)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var uncoded: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.uncoded)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var yiddish: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.yiddish)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var albanian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.albanian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var armenian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.armenian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var assamese: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.assamese)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var assyrian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.assyrian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var cherokee: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.cherokee)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var croatian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.croatian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var dzongkha: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.dzongkha)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var estonian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.estonian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var georgian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.georgian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var gujarati: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.gujarati)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var hawaiian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.hawaiian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var japanese: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.japanese)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var kashmiri: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.kashmiri)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var maithili: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.maithili)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var manipuri: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.manipuri)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var multiple: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.multiple)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var rohingya: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.rohingya)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var romanian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.romanian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var sanskrit: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.sanskrit)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var bulgarian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.bulgarian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var cantonese: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.cantonese)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var hungarian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.hungarian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var icelandic: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.icelandic)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var malayalam: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.malayalam)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var mongolian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.mongolian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var norwegian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.norwegian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var slovenian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.slovenian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var ukrainian: LocaleWrapper.LanguageCodeWrapper {
      get {
        LanguageCodeWrapper(Locale.LanguageCode.ukrainian)
      }
    }

    init(_ wrappedInstance: Locale.LanguageCode) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(stringLiteral value: String) {
      wrappedInstance = Locale.LanguageCode(stringLiteral: value)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(_ identifier: String) {
      wrappedInstance = Locale.LanguageCode(identifier)
    }

  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class NumberingSystemWrapper: NSObject {
    var wrappedInstance: Locale.NumberingSystem

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var identifier: String {
      get {
        wrappedInstance.identifier
      }
      set {
        wrappedInstance.identifier = newValue
      }
    }

    @available(macOS, introduced: 14)
    @available(watchOS, introduced: 10)
    @available(iOS, introduced: 17)
    @available(tvOS, introduced: 17)
    @objc public var debugDescription: String {
      get {
        wrappedInstance.debugDescription
      }
    }

    init(_ wrappedInstance: Locale.NumberingSystem) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(stringLiteral value: String) {
      wrappedInstance = Locale.NumberingSystem(stringLiteral: value)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(_ identifier: String) {
      wrappedInstance = Locale.NumberingSystem(identifier)
    }

  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class MeasurementSystemWrapper: NSObject {
    var wrappedInstance: Locale.MeasurementSystem

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var identifier: String {
      get {
        wrappedInstance.identifier
      }
      set {
        wrappedInstance.identifier = newValue
      }
    }

    @available(macOS, introduced: 14)
    @available(watchOS, introduced: 10)
    @available(iOS, introduced: 17)
    @available(tvOS, introduced: 17)
    @objc public var debugDescription: String {
      get {
        wrappedInstance.debugDescription
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var uk: LocaleWrapper.MeasurementSystemWrapper {
      get {
        MeasurementSystemWrapper(Locale.MeasurementSystem.uk)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var us: LocaleWrapper.MeasurementSystemWrapper {
      get {
        MeasurementSystemWrapper(Locale.MeasurementSystem.us)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var metric: LocaleWrapper.MeasurementSystemWrapper {
      get {
        MeasurementSystemWrapper(Locale.MeasurementSystem.metric)
      }
    }

    init(_ wrappedInstance: Locale.MeasurementSystem) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(stringLiteral value: String) {
      wrappedInstance = Locale.MeasurementSystem(stringLiteral: value)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(_ identifier: String) {
      wrappedInstance = Locale.MeasurementSystem(identifier)
    }

  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class RegionWrapper: NSObject {
    var wrappedInstance: Locale.Region

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var curaao: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.curaao)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var runion: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.runion)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var cteDIvoire: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.cteDIvoire)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var landIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.landIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var saintBarthlemy: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.saintBarthlemy)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var soTomPrncipe: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.soTomPrncipe)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var containingRegion: LocaleWrapper.RegionWrapper? {
      get {
        wrappedInstance.containingRegion == nil ? nil : RegionWrapper(wrappedInstance.containingRegion!)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var antarctica: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.antarctica)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var azerbaijan: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.azerbaijan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var bangladesh: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.bangladesh)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var elSalvador: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.elSalvador)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var guadeloupe: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.guadeloupe)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var identifier: String {
      get {
        wrappedInstance.identifier
      }
      set {
        wrappedInstance.identifier = newValue
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var kazakhstan: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.kazakhstan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var kyrgyzstan: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.kyrgyzstan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var luxembourg: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.luxembourg)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var madagascar: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.madagascar)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var martinique: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.martinique)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var mauritania: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.mauritania)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var micronesia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.micronesia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var montenegro: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.montenegro)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var montserrat: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.montserrat)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var mozambique: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.mozambique)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var newZealand: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.newZealand)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var puertoRico: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.puertoRico)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var saintLucia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.saintLucia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var seychelles: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.seychelles)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var southKorea: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.southKorea)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var southSudan: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.southSudan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var tajikistan: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.tajikistan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var timorLeste: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.timorLeste)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var uzbekistan: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.uzbekistan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var afghanistan: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.afghanistan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var burkinaFaso: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.burkinaFaso)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var cookIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.cookIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var diegoGarcia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.diegoGarcia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var isISORegion: Bool {
      get {
        wrappedInstance.isISORegion
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var netherlands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.netherlands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var philippines: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.philippines)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var saintHelena: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.saintHelena)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var saintMartin: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.saintMartin)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var saudiArabia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.saudiArabia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var sierraLeone: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.sierraLeone)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var sintMaarten: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.sintMaarten)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var southAfrica: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.southAfrica)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var switzerland: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.switzerland)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var vaticanCity: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.vaticanCity)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var bouvetIsland: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.bouvetIsland)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var ceutaMelilla: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.ceutaMelilla)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var cocosIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.cocosIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var faroeIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.faroeIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var frenchGuiana: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.frenchGuiana)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var guineaBissau: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.guineaBissau)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var latinAmerica: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.latinAmerica)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var newCaledonia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.newCaledonia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var turkmenistan: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.turkmenistan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var unitedStates: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.unitedStates)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var wallisFutuna: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.wallisFutuna)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var americanSamoa: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.americanSamoa)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var canaryIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.canaryIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var caymanIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.caymanIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var chinaMainland: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.chinaMainland)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var congoKinshasa: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.congoKinshasa)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var liechtenstein: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.liechtenstein)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var norfolkIsland: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.norfolkIsland)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var unitedKingdom: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.unitedKingdom)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var westernSahara: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.westernSahara)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var antiguaBarbuda: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.antiguaBarbuda)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var northMacedonia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.northMacedonia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var papuaNewGuinea: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.papuaNewGuinea)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var solomonIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.solomonIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var trinidadTobago: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.trinidadTobago)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var tristanDaCunha: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.tristanDaCunha)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var ascensionIsland: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.ascensionIsland)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var christmasIsland: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.christmasIsland)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var falklandIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.falklandIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var frenchPolynesia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.frenchPolynesia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var marshallIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.marshallIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var pitcairnIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.pitcairnIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var saintKittsNevis: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.saintKittsNevis)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var clippertonIsland: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.clippertonIsland)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var congoBrazzaville: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.congoBrazzaville)
      }
    }

    @available(macOS, introduced: 14)
    @available(watchOS, introduced: 10)
    @available(iOS, introduced: 17)
    @available(tvOS, introduced: 17)
    @objc public var debugDescription: String {
      get {
        wrappedInstance.debugDescription
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var equatorialGuinea: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.equatorialGuinea)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var svalbardJanMayen: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.svalbardJanMayen)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var bosniaHerzegovina: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.bosniaHerzegovina)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var chagosArchipelago: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.chagosArchipelago)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var dominicanRepublic: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.dominicanRepublic)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var turksCaicosIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.turksCaicosIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var unitedArabEmirates: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.unitedArabEmirates)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var saintPierreMiquelon: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.saintPierreMiquelon)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var britishVirginIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.britishVirginIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var caribbeanNetherlands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.caribbeanNetherlands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var heardMcdonaldIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.heardMcdonaldIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var centralAfricanRepublic: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.centralAfricanRepublic)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var northernMarianaIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.northernMarianaIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var palestinianTerritories: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.palestinianTerritories)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var saintVincentGrenadines: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.saintVincentGrenadines)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var frenchSouthernTerritories: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.frenchSouthernTerritories)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var unitedStatesVirginIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.unitedStatesVirginIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var unitedStatesOutlyingIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.unitedStatesOutlyingIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var southGeorgiaSouthSandwichIslands: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.southGeorgiaSouthSandwichIslands)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var chad: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.chad)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var cuba: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.cuba)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var fiji: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.fiji)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var guam: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.guam)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var iran: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.iran)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var iraq: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.iraq)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var laos: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.laos)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var mali: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.mali)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var niue: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.niue)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var oman: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.oman)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var peru: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.peru)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var togo: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.togo)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var aruba: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.aruba)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var benin: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.benin)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var chile: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.chile)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var egypt: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.egypt)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var gabon: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.gabon)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var ghana: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.ghana)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var haiti: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.haiti)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var india: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.india)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var italy: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.italy)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var japan: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.japan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var kenya: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.kenya)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var libya: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.libya)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var macao: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.macao)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var malta: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.malta)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var nauru: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.nauru)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var nepal: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.nepal)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var niger: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.niger)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var palau: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.palau)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var qatar: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.qatar)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var samoa: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.samoa)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var spain: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.spain)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var tonga: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.tonga)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var world: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.world)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var yemen: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.yemen)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var angola: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.angola)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var belize: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.belize)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var bhutan: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.bhutan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var brazil: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.brazil)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var brunei: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.brunei)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var canada: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.canada)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var cyprus: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.cyprus)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var france: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.france)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var gambia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.gambia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var greece: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.greece)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var guinea: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.guinea)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var guyana: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.guyana)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var israel: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.israel)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var jersey: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.jersey)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var jordan: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.jordan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var kosovo: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.kosovo)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var kuwait: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.kuwait)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var latvia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.latvia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var malawi: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.malawi)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var mexico: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.mexico)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var monaco: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.monaco)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var norway: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.norway)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var panama: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.panama)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var poland: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.poland)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var russia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.russia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var rwanda: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.rwanda)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var serbia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.serbia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var sweden: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.sweden)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var taiwan: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.taiwan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var turkey: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.turkey)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var tuvalu: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.tuvalu)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var uganda: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.uganda)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var zambia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.zambia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var albania: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.albania)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var algeria: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.algeria)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var andorra: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.andorra)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var armenia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.armenia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var austria: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.austria)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var bahamas: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.bahamas)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var bahrain: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.bahrain)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var belarus: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.belarus)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var belgium: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.belgium)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var bermuda: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.bermuda)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var bolivia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.bolivia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var burundi: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.burundi)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var comoros: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.comoros)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var croatia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.croatia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var czechia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.czechia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var denmark: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.denmark)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var ecuador: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.ecuador)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var eritrea: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.eritrea)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var estonia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.estonia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var finland: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.finland)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var georgia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.georgia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var germany: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.germany)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var grenada: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.grenada)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var hungary: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.hungary)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var iceland: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.iceland)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var ireland: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.ireland)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var jamaica: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.jamaica)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var lebanon: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.lebanon)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var lesotho: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.lesotho)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var liberia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.liberia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var mayotte: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.mayotte)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var moldova: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.moldova)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var morocco: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.morocco)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var myanmar: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.myanmar)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var namibia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.namibia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var nigeria: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.nigeria)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var romania: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.romania)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var senegal: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.senegal)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var somalia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.somalia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var tokelau: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.tokelau)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var tunisia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.tunisia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var ukraine: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.ukraine)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var unknown: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.unknown)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var uruguay: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.uruguay)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var vanuatu: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.vanuatu)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var vietnam: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.vietnam)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var anguilla: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.anguilla)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var barbados: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.barbados)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var botswana: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.botswana)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var bulgaria: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.bulgaria)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var cambodia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.cambodia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var cameroon: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.cameroon)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var colombia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.colombia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var djibouti: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.djibouti)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var dominica: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.dominica)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var eswatini: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.eswatini)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var ethiopia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.ethiopia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var guernsey: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.guernsey)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var honduras: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.honduras)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var hongKong: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.hongKong)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var kiribati: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.kiribati)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var malaysia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.malaysia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var maldives: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.maldives)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var mongolia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.mongolia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var pakistan: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.pakistan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var paraguay: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.paraguay)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var portugal: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.portugal)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var slovakia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.slovakia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var slovenia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.slovenia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var sriLanka: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.sriLanka)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var suriname: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.suriname)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var tanzania: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.tanzania)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var thailand: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.thailand)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var zimbabwe: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.zimbabwe)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var argentina: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.argentina)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var australia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.australia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var capeVerde: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.capeVerde)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var continent: LocaleWrapper.RegionWrapper? {
      get {
        wrappedInstance.continent == nil ? nil : RegionWrapper(wrappedInstance.continent!)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var costaRica: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.costaRica)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var gibraltar: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.gibraltar)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var greenland: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.greenland)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var guatemala: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.guatemala)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var indonesia: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.indonesia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var isleOfMan: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.isleOfMan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var lithuania: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.lithuania)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var mauritius: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.mauritius)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var nicaragua: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.nicaragua)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var sanMarino: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.sanMarino)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var singapore: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.singapore)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var venezuela: LocaleWrapper.RegionWrapper {
      get {
        RegionWrapper(Locale.Region.venezuela)
      }
    }

    init(_ wrappedInstance: Locale.Region) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(stringLiteral value: String) {
      wrappedInstance = Locale.Region(stringLiteral: value)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(_ identifier: String) {
      wrappedInstance = Locale.Region(identifier)
    }

  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class ScriptWrapper: NSObject {
    var wrappedInstance: Locale.Script

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var devanagari: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.devanagari)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var identifier: String {
      get {
        wrappedInstance.identifier
      }
      set {
        wrappedInstance.identifier = newValue
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var isISOScript: Bool {
      get {
        wrappedInstance.isISOScript
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var meiteiMayek: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.meiteiMayek)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var hanSimplified: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.hanSimplified)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var arabicNastaliq: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.arabicNastaliq)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var hanTraditional: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.hanTraditional)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var hanifiRohingya: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.hanifiRohingya)
      }
    }

    @available(macOS, introduced: 14)
    @available(watchOS, introduced: 10)
    @available(iOS, introduced: 17)
    @available(tvOS, introduced: 17)
    @objc public var debugDescription: String {
      get {
        wrappedInstance.debugDescription
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var lao: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.lao)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var odia: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.odia)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var thai: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.thai)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var adlam: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.adlam)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var greek: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.greek)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var khmer: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.khmer)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var latin: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.latin)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var tamil: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.tamil)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var arabic: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.arabic)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var bangla: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.bangla)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var hebrew: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.hebrew)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var korean: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.korean)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var syriac: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.syriac)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var telugu: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.telugu)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var thaana: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.thaana)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var kannada: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.kannada)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var myanmar: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.myanmar)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var olChiki: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.olChiki)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var sinhala: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.sinhala)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var tibetan: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.tibetan)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var unknown: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.unknown)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var armenian: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.armenian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var cherokee: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.cherokee)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var cyrillic: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.cyrillic)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var ethiopic: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.ethiopic)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var georgian: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.georgian)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var gujarati: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.gujarati)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var gurmukhi: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.gurmukhi)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var hiragana: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.hiragana)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var japanese: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.japanese)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var katakana: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.katakana)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var malayalam: LocaleWrapper.ScriptWrapper {
      get {
        ScriptWrapper(Locale.Script.malayalam)
      }
    }

    init(_ wrappedInstance: Locale.Script) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(stringLiteral value: String) {
      wrappedInstance = Locale.Script(stringLiteral: value)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(_ identifier: String) {
      wrappedInstance = Locale.Script(identifier)
    }

  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class VariantWrapper: NSObject {
    var wrappedInstance: Locale.Variant

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var identifier: String {
      get {
        wrappedInstance.identifier
      }
      set {
        wrappedInstance.identifier = newValue
      }
    }

    @available(macOS, introduced: 14)
    @available(watchOS, introduced: 10)
    @available(iOS, introduced: 17)
    @available(tvOS, introduced: 17)
    @objc public var debugDescription: String {
      get {
        wrappedInstance.debugDescription
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var posix: LocaleWrapper.VariantWrapper {
      get {
        VariantWrapper(Locale.Variant.posix)
      }
    }

    init(_ wrappedInstance: Locale.Variant) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(stringLiteral value: String) {
      wrappedInstance = Locale.Variant(stringLiteral: value)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(_ identifier: String) {
      wrappedInstance = Locale.Variant(identifier)
    }

  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class CurrencyWrapper: NSObject {
    var wrappedInstance: Locale.Currency

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var identifier: String {
      get {
        wrappedInstance.identifier
      }
      set {
        wrappedInstance.identifier = newValue
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var isISOCurrency: Bool {
      get {
        wrappedInstance.isISOCurrency
      }
    }

    @available(macOS, introduced: 14)
    @available(watchOS, introduced: 10)
    @available(iOS, introduced: 17)
    @available(tvOS, introduced: 17)
    @objc public var debugDescription: String {
      get {
        wrappedInstance.debugDescription
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var unknown: LocaleWrapper.CurrencyWrapper {
      get {
        CurrencyWrapper(Locale.Currency.unknown)
      }
    }

    init(_ wrappedInstance: Locale.Currency) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(stringLiteral value: String) {
      wrappedInstance = Locale.Currency(stringLiteral: value)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(_ identifier: String) {
      wrappedInstance = Locale.Currency(identifier)
    }

  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class LanguageWrapper: NSObject {
    var wrappedInstance: Locale.Language

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var languageCode: LocaleWrapper.LanguageCodeWrapper? {
      get {
        wrappedInstance.languageCode == nil ? nil : LanguageCodeWrapper(wrappedInstance.languageCode!)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var maximalIdentifier: String {
      get {
        wrappedInstance.maximalIdentifier
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var minimalIdentifier: String {
      get {
        wrappedInstance.minimalIdentifier
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var parent: LocaleWrapper.LanguageWrapper? {
      get {
        wrappedInstance.parent == nil ? nil : LanguageWrapper(wrappedInstance.parent!)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var region: LocaleWrapper.RegionWrapper? {
      get {
        wrappedInstance.region == nil ? nil : RegionWrapper(wrappedInstance.region!)
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var script: LocaleWrapper.ScriptWrapper? {
      get {
        wrappedInstance.script == nil ? nil : ScriptWrapper(wrappedInstance.script!)
      }
    }

    init(_ wrappedInstance: Locale.Language) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(components: LanguageWrapper.ComponentsWrapper1) {
      wrappedInstance = Locale.Language(components: components.wrappedInstance)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(identifier: String) {
      wrappedInstance = Locale.Language(identifier: identifier)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public func isEquivalent(to language: LocaleWrapper.LanguageWrapper) -> Bool {
      return wrappedInstance.isEquivalent(to: language.wrappedInstance)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public func hasCommonParent(with language: LocaleWrapper.LanguageWrapper) -> Bool {
      return wrappedInstance.hasCommonParent(with: language.wrappedInstance)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public class ComponentsWrapper1: NSObject {
      var wrappedInstance: Language.Components

      @available(macOS, introduced: 13)
      @available(watchOS, introduced: 9)
      @available(iOS, introduced: 16)
      @available(tvOS, introduced: 16)
      @objc public var languageCode: LocaleWrapper.LanguageCodeWrapper? {
        get {
          wrappedInstance.languageCode == nil ? nil : LanguageCodeWrapper(wrappedInstance.languageCode!)
        }
        set {
          wrappedInstance.languageCode = newValue?.wrappedInstance
        }
      }

      @available(macOS, introduced: 13)
      @available(watchOS, introduced: 9)
      @available(iOS, introduced: 16)
      @available(tvOS, introduced: 16)
      @objc public var region: LocaleWrapper.RegionWrapper? {
        get {
          wrappedInstance.region == nil ? nil : RegionWrapper(wrappedInstance.region!)
        }
        set {
          wrappedInstance.region = newValue?.wrappedInstance
        }
      }

      @available(macOS, introduced: 13)
      @available(watchOS, introduced: 9)
      @available(iOS, introduced: 16)
      @available(tvOS, introduced: 16)
      @objc public var script: LocaleWrapper.ScriptWrapper? {
        get {
          wrappedInstance.script == nil ? nil : ScriptWrapper(wrappedInstance.script!)
        }
        set {
          wrappedInstance.script = newValue?.wrappedInstance
        }
      }

      init(_ wrappedInstance: Language.Components) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 13)
      @available(watchOS, introduced: 9)
      @available(iOS, introduced: 16)
      @available(tvOS, introduced: 16)
      @objc init(identifier: String) {
        wrappedInstance = Language.Components(identifier: identifier)
      }

      @available(macOS, introduced: 13)
      @available(watchOS, introduced: 9)
      @available(iOS, introduced: 16)
      @available(tvOS, introduced: 16)
      @objc init(language: LocaleWrapper.LanguageWrapper) {
        wrappedInstance = Language.Components(language: language.wrappedInstance)
      }

    }

  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc public class CollationWrapper: NSObject {
    var wrappedInstance: Locale.Collation

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc public var identifier: String {
      get {
        wrappedInstance.identifier
      }
      set {
        wrappedInstance.identifier = newValue
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var searchRules: LocaleWrapper.CollationWrapper {
      get {
        CollationWrapper(Locale.Collation.searchRules)
      }
    }

    @available(macOS, introduced: 14)
    @available(watchOS, introduced: 10)
    @available(iOS, introduced: 17)
    @available(tvOS, introduced: 17)
    @objc public var debugDescription: String {
      get {
        wrappedInstance.debugDescription
      }
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc static public var standard: LocaleWrapper.CollationWrapper {
      get {
        CollationWrapper(Locale.Collation.standard)
      }
    }

    init(_ wrappedInstance: Locale.Collation) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(stringLiteral value: String) {
      wrappedInstance = Locale.Collation(stringLiteral: value)
    }

    @available(macOS, introduced: 13)
    @available(watchOS, introduced: 9)
    @available(iOS, introduced: 16)
    @available(tvOS, introduced: 16)
    @objc init(_ identifier: String) {
      wrappedInstance = Locale.Collation(identifier)
    }

  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class CalendarWrapper: NSObject {
  var wrappedInstance: Calendar

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var firstWeekday: Int {
    get {
      wrappedInstance.firstWeekday
    }
    set {
      wrappedInstance.firstWeekday = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var autoupdatingCurrent: CalendarWrapper {
    get {
      CalendarWrapper(Calendar.autoupdatingCurrent)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var minimumDaysInFirstWeek: Int {
    get {
      wrappedInstance.minimumDaysInFirstWeek
    }
    set {
      wrappedInstance.minimumDaysInFirstWeek = newValue
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var locale: LocaleWrapper? {
    get {
      wrappedInstance.locale == nil ? nil : LocaleWrapper(wrappedInstance.locale!)
    }
    set {
      wrappedInstance.locale = newValue?.wrappedInstance
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var current: CalendarWrapper {
    get {
      CalendarWrapper(Calendar.current)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var amSymbol: String {
    get {
      wrappedInstance.amSymbol
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var pmSymbol: String {
    get {
      wrappedInstance.pmSymbol
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var timeZone: TimeZoneWrapper {
    get {
      TimeZoneWrapper(wrappedInstance.timeZone)
    }
    set {
      wrappedInstance.timeZone = newValue.wrappedInstance
    }
  }

  init(_ wrappedInstance: Calendar) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func startOfDay(for date: DateWrapper) -> DateWrapper {
    let result = wrappedInstance.startOfDay(for: date.wrappedInstance)
    return DateWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func isDateInToday(_ date: DateWrapper) -> Bool {
    return wrappedInstance.isDateInToday(date.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func dateComponents(in timeZone: TimeZoneWrapper, from date: DateWrapper) -> DateComponentsWrapper {
    let result = wrappedInstance.dateComponents(in: timeZone.wrappedInstance, from: date.wrappedInstance)
    return DateComponentsWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func isDateInWeekend(_ date: DateWrapper) -> Bool {
    return wrappedInstance.isDateInWeekend(date.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func isDateInTomorrow(_ date: DateWrapper) -> Bool {
    return wrappedInstance.isDateInTomorrow(date.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func isDateInYesterday(_ date: DateWrapper) -> Bool {
    return wrappedInstance.isDateInYesterday(date.wrappedInstance)
  }

  @available(macOS, introduced: 10.12)
  @available(watchOS, introduced: 3.0)
  @available(iOS, introduced: 10.0)
  @available(tvOS, introduced: 10.0)
  @objc public func dateIntervalOfWeekend(containing date: DateWrapper) -> DateIntervalWrapper? {
    let result = wrappedInstance.dateIntervalOfWeekend(containing: date.wrappedInstance)
    return result == nil ? nil : DateIntervalWrapper(result!)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func date(from components: DateComponentsWrapper) -> DateWrapper? {
    let result = wrappedInstance.date(from: components.wrappedInstance)
    return result == nil ? nil : DateWrapper(result!)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func date(_ date: DateWrapper, matchesComponents components: DateComponentsWrapper) -> Bool {
    return wrappedInstance.date(date.wrappedInstance, matchesComponents: components.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func isDate(_ date1: DateWrapper, inSameDayAs date2: DateWrapper) -> Bool {
    return wrappedInstance.isDate(date1.wrappedInstance, inSameDayAs: date2.wrappedInstance)
  }

  @available(macOS, introduced: 15)
  @available(watchOS, introduced: 11)
  @available(iOS, introduced: 18)
  @available(tvOS, introduced: 18)
  @objc public class RecurrenceRuleWrapper: NSObject {
    var wrappedInstance: Calendar.RecurrenceRule

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public var end: RecurrenceRuleWrapper.EndWrapper {
      get {
        EndWrapper(wrappedInstance.end)
      }
      set {
        wrappedInstance.end = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public var calendar: CalendarWrapper {
      get {
        CalendarWrapper(wrappedInstance.calendar)
      }
      set {
        wrappedInstance.calendar = newValue.wrappedInstance
      }
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public var interval: Int {
      get {
        wrappedInstance.interval
      }
      set {
        wrappedInstance.interval = newValue
      }
    }

    init(_ wrappedInstance: Calendar.RecurrenceRule) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public class EndWrapper: NSObject {
      var wrappedInstance: RecurrenceRule.End

      @available(macOS, introduced: 15.2)
      @available(watchOS, introduced: 11.2)
      @available(iOS, introduced: 18.2)
      @available(tvOS, introduced: 18.2)
      @objc public var description: String {
        get {
          wrappedInstance.description
        }
      }

      @available(macOS, introduced: 15.2)
      @available(watchOS, introduced: 11.2)
      @available(iOS, introduced: 18.2)
      @available(tvOS, introduced: 18.2)
      @objc public var occurrences: Int? {
        get {
          wrappedInstance.occurrences
        }
      }

      @available(macOS, introduced: 15.2)
      @available(watchOS, introduced: 11.2)
      @available(iOS, introduced: 18.2)
      @available(tvOS, introduced: 18.2)
      @objc public var date: DateWrapper? {
        get {
          wrappedInstance.date == nil ? nil : DateWrapper(wrappedInstance.date!)
        }
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc static public var never: RecurrenceRuleWrapper.EndWrapper {
        get {
          EndWrapper(RecurrenceRule.End.never)
        }
      }

      init(_ wrappedInstance: RecurrenceRule.End) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc static public func afterOccurrences(_ count: Int) -> RecurrenceRuleWrapper.EndWrapper {
        let result = RecurrenceRule.End.afterOccurrences(count)
        return EndWrapper(result)
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc static public func afterDate(_ date: DateWrapper) -> RecurrenceRuleWrapper.EndWrapper {
        let result = RecurrenceRule.End.afterDate(date.wrappedInstance)
        return EndWrapper(result)
      }

    }

    @available(macOS, introduced: 15)
    @available(watchOS, introduced: 11)
    @available(iOS, introduced: 18)
    @available(tvOS, introduced: 18)
    @objc public class MonthWrapper: NSObject {
      var wrappedInstance: RecurrenceRule.Month

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public var index: Int {
        get {
          wrappedInstance.index
        }
        set {
          wrappedInstance.index = newValue
        }
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc public var isLeap: Bool {
        get {
          wrappedInstance.isLeap
        }
        set {
          wrappedInstance.isLeap = newValue
        }
      }

      init(_ wrappedInstance: RecurrenceRule.Month) {
        self.wrappedInstance = wrappedInstance
      }

      @available(macOS, introduced: 15)
      @available(watchOS, introduced: 11)
      @available(iOS, introduced: 18)
      @available(tvOS, introduced: 18)
      @objc init(integerLiteral value: Int) {
        wrappedInstance = RecurrenceRule.Month(integerLiteral: value)
      }

    }

  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class IndexSetWrapper: NSObject {
  var wrappedInstance: IndexSet

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var endIndex: IndexSetWrapper.IndexWrapper {
    get {
      IndexWrapper(wrappedInstance.endIndex)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var startIndex: IndexSetWrapper.IndexWrapper {
    get {
      IndexWrapper(wrappedInstance.startIndex)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var last: IndexSet.Element? {
    get {
      wrappedInstance.last
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var count: Int {
    get {
      wrappedInstance.count
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var first: IndexSet.Element? {
    get {
      wrappedInstance.first
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var isEmpty: Bool {
    get {
      wrappedInstance.isEmpty
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var rangeView: IndexSetWrapper.RangeViewWrapper {
    get {
      RangeViewWrapper(wrappedInstance.rangeView)
    }
  }

  @objc public var underestimatedCount: Int {
    get {
      wrappedInstance.underestimatedCount
    }
  }

  init(_ wrappedInstance: IndexSet) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(integer: IndexSet.Element) {
    wrappedInstance = IndexSet(integer: integer)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc override init() {
    wrappedInstance = IndexSet()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func intersection(_ other: IndexSetWrapper) -> IndexSetWrapper {
    let result = wrappedInstance.intersection(other.wrappedInstance)
    return IndexSetWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func integerLessThan(_ integer: IndexSet.Element) -> IndexSet.Element? {
    return wrappedInstance.integerLessThan(integer)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func formIntersection(_ other: IndexSetWrapper) {
    return wrappedInstance.formIntersection(other.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func integerGreaterThan(_ integer: IndexSet.Element) -> IndexSet.Element? {
    return wrappedInstance.integerGreaterThan(integer)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func symmetricDifference(_ other: IndexSetWrapper) -> IndexSetWrapper {
    let result = wrappedInstance.symmetricDifference(other.wrappedInstance)
    return IndexSetWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func formSymmetricDifference(_ other: IndexSetWrapper) {
    return wrappedInstance.formSymmetricDifference(other.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func integerLessThanOrEqualTo(_ integer: IndexSet.Element) -> IndexSet.Element? {
    return wrappedInstance.integerLessThanOrEqualTo(integer)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func integerGreaterThanOrEqualTo(_ integer: IndexSet.Element) -> IndexSet.Element? {
    return wrappedInstance.integerGreaterThanOrEqualTo(integer)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func index(after i: IndexSetWrapper.IndexWrapper) -> IndexSetWrapper.IndexWrapper {
    let result = wrappedInstance.index(after: i.wrappedInstance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func index(before i: IndexSetWrapper.IndexWrapper) -> IndexSetWrapper.IndexWrapper {
    let result = wrappedInstance.index(before: i.wrappedInstance)
    return IndexWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func shift(startingAt integer: IndexSet.Element, by delta: Int) {
    return wrappedInstance.shift(startingAt: integer, by: delta)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func union(_ other: IndexSetWrapper) -> IndexSetWrapper {
    let result = wrappedInstance.union(other.wrappedInstance)
    return IndexSetWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func contains(integersIn indexSet: IndexSetWrapper) -> Bool {
    return wrappedInstance.contains(integersIn: indexSet.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func contains(_ integer: IndexSet.Element) -> Bool {
    return wrappedInstance.contains(integer)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func formUnion(_ other: IndexSetWrapper) {
    return wrappedInstance.formUnion(other.wrappedInstance)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func removeAll() {
    return wrappedInstance.removeAll()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public class IndexWrapper: NSObject {
    var wrappedInstance: IndexSet.Index

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc public var description: String {
      get {
        wrappedInstance.description
      }
    }

    init(_ wrappedInstance: IndexSet.Index) {
      self.wrappedInstance = wrappedInstance
    }

  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public class RangeViewWrapper: NSObject {
    var wrappedInstance: IndexSet.RangeView

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc public var endIndex: RangeView.Index {
      get {
        wrappedInstance.endIndex
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc public var startIndex: RangeView.Index {
      get {
        wrappedInstance.startIndex
      }
    }

    @objc public var underestimatedCount: Int {
      get {
        wrappedInstance.underestimatedCount
      }
    }

    @objc public var count: Int {
      get {
        wrappedInstance.count
      }
    }

    @objc public var isEmpty: Bool {
      get {
        wrappedInstance.isEmpty
      }
    }

    init(_ wrappedInstance: IndexSet.RangeView) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc public func index(after i: RangeView.Index) -> RangeView.Index {
      return wrappedInstance.index(after: i)
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc public func index(before i: RangeView.Index) -> RangeView.Index {
      return wrappedInstance.index(before: i)
    }

  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class TimeZoneWrapper: NSObject {
  var wrappedInstance: TimeZone

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var nextDaylightSavingTimeTransition: DateWrapper? {
    get {
      wrappedInstance.nextDaylightSavingTimeTransition == nil ? nil : DateWrapper(wrappedInstance.nextDaylightSavingTimeTransition!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var timeZoneDataVersion: String {
    get {
      TimeZone.timeZoneDataVersion
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var identifier: String {
    get {
      wrappedInstance.identifier
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var autoupdatingCurrent: TimeZoneWrapper {
    get {
      TimeZoneWrapper(TimeZone.autoupdatingCurrent)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var abbreviationDictionary: String {
    get {
      TimeZone.abbreviationDictionary
    }
    set {
      TimeZone.abbreviationDictionary = newValue
    }
  }

  @available(macOS, introduced: 13)
  @available(watchOS, introduced: 9)
  @available(iOS, introduced: 16)
  @available(tvOS, introduced: 16)
  @objc static public var gmt: TimeZoneWrapper {
    get {
      TimeZoneWrapper(TimeZone.gmt)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var current: TimeZoneWrapper {
    get {
      TimeZoneWrapper(TimeZone.current)
    }
  }

  init(_ wrappedInstance: TimeZone) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init?(identifier: String) {
    if let instance = TimeZone(identifier: identifier) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init?(abbreviation: String) {
    if let instance = TimeZone(abbreviation: abbreviation) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init?(secondsFromGMT seconds: Int) {
    if let instance = TimeZone(secondsFromGMT: seconds) {
      wrappedInstance = instance
    } else {
      return nil
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func nextDaylightSavingTimeTransition(after date: DateWrapper) -> DateWrapper? {
    let result = wrappedInstance.nextDaylightSavingTimeTransition(after: date.wrappedInstance)
    return result == nil ? nil : DateWrapper(result!)
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class URLErrorWrapper: NSObject {
  var wrappedInstance: URLError

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var errorDomain: String {
    get {
      URLError.errorDomain
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var failingURL: URLWrapper? {
    get {
      wrappedInstance.failingURL == nil ? nil : URLWrapper(wrappedInstance.failingURL!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var errorDomain: String {
    get {
      URLError.errorDomain
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var callIsActive: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.callIsActive)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var cannotFindHost: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.cannotFindHost)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var cannotMoveFile: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.cannotMoveFile)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var cannotOpenFile: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.cannotOpenFile)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var dataNotAllowed: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.dataNotAllowed)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var unsupportedURL: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.unsupportedURL)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var cannotCloseFile: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.cannotCloseFile)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var dnsLookupFailed: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.dnsLookupFailed)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileIsDirectory: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.fileIsDirectory)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var cannotCreateFile: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.cannotCreateFile)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var cannotRemoveFile: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.cannotRemoveFile)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var failureURLString: String? {
    get {
      wrappedInstance.failureURLString
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var fileDoesNotExist: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.fileDoesNotExist)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var zeroByteResource: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.zeroByteResource)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var badServerResponse: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.badServerResponse)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var cannotWriteToFile: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.cannotWriteToFile)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var cannotConnectToHost: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.cannotConnectToHost)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var cannotDecodeRawData: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.cannotDecodeRawData)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var cannotParseResponse: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.cannotParseResponse)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var resourceUnavailable: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.resourceUnavailable)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var httpTooManyRedirects: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.httpTooManyRedirects)
    }
  }

  @available(macOS, introduced: 14.0)
  @available(watchOS, introduced: 10.0)
  @available(iOS, introduced: 17.0)
  @available(tvOS, introduced: 17.0)
  @objc public var uploadTaskResumeData: DataWrapper? {
    get {
      wrappedInstance.uploadTaskResumeData == nil ? nil : DataWrapper(wrappedInstance.uploadTaskResumeData!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var cannotLoadFromNetwork: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.cannotLoadFromNetwork)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var networkConnectionLost: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.networkConnectionLost)
    }
  }

  @available(macOS, introduced: 10.15)
  @available(watchOS, introduced: 6.0)
  @available(iOS, introduced: 13.0)
  @available(tvOS, introduced: 13.0)
  @objc public var downloadTaskResumeData: DataWrapper? {
    get {
      wrappedInstance.downloadTaskResumeData == nil ? nil : DataWrapper(wrappedInstance.downloadTaskResumeData!)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var notConnectedToInternet: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.notConnectedToInternet)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var secureConnectionFailed: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.secureConnectionFailed)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var cannotDecodeContentData: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.cannotDecodeContentData)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var internationalRoamingOff: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.internationalRoamingOff)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var noPermissionsToReadFile: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.noPermissionsToReadFile)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var dataLengthExceedsMaximum: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.dataLengthExceedsMaximum)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var clientCertificateRejected: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.clientCertificateRejected)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var clientCertificateRequired: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.clientCertificateRequired)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var requestBodyStreamExhausted: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.requestBodyStreamExhausted)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var serverCertificateUntrusted: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.serverCertificateUntrusted)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var userAuthenticationRequired: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.userAuthenticationRequired)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var serverCertificateHasBadDate: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.serverCertificateHasBadDate)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var userCancelledAuthentication: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.userCancelledAuthentication)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var serverCertificateNotYetValid: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.serverCertificateNotYetValid)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var redirectToNonExistentLocation: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.redirectToNonExistentLocation)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var downloadDecodingFailedMidStream: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.downloadDecodingFailedMidStream)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var serverCertificateHasUnknownRoot: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.serverCertificateHasUnknownRoot)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var backgroundSessionWasDisconnected: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.backgroundSessionWasDisconnected)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var downloadDecodingFailedToComplete: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.downloadDecodingFailedToComplete)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var backgroundSessionInUseByAnotherProcess: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.backgroundSessionInUseByAnotherProcess)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var backgroundSessionRequiresSharedContainer: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.backgroundSessionRequiresSharedContainer)
    }
  }

  @available(macOS, introduced: 10.11)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 9.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var appTransportSecurityRequiresSecureConnection: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.appTransportSecurityRequiresSecureConnection)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var badURL: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.badURL)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var unknown: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.unknown)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var timedOut: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.timedOut)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var cancelled: URLErrorWrapper.CodeWrapper {
    get {
      CodeWrapper(URLError.cancelled)
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var localizedDescription: String {
    get {
      wrappedInstance.localizedDescription
    }
  }

  init(_ wrappedInstance: URLError) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public class CodeWrapper: NSObject {
    var wrappedInstance: URLError.Code

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var callIsActive: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.callIsActive)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var cannotFindHost: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.cannotFindHost)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var cannotMoveFile: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.cannotMoveFile)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var cannotOpenFile: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.cannotOpenFile)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var dataNotAllowed: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.dataNotAllowed)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var unsupportedURL: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.unsupportedURL)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var cannotCloseFile: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.cannotCloseFile)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var dnsLookupFailed: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.dnsLookupFailed)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileIsDirectory: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.fileIsDirectory)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var cannotCreateFile: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.cannotCreateFile)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var cannotRemoveFile: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.cannotRemoveFile)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var fileDoesNotExist: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.fileDoesNotExist)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var zeroByteResource: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.zeroByteResource)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var badServerResponse: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.badServerResponse)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var cannotWriteToFile: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.cannotWriteToFile)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var cannotConnectToHost: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.cannotConnectToHost)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var cannotDecodeRawData: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.cannotDecodeRawData)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var cannotParseResponse: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.cannotParseResponse)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var resourceUnavailable: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.resourceUnavailable)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var httpTooManyRedirects: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.httpTooManyRedirects)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var cannotLoadFromNetwork: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.cannotLoadFromNetwork)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var networkConnectionLost: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.networkConnectionLost)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var notConnectedToInternet: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.notConnectedToInternet)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var secureConnectionFailed: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.secureConnectionFailed)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var cannotDecodeContentData: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.cannotDecodeContentData)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var internationalRoamingOff: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.internationalRoamingOff)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var noPermissionsToReadFile: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.noPermissionsToReadFile)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var dataLengthExceedsMaximum: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.dataLengthExceedsMaximum)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var clientCertificateRejected: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.clientCertificateRejected)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var clientCertificateRequired: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.clientCertificateRequired)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var requestBodyStreamExhausted: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.requestBodyStreamExhausted)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var serverCertificateUntrusted: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.serverCertificateUntrusted)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var userAuthenticationRequired: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.userAuthenticationRequired)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var serverCertificateHasBadDate: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.serverCertificateHasBadDate)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var userCancelledAuthentication: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.userCancelledAuthentication)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var serverCertificateNotYetValid: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.serverCertificateNotYetValid)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var redirectToNonExistentLocation: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.redirectToNonExistentLocation)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var downloadDecodingFailedMidStream: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.downloadDecodingFailedMidStream)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var serverCertificateHasUnknownRoot: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.serverCertificateHasUnknownRoot)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var backgroundSessionWasDisconnected: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.backgroundSessionWasDisconnected)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var downloadDecodingFailedToComplete: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.downloadDecodingFailedToComplete)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var backgroundSessionInUseByAnotherProcess: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.backgroundSessionInUseByAnotherProcess)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var backgroundSessionRequiresSharedContainer: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.backgroundSessionRequiresSharedContainer)
      }
    }

    @available(macOS, introduced: 10.11)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 9.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var appTransportSecurityRequiresSecureConnection: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.appTransportSecurityRequiresSecureConnection)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var badURL: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.badURL)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var unknown: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.unknown)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc public var rawValue: Int {
      get {
        wrappedInstance.rawValue
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var timedOut: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.timedOut)
      }
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc static public var cancelled: URLErrorWrapper.CodeWrapper {
      get {
        CodeWrapper(URLError.Code.cancelled)
      }
    }

    init(_ wrappedInstance: URLError.Code) {
      self.wrappedInstance = wrappedInstance
    }

    @available(macOS, introduced: 10.10)
    @available(watchOS, introduced: 2.0)
    @available(iOS, introduced: 8.0)
    @available(tvOS, introduced: 9.0)
    @objc init(rawValue: Int) {
      wrappedInstance = URLError.Code(rawValue: rawValue)
    }

  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class IndexPathWrapper: NSObject {
  var wrappedInstance: IndexPath

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var count: Int {
    get {
      wrappedInstance.count
    }
  }

  @objc public var underestimatedCount: Int {
    get {
      wrappedInstance.underestimatedCount
    }
  }

  @objc public var isEmpty: Bool {
    get {
      wrappedInstance.isEmpty
    }
  }

  init(_ wrappedInstance: IndexPath) {
    self.wrappedInstance = wrappedInstance
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc init(index: IndexPath.Element) {
    wrappedInstance = IndexPath(index: index)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc override init() {
    wrappedInstance = IndexPath()
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func append(_ other: IndexPath.Element) {
    return wrappedInstance.append(other)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func dropLast() -> IndexPathWrapper {
    let result = wrappedInstance.dropLast()
    return IndexPathWrapper(result)
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public func appending(_ other: IndexPath.Element) -> IndexPathWrapper {
    let result = wrappedInstance.appending(other)
    return IndexPathWrapper(result)
  }

  @objc public func removeLast(_ k: Int) {
    return wrappedInstance.removeLast(k)
  }

  @objc public func reverse() {
    return wrappedInstance.reverse()
  }

  @objc public func sort() {
    return wrappedInstance.sort()
  }

  @objc public func shuffle() {
    return wrappedInstance.shuffle()
  }

  @objc public func removeFirst(_ k: Int) {
    return wrappedInstance.removeFirst(k)
  }

}

@available(macOS, introduced: 10.10)
@available(watchOS, introduced: 2.0)
@available(iOS, introduced: 8.0)
@available(tvOS, introduced: 9.0)
@objc public class MachErrorWrapper: NSObject {
  var wrappedInstance: MachError

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var errorDomain: String {
    get {
      MachError.errorDomain
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc static public var errorDomain: String {
    get {
      MachError.errorDomain
    }
  }

  @available(macOS, introduced: 10.10)
  @available(watchOS, introduced: 2.0)
  @available(iOS, introduced: 8.0)
  @available(tvOS, introduced: 9.0)
  @objc public var localizedDescription: String {
    get {
      wrappedInstance.localizedDescription
    }
  }

  init(_ wrappedInstance: MachError) {
    self.wrappedInstance = wrappedInstance
  }

}

@available(macOS, introduced: 14)
@available(watchOS, introduced: 10)
@available(iOS, introduced: 17)
@available(tvOS, introduced: 17)
@objc public class PredicateWrapper: NSObject {
  var wrappedInstance: Predicate

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var description: String {
    get {
      wrappedInstance.description
    }
  }

  @available(macOS, introduced: 14.4)
  @available(watchOS, introduced: 10.4)
  @available(iOS, introduced: 17.4)
  @available(tvOS, introduced: 17.4)
  @objc public var debugDescription: String {
    get {
      wrappedInstance.debugDescription
    }
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc static public var `true`: PredicateWrapper {
    get {
      PredicateWrapper(Predicate.`true`)
    }
  }

  @available(macOS, introduced: 14)
  @available(watchOS, introduced: 10)
  @available(iOS, introduced: 17)
  @available(tvOS, introduced: 17)
  @objc static public var `false`: PredicateWrapper {
    get {
      PredicateWrapper(Predicate.`false`)
    }
  }

  init(_ wrappedInstance: Predicate) {
    self.wrappedInstance = wrappedInstance
  }

}

@objc public class BoolWrapper: NSObject {
  var wrappedInstance: Bool

  init(_ wrappedInstance: Bool) {
    self.wrappedInstance = wrappedInstance
  }

}

