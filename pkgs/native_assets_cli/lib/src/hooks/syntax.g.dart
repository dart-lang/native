// Copyright (c) 2025, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// This file is generated, do not edit.
// File generated by pkgs/hooks/tool/generate_syntax.dart.
// Must be rerun when pkgs/hooks/doc/schema/ is modified.

// ignore_for_file: unused_element

import 'dart:io';

class Asset extends JsonObject {
  factory Asset.fromJson(
    Map<String, Object?> json, {
    List<Object> path = const [],
  }) {
    final result = Asset._fromJson(json, path: path);
    if (result.isHooksMetadataAsset) {
      return result.asHooksMetadataAsset;
    }
    return result;
  }

  Asset._fromJson(super.json, {super.path = const []}) : super.fromJson();

  Asset({required JsonObject? encoding, required String type}) : super() {
    _encoding = encoding;
    _type = type;
    json.sortOnKey();
  }

  JsonObject? get encoding {
    final jsonValue = _reader.optionalMap('encoding');
    if (jsonValue == null) return null;
    return JsonObject.fromJson(jsonValue, path: [...path, 'encoding']);
  }

  set _encoding(JsonObject? value) {
    json.setOrRemove('encoding', value?.json);
  }

  List<String> _validateEncoding() {
    final mapErrors = _reader.validate<Map<String, Object?>?>('encoding');
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    return encoding?.validate() ?? [];
  }

  String get type => _reader.get<String>('type');

  set _type(String value) {
    json.setOrRemove('type', value);
  }

  List<String> _validateType() => _reader.validate<String>('type');

  @override
  List<String> validate() => [
    ...super.validate(),
    ..._validateEncoding(),
    ..._validateType(),
    ..._validateExtraRules(),
  ];

  List<String> _validateExtraRules() {
    final result = <String>[];
    if (_reader.tryTraverse(['type']) == 'hooks/metadata') {
      final objectErrors = _reader.validate<Map<String, Object?>?>('encoding');
      result.addAll(objectErrors);
      if (objectErrors.isEmpty) {
        final jsonValue = _reader.get<Map<String, Object?>?>('encoding');
        if (jsonValue != null) {
          final reader = JsonReader(jsonValue, [...path, 'encoding']);
          result.addAll(reader.validate<Object>('key'));
        }
      }
    }
    return result;
  }

  @override
  String toString() => 'Asset($json)';
}

class BuildConfig extends Config {
  BuildConfig.fromJson(super.json, {super.path}) : super.fromJson();

  BuildConfig({
    required super.buildAssetTypes,
    required super.extensions,
    required bool linkingEnabled,
  }) : super() {
    _linkingEnabled = linkingEnabled;
    json.sortOnKey();
  }

  /// Setup all fields for [BuildConfig] that are not in
  /// [Config].
  void setup({required bool linkingEnabled}) {
    _linkingEnabled = linkingEnabled;
    json.sortOnKey();
  }

  bool get linkingEnabled => _reader.get<bool>('linking_enabled');

  set _linkingEnabled(bool value) {
    json.setOrRemove('linking_enabled', value);
  }

  List<String> _validateLinkingEnabled() =>
      _reader.validate<bool>('linking_enabled');

  @override
  List<String> validate() => [
    ...super.validate(),
    ..._validateLinkingEnabled(),
  ];

  @override
  String toString() => 'BuildConfig($json)';
}

class BuildInput extends HookInput {
  BuildInput.fromJson(super.json, {super.path}) : super.fromJson();

  BuildInput({
    required Map<String, List<Asset>>? assets,
    required BuildConfig config,
    required Map<String, Map<String, Object?>>? dependencyMetadata,
    required super.outDir,
    required super.outDirShared,
    required super.outFile,
    required super.packageName,
    required super.packageRoot,
    required super.userDefines,
    required super.version,
  }) : super(config: config) {
    _assets = assets;
    _dependencyMetadata = dependencyMetadata;
    json.sortOnKey();
  }

  /// Setup all fields for [BuildInput] that are not in
  /// [HookInput].
  void setup({
    required Map<String, List<Asset>>? assets,
    required Map<String, Map<String, Object?>>? dependencyMetadata,
  }) {
    _assets = assets;
    _dependencyMetadata = dependencyMetadata;
    json.sortOnKey();
  }

  Map<String, List<Asset>>? get assets {
    final jsonValue = _reader.optionalMap('assets');
    if (jsonValue == null) {
      return null;
    }
    final result = <String, List<Asset>>{};
    for (final MapEntry(:key, :value) in jsonValue.entries) {
      result[key] = [
        for (final (index, item) in (value as List<Object?>).indexed)
          Asset.fromJson(
            item as Map<String, Object?>,
            path: [...path, key, index],
          ),
      ];
    }
    return result;
  }

  set _assets(Map<String, List<Asset>>? value) {
    if (value == null) {
      json.remove('assets');
    } else {
      json['assets'] = {
        for (final MapEntry(:key, :value) in value.entries)
          key: [for (final item in value) item.json],
      };
    }
  }

  List<String> _validateAssets() {
    final mapErrors = _reader.validateOptionalMap('assets');
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    final jsonValue = _reader.optionalMap('assets');
    if (jsonValue == null) {
      return [];
    }
    final result = <String>[];
    for (final list in assets!.values) {
      for (final element in list) {
        result.addAll(element.validate());
      }
    }
    return result;
  }

  @override
  BuildConfig get config {
    final jsonValue = _reader.map$('config');
    return BuildConfig.fromJson(jsonValue, path: [...path, 'config']);
  }

  Map<String, Map<String, Object?>>? get dependencyMetadata =>
      _reader.optionalMap<Map<String, Object?>>('dependency_metadata');

  set _dependencyMetadata(Map<String, Map<String, Object?>>? value) {
    json.setOrRemove('dependency_metadata', value);
  }

  List<String> _validateDependencyMetadata() =>
      _reader.validateOptionalMap<Map<String, Object?>>('dependency_metadata');

  @override
  List<String> validate() => [
    ...super.validate(),
    ..._validateAssets(),
    ..._validateConfig(),
    ..._validateDependencyMetadata(),
  ];

  @override
  String toString() => 'BuildInput($json)';
}

class BuildOutput extends HookOutput {
  BuildOutput.fromJson(super.json, {super.path}) : super.fromJson();

  BuildOutput({
    required super.assets,
    required List<Asset>? assetsForBuild,
    required Map<String, List<Asset>>? assetsForLinking,
    required Map<String, List<Asset>>? assetsForLinkingOld,
    required super.dependencies,
    required JsonObject? metadata,
    required super.timestamp,
    required super.version,
  }) : super() {
    this.assetsForLinkingOld = assetsForLinkingOld;
    this.assetsForBuild = assetsForBuild;
    this.assetsForLinking = assetsForLinking;
    this.metadata = metadata;
    json.sortOnKey();
  }

  /// Setup all fields for [BuildOutput] that are not in
  /// [HookOutput].
  void setup({
    required Map<String, List<Asset>>? assetsForLinkingOld,
    required List<Asset>? assetsForBuild,
    required Map<String, List<Asset>>? assetsForLinking,
    required JsonObject? metadata,
  }) {
    this.assetsForLinkingOld = assetsForLinkingOld;
    this.assetsForBuild = assetsForBuild;
    this.assetsForLinking = assetsForLinking;
    this.metadata = metadata;
    json.sortOnKey();
  }

  Map<String, List<Asset>>? get assetsForLinkingOld {
    final jsonValue = _reader.optionalMap('assetsForLinking');
    if (jsonValue == null) {
      return null;
    }
    final result = <String, List<Asset>>{};
    for (final MapEntry(:key, :value) in jsonValue.entries) {
      result[key] = [
        for (final (index, item) in (value as List<Object?>).indexed)
          Asset.fromJson(
            item as Map<String, Object?>,
            path: [...path, key, index],
          ),
      ];
    }
    return result;
  }

  set assetsForLinkingOld(Map<String, List<Asset>>? value) {
    if (value == null) {
      json.remove('assetsForLinking');
    } else {
      json['assetsForLinking'] = {
        for (final MapEntry(:key, :value) in value.entries)
          key: [for (final item in value) item.json],
      };
    }
    json.sortOnKey();
  }

  List<String> _validateAssetsForLinkingOld() {
    final mapErrors = _reader.validateOptionalMap('assetsForLinking');
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    final jsonValue = _reader.optionalMap('assetsForLinking');
    if (jsonValue == null) {
      return [];
    }
    final result = <String>[];
    for (final list in assetsForLinkingOld!.values) {
      for (final element in list) {
        result.addAll(element.validate());
      }
    }
    return result;
  }

  List<Asset>? get assetsForBuild {
    final jsonValue = _reader.optionalList('assets_for_build');
    if (jsonValue == null) return null;
    return [
      for (final (index, element) in jsonValue.indexed)
        Asset.fromJson(
          element as Map<String, Object?>,
          path: [...path, 'assets_for_build', index],
        ),
    ];
  }

  set assetsForBuild(List<Asset>? value) {
    if (value == null) {
      json.remove('assets_for_build');
    } else {
      json['assets_for_build'] = [for (final item in value) item.json];
    }
    json.sortOnKey();
  }

  List<String> _validateAssetsForBuild() {
    final listErrors = _reader.validateOptionalList<Map<String, Object?>>(
      'assets_for_build',
    );
    if (listErrors.isNotEmpty) {
      return listErrors;
    }
    final elements = assetsForBuild;
    if (elements == null) {
      return [];
    }
    return [for (final element in elements) ...element.validate()];
  }

  Map<String, List<Asset>>? get assetsForLinking {
    final jsonValue = _reader.optionalMap('assets_for_linking');
    if (jsonValue == null) {
      return null;
    }
    final result = <String, List<Asset>>{};
    for (final MapEntry(:key, :value) in jsonValue.entries) {
      result[key] = [
        for (final (index, item) in (value as List<Object?>).indexed)
          Asset.fromJson(
            item as Map<String, Object?>,
            path: [...path, key, index],
          ),
      ];
    }
    return result;
  }

  set assetsForLinking(Map<String, List<Asset>>? value) {
    if (value == null) {
      json.remove('assets_for_linking');
    } else {
      json['assets_for_linking'] = {
        for (final MapEntry(:key, :value) in value.entries)
          key: [for (final item in value) item.json],
      };
    }
    json.sortOnKey();
  }

  List<String> _validateAssetsForLinking() {
    final mapErrors = _reader.validateOptionalMap('assets_for_linking');
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    final jsonValue = _reader.optionalMap('assets_for_linking');
    if (jsonValue == null) {
      return [];
    }
    final result = <String>[];
    for (final list in assetsForLinking!.values) {
      for (final element in list) {
        result.addAll(element.validate());
      }
    }
    return result;
  }

  JsonObject? get metadata {
    final jsonValue = _reader.optionalMap('metadata');
    if (jsonValue == null) return null;
    return JsonObject.fromJson(jsonValue, path: [...path, 'metadata']);
  }

  set metadata(JsonObject? value) {
    json.setOrRemove('metadata', value?.json);
    json.sortOnKey();
  }

  List<String> _validateMetadata() {
    final mapErrors = _reader.validate<Map<String, Object?>?>('metadata');
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    return metadata?.validate() ?? [];
  }

  @override
  List<String> validate() => [
    ...super.validate(),
    ..._validateAssetsForLinkingOld(),
    ..._validateAssetsForBuild(),
    ..._validateAssetsForLinking(),
    ..._validateMetadata(),
  ];

  @override
  String toString() => 'BuildOutput($json)';
}

class Config extends JsonObject {
  Config.fromJson(super.json, {super.path = const []}) : super.fromJson();

  Config({
    required List<String> buildAssetTypes,
    required JsonObject? extensions,
  }) : super() {
    this.buildAssetTypes = buildAssetTypes;
    this.extensions = extensions;
    json.sortOnKey();
  }

  List<String> get buildAssetTypes => _reader.stringList('build_asset_types');

  set buildAssetTypes(List<String> value) {
    json['build_asset_types'] = value;
    json.sortOnKey();
  }

  List<String> _validateBuildAssetTypes() =>
      _reader.validateStringList('build_asset_types');

  JsonObject? get extensions {
    final jsonValue = _reader.optionalMap('extensions');
    if (jsonValue == null) return null;
    return JsonObject.fromJson(jsonValue, path: [...path, 'extensions']);
  }

  set extensions(JsonObject? value) {
    json.setOrRemove('extensions', value?.json);
    json.sortOnKey();
  }

  List<String> _validateExtensions() {
    final mapErrors = _reader.validate<Map<String, Object?>?>('extensions');
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    return extensions?.validate() ?? [];
  }

  @override
  List<String> validate() => [
    ...super.validate(),
    ..._validateBuildAssetTypes(),
    ..._validateExtensions(),
  ];

  @override
  String toString() => 'Config($json)';
}

class HookInput extends JsonObject {
  HookInput.fromJson(super.json, {super.path = const []}) : super.fromJson();

  HookInput({
    required Config config,
    required Uri outDir,
    required Uri outDirShared,
    required Uri? outFile,
    required String packageName,
    required Uri packageRoot,
    required JsonObject? userDefines,
    required String? version,
  }) : super() {
    this.config = config;
    this.outDir = outDir;
    this.outDirShared = outDirShared;
    this.outFile = outFile;
    this.packageName = packageName;
    this.packageRoot = packageRoot;
    this.userDefines = userDefines;
    this.version = version;
    json.sortOnKey();
  }

  Config get config {
    final jsonValue = _reader.map$('config');
    return Config.fromJson(jsonValue, path: [...path, 'config']);
  }

  set config(Config value) {
    json['config'] = value.json;
    json.sortOnKey();
  }

  List<String> _validateConfig() {
    final mapErrors = _reader.validate<Map<String, Object?>>('config');
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    return config.validate();
  }

  Uri get outDir => _reader.path$('out_dir');

  set outDir(Uri value) {
    json['out_dir'] = value.toFilePath();
    json.sortOnKey();
  }

  List<String> _validateOutDir() => _reader.validatePath('out_dir');

  Uri get outDirShared => _reader.path$('out_dir_shared');

  set outDirShared(Uri value) {
    json['out_dir_shared'] = value.toFilePath();
    json.sortOnKey();
  }

  List<String> _validateOutDirShared() =>
      _reader.validatePath('out_dir_shared');

  Uri? get outFile => _reader.optionalPath('out_file');

  set outFile(Uri? value) {
    json.setOrRemove('out_file', value?.toFilePath());
    json.sortOnKey();
  }

  List<String> _validateOutFile() => _reader.validateOptionalPath('out_file');

  String get packageName => _reader.get<String>('package_name');

  set packageName(String value) {
    json.setOrRemove('package_name', value);
    json.sortOnKey();
  }

  List<String> _validatePackageName() =>
      _reader.validate<String>('package_name');

  Uri get packageRoot => _reader.path$('package_root');

  set packageRoot(Uri value) {
    json['package_root'] = value.toFilePath();
    json.sortOnKey();
  }

  List<String> _validatePackageRoot() => _reader.validatePath('package_root');

  JsonObject? get userDefines {
    final jsonValue = _reader.optionalMap('user_defines');
    if (jsonValue == null) return null;
    return JsonObject.fromJson(jsonValue, path: [...path, 'user_defines']);
  }

  set userDefines(JsonObject? value) {
    json.setOrRemove('user_defines', value?.json);
    json.sortOnKey();
  }

  List<String> _validateUserDefines() {
    final mapErrors = _reader.validate<Map<String, Object?>?>('user_defines');
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    return userDefines?.validate() ?? [];
  }

  String? get version => _reader.get<String?>('version');

  set version(String? value) {
    json.setOrRemove('version', value);
    json.sortOnKey();
  }

  List<String> _validateVersion() => _reader.validate<String?>('version');

  @override
  List<String> validate() => [
    ...super.validate(),
    ..._validateConfig(),
    ..._validateOutDir(),
    ..._validateOutDirShared(),
    ..._validateOutFile(),
    ..._validatePackageName(),
    ..._validatePackageRoot(),
    ..._validateUserDefines(),
    ..._validateVersion(),
  ];

  @override
  String toString() => 'HookInput($json)';
}

class HookOutput extends JsonObject {
  HookOutput.fromJson(super.json, {super.path = const []}) : super.fromJson();

  HookOutput({
    required List<Asset>? assets,
    required List<Uri>? dependencies,
    required String timestamp,
    required String? version,
  }) : super() {
    this.assets = assets;
    this.dependencies = dependencies;
    this.timestamp = timestamp;
    this.version = version;
    json.sortOnKey();
  }

  List<Asset>? get assets {
    final jsonValue = _reader.optionalList('assets');
    if (jsonValue == null) return null;
    return [
      for (final (index, element) in jsonValue.indexed)
        Asset.fromJson(
          element as Map<String, Object?>,
          path: [...path, 'assets', index],
        ),
    ];
  }

  set assets(List<Asset>? value) {
    if (value == null) {
      json.remove('assets');
    } else {
      json['assets'] = [for (final item in value) item.json];
    }
    json.sortOnKey();
  }

  List<String> _validateAssets() {
    final listErrors = _reader.validateOptionalList<Map<String, Object?>>(
      'assets',
    );
    if (listErrors.isNotEmpty) {
      return listErrors;
    }
    final elements = assets;
    if (elements == null) {
      return [];
    }
    return [for (final element in elements) ...element.validate()];
  }

  List<Uri>? get dependencies => _reader.optionalPathList('dependencies');

  set dependencies(List<Uri>? value) {
    json.setOrRemove('dependencies', value?.toJson());
    json.sortOnKey();
  }

  List<String> _validateDependencies() =>
      _reader.validateOptionalPathList('dependencies');

  String get timestamp => _reader.get<String>('timestamp');

  set timestamp(String value) {
    json.setOrRemove('timestamp', value);
    json.sortOnKey();
  }

  List<String> _validateTimestamp() => _reader.validate<String>('timestamp');

  String? get version => _reader.get<String?>('version');

  set version(String? value) {
    json.setOrRemove('version', value);
    json.sortOnKey();
  }

  List<String> _validateVersion() => _reader.validate<String?>('version');

  @override
  List<String> validate() => [
    ...super.validate(),
    ..._validateAssets(),
    ..._validateDependencies(),
    ..._validateTimestamp(),
    ..._validateVersion(),
  ];

  @override
  String toString() => 'HookOutput($json)';
}

class HooksMetadataAsset extends Asset {
  static const typeValue = 'hooks/metadata';

  HooksMetadataAsset.fromJson(super.json, {super.path}) : super._fromJson();

  HooksMetadataAsset({required MetadataAssetEncoding encoding})
    : super(type: 'hooks/metadata', encoding: encoding);

  /// Setup all fields for [HooksMetadataAsset] that are not in
  /// [Asset].
  void setup() {}

  @override
  MetadataAssetEncoding get encoding {
    final jsonValue = _reader.map$('encoding');
    return MetadataAssetEncoding.fromJson(
      jsonValue,
      path: [...path, 'encoding'],
    );
  }

  @override
  List<String> validate() => [...super.validate(), ..._validateEncoding()];

  @override
  String toString() => 'HooksMetadataAsset($json)';
}

extension HooksMetadataAssetExtension on Asset {
  bool get isHooksMetadataAsset => type == 'hooks/metadata';

  HooksMetadataAsset get asHooksMetadataAsset =>
      HooksMetadataAsset.fromJson(json, path: path);
}

class LinkInput extends HookInput {
  LinkInput.fromJson(super.json, {super.path}) : super.fromJson();

  LinkInput({
    required List<Asset>? assets,
    required super.config,
    required super.outDir,
    required super.outDirShared,
    required super.outFile,
    required super.packageName,
    required super.packageRoot,
    required Uri? resourceIdentifiers,
    required super.userDefines,
    required super.version,
  }) : super() {
    _assets = assets;
    _resourceIdentifiers = resourceIdentifiers;
    json.sortOnKey();
  }

  /// Setup all fields for [LinkInput] that are not in
  /// [HookInput].
  void setup({
    required List<Asset>? assets,
    required Uri? resourceIdentifiers,
  }) {
    _assets = assets;
    _resourceIdentifiers = resourceIdentifiers;
    json.sortOnKey();
  }

  List<Asset>? get assets {
    final jsonValue = _reader.optionalList('assets');
    if (jsonValue == null) return null;
    return [
      for (final (index, element) in jsonValue.indexed)
        Asset.fromJson(
          element as Map<String, Object?>,
          path: [...path, 'assets', index],
        ),
    ];
  }

  set _assets(List<Asset>? value) {
    if (value == null) {
      json.remove('assets');
    } else {
      json['assets'] = [for (final item in value) item.json];
    }
  }

  List<String> _validateAssets() {
    final listErrors = _reader.validateOptionalList<Map<String, Object?>>(
      'assets',
    );
    if (listErrors.isNotEmpty) {
      return listErrors;
    }
    final elements = assets;
    if (elements == null) {
      return [];
    }
    return [for (final element in elements) ...element.validate()];
  }

  Uri? get resourceIdentifiers => _reader.optionalPath('resource_identifiers');

  set _resourceIdentifiers(Uri? value) {
    json.setOrRemove('resource_identifiers', value?.toFilePath());
  }

  List<String> _validateResourceIdentifiers() =>
      _reader.validateOptionalPath('resource_identifiers');

  @override
  List<String> validate() => [
    ...super.validate(),
    ..._validateAssets(),
    ..._validateResourceIdentifiers(),
  ];

  @override
  String toString() => 'LinkInput($json)';
}

class LinkOutput extends HookOutput {
  LinkOutput.fromJson(super.json, {super.path}) : super.fromJson();

  LinkOutput({
    required super.assets,
    required super.dependencies,
    required super.timestamp,
    required super.version,
  }) : super();

  @override
  List<String> validate() => [...super.validate()];

  @override
  String toString() => 'LinkOutput($json)';
}

class MetadataAssetEncoding extends JsonObject {
  MetadataAssetEncoding.fromJson(super.json, {super.path = const []})
    : super.fromJson();

  MetadataAssetEncoding({required String key, required Object? value})
    : super() {
    _key = key;
    _value = value;
    json.sortOnKey();
  }

  String get key => _reader.get<String>('key');

  set _key(String value) {
    json.setOrRemove('key', value);
  }

  List<String> _validateKey() => _reader.validate<String>('key');

  Object? get value => _reader.get<Object?>('value');

  set _value(Object? value) {
    json.setOrRemove('value', value);
  }

  List<String> _validateValue() => _reader.validate<Object?>('value');

  @override
  List<String> validate() => [
    ...super.validate(),
    ..._validateKey(),
    ..._validateValue(),
  ];

  @override
  String toString() => 'MetadataAssetEncoding($json)';
}

class JsonObject {
  final Map<String, Object?> json;

  final List<Object> path;

  JsonReader get _reader => JsonReader(json, path);

  JsonObject() : json = {}, path = const [];

  JsonObject.fromJson(this.json, {this.path = const []});

  List<String> validate() => [];
}

class JsonReader {
  /// The JSON Object this reader is reading.
  final Map<String, Object?> json;

  /// The path traversed by readers of the surrounding JSON.
  ///
  /// Contains [String] property keys and [int] indices.
  ///
  /// This is used to give more precise error messages.
  final List<Object> path;

  JsonReader(this.json, this.path);

  T get<T extends Object?>(String key) {
    final value = json[key];
    if (value is T) return value;
    throwFormatException(value, T, [key]);
  }

  List<String> validate<T extends Object?>(String key) {
    final value = json[key];
    if (value is T) return [];
    return [
      errorString(value, T, [key]),
    ];
  }

  List<T> list<T extends Object?>(String key) =>
      _castList<T>(get<List<Object?>>(key), key);

  List<String> validateList<T extends Object?>(String key) {
    final listErrors = validate<List<Object?>>(key);
    if (listErrors.isNotEmpty) {
      return listErrors;
    }
    return _validateListElements(get<List<Object?>>(key), key);
  }

  List<T>? optionalList<T extends Object?>(String key) =>
      switch (get<List<Object?>?>(key)?.cast<T>()) {
        null => null,
        final l => _castList<T>(l, key),
      };

  List<String> validateOptionalList<T extends Object?>(String key) {
    final listErrors = validate<List<Object?>?>(key);
    if (listErrors.isNotEmpty) {
      return listErrors;
    }
    final list = get<List<Object?>?>(key);
    if (list == null) {
      return [];
    }
    return _validateListElements(list, key);
  }

  /// [List.cast] but with [FormatException]s.
  List<T> _castList<T extends Object?>(List<Object?> list, String key) {
    for (final (index, value) in list.indexed) {
      if (value is! T) {
        throwFormatException(value, T, [key, index]);
      }
    }
    return list.cast();
  }

  List<String> _validateListElements<T extends Object?>(
    List<Object?> list,
    String key,
  ) {
    final result = <String>[];
    for (final (index, value) in list.indexed) {
      if (value is! T) {
        result.add(errorString(value, T, [key, index]));
      }
    }
    return result;
  }

  Map<String, T> map$<T extends Object?>(String key) =>
      _castMap<T>(get<Map<String, Object?>>(key), key);

  List<String> validateMap<T extends Object?>(String key) {
    final mapErrors = validate<Map<String, Object?>>(key);
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    return _validateMapElements<T>(get<Map<String, Object?>>(key), key);
  }

  Map<String, T>? optionalMap<T extends Object?>(String key) =>
      switch (get<Map<String, Object?>?>(key)) {
        null => null,
        final m => _castMap<T>(m, key),
      };

  List<String> validateOptionalMap<T extends Object?>(String key) {
    final mapErrors = validate<Map<String, Object?>?>(key);
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    final map = get<Map<String, Object?>?>(key);
    if (map == null) {
      return [];
    }
    return _validateMapElements<T>(map, key);
  }

  /// [Map.cast] but with [FormatException]s.
  Map<String, T> _castMap<T extends Object?>(
    Map<String, Object?> map_,
    String parentKey,
  ) {
    for (final MapEntry(:key, :value) in map_.entries) {
      if (value is! T) {
        throwFormatException(value, T, [parentKey, key]);
      }
    }
    return map_.cast();
  }

  List<String> _validateMapElements<T extends Object?>(
    Map<String, Object?> map_,
    String parentKey,
  ) {
    final result = <String>[];
    for (final MapEntry(:key, :value) in map_.entries) {
      if (value is! T) {
        result.add(errorString(value, T, [parentKey, key]));
      }
    }
    return result;
  }

  List<String>? optionalStringList(String key) => optionalList<String>(key);

  List<String> validateOptionalStringList(String key) =>
      validateOptionalList<String>(key);

  List<String> stringList(String key) => list<String>(key);

  List<String> validateStringList(String key) => validateList<String>(key);

  Uri path$(String key) => _fileSystemPathToUri(get<String>(key));

  List<String> validatePath(String key) => validate<String>(key);

  Uri? optionalPath(String key) {
    final value = get<String?>(key);
    if (value == null) return null;
    return _fileSystemPathToUri(value);
  }

  List<String> validateOptionalPath(String key) => validate<String?>(key);

  List<Uri>? optionalPathList(String key) {
    final strings = optionalStringList(key);
    if (strings == null) {
      return null;
    }
    return [for (final string in strings) _fileSystemPathToUri(string)];
  }

  List<String> validateOptionalPathList(String key) =>
      validateOptionalStringList(key);

  static Uri _fileSystemPathToUri(String path) {
    if (path.endsWith(Platform.pathSeparator)) {
      return Uri.directory(path);
    }
    return Uri.file(path);
  }

  String _jsonPathToString(List<Object> pathEnding) =>
      [...path, ...pathEnding].join('.');

  Never throwFormatException(
    Object? value,
    Type expectedType,
    List<Object> pathExtension,
  ) {
    throw FormatException(errorString(value, expectedType, pathExtension));
  }

  String errorString(
    Object? value,
    Type expectedType,
    List<Object> pathExtension,
  ) {
    final pathString = _jsonPathToString(pathExtension);
    if (value == null) {
      return "No value was provided for '$pathString'."
          ' Expected a $expectedType.';
    }
    return "Unexpected value '$value' (${value.runtimeType}) for '$pathString'."
        ' Expected a $expectedType.';
  }

  /// Traverses a JSON path, returns `null` if the path cannot be traversed.
  Object? tryTraverse(List<String> path) {
    Object? json = this.json;
    for (final key in path) {
      if (json is! Map<String, Object?>) {
        return null;
      }
      json = json[key];
    }
    return json;
  }
}

extension on Map<String, Object?> {
  void setOrRemove(String key, Object? value) {
    if (value == null) {
      remove(key);
    } else {
      this[key] = value;
    }
  }
}

extension on List<Uri> {
  List<String> toJson() => [for (final uri in this) uri.toFilePath()];
}

extension<K extends Comparable<K>, V extends Object?> on Map<K, V> {
  void sortOnKey() {
    final result = <K, V>{};
    final keysSorted = keys.toList()..sort();
    for (final key in keysSorted) {
      result[key] = this[key] as V;
    }
    clear();
    addAll(result);
  }
}
