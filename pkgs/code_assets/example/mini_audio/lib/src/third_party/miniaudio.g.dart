// This is free and unencumbered software released into the public domain.
//
// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
// software, either in source code form or as a compiled binary, for any purpose,
// commercial or non-commercial, and by any means.
//
// In jurisdictions that recognize copyright laws, the author or authors of this
// software dedicate any and all copyright interest in the software to the public
// domain. We make this dedication for the benefit of the public at large and to
// the detriment of our heirs and successors. We intend this dedication to be an
// overt act of relinquishment in perpetuity of all present and future rights to
// this software under copyright law.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// For more information, please refer to <http://unlicense.org/>

// ignore_for_file: unused_field

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

@ffi.Native<
  ffi.Int Function(ffi.Pointer<ma_engine_config>, ffi.Pointer<ma_engine>)
>(symbol: 'ma_engine_init')
external int _ma_engine_init(
  ffi.Pointer<ma_engine_config> pConfig,
  ffi.Pointer<ma_engine> pEngine,
);

ma_result ma_engine_init(
  ffi.Pointer<ma_engine_config> pConfig,
  ffi.Pointer<ma_engine> pEngine,
) => ma_result.fromValue(_ma_engine_init(pConfig, pEngine));

@ffi.Native<ffi.Void Function(ffi.Pointer<ma_engine>)>()
external void ma_engine_uninit(ffi.Pointer<ma_engine> pEngine);

@ffi.Native<
  ffi.Int Function(
    ffi.Pointer<ma_engine>,
    ffi.Pointer<ffi.Char>,
    ffi.Pointer<ma_sound>,
  )
>(symbol: 'ma_engine_play_sound')
external int _ma_engine_play_sound(
  ffi.Pointer<ma_engine> pEngine,
  ffi.Pointer<ffi.Char> pFilePath,
  ffi.Pointer<ma_sound> pGroup,
);

ma_result ma_engine_play_sound(
  ffi.Pointer<ma_engine> pEngine,
  ffi.Pointer<ffi.Char> pFilePath,
  ffi.Pointer<ma_sound> pGroup,
) => ma_result.fromValue(_ma_engine_play_sound(pEngine, pFilePath, pGroup));

final class ma_device extends ffi.Opaque {}

enum ma_result {
  MA_SUCCESS(0),
  MA_ERROR(-1),
  MA_INVALID_ARGS(-2),
  MA_INVALID_OPERATION(-3),
  MA_OUT_OF_MEMORY(-4),
  MA_OUT_OF_RANGE(-5),
  MA_ACCESS_DENIED(-6),
  MA_DOES_NOT_EXIST(-7),
  MA_ALREADY_EXISTS(-8),
  MA_TOO_MANY_OPEN_FILES(-9),
  MA_INVALID_FILE(-10),
  MA_TOO_BIG(-11),
  MA_PATH_TOO_LONG(-12),
  MA_NAME_TOO_LONG(-13),
  MA_NOT_DIRECTORY(-14),
  MA_IS_DIRECTORY(-15),
  MA_DIRECTORY_NOT_EMPTY(-16),
  MA_AT_END(-17),
  MA_NO_SPACE(-18),
  MA_BUSY(-19),
  MA_IO_ERROR(-20),
  MA_INTERRUPT(-21),
  MA_UNAVAILABLE(-22),
  MA_ALREADY_IN_USE(-23),
  MA_BAD_ADDRESS(-24),
  MA_BAD_SEEK(-25),
  MA_BAD_PIPE(-26),
  MA_DEADLOCK(-27),
  MA_TOO_MANY_LINKS(-28),
  MA_NOT_IMPLEMENTED(-29),
  MA_NO_MESSAGE(-30),
  MA_BAD_MESSAGE(-31),
  MA_NO_DATA_AVAILABLE(-32),
  MA_INVALID_DATA(-33),
  MA_TIMEOUT(-34),
  MA_NO_NETWORK(-35),
  MA_NOT_UNIQUE(-36),
  MA_NOT_SOCKET(-37),
  MA_NO_ADDRESS(-38),
  MA_BAD_PROTOCOL(-39),
  MA_PROTOCOL_UNAVAILABLE(-40),
  MA_PROTOCOL_NOT_SUPPORTED(-41),
  MA_PROTOCOL_FAMILY_NOT_SUPPORTED(-42),
  MA_ADDRESS_FAMILY_NOT_SUPPORTED(-43),
  MA_SOCKET_NOT_SUPPORTED(-44),
  MA_CONNECTION_RESET(-45),
  MA_ALREADY_CONNECTED(-46),
  MA_NOT_CONNECTED(-47),
  MA_CONNECTION_REFUSED(-48),
  MA_NO_HOST(-49),
  MA_IN_PROGRESS(-50),
  MA_CANCELLED(-51),
  MA_MEMORY_ALREADY_MAPPED(-52),
  MA_CRC_MISMATCH(-100),
  MA_FORMAT_NOT_SUPPORTED(-200),
  MA_DEVICE_TYPE_NOT_SUPPORTED(-201),
  MA_SHARE_MODE_NOT_SUPPORTED(-202),
  MA_NO_BACKEND(-203),
  MA_NO_DEVICE(-204),
  MA_API_NOT_FOUND(-205),
  MA_INVALID_DEVICE_CONFIG(-206),
  MA_LOOP(-207),
  MA_BACKEND_NOT_ENABLED(-208),
  MA_DEVICE_NOT_INITIALIZED(-300),
  MA_DEVICE_ALREADY_INITIALIZED(-301),
  MA_DEVICE_NOT_STARTED(-302),
  MA_DEVICE_NOT_STOPPED(-303),
  MA_FAILED_TO_INIT_BACKEND(-400),
  MA_FAILED_TO_OPEN_BACKEND_DEVICE(-401),
  MA_FAILED_TO_START_BACKEND_DEVICE(-402),
  MA_FAILED_TO_STOP_BACKEND_DEVICE(-403);

  final int value;
  const ma_result(this.value);

  static ma_result fromValue(int value) => switch (value) {
    0 => MA_SUCCESS,
    -1 => MA_ERROR,
    -2 => MA_INVALID_ARGS,
    -3 => MA_INVALID_OPERATION,
    -4 => MA_OUT_OF_MEMORY,
    -5 => MA_OUT_OF_RANGE,
    -6 => MA_ACCESS_DENIED,
    -7 => MA_DOES_NOT_EXIST,
    -8 => MA_ALREADY_EXISTS,
    -9 => MA_TOO_MANY_OPEN_FILES,
    -10 => MA_INVALID_FILE,
    -11 => MA_TOO_BIG,
    -12 => MA_PATH_TOO_LONG,
    -13 => MA_NAME_TOO_LONG,
    -14 => MA_NOT_DIRECTORY,
    -15 => MA_IS_DIRECTORY,
    -16 => MA_DIRECTORY_NOT_EMPTY,
    -17 => MA_AT_END,
    -18 => MA_NO_SPACE,
    -19 => MA_BUSY,
    -20 => MA_IO_ERROR,
    -21 => MA_INTERRUPT,
    -22 => MA_UNAVAILABLE,
    -23 => MA_ALREADY_IN_USE,
    -24 => MA_BAD_ADDRESS,
    -25 => MA_BAD_SEEK,
    -26 => MA_BAD_PIPE,
    -27 => MA_DEADLOCK,
    -28 => MA_TOO_MANY_LINKS,
    -29 => MA_NOT_IMPLEMENTED,
    -30 => MA_NO_MESSAGE,
    -31 => MA_BAD_MESSAGE,
    -32 => MA_NO_DATA_AVAILABLE,
    -33 => MA_INVALID_DATA,
    -34 => MA_TIMEOUT,
    -35 => MA_NO_NETWORK,
    -36 => MA_NOT_UNIQUE,
    -37 => MA_NOT_SOCKET,
    -38 => MA_NO_ADDRESS,
    -39 => MA_BAD_PROTOCOL,
    -40 => MA_PROTOCOL_UNAVAILABLE,
    -41 => MA_PROTOCOL_NOT_SUPPORTED,
    -42 => MA_PROTOCOL_FAMILY_NOT_SUPPORTED,
    -43 => MA_ADDRESS_FAMILY_NOT_SUPPORTED,
    -44 => MA_SOCKET_NOT_SUPPORTED,
    -45 => MA_CONNECTION_RESET,
    -46 => MA_ALREADY_CONNECTED,
    -47 => MA_NOT_CONNECTED,
    -48 => MA_CONNECTION_REFUSED,
    -49 => MA_NO_HOST,
    -50 => MA_IN_PROGRESS,
    -51 => MA_CANCELLED,
    -52 => MA_MEMORY_ALREADY_MAPPED,
    -100 => MA_CRC_MISMATCH,
    -200 => MA_FORMAT_NOT_SUPPORTED,
    -201 => MA_DEVICE_TYPE_NOT_SUPPORTED,
    -202 => MA_SHARE_MODE_NOT_SUPPORTED,
    -203 => MA_NO_BACKEND,
    -204 => MA_NO_DEVICE,
    -205 => MA_API_NOT_FOUND,
    -206 => MA_INVALID_DEVICE_CONFIG,
    -207 => MA_LOOP,
    -208 => MA_BACKEND_NOT_ENABLED,
    -300 => MA_DEVICE_NOT_INITIALIZED,
    -301 => MA_DEVICE_ALREADY_INITIALIZED,
    -302 => MA_DEVICE_NOT_STARTED,
    -303 => MA_DEVICE_NOT_STOPPED,
    -400 => MA_FAILED_TO_INIT_BACKEND,
    -401 => MA_FAILED_TO_OPEN_BACKEND_DEVICE,
    -402 => MA_FAILED_TO_START_BACKEND_DEVICE,
    -403 => MA_FAILED_TO_STOP_BACKEND_DEVICE,
    _ => throw ArgumentError('Unknown value for ma_result: $value'),
  };
}

final class ma_allocation_callbacks extends ffi.Struct {
  external ffi.Pointer<ffi.Void> pUserData;

  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(
        ffi.Size sz,
        ffi.Pointer<ffi.Void> pUserData,
      )
    >
  >
  onMalloc;

  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<ffi.Void> p,
        ffi.Size sz,
        ffi.Pointer<ffi.Void> pUserData,
      )
    >
  >
  onRealloc;

  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<ffi.Void> p,
        ffi.Pointer<ffi.Void> pUserData,
      )
    >
  >
  onFree;
}

final class ma_log extends ffi.Opaque {}

final class ma_vec3f extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double z;
}

final class ma_atomic_vec3f extends ffi.Struct {
  external ma_vec3f v;

  @ffi.UnsignedInt()
  external int lock;
}

enum ma_handedness {
  ma_handedness_right(0),
  ma_handedness_left(1);

  final int value;
  const ma_handedness(this.value);

  static ma_handedness fromValue(int value) => switch (value) {
    0 => ma_handedness_right,
    1 => ma_handedness_left,
    _ => throw ArgumentError('Unknown value for ma_handedness: $value'),
  };
}

final class ma_spatializer_listener_config extends ffi.Struct {
  @ffi.UnsignedInt()
  external int channelsOut;

  external ffi.Pointer<ffi.UnsignedChar> pChannelMapOut;

  @ffi.UnsignedInt()
  external int handednessAsInt;

  ma_handedness get handedness => ma_handedness.fromValue(handednessAsInt);

  @ffi.Float()
  external double coneInnerAngleInRadians;

  @ffi.Float()
  external double coneOuterAngleInRadians;

  @ffi.Float()
  external double coneOuterGain;

  @ffi.Float()
  external double speedOfSound;

  external ma_vec3f worldUp;
}

final class ma_spatializer_listener extends ffi.Struct {
  external ma_spatializer_listener_config config;

  external ma_atomic_vec3f position;

  external ma_atomic_vec3f direction;

  external ma_atomic_vec3f velocity;

  @ffi.UnsignedInt()
  external int isEnabled;

  @ffi.UnsignedInt()
  external int _ownsHeap;

  external ffi.Pointer<ffi.Void> _pHeap;
}

enum ma_mono_expansion_mode {
  ma_mono_expansion_mode_duplicate(0),
  ma_mono_expansion_mode_average(1),
  ma_mono_expansion_mode_stereo_only(2);

  static const ma_mono_expansion_mode_default =
      ma_mono_expansion_mode_duplicate;

  final int value;
  const ma_mono_expansion_mode(this.value);

  static ma_mono_expansion_mode fromValue(int value) => switch (value) {
    0 => ma_mono_expansion_mode_duplicate,
    1 => ma_mono_expansion_mode_average,
    2 => ma_mono_expansion_mode_stereo_only,
    _ => throw ArgumentError(
      'Unknown value for ma_mono_expansion_mode: $value',
    ),
  };

  @override
  String toString() {
    if (this == ma_mono_expansion_mode_duplicate)
      return "ma_mono_expansion_mode.ma_mono_expansion_mode_duplicate, ma_mono_expansion_mode.ma_mono_expansion_mode_default";
    return super.toString();
  }
}

final class ma_resource_manager extends ffi.Opaque {}

final class ma_stack extends ffi.Opaque {}

final class ma_node_vtable extends ffi.Opaque {}

final class ma_node_output_bus extends ffi.Struct {
  external ffi.Pointer<ffi.Void> pNode;

  @ffi.UnsignedChar()
  external int outputBusIndex;

  @ffi.UnsignedChar()
  external int channels;

  @ffi.UnsignedChar()
  external int inputNodeInputBusIndex;

  @ffi.UnsignedInt()
  external int flags;

  @ffi.UnsignedInt()
  external int refCount;

  @ffi.UnsignedInt()
  external int isAttached;

  @ffi.UnsignedInt()
  external int lock;

  @ffi.Float()
  external double volume;

  external ffi.Pointer<ma_node_output_bus> pNext;

  external ffi.Pointer<ma_node_output_bus> pPrev;

  external ffi.Pointer<ffi.Void> pInputNode;
}

final class ma_node_input_bus extends ffi.Struct {
  external ma_node_output_bus head;

  @ffi.UnsignedInt()
  external int nextCounter;

  @ffi.UnsignedInt()
  external int lock;

  @ffi.UnsignedChar()
  external int channels;
}

enum ma_node_state {
  ma_node_state_started(0),
  ma_node_state_stopped(1);

  final int value;
  const ma_node_state(this.value);

  static ma_node_state fromValue(int value) => switch (value) {
    0 => ma_node_state_started,
    1 => ma_node_state_stopped,
    _ => throw ArgumentError('Unknown value for ma_node_state: $value'),
  };
}

final class ma_node_base extends ffi.Struct {
  external ffi.Pointer<ma_node_graph> pNodeGraph;

  external ffi.Pointer<ma_node_vtable> vtable;

  @ffi.UnsignedInt()
  external int inputBusCount;

  @ffi.UnsignedInt()
  external int outputBusCount;

  external ffi.Pointer<ma_node_input_bus> pInputBuses;

  external ffi.Pointer<ma_node_output_bus> pOutputBuses;

  external ffi.Pointer<ffi.Float> pCachedData;

  @ffi.UnsignedShort()
  external int cachedDataCapInFramesPerBus;

  @ffi.UnsignedShort()
  external int cachedFrameCountOut;

  @ffi.UnsignedShort()
  external int cachedFrameCountIn;

  @ffi.UnsignedShort()
  external int consumedFrameCountIn;

  @ffi.UnsignedInt()
  external int stateAsInt;

  ma_node_state get state => ma_node_state.fromValue(stateAsInt);

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedLongLong> stateTimes;

  @ffi.UnsignedLongLong()
  external int localTime;

  @ffi.Array.multi([2])
  external ffi.Array<ma_node_input_bus> _inputBuses;

  @ffi.Array.multi([2])
  external ffi.Array<ma_node_output_bus> _outputBuses;

  external ffi.Pointer<ffi.Void> _pHeap;

  @ffi.UnsignedInt()
  external int _ownsHeap;
}

final class ma_node_graph extends ffi.Struct {
  external ma_node_base base;

  external ma_node_base endpoint;

  external ffi.Pointer<ffi.Float> pProcessingCache;

  @ffi.UnsignedInt()
  external int processingCacheFramesRemaining;

  @ffi.UnsignedInt()
  external int processingSizeInFrames;

  @ffi.UnsignedInt()
  external int isReading;

  external ffi.Pointer<ma_stack> pPreMixStack;
}

final class ma_sound_inlined extends ffi.Opaque {}

final class ma_engine extends ffi.Struct {
  external ma_node_graph nodeGraph;

  external ffi.Pointer<ma_resource_manager> pResourceManager;

  external ffi.Pointer<ma_device> pDevice;

  external ffi.Pointer<ma_log> pLog;

  @ffi.UnsignedInt()
  external int sampleRate;

  @ffi.UnsignedInt()
  external int listenerCount;

  @ffi.Array.multi([4])
  external ffi.Array<ma_spatializer_listener> listeners;

  external ma_allocation_callbacks allocationCallbacks;

  @ffi.UnsignedChar()
  external int ownsResourceManager;

  @ffi.UnsignedChar()
  external int ownsDevice;

  @ffi.UnsignedInt()
  external int inlinedSoundLock;

  external ffi.Pointer<ma_sound_inlined> pInlinedSoundHead;

  @ffi.UnsignedInt()
  external int inlinedSoundCount;

  @ffi.UnsignedInt()
  external int gainSmoothTimeInFrames;

  @ffi.UnsignedInt()
  external int defaultVolumeSmoothTimeInPCMFrames;

  @ffi.UnsignedInt()
  external int monoExpansionModeAsInt;

  ma_mono_expansion_mode get monoExpansionMode =>
      ma_mono_expansion_mode.fromValue(monoExpansionModeAsInt);

  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<ffi.Void> pUserData,
        ffi.Pointer<ffi.Float> pFramesOut,
        ffi.UnsignedLongLong frameCount,
      )
    >
  >
  onProcess;

  external ffi.Pointer<ffi.Void> pProcessUserData;
}

final class ma_sound extends ffi.Opaque {}

final class ma_engine_config extends ffi.Opaque {}
