// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  void implements(int dynamic, int in$, int deferred) {
    return _implements(dynamic, in$, deferred);
  }

  late final _implementsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int, ffi.Int, ffi.Int)>>(
        'implements',
      );
  late final _implements = _implementsPtr
      .asFunction<void Function(int, int, int)>();

  late final ffi.Pointer<ffi.Int> _import = _lookup<ffi.Int>('import');

  int get import => _import.value;

  set import(int value) => _import.value = value;
}

final class Repro2795 extends ffi.Struct {
  external ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> in$)>
  >
  var$1;

  static ffi.Pointer<Repro2795> $allocate(
    ffi.Allocator $allocator, {
    required ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> in$)>
    >
    var$1,
  }) => $allocator<Repro2795>()..ref.var$1 = var$1;
}

final class abstract$ extends ffi.Opaque {}

enum export$ {
  covariant(0);

  final int value;
  const export$(this.value);

  static export$ fromValue(int value) => switch (value) {
    0 => covariant,
    _ => throw ArgumentError('Unknown value for export\$: $value'),
  };
}

final class show extends ffi.Opaque {}

typedef var$ = ffi.Void;
typedef Dartvar = void;
