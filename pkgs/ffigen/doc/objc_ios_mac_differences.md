# Dealing with iOS/macOS API differences

Objective-C can guard iOS/macOS specific code with `#if` macros, so that it
will only be compiled on specific platforms:

```obj-c
#if TARGET_OS_IPHONE
@interface WKWebView : UIView
#else
@interface WKWebView : NSView
#endif
```

Dart has no equivalent of this, because Dart's kernel files are designed to
work on any platform. `Platform.isMacOS` etc are runtime values, not compile
time constants (technical detail: they're compile time constant in AOT mode,
but not in JIT mode). So it's not possible to conditionally import dart files
based on `Platform.isMacOS`/`isIOS`.

There are two approaches for dealing with platform differences, depending
on how significant the differences are. If the API you're working with only
has small differences between iOS and macOS, you can try to generate a
single FFIgen wrapper for both, and use runtime `Platform.isMacOS`/`isIOS`
checks to call different methods. At runtime, FFIgen lazy loads all classes
and methods, so if a class/method doesn't exist in your plugin/app's native
code, that's fine as long as the class/method isn't used at runtime.

```dart
final foo = Foo();
if (Platform.isMacOS) {
  final bar = MacSpecificBar();
  foo.macSpecificMethod(bar);
} else {
  assert(Platform.isIOS);
  final bar = IosSpecificBar();
  foo.iosSpecificMethod(bar);
}
```

If the API differences are severe enough that they would cause compile time
errors if they're in a single library, that approach won't work. For example,
`WKWebView` inherits from `UIView` on iOS and `NSView` on macOS, so there's
no way FFIgen can generate a single `WKWebView` class for both platforms.
In cases like this, it's necessary to run FFIgen separately for each
platform, and generate different bindings for iOS and macOS. Since you can't
conditionally import based on the OS, you need a way of pulling both sets
of bindings into your plugin. The simplest approach is to use the rename
config option to rename the APIs so they don't conflict (eg `WKWebViewIOS`
and `WKWebViewMacOS`), then import both sets of bindings and use `Platform`
checks to call different APIs.

```dart
if (Platform.isMacOS) {
  final webView = WKWebViewMacOS();
  // ...
} else {
  assert(Platform.isIOS);
  final webView = WKWebViewIOS();
  // ...
}
```

If renaming isn't practical (e.g. there would be too many renames or `Platform`
checks), then you can write separate Dart classes for each platform that
implement a shared interface:

```dart
// Both imports were generated by FFIgen.
import 'web_view_bindings_mac.dart' as mac;
import 'web_view_bindings_ios.dart' as ios;

abstract interface class WebView {
  void load(Uri uri);

  factory WebView() {
    if (Platform.isMacOS) {
      return WebViewMac();
    } else {
      assert(Platform.isIOS);
      return WebViewIOS();
    }
  }
}

class WebViewMac implements WebView {
  mac.WKWebView _view;

  @override
  void load(Uri uri) {
    // ...
  }
}

class WebViewIOS implements WebView {
  ios.WKWebView _view;

  @override
  void load(Uri uri) {
    // ...
  }
}
```
