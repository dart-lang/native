// Copyright (c) 2022, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

/// from: com.github.dart_lang.jnigen.simple_package.Example$Nested$NestedTwice
class Example_Nested_NestedTwice extends jni.JObject {
  @override
  late final jni.JObjType<Example_Nested_NestedTwice> $type = type;

  Example_Nested_NestedTwice.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/simple_package/Example$Nested$NestedTwice");

  /// The type which includes information such as the signature of this class.
  static const type = $Example_Nested_NestedTwiceType();
  static final _id_ZERO = _class.staticFieldId(
    r"ZERO",
    r"I",
  );

  /// from: static public int ZERO
  static int get ZERO => _id_ZERO.get(_class, const jni.jintType());

  /// from: static public int ZERO
  static set ZERO(int value) =>
      _id_ZERO.set(_class, const jni.jintType(), value);

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Example_Nested_NestedTwice() {
    return Example_Nested_NestedTwice.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $Example_Nested_NestedTwiceType
    extends jni.JObjType<Example_Nested_NestedTwice> {
  const $Example_Nested_NestedTwiceType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/simple_package/Example$Nested$NestedTwice;";

  @override
  Example_Nested_NestedTwice fromReference(jni.JReference reference) =>
      Example_Nested_NestedTwice.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Example_Nested_NestedTwiceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example_Nested_NestedTwiceType) &&
        other is $Example_Nested_NestedTwiceType;
  }
}

/// from: com.github.dart_lang.jnigen.simple_package.Example$Nested
class Example_Nested extends jni.JObject {
  @override
  late final jni.JObjType<Example_Nested> $type = type;

  Example_Nested.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/simple_package/Example$Nested");

  /// The type which includes information such as the signature of this class.
  static const type = $Example_NestedType();
  static final _id_new0 = _class.constructorId(
    r"(Z)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void <init>(boolean value)
  /// The returned object must be released after use, by calling the [release] method.
  factory Example_Nested(
    bool value,
  ) {
    return Example_Nested.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, value ? 1 : 0)
        .reference);
  }

  static final _id_usesAnonymousInnerClass = _class.instanceMethodId(
    r"usesAnonymousInnerClass",
    r"()V",
  );

  static final _usesAnonymousInnerClass = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void usesAnonymousInnerClass()
  void usesAnonymousInnerClass() {
    _usesAnonymousInnerClass(
            reference.pointer, _id_usesAnonymousInnerClass as jni.JMethodIDPtr)
        .check();
  }

  static final _id_getValue = _class.instanceMethodId(
    r"getValue",
    r"()Z",
  );

  static final _getValue = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean getValue()
  bool getValue() {
    return _getValue(reference.pointer, _id_getValue as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setValue = _class.instanceMethodId(
    r"setValue",
    r"(Z)V",
  );

  static final _setValue = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setValue(boolean value)
  void setValue(
    bool value,
  ) {
    _setValue(
            reference.pointer, _id_setValue as jni.JMethodIDPtr, value ? 1 : 0)
        .check();
  }
}

final class $Example_NestedType extends jni.JObjType<Example_Nested> {
  const $Example_NestedType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;";

  @override
  Example_Nested fromReference(jni.JReference reference) =>
      Example_Nested.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Example_NestedType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example_NestedType) &&
        other is $Example_NestedType;
  }
}

/// from: com.github.dart_lang.jnigen.simple_package.Example$NonStaticNested
class Example_NonStaticNested extends jni.JObject {
  @override
  late final jni.JObjType<Example_NonStaticNested> $type = type;

  Example_NonStaticNested.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/simple_package/Example$NonStaticNested");

  /// The type which includes information such as the signature of this class.
  static const type = $Example_NonStaticNestedType();
  static final _id_ok = _class.instanceFieldId(
    r"ok",
    r"Z",
  );

  /// from: public boolean ok
  bool get ok => _id_ok.get(this, const jni.jbooleanType());

  /// from: public boolean ok
  set ok(bool value) => _id_ok.set(this, const jni.jbooleanType(), value);

  static final _id_new0 = _class.constructorId(
    r"(Lcom/github/dart_lang/jnigen/simple_package/Example;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.github.dart_lang.jnigen.simple_package.Example $parent)
  /// The returned object must be released after use, by calling the [release] method.
  factory Example_NonStaticNested(
    Example $parent,
  ) {
    return Example_NonStaticNested.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, $parent.reference.pointer)
        .reference);
  }
}

final class $Example_NonStaticNestedType
    extends jni.JObjType<Example_NonStaticNested> {
  const $Example_NonStaticNestedType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/simple_package/Example$NonStaticNested;";

  @override
  Example_NonStaticNested fromReference(jni.JReference reference) =>
      Example_NonStaticNested.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Example_NonStaticNestedType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example_NonStaticNestedType) &&
        other is $Example_NonStaticNestedType;
  }
}

/// from: com.github.dart_lang.jnigen.simple_package.Example
class Example extends jni.JObject {
  @override
  late final jni.JObjType<Example> $type = type;

  Example.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/github/dart_lang/jnigen/simple_package/Example");

  /// The type which includes information such as the signature of this class.
  static const type = $ExampleType();

  /// from: static public final int ON
  static const ON = 1;

  /// from: static public final int OFF
  static const OFF = 0;

  /// from: static public final double PI
  static const PI = 3.14159;

  /// from: static public final char SEMICOLON
  static const SEMICOLON = 59;
  static final _id_SEMICOLON_STRING = _class.staticFieldId(
    r"SEMICOLON_STRING",
    r"Ljava/lang/String;",
  );

  /// from: static public final java.lang.String SEMICOLON_STRING
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SEMICOLON_STRING =>
      _id_SEMICOLON_STRING.get(_class, const jni.JStringType());

  static final _id_unusedRandom = _class.staticFieldId(
    r"unusedRandom",
    r"Ljava/util/Random;",
  );

  /// from: static public final java.util.Random unusedRandom
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get unusedRandom =>
      _id_unusedRandom.get(_class, const jni.JObjectType());

  static final _id_protectedField = _class.instanceFieldId(
    r"protectedField",
    r"Ljava/util/Random;",
  );

  /// from: protected java.util.Random protectedField
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject get protectedField =>
      _id_protectedField.get(this, const jni.JObjectType());

  /// from: protected java.util.Random protectedField
  /// The returned object must be released after use, by calling the [release] method.
  set protectedField(jni.JObject value) =>
      _id_protectedField.set(this, const jni.JObjectType(), value);

  static final _id_getAmount = _class.staticMethodId(
    r"getAmount",
    r"()I",
  );

  static final _getAmount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public int getAmount()
  static int getAmount() {
    return _getAmount(
            _class.reference.pointer, _id_getAmount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getPi = _class.staticMethodId(
    r"getPi",
    r"()D",
  );

  static final _getPi = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticDoubleMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public double getPi()
  static double getPi() {
    return _getPi(_class.reference.pointer, _id_getPi as jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getAsterisk = _class.staticMethodId(
    r"getAsterisk",
    r"()C",
  );

  static final _getAsterisk = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticCharMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public char getAsterisk()
  static int getAsterisk() {
    return _getAsterisk(
            _class.reference.pointer, _id_getAsterisk as jni.JMethodIDPtr)
        .char;
  }

  static final _id_getName = _class.staticMethodId(
    r"getName",
    r"()Ljava/lang/String;",
  );

  static final _getName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.lang.String getName()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getName() {
    return _getName(_class.reference.pointer, _id_getName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getNestedInstance = _class.staticMethodId(
    r"getNestedInstance",
    r"()Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;",
  );

  static final _getNestedInstance = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public com.github.dart_lang.jnigen.simple_package.Example.Nested getNestedInstance()
  /// The returned object must be released after use, by calling the [release] method.
  static Example_Nested getNestedInstance() {
    return _getNestedInstance(
            _class.reference.pointer, _id_getNestedInstance as jni.JMethodIDPtr)
        .object(const $Example_NestedType());
  }

  static final _id_setAmount = _class.staticMethodId(
    r"setAmount",
    r"(I)V",
  );

  static final _setAmount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>("globalEnv_CallStaticVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: static public void setAmount(int newAmount)
  static void setAmount(
    int newAmount,
  ) {
    _setAmount(_class.reference.pointer, _id_setAmount as jni.JMethodIDPtr,
            newAmount)
        .check();
  }

  static final _id_setName = _class.staticMethodId(
    r"setName",
    r"(Ljava/lang/String;)V",
  );

  static final _setName = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void setName(java.lang.String newName)
  static void setName(
    jni.JString newName,
  ) {
    _setName(_class.reference.pointer, _id_setName as jni.JMethodIDPtr,
            newName.reference.pointer)
        .check();
  }

  static final _id_setNestedInstance = _class.staticMethodId(
    r"setNestedInstance",
    r"(Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;)V",
  );

  static final _setNestedInstance = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void setNestedInstance(com.github.dart_lang.jnigen.simple_package.Example.Nested newNested)
  static void setNestedInstance(
    Example_Nested newNested,
  ) {
    _setNestedInstance(
            _class.reference.pointer,
            _id_setNestedInstance as jni.JMethodIDPtr,
            newNested.reference.pointer)
        .check();
  }

  static final _id_max4 = _class.staticMethodId(
    r"max4",
    r"(IIII)I",
  );

  static final _max4 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64
                      )>)>>("globalEnv_CallStaticIntMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int, int)>();

  /// from: static public int max4(int a, int b, int c, int d)
  static int max4(
    int a,
    int b,
    int c,
    int d,
  ) {
    return _max4(
            _class.reference.pointer, _id_max4 as jni.JMethodIDPtr, a, b, c, d)
        .integer;
  }

  static final _id_max8 = _class.staticMethodId(
    r"max8",
    r"(IIIIIIII)I",
  );

  static final _max8 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64
                      )>)>>("globalEnv_CallStaticIntMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, int, int, int, int, int, int)>();

  /// from: static public int max8(int a, int b, int c, int d, int e, int f, int g, int h)
  static int max8(
    int a,
    int b,
    int c,
    int d,
    int e,
    int f,
    int g,
    int h,
  ) {
    return _max8(_class.reference.pointer, _id_max8 as jni.JMethodIDPtr, a, b,
            c, d, e, f, g, h)
        .integer;
  }

  static final _id_getNumber = _class.instanceMethodId(
    r"getNumber",
    r"()I",
  );

  static final _getNumber = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int getNumber()
  int getNumber() {
    return _getNumber(reference.pointer, _id_getNumber as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setNumber = _class.instanceMethodId(
    r"setNumber",
    r"(I)V",
  );

  static final _setNumber = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setNumber(int number)
  void setNumber(
    int number,
  ) {
    _setNumber(reference.pointer, _id_setNumber as jni.JMethodIDPtr, number)
        .check();
  }

  static final _id_getIsUp = _class.instanceMethodId(
    r"getIsUp",
    r"()Z",
  );

  static final _getIsUp = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean getIsUp()
  bool getIsUp() {
    return _getIsUp(reference.pointer, _id_getIsUp as jni.JMethodIDPtr).boolean;
  }

  static final _id_setUp = _class.instanceMethodId(
    r"setUp",
    r"(Z)V",
  );

  static final _setUp = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void setUp(boolean isUp)
  void setUp(
    bool isUp,
  ) {
    _setUp(reference.pointer, _id_setUp as jni.JMethodIDPtr, isUp ? 1 : 0)
        .check();
  }

  static final _id_getCodename = _class.instanceMethodId(
    r"getCodename",
    r"()Ljava/lang/String;",
  );

  static final _getCodename = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String getCodename()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getCodename() {
    return _getCodename(reference.pointer, _id_getCodename as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setCodename = _class.instanceMethodId(
    r"setCodename",
    r"(Ljava/lang/String;)V",
  );

  static final _setCodename = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setCodename(java.lang.String codename)
  void setCodename(
    jni.JString codename,
  ) {
    _setCodename(reference.pointer, _id_setCodename as jni.JMethodIDPtr,
            codename.reference.pointer)
        .check();
  }

  static final _id_getRandom = _class.instanceMethodId(
    r"getRandom",
    r"()Ljava/util/Random;",
  );

  static final _getRandom = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.Random getRandom()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getRandom() {
    return _getRandom(reference.pointer, _id_getRandom as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setRandom = _class.instanceMethodId(
    r"setRandom",
    r"(Ljava/util/Random;)V",
  );

  static final _setRandom = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setRandom(java.util.Random random)
  void setRandom(
    jni.JObject random,
  ) {
    _setRandom(reference.pointer, _id_setRandom as jni.JMethodIDPtr,
            random.reference.pointer)
        .check();
  }

  static final _id_getRandomLong = _class.instanceMethodId(
    r"getRandomLong",
    r"()J",
  );

  static final _getRandomLong = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallLongMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public long getRandomLong()
  int getRandomLong() {
    return _getRandomLong(
            reference.pointer, _id_getRandomLong as jni.JMethodIDPtr)
        .long;
  }

  static final _id_add4Longs = _class.instanceMethodId(
    r"add4Longs",
    r"(JJJJ)J",
  );

  static final _add4Longs = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64
                      )>)>>("globalEnv_CallLongMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int, int)>();

  /// from: public long add4Longs(long a, long b, long c, long d)
  int add4Longs(
    int a,
    int b,
    int c,
    int d,
  ) {
    return _add4Longs(
            reference.pointer, _id_add4Longs as jni.JMethodIDPtr, a, b, c, d)
        .long;
  }

  static final _id_add8Longs = _class.instanceMethodId(
    r"add8Longs",
    r"(JJJJJJJJ)J",
  );

  static final _add8Longs = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64
                      )>)>>("globalEnv_CallLongMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, int, int, int, int, int, int)>();

  /// from: public long add8Longs(long a, long b, long c, long d, long e, long f, long g, long h)
  int add8Longs(
    int a,
    int b,
    int c,
    int d,
    int e,
    int f,
    int g,
    int h,
  ) {
    return _add8Longs(reference.pointer, _id_add8Longs as jni.JMethodIDPtr, a,
            b, c, d, e, f, g, h)
        .long;
  }

  static final _id_getRandomNumericString = _class.instanceMethodId(
    r"getRandomNumericString",
    r"(Ljava/util/Random;)Ljava/lang/String;",
  );

  static final _getRandomNumericString = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getRandomNumericString(java.util.Random random)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getRandomNumericString(
    jni.JObject random,
  ) {
    return _getRandomNumericString(
            reference.pointer,
            _id_getRandomNumericString as jni.JMethodIDPtr,
            random.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_protectedMethod = _class.instanceMethodId(
    r"protectedMethod",
    r"(Ljava/lang/String;Ljava/lang/String;)V",
  );

  static final _protectedMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void protectedMethod(java.lang.String a, java.lang.String b)
  void protectedMethod(
    jni.JString a,
    jni.JString b,
  ) {
    _protectedMethod(reference.pointer, _id_protectedMethod as jni.JMethodIDPtr,
            a.reference.pointer, b.reference.pointer)
        .check();
  }

  static final _id_finalMethod = _class.instanceMethodId(
    r"finalMethod",
    r"()V",
  );

  static final _finalMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void finalMethod()
  void finalMethod() {
    _finalMethod(reference.pointer, _id_finalMethod as jni.JMethodIDPtr)
        .check();
  }

  static final _id_getList = _class.instanceMethodId(
    r"getList",
    r"()Ljava/util/List;",
  );

  static final _getList = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.List<java.lang.String> getList()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> getList() {
    return _getList(reference.pointer, _id_getList as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _id_joinStrings = _class.instanceMethodId(
    r"joinStrings",
    r"(Ljava/util/List;Ljava/lang/String;)Ljava/lang/String;",
  );

  static final _joinStrings = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String joinStrings(java.util.List<java.lang.String> values, java.lang.String delim)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Joins the strings in the list using the given delimiter.
  jni.JString joinStrings(
    jni.JList<jni.JString> values,
    jni.JString delim,
  ) {
    return _joinStrings(reference.pointer, _id_joinStrings as jni.JMethodIDPtr,
            values.reference.pointer, delim.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_methodWithSeveralParams = _class.instanceMethodId(
    r"methodWithSeveralParams",
    r"(CLjava/lang/String;[ILjava/lang/CharSequence;Ljava/util/List;Ljava/util/Map;)V",
  );

  static final _methodWithSeveralParams = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Int64,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void methodWithSeveralParams(char ch, java.lang.String s, int[] a, T t, java.util.List<T> lt, java.util.Map<java.lang.String,? extends java.lang.CharSequence> wm)
  void methodWithSeveralParams<$T extends jni.JObject>(
    int ch,
    jni.JString s,
    jni.JArray<jni.jint> a,
    $T t,
    jni.JList<$T> lt,
    jni.JMap<jni.JString, jni.JObject> wm, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      (lt.$type as jni.JListType).E,
      t.$type,
    ]) as jni.JObjType<$T>;
    _methodWithSeveralParams(
            reference.pointer,
            _id_methodWithSeveralParams as jni.JMethodIDPtr,
            ch,
            s.reference.pointer,
            a.reference.pointer,
            t.reference.pointer,
            lt.reference.pointer,
            wm.reference.pointer)
        .check();
  }

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Example() {
    return Example.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r"(I)V",
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void <init>(int number)
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new1(
    int number,
  ) {
    return Example.fromReference(
        _new1(_class.reference.pointer, _id_new1 as jni.JMethodIDPtr, number)
            .reference);
  }

  static final _id_new2 = _class.constructorId(
    r"(IZ)V",
  );

  static final _new2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64, ffi.Int64)>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public void <init>(int number, boolean isUp)
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new2(
    int number,
    bool isUp,
  ) {
    return Example.fromReference(_new2(_class.reference.pointer,
            _id_new2 as jni.JMethodIDPtr, number, isUp ? 1 : 0)
        .reference);
  }

  static final _id_new3 = _class.constructorId(
    r"(IZLjava/lang/String;)V",
  );

  static final _new3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int number, boolean isUp, java.lang.String codename)
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new3(
    int number,
    bool isUp,
    jni.JString codename,
  ) {
    return Example.fromReference(_new3(
            _class.reference.pointer,
            _id_new3 as jni.JMethodIDPtr,
            number,
            isUp ? 1 : 0,
            codename.reference.pointer)
        .reference);
  }

  static final _id_new4 = _class.constructorId(
    r"(IIIIIIII)V",
  );

  static final _new4 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, int, int, int, int, int, int)>();

  /// from: public void <init>(int a, int b, int c, int d, int e, int f, int g, int h)
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new4(
    int a,
    int b,
    int c,
    int d,
    int e,
    int f,
    int g,
    int h,
  ) {
    return Example.fromReference(_new4(_class.reference.pointer,
            _id_new4 as jni.JMethodIDPtr, a, b, c, d, e, f, g, h)
        .reference);
  }

  static final _id_whichExample = _class.instanceMethodId(
    r"whichExample",
    r"()I",
  );

  static final _whichExample = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int whichExample()
  int whichExample() {
    return _whichExample(
            reference.pointer, _id_whichExample as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_addInts = _class.staticMethodId(
    r"addInts",
    r"(II)I",
  );

  static final _addInts = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr, ffi.VarArgs<(ffi.Int64, ffi.Int64)>)>>(
          "globalEnv_CallStaticIntMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: static public int addInts(int a, int b)
  static int addInts(
    int a,
    int b,
  ) {
    return _addInts(
            _class.reference.pointer, _id_addInts as jni.JMethodIDPtr, a, b)
        .integer;
  }

  static final _id_getArr = _class.staticMethodId(
    r"getArr",
    r"()[I",
  );

  static final _getArr = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public int[] getArr()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> getArr() {
    return _getArr(_class.reference.pointer, _id_getArr as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_addAll = _class.staticMethodId(
    r"addAll",
    r"([I)I",
  );

  static final _addAll = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticIntMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public int addAll(int[] arr)
  static int addAll(
    jni.JArray<jni.jint> arr,
  ) {
    return _addAll(_class.reference.pointer, _id_addAll as jni.JMethodIDPtr,
            arr.reference.pointer)
        .integer;
  }

  static final _id_getSelf = _class.instanceMethodId(
    r"getSelf",
    r"()Lcom/github/dart_lang/jnigen/simple_package/Example;",
  );

  static final _getSelf = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.github.dart_lang.jnigen.simple_package.Example getSelf()
  /// The returned object must be released after use, by calling the [release] method.
  Example getSelf() {
    return _getSelf(reference.pointer, _id_getSelf as jni.JMethodIDPtr)
        .object(const $ExampleType());
  }

  static final _id_throwException = _class.staticMethodId(
    r"throwException",
    r"()V",
  );

  static final _throwException = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public void throwException()
  static void throwException() {
    _throwException(
            _class.reference.pointer, _id_throwException as jni.JMethodIDPtr)
        .check();
  }

  static final _id_overloaded = _class.instanceMethodId(
    r"overloaded",
    r"()V",
  );

  static final _overloaded = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void overloaded()
  void overloaded() {
    _overloaded(reference.pointer, _id_overloaded as jni.JMethodIDPtr).check();
  }

  static final _id_overloaded1 = _class.instanceMethodId(
    r"overloaded",
    r"(ILjava/lang/String;)V",
  );

  static final _overloaded1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void overloaded(int a, java.lang.String b)
  void overloaded1(
    int a,
    jni.JString b,
  ) {
    _overloaded1(reference.pointer, _id_overloaded1 as jni.JMethodIDPtr, a,
            b.reference.pointer)
        .check();
  }

  static final _id_overloaded2 = _class.instanceMethodId(
    r"overloaded",
    r"(I)V",
  );

  static final _overloaded2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void overloaded(int a)
  void overloaded2(
    int a,
  ) {
    _overloaded2(reference.pointer, _id_overloaded2 as jni.JMethodIDPtr, a)
        .check();
  }

  static final _id_overloaded3 = _class.instanceMethodId(
    r"overloaded",
    r"(Ljava/util/List;Ljava/lang/String;)V",
  );

  static final _overloaded3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void overloaded(java.util.List<java.lang.Integer> a, java.lang.String b)
  void overloaded3(
    jni.JList<jni.JInteger> a,
    jni.JString b,
  ) {
    _overloaded3(reference.pointer, _id_overloaded3 as jni.JMethodIDPtr,
            a.reference.pointer, b.reference.pointer)
        .check();
  }

  static final _id_overloaded4 = _class.instanceMethodId(
    r"overloaded",
    r"(Ljava/util/List;)V",
  );

  static final _overloaded4 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void overloaded(java.util.List<java.lang.Integer> a)
  void overloaded4(
    jni.JList<jni.JInteger> a,
  ) {
    _overloaded4(reference.pointer, _id_overloaded4 as jni.JMethodIDPtr,
            a.reference.pointer)
        .check();
  }
}

final class $ExampleType extends jni.JObjType<Example> {
  const $ExampleType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/simple_package/Example;";

  @override
  Example fromReference(jni.JReference reference) =>
      Example.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExampleType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ExampleType) && other is $ExampleType;
  }
}

/// from: com.github.dart_lang.jnigen.pkg2.C2
class C2 extends jni.JObject {
  @override
  late final jni.JObjType<C2> $type = type;

  C2.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/github/dart_lang/jnigen/pkg2/C2");

  /// The type which includes information such as the signature of this class.
  static const type = $C2Type();
  static final _id_CONSTANT = _class.staticFieldId(
    r"CONSTANT",
    r"I",
  );

  /// from: static public int CONSTANT
  static int get CONSTANT => _id_CONSTANT.get(_class, const jni.jintType());

  /// from: static public int CONSTANT
  static set CONSTANT(int value) =>
      _id_CONSTANT.set(_class, const jni.jintType(), value);

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory C2() {
    return C2.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $C2Type extends jni.JObjType<C2> {
  const $C2Type();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/pkg2/C2;";

  @override
  C2 fromReference(jni.JReference reference) => C2.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($C2Type).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($C2Type) && other is $C2Type;
  }
}

/// from: com.github.dart_lang.jnigen.pkg2.Example
class Example1 extends jni.JObject {
  @override
  late final jni.JObjType<Example1> $type = type;

  Example1.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/github/dart_lang/jnigen/pkg2/Example");

  /// The type which includes information such as the signature of this class.
  static const type = $Example1Type();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Example1() {
    return Example1.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_whichExample = _class.instanceMethodId(
    r"whichExample",
    r"()I",
  );

  static final _whichExample = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int whichExample()
  int whichExample() {
    return _whichExample(
            reference.pointer, _id_whichExample as jni.JMethodIDPtr)
        .integer;
  }
}

final class $Example1Type extends jni.JObjType<Example1> {
  const $Example1Type();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/pkg2/Example;";

  @override
  Example1 fromReference(jni.JReference reference) =>
      Example1.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Example1Type).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example1Type) && other is $Example1Type;
  }
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent$Parent$Child
class GrandParent_Parent_Child<$T extends jni.JObject, $S extends jni.JObject,
    $U extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<GrandParent_Parent_Child<$T, $S, $U>> $type =
      type(T, S, U);

  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  GrandParent_Parent_Child.fromReference(
    this.T,
    this.S,
    this.U,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/generics/GrandParent$Parent$Child");

  /// The type which includes information such as the signature of this class.
  static $GrandParent_Parent_ChildType<$T, $S, $U> type<$T extends jni.JObject,
      $S extends jni.JObject, $U extends jni.JObject>(
    jni.JObjType<$T> T,
    jni.JObjType<$S> S,
    jni.JObjType<$U> U,
  ) {
    return $GrandParent_Parent_ChildType(
      T,
      S,
      U,
    );
  }

  static final _id_grandParentValue = _class.instanceFieldId(
    r"grandParentValue",
    r"Ljava/lang/Object;",
  );

  /// from: public T grandParentValue
  /// The returned object must be released after use, by calling the [release] method.
  $T get grandParentValue => _id_grandParentValue.get(this, T);

  /// from: public T grandParentValue
  /// The returned object must be released after use, by calling the [release] method.
  set grandParentValue($T value) => _id_grandParentValue.set(this, T, value);

  static final _id_parentValue = _class.instanceFieldId(
    r"parentValue",
    r"Ljava/lang/Object;",
  );

  /// from: public S parentValue
  /// The returned object must be released after use, by calling the [release] method.
  $S get parentValue => _id_parentValue.get(this, S);

  /// from: public S parentValue
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($S value) => _id_parentValue.set(this, S, value);

  static final _id_value = _class.instanceFieldId(
    r"value",
    r"Ljava/lang/Object;",
  );

  /// from: public U value
  /// The returned object must be released after use, by calling the [release] method.
  $U get value => _id_value.get(this, U);

  /// from: public U value
  /// The returned object must be released after use, by calling the [release] method.
  set value($U value) => _id_value.set(this, U, value);

  static final _id_new0 = _class.constructorId(
    r"(Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;Ljava/lang/Object;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.github.dart_lang.jnigen.generics.GrandParent$Parent $parent, U newValue)
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_Parent_Child(
    GrandParent_Parent<$T, $S> $parent,
    $U newValue, {
    jni.JObjType<$T>? T,
    jni.JObjType<$S>? S,
    jni.JObjType<$U>? U,
  }) {
    T ??= jni.lowestCommonSuperType([
      ($parent.$type as $GrandParent_ParentType).T,
    ]) as jni.JObjType<$T>;
    S ??= jni.lowestCommonSuperType([
      ($parent.$type as $GrandParent_ParentType).S,
    ]) as jni.JObjType<$S>;
    U ??= jni.lowestCommonSuperType([
      newValue.$type,
    ]) as jni.JObjType<$U>;
    return GrandParent_Parent_Child.fromReference(
        T,
        S,
        U,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr,
                $parent.reference.pointer, newValue.reference.pointer)
            .reference);
  }
}

final class $GrandParent_Parent_ChildType<$T extends jni.JObject,
        $S extends jni.JObject, $U extends jni.JObject>
    extends jni.JObjType<GrandParent_Parent_Child<$T, $S, $U>> {
  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  const $GrandParent_Parent_ChildType(
    this.T,
    this.S,
    this.U,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent$Child;";

  @override
  GrandParent_Parent_Child<$T, $S, $U> fromReference(
          jni.JReference reference) =>
      GrandParent_Parent_Child.fromReference(T, S, U, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParent_Parent_ChildType, T, S, U);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent_Parent_ChildType<$T, $S, $U>) &&
        other is $GrandParent_Parent_ChildType<$T, $S, $U> &&
        T == other.T &&
        S == other.S &&
        U == other.U;
  }
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent$Parent
class GrandParent_Parent<$T extends jni.JObject, $S extends jni.JObject>
    extends jni.JObject {
  @override
  late final jni.JObjType<GrandParent_Parent<$T, $S>> $type = type(T, S);

  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;

  GrandParent_Parent.fromReference(
    this.T,
    this.S,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/generics/GrandParent$Parent");

  /// The type which includes information such as the signature of this class.
  static $GrandParent_ParentType<$T, $S>
      type<$T extends jni.JObject, $S extends jni.JObject>(
    jni.JObjType<$T> T,
    jni.JObjType<$S> S,
  ) {
    return $GrandParent_ParentType(
      T,
      S,
    );
  }

  static final _id_parentValue = _class.instanceFieldId(
    r"parentValue",
    r"Ljava/lang/Object;",
  );

  /// from: public T parentValue
  /// The returned object must be released after use, by calling the [release] method.
  $T get parentValue => _id_parentValue.get(this, T);

  /// from: public T parentValue
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($T value) => _id_parentValue.set(this, T, value);

  static final _id_value = _class.instanceFieldId(
    r"value",
    r"Ljava/lang/Object;",
  );

  /// from: public S value
  /// The returned object must be released after use, by calling the [release] method.
  $S get value => _id_value.get(this, S);

  /// from: public S value
  /// The returned object must be released after use, by calling the [release] method.
  set value($S value) => _id_value.set(this, S, value);

  static final _id_new0 = _class.constructorId(
    r"(Lcom/github/dart_lang/jnigen/generics/GrandParent;Ljava/lang/Object;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.github.dart_lang.jnigen.generics.GrandParent $parent, S newValue)
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_Parent(
    GrandParent<$T> $parent,
    $S newValue, {
    jni.JObjType<$T>? T,
    jni.JObjType<$S>? S,
  }) {
    T ??= jni.lowestCommonSuperType([
      ($parent.$type as $GrandParentType).T,
    ]) as jni.JObjType<$T>;
    S ??= jni.lowestCommonSuperType([
      newValue.$type,
    ]) as jni.JObjType<$S>;
    return GrandParent_Parent.fromReference(
        T,
        S,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr,
                $parent.reference.pointer, newValue.reference.pointer)
            .reference);
  }
}

final class $GrandParent_ParentType<$T extends jni.JObject,
    $S extends jni.JObject> extends jni.JObjType<GrandParent_Parent<$T, $S>> {
  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;

  const $GrandParent_ParentType(
    this.T,
    this.S,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;";

  @override
  GrandParent_Parent<$T, $S> fromReference(jni.JReference reference) =>
      GrandParent_Parent.fromReference(T, S, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParent_ParentType, T, S);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent_ParentType<$T, $S>) &&
        other is $GrandParent_ParentType<$T, $S> &&
        T == other.T &&
        S == other.S;
  }
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent$StaticParent$Child
class GrandParent_StaticParent_Child<$S extends jni.JObject,
    $U extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<GrandParent_StaticParent_Child<$S, $U>> $type =
      type(S, U);

  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  GrandParent_StaticParent_Child.fromReference(
    this.S,
    this.U,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child");

  /// The type which includes information such as the signature of this class.
  static $GrandParent_StaticParent_ChildType<$S, $U>
      type<$S extends jni.JObject, $U extends jni.JObject>(
    jni.JObjType<$S> S,
    jni.JObjType<$U> U,
  ) {
    return $GrandParent_StaticParent_ChildType(
      S,
      U,
    );
  }

  static final _id_parentValue = _class.instanceFieldId(
    r"parentValue",
    r"Ljava/lang/Object;",
  );

  /// from: public S parentValue
  /// The returned object must be released after use, by calling the [release] method.
  $S get parentValue => _id_parentValue.get(this, S);

  /// from: public S parentValue
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($S value) => _id_parentValue.set(this, S, value);

  static final _id_value = _class.instanceFieldId(
    r"value",
    r"Ljava/lang/Object;",
  );

  /// from: public U value
  /// The returned object must be released after use, by calling the [release] method.
  $U get value => _id_value.get(this, U);

  /// from: public U value
  /// The returned object must be released after use, by calling the [release] method.
  set value($U value) => _id_value.set(this, U, value);

  static final _id_new0 = _class.constructorId(
    r"(Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;Ljava/lang/Object;Ljava/lang/Object;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.github.dart_lang.jnigen.generics.GrandParent$StaticParent $parent, S parentValue, U value)
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_StaticParent_Child(
    GrandParent_StaticParent<$S> $parent,
    $S parentValue,
    $U value, {
    jni.JObjType<$S>? S,
    jni.JObjType<$U>? U,
  }) {
    S ??= jni.lowestCommonSuperType([
      parentValue.$type,
      ($parent.$type as $GrandParent_StaticParentType).S,
    ]) as jni.JObjType<$S>;
    U ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$U>;
    return GrandParent_StaticParent_Child.fromReference(
        S,
        U,
        _new0(
                _class.reference.pointer,
                _id_new0 as jni.JMethodIDPtr,
                $parent.reference.pointer,
                parentValue.reference.pointer,
                value.reference.pointer)
            .reference);
  }
}

final class $GrandParent_StaticParent_ChildType<$S extends jni.JObject,
        $U extends jni.JObject>
    extends jni.JObjType<GrandParent_StaticParent_Child<$S, $U>> {
  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  const $GrandParent_StaticParent_ChildType(
    this.S,
    this.U,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child;";

  @override
  GrandParent_StaticParent_Child<$S, $U> fromReference(
          jni.JReference reference) =>
      GrandParent_StaticParent_Child.fromReference(S, U, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParent_StaticParent_ChildType, S, U);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent_StaticParent_ChildType<$S, $U>) &&
        other is $GrandParent_StaticParent_ChildType<$S, $U> &&
        S == other.S &&
        U == other.U;
  }
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent$StaticParent
class GrandParent_StaticParent<$S extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<GrandParent_StaticParent<$S>> $type = type(S);

  final jni.JObjType<$S> S;

  GrandParent_StaticParent.fromReference(
    this.S,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/generics/GrandParent$StaticParent");

  /// The type which includes information such as the signature of this class.
  static $GrandParent_StaticParentType<$S> type<$S extends jni.JObject>(
    jni.JObjType<$S> S,
  ) {
    return $GrandParent_StaticParentType(
      S,
    );
  }

  static final _id_value = _class.instanceFieldId(
    r"value",
    r"Ljava/lang/Object;",
  );

  /// from: public S value
  /// The returned object must be released after use, by calling the [release] method.
  $S get value => _id_value.get(this, S);

  /// from: public S value
  /// The returned object must be released after use, by calling the [release] method.
  set value($S value) => _id_value.set(this, S, value);

  static final _id_new0 = _class.constructorId(
    r"(Ljava/lang/Object;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(S value)
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_StaticParent(
    $S value, {
    jni.JObjType<$S>? S,
  }) {
    S ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$S>;
    return GrandParent_StaticParent.fromReference(
        S,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr,
                value.reference.pointer)
            .reference);
  }
}

final class $GrandParent_StaticParentType<$S extends jni.JObject>
    extends jni.JObjType<GrandParent_StaticParent<$S>> {
  final jni.JObjType<$S> S;

  const $GrandParent_StaticParentType(
    this.S,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;";

  @override
  GrandParent_StaticParent<$S> fromReference(jni.JReference reference) =>
      GrandParent_StaticParent.fromReference(S, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParent_StaticParentType, S);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent_StaticParentType<$S>) &&
        other is $GrandParent_StaticParentType<$S> &&
        S == other.S;
  }
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent
class GrandParent<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<GrandParent<$T>> $type = type(T);

  final jni.JObjType<$T> T;

  GrandParent.fromReference(
    this.T,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/github/dart_lang/jnigen/generics/GrandParent");

  /// The type which includes information such as the signature of this class.
  static $GrandParentType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $GrandParentType(
      T,
    );
  }

  static final _id_value = _class.instanceFieldId(
    r"value",
    r"Ljava/lang/Object;",
  );

  /// from: public T value
  /// The returned object must be released after use, by calling the [release] method.
  $T get value => _id_value.get(this, T);

  /// from: public T value
  /// The returned object must be released after use, by calling the [release] method.
  set value($T value) => _id_value.set(this, T, value);

  static final _id_new0 = _class.constructorId(
    r"(Ljava/lang/Object;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(T value)
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent(
    $T value, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$T>;
    return GrandParent.fromReference(
        T,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr,
                value.reference.pointer)
            .reference);
  }

  static final _id_stringParent = _class.instanceMethodId(
    r"stringParent",
    r"()Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;",
  );

  static final _stringParent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.github.dart_lang.jnigen.generics.GrandParent<T>.Parent<java.lang.String> stringParent()
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent_Parent<jni.JObject, jni.JString> stringParent() {
    return _stringParent(
            reference.pointer, _id_stringParent as jni.JMethodIDPtr)
        .object(const $GrandParent_ParentType(
            jni.JObjectType(), jni.JStringType()));
  }

  static final _id_varParent = _class.instanceMethodId(
    r"varParent",
    r"(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;",
  );

  static final _varParent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.github.dart_lang.jnigen.generics.GrandParent<T>.Parent<S> varParent(S nestedValue)
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent_Parent<jni.JObject, $S> varParent<$S extends jni.JObject>(
    $S nestedValue, {
    jni.JObjType<$S>? S,
  }) {
    S ??= jni.lowestCommonSuperType([
      nestedValue.$type,
    ]) as jni.JObjType<$S>;
    return _varParent(reference.pointer, _id_varParent as jni.JMethodIDPtr,
            nestedValue.reference.pointer)
        .object($GrandParent_ParentType(const jni.JObjectType(), S));
  }

  static final _id_stringStaticParent = _class.staticMethodId(
    r"stringStaticParent",
    r"()Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;",
  );

  static final _stringStaticParent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<java.lang.String> stringStaticParent()
  /// The returned object must be released after use, by calling the [release] method.
  static GrandParent_StaticParent<jni.JString> stringStaticParent() {
    return _stringStaticParent(_class.reference.pointer,
            _id_stringStaticParent as jni.JMethodIDPtr)
        .object(const $GrandParent_StaticParentType(jni.JStringType()));
  }

  static final _id_varStaticParent = _class.staticMethodId(
    r"varStaticParent",
    r"(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;",
  );

  static final _varStaticParent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<S> varStaticParent(S value)
  /// The returned object must be released after use, by calling the [release] method.
  static GrandParent_StaticParent<$S> varStaticParent<$S extends jni.JObject>(
    $S value, {
    jni.JObjType<$S>? S,
  }) {
    S ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$S>;
    return _varStaticParent(_class.reference.pointer,
            _id_varStaticParent as jni.JMethodIDPtr, value.reference.pointer)
        .object($GrandParent_StaticParentType(S));
  }

  static final _id_staticParentWithSameType = _class.instanceMethodId(
    r"staticParentWithSameType",
    r"()Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;",
  );

  static final _staticParentWithSameType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<T> staticParentWithSameType()
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent_StaticParent<$T> staticParentWithSameType() {
    return _staticParentWithSameType(
            reference.pointer, _id_staticParentWithSameType as jni.JMethodIDPtr)
        .object($GrandParent_StaticParentType(T));
  }
}

final class $GrandParentType<$T extends jni.JObject>
    extends jni.JObjType<GrandParent<$T>> {
  final jni.JObjType<$T> T;

  const $GrandParentType(
    this.T,
  );

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/GrandParent;";

  @override
  GrandParent<$T> fromReference(jni.JReference reference) =>
      GrandParent.fromReference(T, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParentType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParentType<$T>) &&
        other is $GrandParentType<$T> &&
        T == other.T;
  }
}

/// from: com.github.dart_lang.jnigen.generics.MyMap$MyEntry
class MyMap_MyEntry<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObject {
  @override
  late final jni.JObjType<MyMap_MyEntry<$K, $V>> $type = type(K, V);

  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  MyMap_MyEntry.fromReference(
    this.K,
    this.V,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/github/dart_lang/jnigen/generics/MyMap$MyEntry");

  /// The type which includes information such as the signature of this class.
  static $MyMap_MyEntryType<$K, $V>
      type<$K extends jni.JObject, $V extends jni.JObject>(
    jni.JObjType<$K> K,
    jni.JObjType<$V> V,
  ) {
    return $MyMap_MyEntryType(
      K,
      V,
    );
  }

  static final _id_key = _class.instanceFieldId(
    r"key",
    r"Ljava/lang/Object;",
  );

  /// from: public K key
  /// The returned object must be released after use, by calling the [release] method.
  $K get key => _id_key.get(this, K);

  /// from: public K key
  /// The returned object must be released after use, by calling the [release] method.
  set key($K value) => _id_key.set(this, K, value);

  static final _id_value = _class.instanceFieldId(
    r"value",
    r"Ljava/lang/Object;",
  );

  /// from: public V value
  /// The returned object must be released after use, by calling the [release] method.
  $V get value => _id_value.get(this, V);

  /// from: public V value
  /// The returned object must be released after use, by calling the [release] method.
  set value($V value) => _id_value.set(this, V, value);

  static final _id_new0 = _class.constructorId(
    r"(Lcom/github/dart_lang/jnigen/generics/MyMap;Ljava/lang/Object;Ljava/lang/Object;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.github.dart_lang.jnigen.generics.MyMap $parent, K key, V value)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyMap_MyEntry(
    MyMap<$K, $V> $parent,
    $K key,
    $V value, {
    jni.JObjType<$K>? K,
    jni.JObjType<$V>? V,
  }) {
    K ??= jni.lowestCommonSuperType([
      key.$type,
      ($parent.$type as $MyMapType).K,
    ]) as jni.JObjType<$K>;
    V ??= jni.lowestCommonSuperType([
      value.$type,
      ($parent.$type as $MyMapType).V,
    ]) as jni.JObjType<$V>;
    return MyMap_MyEntry.fromReference(
        K,
        V,
        _new0(
                _class.reference.pointer,
                _id_new0 as jni.JMethodIDPtr,
                $parent.reference.pointer,
                key.reference.pointer,
                value.reference.pointer)
            .reference);
  }
}

final class $MyMap_MyEntryType<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObjType<MyMap_MyEntry<$K, $V>> {
  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  const $MyMap_MyEntryType(
    this.K,
    this.V,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/MyMap$MyEntry;";

  @override
  MyMap_MyEntry<$K, $V> fromReference(jni.JReference reference) =>
      MyMap_MyEntry.fromReference(K, V, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($MyMap_MyEntryType, K, V);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyMap_MyEntryType<$K, $V>) &&
        other is $MyMap_MyEntryType<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

/// from: com.github.dart_lang.jnigen.generics.MyMap
class MyMap<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObject {
  @override
  late final jni.JObjType<MyMap<$K, $V>> $type = type(K, V);

  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  MyMap.fromReference(
    this.K,
    this.V,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/github/dart_lang/jnigen/generics/MyMap");

  /// The type which includes information such as the signature of this class.
  static $MyMapType<$K, $V>
      type<$K extends jni.JObject, $V extends jni.JObject>(
    jni.JObjType<$K> K,
    jni.JObjType<$V> V,
  ) {
    return $MyMapType(
      K,
      V,
    );
  }

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MyMap({
    required jni.JObjType<$K> K,
    required jni.JObjType<$V> V,
  }) {
    return MyMap.fromReference(
        K,
        V,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_get0 = _class.instanceMethodId(
    r"get",
    r"(Ljava/lang/Object;)Ljava/lang/Object;",
  );

  static final _get0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public V get(K key)
  /// The returned object must be released after use, by calling the [release] method.
  $V get0(
    $K key,
  ) {
    return _get0(reference.pointer, _id_get0 as jni.JMethodIDPtr,
            key.reference.pointer)
        .object(V);
  }

  static final _id_put = _class.instanceMethodId(
    r"put",
    r"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;",
  );

  static final _put = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public V put(K key, V value)
  /// The returned object must be released after use, by calling the [release] method.
  $V put(
    $K key,
    $V value,
  ) {
    return _put(reference.pointer, _id_put as jni.JMethodIDPtr,
            key.reference.pointer, value.reference.pointer)
        .object(V);
  }

  static final _id_entryStack = _class.instanceMethodId(
    r"entryStack",
    r"()Lcom/github/dart_lang/jnigen/generics/MyStack;",
  );

  static final _entryStack = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public com.github.dart_lang.jnigen.generics.MyStack<com.github.dart_lang.jnigen.generics.MyMap<K,V>.MyEntry> entryStack()
  /// The returned object must be released after use, by calling the [release] method.
  MyStack<MyMap_MyEntry<jni.JObject, jni.JObject>> entryStack() {
    return _entryStack(reference.pointer, _id_entryStack as jni.JMethodIDPtr)
        .object(const $MyStackType(
            $MyMap_MyEntryType(jni.JObjectType(), jni.JObjectType())));
  }
}

final class $MyMapType<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObjType<MyMap<$K, $V>> {
  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  const $MyMapType(
    this.K,
    this.V,
  );

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/MyMap;";

  @override
  MyMap<$K, $V> fromReference(jni.JReference reference) =>
      MyMap.fromReference(K, V, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($MyMapType, K, V);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyMapType<$K, $V>) &&
        other is $MyMapType<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

/// from: com.github.dart_lang.jnigen.generics.MyStack
class MyStack<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<MyStack<$T>> $type = type(T);

  final jni.JObjType<$T> T;

  MyStack.fromReference(
    this.T,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/github/dart_lang/jnigen/generics/MyStack");

  /// The type which includes information such as the signature of this class.
  static $MyStackType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $MyStackType(
      T,
    );
  }

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MyStack({
    required jni.JObjType<$T> T,
  }) {
    return MyStack.fromReference(
        T,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_fromArray = _class.staticMethodId(
    r"fromArray",
    r"([Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;",
  );

  static final _fromArray = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.generics.MyStack<T> fromArray(T[] arr)
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T> fromArray<$T extends jni.JObject>(
    jni.JArray<$T> arr, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      ((arr.$type as jni.JArrayType).elementType as jni.JObjType),
    ]) as jni.JObjType<$T>;
    return _fromArray(_class.reference.pointer,
            _id_fromArray as jni.JMethodIDPtr, arr.reference.pointer)
        .object($MyStackType(T));
  }

  static final _id_fromArrayOfArrayOfGrandParents = _class.staticMethodId(
    r"fromArrayOfArrayOfGrandParents",
    r"([[Lcom/github/dart_lang/jnigen/generics/GrandParent;)Lcom/github/dart_lang/jnigen/generics/MyStack;",
  );

  static final _fromArrayOfArrayOfGrandParents = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.generics.MyStack<S> fromArrayOfArrayOfGrandParents(com.github.dart_lang.jnigen.generics.GrandParent<S>[][] arr)
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$S> fromArrayOfArrayOfGrandParents<$S extends jni.JObject>(
    jni.JArray<jni.JArray<GrandParent<$S>>> arr, {
    jni.JObjType<$S>? S,
  }) {
    S ??= jni.lowestCommonSuperType([
      (((((arr.$type as jni.JArrayType).elementType as jni.JObjType)
                  as jni.JArrayType)
              .elementType as jni.JObjType) as $GrandParentType)
          .T,
    ]) as jni.JObjType<$S>;
    return _fromArrayOfArrayOfGrandParents(
            _class.reference.pointer,
            _id_fromArrayOfArrayOfGrandParents as jni.JMethodIDPtr,
            arr.reference.pointer)
        .object($MyStackType(S));
  }

  static final _id_of = _class.staticMethodId(
    r"of",
    r"()Lcom/github/dart_lang/jnigen/generics/MyStack;",
  );

  static final _of = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public com.github.dart_lang.jnigen.generics.MyStack<T> of()
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T> of<$T extends jni.JObject>({
    required jni.JObjType<$T> T,
  }) {
    return _of(_class.reference.pointer, _id_of as jni.JMethodIDPtr)
        .object($MyStackType(T));
  }

  static final _id_of1 = _class.staticMethodId(
    r"of",
    r"(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;",
  );

  static final _of1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.generics.MyStack<T> of(T obj)
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T> of1<$T extends jni.JObject>(
    $T obj, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      obj.$type,
    ]) as jni.JObjType<$T>;
    return _of1(_class.reference.pointer, _id_of1 as jni.JMethodIDPtr,
            obj.reference.pointer)
        .object($MyStackType(T));
  }

  static final _id_of2 = _class.staticMethodId(
    r"of",
    r"(Ljava/lang/Object;Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;",
  );

  static final _of2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.generics.MyStack<T> of(T obj, T obj2)
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T> of2<$T extends jni.JObject>(
    $T obj,
    $T obj2, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      obj2.$type,
      obj.$type,
    ]) as jni.JObjType<$T>;
    return _of2(_class.reference.pointer, _id_of2 as jni.JMethodIDPtr,
            obj.reference.pointer, obj2.reference.pointer)
        .object($MyStackType(T));
  }

  static final _id_push = _class.instanceMethodId(
    r"push",
    r"(Ljava/lang/Object;)V",
  );

  static final _push = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void push(T item)
  void push(
    $T item,
  ) {
    _push(reference.pointer, _id_push as jni.JMethodIDPtr,
            item.reference.pointer)
        .check();
  }

  static final _id_pop = _class.instanceMethodId(
    r"pop",
    r"()Ljava/lang/Object;",
  );

  static final _pop = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public T pop()
  /// The returned object must be released after use, by calling the [release] method.
  $T pop() {
    return _pop(reference.pointer, _id_pop as jni.JMethodIDPtr).object(T);
  }

  static final _id_size = _class.instanceMethodId(
    r"size",
    r"()I",
  );

  static final _size = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int size()
  int size() {
    return _size(reference.pointer, _id_size as jni.JMethodIDPtr).integer;
  }
}

final class $MyStackType<$T extends jni.JObject>
    extends jni.JObjType<MyStack<$T>> {
  final jni.JObjType<$T> T;

  const $MyStackType(
    this.T,
  );

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/MyStack;";

  @override
  MyStack<$T> fromReference(jni.JReference reference) =>
      MyStack.fromReference(T, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($MyStackType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyStackType<$T>) &&
        other is $MyStackType<$T> &&
        T == other.T;
  }
}

/// from: com.github.dart_lang.jnigen.generics.StringKeyedMap
class StringKeyedMap<$V extends jni.JObject> extends MyMap<jni.JString, $V> {
  @override
  late final jni.JObjType<StringKeyedMap<$V>> $type = type(V);

  final jni.JObjType<$V> V;

  StringKeyedMap.fromReference(
    this.V,
    jni.JReference reference,
  ) : super.fromReference(const jni.JStringType(), V, reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/generics/StringKeyedMap");

  /// The type which includes information such as the signature of this class.
  static $StringKeyedMapType<$V> type<$V extends jni.JObject>(
    jni.JObjType<$V> V,
  ) {
    return $StringKeyedMapType(
      V,
    );
  }

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory StringKeyedMap({
    required jni.JObjType<$V> V,
  }) {
    return StringKeyedMap.fromReference(
        V,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $StringKeyedMapType<$V extends jni.JObject>
    extends jni.JObjType<StringKeyedMap<$V>> {
  final jni.JObjType<$V> V;

  const $StringKeyedMapType(
    this.V,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/StringKeyedMap;";

  @override
  StringKeyedMap<$V> fromReference(jni.JReference reference) =>
      StringKeyedMap.fromReference(V, reference);

  @override
  jni.JObjType get superType => $MyMapType(const jni.JStringType(), V);

  @override
  final superCount = 2;

  @override
  int get hashCode => Object.hash($StringKeyedMapType, V);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringKeyedMapType<$V>) &&
        other is $StringKeyedMapType<$V> &&
        V == other.V;
  }
}

/// from: com.github.dart_lang.jnigen.generics.StringStack
class StringStack extends MyStack<jni.JString> {
  @override
  late final jni.JObjType<StringStack> $type = type;

  StringStack.fromReference(
    jni.JReference reference,
  ) : super.fromReference(const jni.JStringType(), reference);

  static final _class =
      jni.JClass.forName(r"com/github/dart_lang/jnigen/generics/StringStack");

  /// The type which includes information such as the signature of this class.
  static const type = $StringStackType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory StringStack() {
    return StringStack.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $StringStackType extends jni.JObjType<StringStack> {
  const $StringStackType();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/StringStack;";

  @override
  StringStack fromReference(jni.JReference reference) =>
      StringStack.fromReference(reference);

  @override
  jni.JObjType get superType => const $MyStackType(jni.JStringType());

  @override
  final superCount = 2;

  @override
  int get hashCode => ($StringStackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringStackType) && other is $StringStackType;
  }
}

/// from: com.github.dart_lang.jnigen.generics.StringValuedMap
class StringValuedMap<$K extends jni.JObject> extends MyMap<$K, jni.JString> {
  @override
  late final jni.JObjType<StringValuedMap<$K>> $type = type(K);

  final jni.JObjType<$K> K;

  StringValuedMap.fromReference(
    this.K,
    jni.JReference reference,
  ) : super.fromReference(K, const jni.JStringType(), reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/generics/StringValuedMap");

  /// The type which includes information such as the signature of this class.
  static $StringValuedMapType<$K> type<$K extends jni.JObject>(
    jni.JObjType<$K> K,
  ) {
    return $StringValuedMapType(
      K,
    );
  }

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory StringValuedMap({
    required jni.JObjType<$K> K,
  }) {
    return StringValuedMap.fromReference(
        K,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $StringValuedMapType<$K extends jni.JObject>
    extends jni.JObjType<StringValuedMap<$K>> {
  final jni.JObjType<$K> K;

  const $StringValuedMapType(
    this.K,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/StringValuedMap;";

  @override
  StringValuedMap<$K> fromReference(jni.JReference reference) =>
      StringValuedMap.fromReference(K, reference);

  @override
  jni.JObjType get superType => $MyMapType(K, const jni.JStringType());

  @override
  final superCount = 2;

  @override
  int get hashCode => Object.hash($StringValuedMapType, K);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringValuedMapType<$K>) &&
        other is $StringValuedMapType<$K> &&
        K == other.K;
  }
}

/// from: com.github.dart_lang.jnigen.interfaces.MyInterface
class MyInterface<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<MyInterface<$T>> $type = type(T);

  final jni.JObjType<$T> T;

  MyInterface.fromReference(
    this.T,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/github/dart_lang/jnigen/interfaces/MyInterface");

  /// The type which includes information such as the signature of this class.
  static $MyInterfaceType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $MyInterfaceType(
      T,
    );
  }

  static final _id_voidCallback = _class.instanceMethodId(
    r"voidCallback",
    r"(Ljava/lang/String;)V",
  );

  static final _voidCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void voidCallback(java.lang.String s)
  void voidCallback(
    jni.JString s,
  ) {
    _voidCallback(reference.pointer, _id_voidCallback as jni.JMethodIDPtr,
            s.reference.pointer)
        .check();
  }

  static final _id_stringCallback = _class.instanceMethodId(
    r"stringCallback",
    r"(Ljava/lang/String;)Ljava/lang/String;",
  );

  static final _stringCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String stringCallback(java.lang.String s)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString stringCallback(
    jni.JString s,
  ) {
    return _stringCallback(reference.pointer,
            _id_stringCallback as jni.JMethodIDPtr, s.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_varCallback = _class.instanceMethodId(
    r"varCallback",
    r"(Ljava/lang/Object;)Ljava/lang/Object;",
  );

  static final _varCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract T varCallback(T t)
  /// The returned object must be released after use, by calling the [release] method.
  $T varCallback(
    $T t,
  ) {
    return _varCallback(reference.pointer, _id_varCallback as jni.JMethodIDPtr,
            t.reference.pointer)
        .object(T);
  }

  static final _id_manyPrimitives = _class.instanceMethodId(
    r"manyPrimitives",
    r"(IZCD)J",
  );

  static final _manyPrimitives = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Double
                      )>)>>("globalEnv_CallLongMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, int, double)>();

  /// from: public abstract long manyPrimitives(int a, boolean b, char c, double d)
  int manyPrimitives(
    int a,
    bool b,
    int c,
    double d,
  ) {
    return _manyPrimitives(reference.pointer,
            _id_manyPrimitives as jni.JMethodIDPtr, a, b ? 1 : 0, c, d)
        .long;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MyInterfaceImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"voidCallback(Ljava/lang/String;)V") {
        _$impls[$p]!.voidCallback(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"stringCallback(Ljava/lang/String;)Ljava/lang/String;") {
        final $r = _$impls[$p]!.stringCallback(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r"varCallback(Ljava/lang/Object;)Ljava/lang/Object;") {
        final $r = _$impls[$p]!.varCallback(
          $a[0].castTo(_$impls[$p]!.T, releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r"manyPrimitives(IZCD)J") {
        final $r = _$impls[$p]!.manyPrimitives(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
          $a[2]
              .castTo(const jni.JCharacterType(), releaseOriginal: true)
              .charValue(releaseOriginal: true),
          $a[3]
              .castTo(const jni.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return jni.JLong($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory MyInterface.implement(
    $MyInterfaceImpl<$T> $impl,
  ) {
    final $p = ReceivePort();
    final $x = MyInterface.fromReference(
      $impl.T,
      ProtectedJniExtensions.newPortProxy(
        r"com.github.dart_lang.jnigen.interfaces.MyInterface",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
  static Map<int, $MyInterfaceImpl> get $impls => _$impls;
}

abstract interface class $MyInterfaceImpl<$T extends jni.JObject> {
  factory $MyInterfaceImpl({
    required jni.JObjType<$T> T,
    required void Function(jni.JString s) voidCallback,
    required jni.JString Function(jni.JString s) stringCallback,
    required $T Function($T t) varCallback,
    required int Function(int a, bool b, int c, double d) manyPrimitives,
  }) = _$MyInterfaceImpl;

  jni.JObjType<$T> get T;

  void voidCallback(jni.JString s);
  jni.JString stringCallback(jni.JString s);
  $T varCallback($T t);
  int manyPrimitives(int a, bool b, int c, double d);
}

class _$MyInterfaceImpl<$T extends jni.JObject>
    implements $MyInterfaceImpl<$T> {
  _$MyInterfaceImpl({
    required this.T,
    required void Function(jni.JString s) voidCallback,
    required jni.JString Function(jni.JString s) stringCallback,
    required $T Function($T t) varCallback,
    required int Function(int a, bool b, int c, double d) manyPrimitives,
  })  : _voidCallback = voidCallback,
        _stringCallback = stringCallback,
        _varCallback = varCallback,
        _manyPrimitives = manyPrimitives;

  @override
  final jni.JObjType<$T> T;

  final void Function(jni.JString s) _voidCallback;
  final jni.JString Function(jni.JString s) _stringCallback;
  final $T Function($T t) _varCallback;
  final int Function(int a, bool b, int c, double d) _manyPrimitives;

  void voidCallback(jni.JString s) {
    return _voidCallback(s);
  }

  jni.JString stringCallback(jni.JString s) {
    return _stringCallback(s);
  }

  $T varCallback($T t) {
    return _varCallback(t);
  }

  int manyPrimitives(int a, bool b, int c, double d) {
    return _manyPrimitives(a, b, c, d);
  }
}

final class $MyInterfaceType<$T extends jni.JObject>
    extends jni.JObjType<MyInterface<$T>> {
  final jni.JObjType<$T> T;

  const $MyInterfaceType(
    this.T,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/interfaces/MyInterface;";

  @override
  MyInterface<$T> fromReference(jni.JReference reference) =>
      MyInterface.fromReference(T, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($MyInterfaceType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyInterfaceType<$T>) &&
        other is $MyInterfaceType<$T> &&
        T == other.T;
  }
}

/// from: com.github.dart_lang.jnigen.interfaces.MyInterfaceConsumer
class MyInterfaceConsumer extends jni.JObject {
  @override
  late final jni.JObjType<MyInterfaceConsumer> $type = type;

  MyInterfaceConsumer.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/interfaces/MyInterfaceConsumer");

  /// The type which includes information such as the signature of this class.
  static const type = $MyInterfaceConsumerType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MyInterfaceConsumer() {
    return MyInterfaceConsumer.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_consumeOnAnotherThread = _class.staticMethodId(
    r"consumeOnAnotherThread",
    r"(Lcom/github/dart_lang/jnigen/interfaces/MyInterface;Ljava/lang/String;IZCDLjava/lang/Object;)V",
  );

  static final _consumeOnAnotherThread = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Double,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              double,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void consumeOnAnotherThread(com.github.dart_lang.jnigen.interfaces.MyInterface<T> myInterface, java.lang.String s, int a, boolean b, char c, double d, T t)
  static void consumeOnAnotherThread<$T extends jni.JObject>(
    MyInterface<$T> myInterface,
    jni.JString s,
    int a,
    bool b,
    int c,
    double d,
    $T t, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      t.$type,
      (myInterface.$type as $MyInterfaceType).T,
    ]) as jni.JObjType<$T>;
    _consumeOnAnotherThread(
            _class.reference.pointer,
            _id_consumeOnAnotherThread as jni.JMethodIDPtr,
            myInterface.reference.pointer,
            s.reference.pointer,
            a,
            b ? 1 : 0,
            c,
            d,
            t.reference.pointer)
        .check();
  }

  static final _id_consumeOnSameThread = _class.staticMethodId(
    r"consumeOnSameThread",
    r"(Lcom/github/dart_lang/jnigen/interfaces/MyInterface;Ljava/lang/String;IZCDLjava/lang/Object;)V",
  );

  static final _consumeOnSameThread = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Double,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              double,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void consumeOnSameThread(com.github.dart_lang.jnigen.interfaces.MyInterface<T> myInterface, java.lang.String s, int a, boolean b, char c, double d, T t)
  static void consumeOnSameThread<$T extends jni.JObject>(
    MyInterface<$T> myInterface,
    jni.JString s,
    int a,
    bool b,
    int c,
    double d,
    $T t, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      t.$type,
      (myInterface.$type as $MyInterfaceType).T,
    ]) as jni.JObjType<$T>;
    _consumeOnSameThread(
            _class.reference.pointer,
            _id_consumeOnSameThread as jni.JMethodIDPtr,
            myInterface.reference.pointer,
            s.reference.pointer,
            a,
            b ? 1 : 0,
            c,
            d,
            t.reference.pointer)
        .check();
  }
}

final class $MyInterfaceConsumerType extends jni.JObjType<MyInterfaceConsumer> {
  const $MyInterfaceConsumerType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/interfaces/MyInterfaceConsumer;";

  @override
  MyInterfaceConsumer fromReference(jni.JReference reference) =>
      MyInterfaceConsumer.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyInterfaceConsumerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyInterfaceConsumerType) &&
        other is $MyInterfaceConsumerType;
  }
}

/// from: com.github.dart_lang.jnigen.interfaces.MyRunnable
class MyRunnable extends jni.JObject {
  @override
  late final jni.JObjType<MyRunnable> $type = type;

  MyRunnable.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/github/dart_lang/jnigen/interfaces/MyRunnable");

  /// The type which includes information such as the signature of this class.
  static const type = $MyRunnableType();
  static final _id_run = _class.instanceMethodId(
    r"run",
    r"()V",
  );

  static final _run = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void run()
  void run() {
    _run(reference.pointer, _id_run as jni.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MyRunnableImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"run()V") {
        _$impls[$p]!.run();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory MyRunnable.implement(
    $MyRunnableImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MyRunnable.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.github.dart_lang.jnigen.interfaces.MyRunnable",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MyRunnableImpl {
  factory $MyRunnableImpl({
    required void Function() run,
  }) = _$MyRunnableImpl;

  void run();
}

class _$MyRunnableImpl implements $MyRunnableImpl {
  _$MyRunnableImpl({
    required void Function() run,
  }) : _run = run;

  final void Function() _run;

  void run() {
    return _run();
  }
}

final class $MyRunnableType extends jni.JObjType<MyRunnable> {
  const $MyRunnableType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/interfaces/MyRunnable;";

  @override
  MyRunnable fromReference(jni.JReference reference) =>
      MyRunnable.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyRunnableType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyRunnableType) && other is $MyRunnableType;
  }
}

/// from: com.github.dart_lang.jnigen.interfaces.MyRunnableRunner
class MyRunnableRunner extends jni.JObject {
  @override
  late final jni.JObjType<MyRunnableRunner> $type = type;

  MyRunnableRunner.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/interfaces/MyRunnableRunner");

  /// The type which includes information such as the signature of this class.
  static const type = $MyRunnableRunnerType();
  static final _id_error = _class.instanceFieldId(
    r"error",
    r"Ljava/lang/Throwable;",
  );

  /// from: public java.lang.Throwable error
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject get error => _id_error.get(this, const jni.JObjectType());

  /// from: public java.lang.Throwable error
  /// The returned object must be released after use, by calling the [release] method.
  set error(jni.JObject value) =>
      _id_error.set(this, const jni.JObjectType(), value);

  static final _id_new0 = _class.constructorId(
    r"(Lcom/github/dart_lang/jnigen/interfaces/MyRunnable;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.github.dart_lang.jnigen.interfaces.MyRunnable runnable)
  /// The returned object must be released after use, by calling the [release] method.
  factory MyRunnableRunner(
    MyRunnable runnable,
  ) {
    return MyRunnableRunner.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, runnable.reference.pointer)
        .reference);
  }

  static final _id_runOnSameThread = _class.instanceMethodId(
    r"runOnSameThread",
    r"()V",
  );

  static final _runOnSameThread = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void runOnSameThread()
  void runOnSameThread() {
    _runOnSameThread(reference.pointer, _id_runOnSameThread as jni.JMethodIDPtr)
        .check();
  }

  static final _id_runOnAnotherThread = _class.instanceMethodId(
    r"runOnAnotherThread",
    r"()V",
  );

  static final _runOnAnotherThread = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void runOnAnotherThread()
  void runOnAnotherThread() {
    _runOnAnotherThread(
            reference.pointer, _id_runOnAnotherThread as jni.JMethodIDPtr)
        .check();
  }
}

final class $MyRunnableRunnerType extends jni.JObjType<MyRunnableRunner> {
  const $MyRunnableRunnerType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/interfaces/MyRunnableRunner;";

  @override
  MyRunnableRunner fromReference(jni.JReference reference) =>
      MyRunnableRunner.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyRunnableRunnerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyRunnableRunnerType) &&
        other is $MyRunnableRunnerType;
  }
}

/// from: com.github.dart_lang.jnigen.annotations.JsonSerializable$Case
class JsonSerializable_Case extends jni.JObject {
  @override
  late final jni.JObjType<JsonSerializable_Case> $type = type;

  JsonSerializable_Case.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/annotations/JsonSerializable$Case");

  /// The type which includes information such as the signature of this class.
  static const type = $JsonSerializable_CaseType();
  static final _id_values = _class.staticMethodId(
    r"values",
    r"()[Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;",
  );

  static final _values = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public com.github.dart_lang.jnigen.annotations.JsonSerializable.Case[] values()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<JsonSerializable_Case> values() {
    return _values(_class.reference.pointer, _id_values as jni.JMethodIDPtr)
        .object(const jni.JArrayType($JsonSerializable_CaseType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r"valueOf",
    r"(Ljava/lang/String;)Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;",
  );

  static final _valueOf = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.annotations.JsonSerializable.Case valueOf(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable_Case valueOf(
    jni.JString name,
  ) {
    return _valueOf(_class.reference.pointer, _id_valueOf as jni.JMethodIDPtr,
            name.reference.pointer)
        .object(const $JsonSerializable_CaseType());
  }
}

final class $JsonSerializable_CaseType
    extends jni.JObjType<JsonSerializable_Case> {
  const $JsonSerializable_CaseType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;";

  @override
  JsonSerializable_Case fromReference(jni.JReference reference) =>
      JsonSerializable_Case.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($JsonSerializable_CaseType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($JsonSerializable_CaseType) &&
        other is $JsonSerializable_CaseType;
  }
}

/// from: com.github.dart_lang.jnigen.annotations.JsonSerializable
class JsonSerializable extends jni.JObject {
  @override
  late final jni.JObjType<JsonSerializable> $type = type;

  JsonSerializable.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/annotations/JsonSerializable");

  /// The type which includes information such as the signature of this class.
  static const type = $JsonSerializableType();
  static final _id_value = _class.instanceMethodId(
    r"value",
    r"()Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;",
  );

  static final _value = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract com.github.dart_lang.jnigen.annotations.JsonSerializable$Case value()
  /// The returned object must be released after use, by calling the [release] method.
  JsonSerializable_Case value() {
    return _value(reference.pointer, _id_value as jni.JMethodIDPtr)
        .object(const $JsonSerializable_CaseType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $JsonSerializableImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"value()Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;") {
        final $r = _$impls[$p]!.value();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory JsonSerializable.implement(
    $JsonSerializableImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = JsonSerializable.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.github.dart_lang.jnigen.annotations.JsonSerializable",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $JsonSerializableImpl {
  factory $JsonSerializableImpl({
    required JsonSerializable_Case Function() value,
  }) = _$JsonSerializableImpl;

  JsonSerializable_Case value();
}

class _$JsonSerializableImpl implements $JsonSerializableImpl {
  _$JsonSerializableImpl({
    required JsonSerializable_Case Function() value,
  }) : _value = value;

  final JsonSerializable_Case Function() _value;

  JsonSerializable_Case value() {
    return _value();
  }
}

final class $JsonSerializableType extends jni.JObjType<JsonSerializable> {
  const $JsonSerializableType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/annotations/JsonSerializable;";

  @override
  JsonSerializable fromReference(jni.JReference reference) =>
      JsonSerializable.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($JsonSerializableType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($JsonSerializableType) &&
        other is $JsonSerializableType;
  }
}

/// from: com.github.dart_lang.jnigen.annotations.MyDataClass
class MyDataClass extends jni.JObject {
  @override
  late final jni.JObjType<MyDataClass> $type = type;

  MyDataClass.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/annotations/MyDataClass");

  /// The type which includes information such as the signature of this class.
  static const type = $MyDataClassType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory MyDataClass() {
    return MyDataClass.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $MyDataClassType extends jni.JObjType<MyDataClass> {
  const $MyDataClassType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/annotations/MyDataClass;";

  @override
  MyDataClass fromReference(jni.JReference reference) =>
      MyDataClass.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyDataClassType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyDataClassType) && other is $MyDataClassType;
  }
}

/// from: com.github.dart_lang.jnigen.simple_package.Color
class Color extends jni.JObject {
  @override
  late final jni.JObjType<Color> $type = type;

  Color.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/github/dart_lang/jnigen/simple_package/Color");

  /// The type which includes information such as the signature of this class.
  static const type = $ColorType();
  static final _id_values = _class.staticMethodId(
    r"values",
    r"()[Lcom/github/dart_lang/jnigen/simple_package/Color;",
  );

  static final _values = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public com.github.dart_lang.jnigen.simple_package.Color[] values()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<Color> values() {
    return _values(_class.reference.pointer, _id_values as jni.JMethodIDPtr)
        .object(const jni.JArrayType($ColorType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r"valueOf",
    r"(Ljava/lang/String;)Lcom/github/dart_lang/jnigen/simple_package/Color;",
  );

  static final _valueOf = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.simple_package.Color valueOf(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  static Color valueOf(
    jni.JString name,
  ) {
    return _valueOf(_class.reference.pointer, _id_valueOf as jni.JMethodIDPtr,
            name.reference.pointer)
        .object(const $ColorType());
  }
}

final class $ColorType extends jni.JObjType<Color> {
  const $ColorType();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/simple_package/Color;";

  @override
  Color fromReference(jni.JReference reference) =>
      Color.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ColorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ColorType) && other is $ColorType;
  }
}

/// from: com.github.dart_lang.jnigen.simple_package.Exceptions
class Exceptions extends jni.JObject {
  @override
  late final jni.JObjType<Exceptions> $type = type;

  Exceptions.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/simple_package/Exceptions");

  /// The type which includes information such as the signature of this class.
  static const type = $ExceptionsType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions() {
    return Exceptions.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r"(F)V",
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: public void <init>(float x)
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions.new1(
    double x,
  ) {
    return Exceptions.fromReference(
        _new1(_class.reference.pointer, _id_new1 as jni.JMethodIDPtr, x)
            .reference);
  }

  static final _id_new2 = _class.constructorId(
    r"(IIIIII)V",
  );

  static final _new2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, int, int, int, int)>();

  /// from: public void <init>(int a, int b, int c, int d, int e, int f)
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions.new2(
    int a,
    int b,
    int c,
    int d,
    int e,
    int f,
  ) {
    return Exceptions.fromReference(_new2(_class.reference.pointer,
            _id_new2 as jni.JMethodIDPtr, a, b, c, d, e, f)
        .reference);
  }

  static final _id_staticObjectMethod = _class.staticMethodId(
    r"staticObjectMethod",
    r"()Ljava/lang/Object;",
  );

  static final _staticObjectMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.lang.Object staticObjectMethod()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject staticObjectMethod() {
    return _staticObjectMethod(_class.reference.pointer,
            _id_staticObjectMethod as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_staticIntMethod = _class.staticMethodId(
    r"staticIntMethod",
    r"()I",
  );

  static final _staticIntMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public int staticIntMethod()
  static int staticIntMethod() {
    return _staticIntMethod(
            _class.reference.pointer, _id_staticIntMethod as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_staticObjectArrayMethod = _class.staticMethodId(
    r"staticObjectArrayMethod",
    r"()[Ljava/lang/Object;",
  );

  static final _staticObjectArrayMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.lang.Object[] staticObjectArrayMethod()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JObject> staticObjectArrayMethod() {
    return _staticObjectArrayMethod(_class.reference.pointer,
            _id_staticObjectArrayMethod as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_staticIntArrayMethod = _class.staticMethodId(
    r"staticIntArrayMethod",
    r"()[I",
  );

  static final _staticIntArrayMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public int[] staticIntArrayMethod()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> staticIntArrayMethod() {
    return _staticIntArrayMethod(_class.reference.pointer,
            _id_staticIntArrayMethod as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_objectMethod = _class.instanceMethodId(
    r"objectMethod",
    r"()Ljava/lang/Object;",
  );

  static final _objectMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Object objectMethod()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject objectMethod() {
    return _objectMethod(
            reference.pointer, _id_objectMethod as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_intMethod = _class.instanceMethodId(
    r"intMethod",
    r"()I",
  );

  static final _intMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int intMethod()
  int intMethod() {
    return _intMethod(reference.pointer, _id_intMethod as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_objectArrayMethod = _class.instanceMethodId(
    r"objectArrayMethod",
    r"()[Ljava/lang/Object;",
  );

  static final _objectArrayMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Object[] objectArrayMethod()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JObject> objectArrayMethod() {
    return _objectArrayMethod(
            reference.pointer, _id_objectArrayMethod as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_intArrayMethod = _class.instanceMethodId(
    r"intArrayMethod",
    r"()[I",
  );

  static final _intArrayMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int[] intArrayMethod()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> intArrayMethod() {
    return _intArrayMethod(
            reference.pointer, _id_intArrayMethod as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_throwNullPointerException = _class.instanceMethodId(
    r"throwNullPointerException",
    r"()I",
  );

  static final _throwNullPointerException = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int throwNullPointerException()
  int throwNullPointerException() {
    return _throwNullPointerException(reference.pointer,
            _id_throwNullPointerException as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_throwFileNotFoundException = _class.instanceMethodId(
    r"throwFileNotFoundException",
    r"()Ljava/io/InputStream;",
  );

  static final _throwFileNotFoundException = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.io.InputStream throwFileNotFoundException()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject throwFileNotFoundException() {
    return _throwFileNotFoundException(reference.pointer,
            _id_throwFileNotFoundException as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_throwClassCastException = _class.instanceMethodId(
    r"throwClassCastException",
    r"()Ljava/io/FileInputStream;",
  );

  static final _throwClassCastException = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.io.FileInputStream throwClassCastException()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject throwClassCastException() {
    return _throwClassCastException(
            reference.pointer, _id_throwClassCastException as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_throwArrayIndexException = _class.instanceMethodId(
    r"throwArrayIndexException",
    r"()I",
  );

  static final _throwArrayIndexException = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int throwArrayIndexException()
  int throwArrayIndexException() {
    return _throwArrayIndexException(
            reference.pointer, _id_throwArrayIndexException as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_throwArithmeticException = _class.instanceMethodId(
    r"throwArithmeticException",
    r"()I",
  );

  static final _throwArithmeticException = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int throwArithmeticException()
  int throwArithmeticException() {
    return _throwArithmeticException(
            reference.pointer, _id_throwArithmeticException as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_throwLoremIpsum = _class.staticMethodId(
    r"throwLoremIpsum",
    r"()V",
  );

  static final _throwLoremIpsum = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallStaticVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public void throwLoremIpsum()
  static void throwLoremIpsum() {
    _throwLoremIpsum(
            _class.reference.pointer, _id_throwLoremIpsum as jni.JMethodIDPtr)
        .check();
  }
}

final class $ExceptionsType extends jni.JObjType<Exceptions> {
  const $ExceptionsType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/simple_package/Exceptions;";

  @override
  Exceptions fromReference(jni.JReference reference) =>
      Exceptions.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExceptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ExceptionsType) && other is $ExceptionsType;
  }
}

/// from: com.github.dart_lang.jnigen.simple_package.Fields
class Fields extends jni.JObject {
  @override
  late final jni.JObjType<Fields> $type = type;

  Fields.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/github/dart_lang/jnigen/simple_package/Fields");

  /// The type which includes information such as the signature of this class.
  static const type = $FieldsType();
  static final _id_amount = _class.staticFieldId(
    r"amount",
    r"I",
  );

  /// from: static public int amount
  static int get amount => _id_amount.get(_class, const jni.jintType());

  /// from: static public int amount
  static set amount(int value) =>
      _id_amount.set(_class, const jni.jintType(), value);

  static final _id_pi = _class.staticFieldId(
    r"pi",
    r"D",
  );

  /// from: static public double pi
  static double get pi => _id_pi.get(_class, const jni.jdoubleType());

  /// from: static public double pi
  static set pi(double value) =>
      _id_pi.set(_class, const jni.jdoubleType(), value);

  static final _id_asterisk = _class.staticFieldId(
    r"asterisk",
    r"C",
  );

  /// from: static public char asterisk
  static int get asterisk => _id_asterisk.get(_class, const jni.jcharType());

  /// from: static public char asterisk
  static set asterisk(int value) =>
      _id_asterisk.set(_class, const jni.jcharType(), value);

  static final _id_name = _class.staticFieldId(
    r"name",
    r"Ljava/lang/String;",
  );

  /// from: static public java.lang.String name
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get name => _id_name.get(_class, const jni.JStringType());

  /// from: static public java.lang.String name
  /// The returned object must be released after use, by calling the [release] method.
  static set name(jni.JString value) =>
      _id_name.set(_class, const jni.JStringType(), value);

  static final _id_i = _class.instanceFieldId(
    r"i",
    r"Ljava/lang/Integer;",
  );

  /// from: public java.lang.Integer i
  /// The returned object must be released after use, by calling the [release] method.
  jni.JInteger get i => _id_i.get(this, const jni.JIntegerType());

  /// from: public java.lang.Integer i
  /// The returned object must be released after use, by calling the [release] method.
  set i(jni.JInteger value) => _id_i.set(this, const jni.JIntegerType(), value);

  static final _id_trillion = _class.instanceFieldId(
    r"trillion",
    r"J",
  );

  /// from: public long trillion
  int get trillion => _id_trillion.get(this, const jni.jlongType());

  /// from: public long trillion
  set trillion(int value) =>
      _id_trillion.set(this, const jni.jlongType(), value);

  static final _id_isAchillesDead = _class.instanceFieldId(
    r"isAchillesDead",
    r"Z",
  );

  /// from: public boolean isAchillesDead
  bool get isAchillesDead =>
      _id_isAchillesDead.get(this, const jni.jbooleanType());

  /// from: public boolean isAchillesDead
  set isAchillesDead(bool value) =>
      _id_isAchillesDead.set(this, const jni.jbooleanType(), value);

  static final _id_bestFighterInGreece = _class.instanceFieldId(
    r"bestFighterInGreece",
    r"Ljava/lang/String;",
  );

  /// from: public java.lang.String bestFighterInGreece
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString get bestFighterInGreece =>
      _id_bestFighterInGreece.get(this, const jni.JStringType());

  /// from: public java.lang.String bestFighterInGreece
  /// The returned object must be released after use, by calling the [release] method.
  set bestFighterInGreece(jni.JString value) =>
      _id_bestFighterInGreece.set(this, const jni.JStringType(), value);

  static final _id_random = _class.instanceFieldId(
    r"random",
    r"Ljava/util/Random;",
  );

  /// from: public java.util.Random random
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject get random => _id_random.get(this, const jni.JObjectType());

  /// from: public java.util.Random random
  /// The returned object must be released after use, by calling the [release] method.
  set random(jni.JObject value) =>
      _id_random.set(this, const jni.JObjectType(), value);

  static final _id_euroSymbol = _class.staticFieldId(
    r"euroSymbol",
    r"C",
  );

  /// from: static public char euroSymbol
  static int get euroSymbol =>
      _id_euroSymbol.get(_class, const jni.jcharType());

  /// from: static public char euroSymbol
  static set euroSymbol(int value) =>
      _id_euroSymbol.set(_class, const jni.jcharType(), value);

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Fields() {
    return Fields.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $FieldsType extends jni.JObjType<Fields> {
  const $FieldsType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/simple_package/Fields;";

  @override
  Fields fromReference(jni.JReference reference) =>
      Fields.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FieldsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FieldsType) && other is $FieldsType;
  }
}

/// from: com.github.dart_lang.jnigen.simple_package.Fields$Nested
class Fields_Nested extends jni.JObject {
  @override
  late final jni.JObjType<Fields_Nested> $type = type;

  Fields_Nested.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/simple_package/Fields$Nested");

  /// The type which includes information such as the signature of this class.
  static const type = $Fields_NestedType();
  static final _id_hundred = _class.instanceFieldId(
    r"hundred",
    r"J",
  );

  /// from: public long hundred
  int get hundred => _id_hundred.get(this, const jni.jlongType());

  /// from: public long hundred
  set hundred(int value) => _id_hundred.set(this, const jni.jlongType(), value);

  static final _id_BEST_GOD = _class.staticFieldId(
    r"BEST_GOD",
    r"Ljava/lang/String;",
  );

  /// from: static public java.lang.String BEST_GOD
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BEST_GOD =>
      _id_BEST_GOD.get(_class, const jni.JStringType());

  /// from: static public java.lang.String BEST_GOD
  /// The returned object must be released after use, by calling the [release] method.
  static set BEST_GOD(jni.JString value) =>
      _id_BEST_GOD.set(_class, const jni.JStringType(), value);

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Fields_Nested() {
    return Fields_Nested.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $Fields_NestedType extends jni.JObjType<Fields_Nested> {
  const $Fields_NestedType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/simple_package/Fields$Nested;";

  @override
  Fields_Nested fromReference(jni.JReference reference) =>
      Fields_Nested.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Fields_NestedType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Fields_NestedType) &&
        other is $Fields_NestedType;
  }
}

/// from: com.github.dart_lang.jnigen.generics.GenericTypeParams
class GenericTypeParams<$S extends jni.JObject, $K extends jni.JObject>
    extends jni.JObject {
  @override
  late final jni.JObjType<GenericTypeParams<$S, $K>> $type = type(S, K);

  final jni.JObjType<$S> S;
  final jni.JObjType<$K> K;

  GenericTypeParams.fromReference(
    this.S,
    this.K,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r"com/github/dart_lang/jnigen/generics/GenericTypeParams");

  /// The type which includes information such as the signature of this class.
  static $GenericTypeParamsType<$S, $K>
      type<$S extends jni.JObject, $K extends jni.JObject>(
    jni.JObjType<$S> S,
    jni.JObjType<$K> K,
  ) {
    return $GenericTypeParamsType(
      S,
      K,
    );
  }

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory GenericTypeParams({
    required jni.JObjType<$S> S,
    required jni.JObjType<$K> K,
  }) {
    return GenericTypeParams.fromReference(
        S,
        K,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $GenericTypeParamsType<$S extends jni.JObject,
    $K extends jni.JObject> extends jni.JObjType<GenericTypeParams<$S, $K>> {
  final jni.JObjType<$S> S;
  final jni.JObjType<$K> K;

  const $GenericTypeParamsType(
    this.S,
    this.K,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/GenericTypeParams;";

  @override
  GenericTypeParams<$S, $K> fromReference(jni.JReference reference) =>
      GenericTypeParams.fromReference(S, K, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GenericTypeParamsType, S, K);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($GenericTypeParamsType<$S, $K>) &&
        other is $GenericTypeParamsType<$S, $K> &&
        S == other.S &&
        K == other.K;
  }
}

/// from: com.github.dart_lang.jnigen.generics.StringMap
class StringMap extends StringKeyedMap<jni.JString> {
  @override
  late final jni.JObjType<StringMap> $type = type;

  StringMap.fromReference(
    jni.JReference reference,
  ) : super.fromReference(const jni.JStringType(), reference);

  static final _class =
      jni.JClass.forName(r"com/github/dart_lang/jnigen/generics/StringMap");

  /// The type which includes information such as the signature of this class.
  static const type = $StringMapType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory StringMap() {
    return StringMap.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $StringMapType extends jni.JObjType<StringMap> {
  const $StringMapType();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/StringMap;";

  @override
  StringMap fromReference(jni.JReference reference) =>
      StringMap.fromReference(reference);

  @override
  jni.JObjType get superType => const $StringKeyedMapType(jni.JStringType());

  @override
  final superCount = 3;

  @override
  int get hashCode => ($StringMapType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringMapType) && other is $StringMapType;
  }
}
