// AUTO GENERATED BY JNIGEN 0.15.1. DO NOT EDIT!

// Copyright (c) 2022, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `com.github.dart_lang.jnigen.simple_package.Example$Nested$NestedTwice`
extension type Example$Nested$NestedTwice._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example$Nested$NestedTwice');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Example$Nested$NestedTwice> type =
      $Example$Nested$NestedTwice$Type$();
  static final _id_ZERO = _class.staticFieldId(
    r'ZERO',
    r'I',
  );

  /// from: `static public int ZERO`
  static int get ZERO => _id_ZERO.get(_class, jni$_.jint.type);

  /// from: `static public int ZERO`
  static set ZERO(int value) => _id_ZERO.set(_class, jni$_.jint.type, value);

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example$Nested$NestedTwice() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<Example$Nested$NestedTwice>();
  }
}

final class $Example$Nested$NestedTwice$Type$
    extends jni$_.JType<Example$Nested$NestedTwice> {
  @jni$_.internal
  const $Example$Nested$NestedTwice$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$Nested$NestedTwice;';
}

/// from: `com.github.dart_lang.jnigen.simple_package.Example$Nested`
extension type Example$Nested._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example$Nested');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Example$Nested> type = $Example$Nested$Type$();
  static final _id_new$ = _class.constructorId(
    r'(Z)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void <init>(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example$Nested(
    core$_.bool z,
  ) {
    return _new$(
            _class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<Example$Nested>();
  }

  static final _id_usesAnonymousInnerClass = _class.instanceMethodId(
    r'usesAnonymousInnerClass',
    r'()V',
  );

  static final _usesAnonymousInnerClass = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void usesAnonymousInnerClass()`
  void usesAnonymousInnerClass() {
    _usesAnonymousInnerClass(reference.pointer,
            _id_usesAnonymousInnerClass as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getValue = _class.instanceMethodId(
    r'getValue',
    r'()Z',
  );

  static final _getValue = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getValue()`
  core$_.bool getValue() {
    return _getValue(reference.pointer, _id_getValue as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setValue = _class.instanceMethodId(
    r'setValue',
    r'(Z)V',
  );

  static final _setValue = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setValue(boolean z)`
  void setValue(
    core$_.bool z,
  ) {
    _setValue(reference.pointer, _id_setValue as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }
}

final class $Example$Nested$Type$ extends jni$_.JType<Example$Nested> {
  @jni$_.internal
  const $Example$Nested$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;';
}

/// from: `com.github.dart_lang.jnigen.simple_package.Example$NonStaticNested`
extension type Example$NonStaticNested._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example$NonStaticNested');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Example$NonStaticNested> type =
      $Example$NonStaticNested$Type$();
  static final _id_ok = _class.instanceFieldId(
    r'ok',
    r'Z',
  );

  /// from: `public boolean ok`
  core$_.bool get ok => _id_ok.get(this, jni$_.jboolean.type);

  /// from: `public boolean ok`
  set ok(core$_.bool value) => _id_ok.set(this, jni$_.jboolean.type, value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/simple_package/Example;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.simple_package.Example $outerClass)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example$NonStaticNested(
    Example $outerClass,
  ) {
    final _$$outerClass = $outerClass.reference;
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
            _$$outerClass.pointer)
        .object<Example$NonStaticNested>();
  }
}

final class $Example$NonStaticNested$Type$
    extends jni$_.JType<Example$NonStaticNested> {
  @jni$_.internal
  const $Example$NonStaticNested$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$NonStaticNested;';
}

/// from: `com.github.dart_lang.jnigen.simple_package.Example`
extension type Example._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Example> type = $Example$Type$();

  /// from: `static public final int ON`
  static const ON = 1;

  /// from: `static public final int OFF`
  static const OFF = 0;

  /// from: `static public final double PI`
  static const PI = 3.14159;

  /// from: `static public final char SEMICOLON`
  static const SEMICOLON = 59;
  static final _id_SEMICOLON_STRING = _class.staticFieldId(
    r'SEMICOLON_STRING',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SEMICOLON_STRING`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SEMICOLON_STRING =>
      _id_SEMICOLON_STRING.get(_class, const jni$_.$JObject$Type$());

  static final _id_unusedRandom = _class.staticFieldId(
    r'unusedRandom',
    r'Ljava/util/Random;',
  );

  /// from: `static public final java.util.Random unusedRandom`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? get unusedRandom =>
      _id_unusedRandom.get(_class, const jni$_.$JObject$Type$());

  static final _id_getAmount = _class.staticMethodId(
    r'getAmount',
    r'()I',
  );

  static final _getAmount = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public int getAmount()`
  static int getAmount() {
    return _getAmount(
            _class.reference.pointer, _id_getAmount as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getPi = _class.staticMethodId(
    r'getPi',
    r'()D',
  );

  static final _getPi = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public double getPi()`
  static double getPi() {
    return _getPi(_class.reference.pointer, _id_getPi as jni$_.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getAsterisk = _class.staticMethodId(
    r'getAsterisk',
    r'()C',
  );

  static final _getAsterisk = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticCharMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public char getAsterisk()`
  static int getAsterisk() {
    return _getAsterisk(
            _class.reference.pointer, _id_getAsterisk as jni$_.JMethodIDPtr)
        .char;
  }

  static final _id_getName = _class.staticMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? getName() {
    return _getName(_class.reference.pointer, _id_getName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>();
  }

  static final _id_getNestedInstance = _class.staticMethodId(
    r'getNestedInstance',
    r'()Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;',
  );

  static final _getNestedInstance = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.simple_package.Example$Nested getNestedInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static Example$Nested? getNestedInstance() {
    return _getNestedInstance(_class.reference.pointer,
            _id_getNestedInstance as jni$_.JMethodIDPtr)
        .object<Example$Nested?>();
  }

  static final _id_setAmount = _class.staticMethodId(
    r'setAmount',
    r'(I)V',
  );

  static final _setAmount = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public void setAmount(int i)`
  static void setAmount(
    int i,
  ) {
    _setAmount(_class.reference.pointer, _id_setAmount as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_setName = _class.staticMethodId(
    r'setName',
    r'(Ljava/lang/String;)V',
  );

  static final _setName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setName(java.lang.String string)`
  static void setName(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setName(_class.reference.pointer, _id_setName as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setNestedInstance = _class.staticMethodId(
    r'setNestedInstance',
    r'(Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;)V',
  );

  static final _setNestedInstance = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setNestedInstance(com.github.dart_lang.jnigen.simple_package.Example$Nested nested)`
  static void setNestedInstance(
    Example$Nested? nested,
  ) {
    final _$nested = nested?.reference ?? jni$_.jNullReference;
    _setNestedInstance(_class.reference.pointer,
            _id_setNestedInstance as jni$_.JMethodIDPtr, _$nested.pointer)
        .check();
  }

  static final _id_max4 = _class.staticMethodId(
    r'max4',
    r'(IIII)I',
  );

  static final _max4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, int)>();

  /// from: `static public int max4(int i, int i1, int i2, int i3)`
  static int max4(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _max4(_class.reference.pointer, _id_max4 as jni$_.JMethodIDPtr, i,
            i1, i2, i3)
        .integer;
  }

  static final _id_max8 = _class.staticMethodId(
    r'max8',
    r'(IIIIIIII)I',
  );

  static final _max8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, int, int, int, int, int)>();

  /// from: `static public int max8(int i, int i1, int i2, int i3, int i4, int i5, int i6, int i7)`
  static int max8(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
    int i7,
  ) {
    return _max8(_class.reference.pointer, _id_max8 as jni$_.JMethodIDPtr, i,
            i1, i2, i3, i4, i5, i6, i7)
        .integer;
  }

  static final _id_getNumber = _class.instanceMethodId(
    r'getNumber',
    r'()I',
  );

  static final _getNumber = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getNumber()`
  int getNumber() {
    return _getNumber(reference.pointer, _id_getNumber as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setNumber = _class.instanceMethodId(
    r'setNumber',
    r'(I)V',
  );

  static final _setNumber = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setNumber(int i)`
  void setNumber(
    int i,
  ) {
    _setNumber(reference.pointer, _id_setNumber as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_getIsUp = _class.instanceMethodId(
    r'getIsUp',
    r'()Z',
  );

  static final _getIsUp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getIsUp()`
  core$_.bool getIsUp() {
    return _getIsUp(reference.pointer, _id_getIsUp as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setUp = _class.instanceMethodId(
    r'setUp',
    r'(Z)V',
  );

  static final _setUp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setUp(boolean z)`
  void setUp(
    core$_.bool z,
  ) {
    _setUp(reference.pointer, _id_setUp as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getCodename = _class.instanceMethodId(
    r'getCodename',
    r'()Ljava/lang/String;',
  );

  static final _getCodename = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getCodename()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCodename() {
    return _getCodename(
            reference.pointer, _id_getCodename as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>();
  }

  static final _id_setCodename = _class.instanceMethodId(
    r'setCodename',
    r'(Ljava/lang/String;)V',
  );

  static final _setCodename = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setCodename(java.lang.String string)`
  void setCodename(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setCodename(reference.pointer, _id_setCodename as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getRandom = _class.instanceMethodId(
    r'getRandom',
    r'()Ljava/util/Random;',
  );

  static final _getRandom = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Random getRandom()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRandom() {
    return _getRandom(reference.pointer, _id_getRandom as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>();
  }

  static final _id_setRandom = _class.instanceMethodId(
    r'setRandom',
    r'(Ljava/util/Random;)V',
  );

  static final _setRandom = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setRandom(java.util.Random random)`
  void setRandom(
    jni$_.JObject? random,
  ) {
    final _$random = random?.reference ?? jni$_.jNullReference;
    _setRandom(reference.pointer, _id_setRandom as jni$_.JMethodIDPtr,
            _$random.pointer)
        .check();
  }

  static final _id_getRandomLong = _class.instanceMethodId(
    r'getRandomLong',
    r'()J',
  );

  static final _getRandomLong = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getRandomLong()`
  int getRandomLong() {
    return _getRandomLong(
            reference.pointer, _id_getRandomLong as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_add4Longs = _class.instanceMethodId(
    r'add4Longs',
    r'(JJJJ)J',
  );

  static final _add4Longs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, int)>();

  /// from: `public long add4Longs(long j, long j1, long j2, long j3)`
  int add4Longs(
    int j,
    int j1,
    int j2,
    int j3,
  ) {
    return _add4Longs(reference.pointer, _id_add4Longs as jni$_.JMethodIDPtr, j,
            j1, j2, j3)
        .long;
  }

  static final _id_add8Longs = _class.instanceMethodId(
    r'add8Longs',
    r'(JJJJJJJJ)J',
  );

  static final _add8Longs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, int, int, int, int, int)>();

  /// from: `public long add8Longs(long j, long j1, long j2, long j3, long j4, long j5, long j6, long j7)`
  int add8Longs(
    int j,
    int j1,
    int j2,
    int j3,
    int j4,
    int j5,
    int j6,
    int j7,
  ) {
    return _add8Longs(reference.pointer, _id_add8Longs as jni$_.JMethodIDPtr, j,
            j1, j2, j3, j4, j5, j6, j7)
        .long;
  }

  static final _id_getRandomNumericString = _class.instanceMethodId(
    r'getRandomNumericString',
    r'(Ljava/util/Random;)Ljava/lang/String;',
  );

  static final _getRandomNumericString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String getRandomNumericString(java.util.Random random)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRandomNumericString(
    jni$_.JObject? random,
  ) {
    final _$random = random?.reference ?? jni$_.jNullReference;
    return _getRandomNumericString(reference.pointer,
            _id_getRandomNumericString as jni$_.JMethodIDPtr, _$random.pointer)
        .object<jni$_.JString?>();
  }

  static final _id_finalMethod = _class.instanceMethodId(
    r'finalMethod',
    r'()V',
  );

  static final _finalMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final void finalMethod()`
  void finalMethod() {
    _finalMethod(reference.pointer, _id_finalMethod as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getList() {
    return _getList(reference.pointer, _id_getList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>();
  }

  static final _id_joinStrings = _class.instanceMethodId(
    r'joinStrings',
    r'(Ljava/util/List;Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _joinStrings = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String joinStrings(java.util.List<java.lang.String> list, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? joinStrings(
    jni$_.JList<jni$_.JString?>? list,
    jni$_.JString? string,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _joinStrings(
            reference.pointer,
            _id_joinStrings as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$string.pointer)
        .object<jni$_.JString?>();
  }

  static final _id_methodWithSeveralParams = _class.instanceMethodId(
    r'methodWithSeveralParams',
    r'(CLjava/lang/String;[ILjava/lang/CharSequence;Ljava/util/List;Ljava/util/Map;)V',
  );

  static final _methodWithSeveralParams = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void methodWithSeveralParams(char c, java.lang.String string, int[] is, T charSequence, java.util.List<T> list, java.util.Map<java.lang.String, ? extends java.lang.CharSequence> map)`
  void methodWithSeveralParams<$T extends jni$_.JObject?>(
    int c,
    jni$_.JString? string,
    jni$_.JIntArray? is$,
    $T? charSequence,
    jni$_.JList<$T?>? list,
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    _methodWithSeveralParams(
            reference.pointer,
            _id_methodWithSeveralParams as jni$_.JMethodIDPtr,
            c,
            _$string.pointer,
            _$is$.pointer,
            _$charSequence.pointer,
            _$list.pointer,
            _$map.pointer)
        .check();
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<Example>();
  }

  static final _id_new$1 = _class.constructorId(
    r'(I)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new$1(
    int i,
  ) {
    return _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr, i)
        .object<Example>();
  }

  static final _id_new$2 = _class.constructorId(
    r'(IZ)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public void <init>(int i, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new$2(
    int i,
    core$_.bool z,
  ) {
    return _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr, i,
            z ? 1 : 0)
        .object<Example>();
  }

  static final _id_new$3 = _class.constructorId(
    r'(IZLjava/lang/String;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(int i, boolean z, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new$3(
    int i,
    core$_.bool z,
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _new$3(_class.reference.pointer, _id_new$3 as jni$_.JMethodIDPtr, i,
            z ? 1 : 0, _$string.pointer)
        .object<Example>();
  }

  static final _id_new$4 = _class.constructorId(
    r'(IIIIIIII)V',
  );

  static final _new$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, int, int, int, int, int)>();

  /// from: `public void <init>(int i, int i1, int i2, int i3, int i4, int i5, int i6, int i7)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new$4(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
    int i7,
  ) {
    return _new$4(_class.reference.pointer, _id_new$4 as jni$_.JMethodIDPtr, i,
            i1, i2, i3, i4, i5, i6, i7)
        .object<Example>();
  }

  static final _id_whichExample = _class.instanceMethodId(
    r'whichExample',
    r'()I',
  );

  static final _whichExample = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int whichExample()`
  int whichExample() {
    return _whichExample(
            reference.pointer, _id_whichExample as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_addInts = _class.staticMethodId(
    r'addInts',
    r'(II)I',
  );

  static final _addInts = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `static public int addInts(int i, int i1)`
  static int addInts(
    int i,
    int i1,
  ) {
    return _addInts(
            _class.reference.pointer, _id_addInts as jni$_.JMethodIDPtr, i, i1)
        .integer;
  }

  static final _id_getArr = _class.staticMethodId(
    r'getArr',
    r'()[I',
  );

  static final _getArr = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public int[] getArr()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JIntArray? getArr() {
    return _getArr(_class.reference.pointer, _id_getArr as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>();
  }

  static final _id_addAll = _class.staticMethodId(
    r'addAll',
    r'([I)I',
  );

  static final _addAll = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public int addAll(int[] is)`
  static int addAll(
    jni$_.JIntArray? is$,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _addAll(_class.reference.pointer, _id_addAll as jni$_.JMethodIDPtr,
            _$is$.pointer)
        .integer;
  }

  static final _id_getSelf = _class.instanceMethodId(
    r'getSelf',
    r'()Lcom/github/dart_lang/jnigen/simple_package/Example;',
  );

  static final _getSelf = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.simple_package.Example getSelf()`
  /// The returned object must be released after use, by calling the [release] method.
  Example? getSelf() {
    return _getSelf(reference.pointer, _id_getSelf as jni$_.JMethodIDPtr)
        .object<Example?>();
  }

  static final _id_throwException = _class.staticMethodId(
    r'throwException',
    r'()V',
  );

  static final _throwException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void throwException()`
  static void throwException() {
    _throwException(
            _class.reference.pointer, _id_throwException as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_overloaded = _class.instanceMethodId(
    r'overloaded',
    r'()V',
  );

  static final _overloaded = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void overloaded()`
  void overloaded() {
    _overloaded(reference.pointer, _id_overloaded as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_overloaded$1 = _class.instanceMethodId(
    r'overloaded',
    r'(ILjava/lang/String;)V',
  );

  static final _overloaded$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void overloaded(int i, java.lang.String string)`
  void overloaded$1(
    int i,
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _overloaded$1(reference.pointer, _id_overloaded$1 as jni$_.JMethodIDPtr, i,
            _$string.pointer)
        .check();
  }

  static final _id_overloaded$2 = _class.instanceMethodId(
    r'overloaded',
    r'(I)V',
  );

  static final _overloaded$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void overloaded(int i)`
  void overloaded$2(
    int i,
  ) {
    _overloaded$2(reference.pointer, _id_overloaded$2 as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_overloaded$3 = _class.instanceMethodId(
    r'overloaded',
    r'(Ljava/util/List;Ljava/lang/String;)V',
  );

  static final _overloaded$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void overloaded(java.util.List<java.lang.Integer> list, java.lang.String string)`
  void overloaded$3(
    jni$_.JList<jni$_.JInteger?>? list,
    jni$_.JString? string,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _overloaded$3(reference.pointer, _id_overloaded$3 as jni$_.JMethodIDPtr,
            _$list.pointer, _$string.pointer)
        .check();
  }

  static final _id_overloaded$4 = _class.instanceMethodId(
    r'overloaded',
    r'(Ljava/util/List;)V',
  );

  static final _overloaded$4 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void overloaded(java.util.List<java.lang.Integer> list)`
  void overloaded$4(
    jni$_.JList<jni$_.JInteger?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _overloaded$4(reference.pointer, _id_overloaded$4 as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }

  static final _id_bool = _class.instanceMethodId(
    r'bool',
    r'(Z)Z',
  );

  static final _bool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public boolean bool(boolean z)`
  core$_.bool bool(
    core$_.bool z,
  ) {
    return _bool(reference.pointer, _id_bool as jni$_.JMethodIDPtr, z ? 1 : 0)
        .boolean;
  }

  static final _id_num = _class.instanceMethodId(
    r'num',
    r'(D)D',
  );

  static final _num = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_
                      .VarArgs<(jni$_.Double,)>)>>('globalEnv_CallDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public double num(double d)`
  double num(
    double d,
  ) {
    return _num(reference.pointer, _id_num as jni$_.JMethodIDPtr, d)
        .doubleFloat;
  }
}

final class $Example$Type$ extends jni$_.JType<Example> {
  @jni$_.internal
  const $Example$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example;';
}

/// from: `com.github.dart_lang.jnigen.simple_package.Exceptions`
extension type Exceptions._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Exceptions');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Exceptions> type = $Exceptions$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<Exceptions>();
  }

  static final _id_new$1 = _class.constructorId(
    r'(F)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Double,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public void <init>(float f)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions.new$1(
    double f,
  ) {
    return _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr, f)
        .object<Exceptions>();
  }

  static final _id_new$2 = _class.constructorId(
    r'(IIIIII)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, int, int, int)>();

  /// from: `public void <init>(int i, int i1, int i2, int i3, int i4, int i5)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions.new$2(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    return _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr, i,
            i1, i2, i3, i4, i5)
        .object<Exceptions>();
  }

  static final _id_staticObjectMethod = _class.staticMethodId(
    r'staticObjectMethod',
    r'()Ljava/lang/Object;',
  );

  static final _staticObjectMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.Object staticObjectMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? staticObjectMethod() {
    return _staticObjectMethod(_class.reference.pointer,
            _id_staticObjectMethod as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>();
  }

  static final _id_staticIntMethod = _class.staticMethodId(
    r'staticIntMethod',
    r'()I',
  );

  static final _staticIntMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public int staticIntMethod()`
  static int staticIntMethod() {
    return _staticIntMethod(
            _class.reference.pointer, _id_staticIntMethod as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_staticObjectArrayMethod = _class.staticMethodId(
    r'staticObjectArrayMethod',
    r'()[Ljava/lang/Object;',
  );

  static final _staticObjectArrayMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.Object[] staticObjectArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JObject?>? staticObjectArrayMethod() {
    return _staticObjectArrayMethod(_class.reference.pointer,
            _id_staticObjectArrayMethod as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JObject?>?>();
  }

  static final _id_staticIntArrayMethod = _class.staticMethodId(
    r'staticIntArrayMethod',
    r'()[I',
  );

  static final _staticIntArrayMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public int[] staticIntArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JIntArray? staticIntArrayMethod() {
    return _staticIntArrayMethod(_class.reference.pointer,
            _id_staticIntArrayMethod as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>();
  }

  static final _id_objectMethod = _class.instanceMethodId(
    r'objectMethod',
    r'()Ljava/lang/Object;',
  );

  static final _objectMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object objectMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? objectMethod() {
    return _objectMethod(
            reference.pointer, _id_objectMethod as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>();
  }

  static final _id_intMethod = _class.instanceMethodId(
    r'intMethod',
    r'()I',
  );

  static final _intMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int intMethod()`
  int intMethod() {
    return _intMethod(reference.pointer, _id_intMethod as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_objectArrayMethod = _class.instanceMethodId(
    r'objectArrayMethod',
    r'()[Ljava/lang/Object;',
  );

  static final _objectArrayMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object[] objectArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? objectArrayMethod() {
    return _objectArrayMethod(
            reference.pointer, _id_objectArrayMethod as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JObject?>?>();
  }

  static final _id_intArrayMethod = _class.instanceMethodId(
    r'intArrayMethod',
    r'()[I',
  );

  static final _intArrayMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int[] intArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? intArrayMethod() {
    return _intArrayMethod(
            reference.pointer, _id_intArrayMethod as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>();
  }

  static final _id_throwNullPointerException = _class.instanceMethodId(
    r'throwNullPointerException',
    r'()I',
  );

  static final _throwNullPointerException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int throwNullPointerException()`
  int throwNullPointerException() {
    return _throwNullPointerException(reference.pointer,
            _id_throwNullPointerException as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_throwFileNotFoundException = _class.instanceMethodId(
    r'throwFileNotFoundException',
    r'()Ljava/io/InputStream;',
  );

  static final _throwFileNotFoundException =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.io.InputStream throwFileNotFoundException()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwFileNotFoundException() {
    return _throwFileNotFoundException(reference.pointer,
            _id_throwFileNotFoundException as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>();
  }

  static final _id_throwClassCastException = _class.instanceMethodId(
    r'throwClassCastException',
    r'()Ljava/io/FileInputStream;',
  );

  static final _throwClassCastException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.io.FileInputStream throwClassCastException()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwClassCastException() {
    return _throwClassCastException(reference.pointer,
            _id_throwClassCastException as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>();
  }

  static final _id_throwArrayIndexException = _class.instanceMethodId(
    r'throwArrayIndexException',
    r'()I',
  );

  static final _throwArrayIndexException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int throwArrayIndexException()`
  int throwArrayIndexException() {
    return _throwArrayIndexException(reference.pointer,
            _id_throwArrayIndexException as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_throwArithmeticException = _class.instanceMethodId(
    r'throwArithmeticException',
    r'()I',
  );

  static final _throwArithmeticException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int throwArithmeticException()`
  int throwArithmeticException() {
    return _throwArithmeticException(reference.pointer,
            _id_throwArithmeticException as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_throwLoremIpsum = _class.staticMethodId(
    r'throwLoremIpsum',
    r'()V',
  );

  static final _throwLoremIpsum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void throwLoremIpsum()`
  static void throwLoremIpsum() {
    _throwLoremIpsum(
            _class.reference.pointer, _id_throwLoremIpsum as jni$_.JMethodIDPtr)
        .check();
  }
}

final class $Exceptions$Type$ extends jni$_.JType<Exceptions> {
  @jni$_.internal
  const $Exceptions$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Exceptions;';
}

/// from: `com.github.dart_lang.jnigen.simple_package.Fields$Nested`
extension type Fields$Nested._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Fields$Nested');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Fields$Nested> type = $Fields$Nested$Type$();
  static final _id_hundred = _class.instanceFieldId(
    r'hundred',
    r'J',
  );

  /// from: `public long hundred`
  int get hundred => _id_hundred.get(this, jni$_.jlong.type);

  /// from: `public long hundred`
  set hundred(int value) => _id_hundred.set(this, jni$_.jlong.type, value);

  static final _id_BEST_GOD = _class.staticFieldId(
    r'BEST_GOD',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String BEST_GOD`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BEST_GOD =>
      _id_BEST_GOD.get(_class, const jni$_.$JObject$Type$());

  /// from: `static public java.lang.String BEST_GOD`
  /// The returned object must be released after use, by calling the [release] method.
  static set BEST_GOD(jni$_.JString? value) =>
      _id_BEST_GOD.set(_class, const jni$_.$JObject$Type$(), value);

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Fields$Nested() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<Fields$Nested>();
  }
}

final class $Fields$Nested$Type$ extends jni$_.JType<Fields$Nested> {
  @jni$_.internal
  const $Fields$Nested$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Fields$Nested;';
}

/// from: `com.github.dart_lang.jnigen.simple_package.Fields`
extension type Fields._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Fields');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Fields> type = $Fields$Type$();
  static final _id_amount = _class.staticFieldId(
    r'amount',
    r'I',
  );

  /// from: `static public int amount`
  static int get amount => _id_amount.get(_class, jni$_.jint.type);

  /// from: `static public int amount`
  static set amount(int value) =>
      _id_amount.set(_class, jni$_.jint.type, value);

  static final _id_pi = _class.staticFieldId(
    r'pi',
    r'D',
  );

  /// from: `static public double pi`
  static double get pi => _id_pi.get(_class, jni$_.jdouble.type);

  /// from: `static public double pi`
  static set pi(double value) => _id_pi.set(_class, jni$_.jdouble.type, value);

  static final _id_asterisk = _class.staticFieldId(
    r'asterisk',
    r'C',
  );

  /// from: `static public char asterisk`
  static int get asterisk => _id_asterisk.get(_class, jni$_.jchar.type);

  /// from: `static public char asterisk`
  static set asterisk(int value) =>
      _id_asterisk.set(_class, jni$_.jchar.type, value);

  static final _id_name = _class.staticFieldId(
    r'name',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String name`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get name =>
      _id_name.get(_class, const jni$_.$JObject$Type$());

  /// from: `static public java.lang.String name`
  /// The returned object must be released after use, by calling the [release] method.
  static set name(jni$_.JString? value) =>
      _id_name.set(_class, const jni$_.$JObject$Type$(), value);

  static final _id_i = _class.instanceFieldId(
    r'i',
    r'Ljava/lang/Integer;',
  );

  /// from: `public java.lang.Integer i`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JInteger? get i => _id_i.get(this, const jni$_.$JObject$Type$());

  /// from: `public java.lang.Integer i`
  /// The returned object must be released after use, by calling the [release] method.
  set i(jni$_.JInteger? value) =>
      _id_i.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_trillion = _class.instanceFieldId(
    r'trillion',
    r'J',
  );

  /// from: `public long trillion`
  int get trillion => _id_trillion.get(this, jni$_.jlong.type);

  /// from: `public long trillion`
  set trillion(int value) => _id_trillion.set(this, jni$_.jlong.type, value);

  static final _id_isAchillesDead = _class.instanceFieldId(
    r'isAchillesDead',
    r'Z',
  );

  /// from: `public boolean isAchillesDead`
  core$_.bool get isAchillesDead =>
      _id_isAchillesDead.get(this, jni$_.jboolean.type);

  /// from: `public boolean isAchillesDead`
  set isAchillesDead(core$_.bool value) =>
      _id_isAchillesDead.set(this, jni$_.jboolean.type, value);

  static final _id_bestFighterInGreece = _class.instanceFieldId(
    r'bestFighterInGreece',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String bestFighterInGreece`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get bestFighterInGreece =>
      _id_bestFighterInGreece.get(this, const jni$_.$JObject$Type$());

  /// from: `public java.lang.String bestFighterInGreece`
  /// The returned object must be released after use, by calling the [release] method.
  set bestFighterInGreece(jni$_.JString? value) =>
      _id_bestFighterInGreece.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_random = _class.instanceFieldId(
    r'random',
    r'Ljava/util/Random;',
  );

  /// from: `public java.util.Random random`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get random =>
      _id_random.get(this, const jni$_.$JObject$Type$());

  /// from: `public java.util.Random random`
  /// The returned object must be released after use, by calling the [release] method.
  set random(jni$_.JObject? value) =>
      _id_random.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_euroSymbol = _class.staticFieldId(
    r'euroSymbol',
    r'C',
  );

  /// from: `static public char euroSymbol`
  static int get euroSymbol => _id_euroSymbol.get(_class, jni$_.jchar.type);

  /// from: `static public char euroSymbol`
  static set euroSymbol(int value) =>
      _id_euroSymbol.set(_class, jni$_.jchar.type, value);

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Fields() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<Fields>();
  }
}

final class $Fields$Type$ extends jni$_.JType<Fields> {
  @jni$_.internal
  const $Fields$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Fields;';
}

/// from: `com.github.dart_lang.jnigen.pkg2.C2`
extension type C2._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/pkg2/C2');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<C2> type = $C2$Type$();
  static final _id_CONSTANT = _class.staticFieldId(
    r'CONSTANT',
    r'I',
  );

  /// from: `static public int CONSTANT`
  static int get CONSTANT => _id_CONSTANT.get(_class, jni$_.jint.type);

  /// from: `static public int CONSTANT`
  static set CONSTANT(int value) =>
      _id_CONSTANT.set(_class, jni$_.jint.type, value);

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory C2() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<C2>();
  }
}

final class $C2$Type$ extends jni$_.JType<C2> {
  @jni$_.internal
  const $C2$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/pkg2/C2;';
}

/// from: `com.github.dart_lang.jnigen.pkg2.Example`
extension type Example$1._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/pkg2/Example');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Example$1> type = $Example$1$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example$1() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<Example$1>();
  }

  static final _id_whichExample = _class.instanceMethodId(
    r'whichExample',
    r'()I',
  );

  static final _whichExample = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int whichExample()`
  int whichExample() {
    return _whichExample(
            reference.pointer, _id_whichExample as jni$_.JMethodIDPtr)
        .integer;
  }
}

final class $Example$1$Type$ extends jni$_.JType<Example$1> {
  @jni$_.internal
  const $Example$1$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/pkg2/Example;';
}

/// from: `com.github.dart_lang.jnigen.enums.Colors$RGB`
extension type Colors$RGB._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/enums/Colors$RGB');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Colors$RGB> type = $Colors$RGB$Type$();
  static final _id_red = _class.instanceFieldId(
    r'red',
    r'I',
  );

  /// from: `public int red`
  int get red => _id_red.get(this, jni$_.jint.type);

  /// from: `public int red`
  set red(int value) => _id_red.set(this, jni$_.jint.type, value);

  static final _id_green = _class.instanceFieldId(
    r'green',
    r'I',
  );

  /// from: `public int green`
  int get green => _id_green.get(this, jni$_.jint.type);

  /// from: `public int green`
  set green(int value) => _id_green.set(this, jni$_.jint.type, value);

  static final _id_blue = _class.instanceFieldId(
    r'blue',
    r'I',
  );

  /// from: `public int blue`
  int get blue => _id_blue.get(this, jni$_.jint.type);

  /// from: `public int blue`
  set blue(int value) => _id_blue.set(this, jni$_.jint.type, value);

  static final _id_new$ = _class.constructorId(
    r'(III)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int, int)>();

  /// from: `public void <init>(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Colors$RGB(
    int i,
    int i1,
    int i2,
  ) {
    return _new$(
            _class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr, i, i1, i2)
        .object<Colors$RGB>();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  core$_.bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }
}

final class $Colors$RGB$Type$ extends jni$_.JType<Colors$RGB> {
  @jni$_.internal
  const $Colors$RGB$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/enums/Colors$RGB;';
}

/// from: `com.github.dart_lang.jnigen.enums.Colors`
extension type Colors._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/enums/Colors');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Colors> type = $Colors$Type$();
  static final _id_red = _class.staticFieldId(
    r'red',
    r'Lcom/github/dart_lang/jnigen/enums/Colors;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.enums.Colors red`
  /// The returned object must be released after use, by calling the [release] method.
  static Colors get red => _id_red.get(_class, const jni$_.$JObject$Type$());

  static final _id_green = _class.staticFieldId(
    r'green',
    r'Lcom/github/dart_lang/jnigen/enums/Colors;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.enums.Colors green`
  /// The returned object must be released after use, by calling the [release] method.
  static Colors get green =>
      _id_green.get(_class, const jni$_.$JObject$Type$());

  static final _id_blue = _class.staticFieldId(
    r'blue',
    r'Lcom/github/dart_lang/jnigen/enums/Colors;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.enums.Colors blue`
  /// The returned object must be released after use, by calling the [release] method.
  static Colors get blue => _id_blue.get(_class, const jni$_.$JObject$Type$());

  static final _id_code = _class.instanceFieldId(
    r'code',
    r'I',
  );

  /// from: `public final int code`
  int get code => _id_code.get(this, jni$_.jint.type);

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lcom/github/dart_lang/jnigen/enums/Colors;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.enums.Colors[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Colors?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<Colors?>?>();
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lcom/github/dart_lang/jnigen/enums/Colors;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.enums.Colors valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Colors? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<Colors?>();
  }

  static final _id_toRGB = _class.instanceMethodId(
    r'toRGB',
    r'()Lcom/github/dart_lang/jnigen/enums/Colors$RGB;',
  );

  static final _toRGB = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.enums.Colors$RGB toRGB()`
  /// The returned object must be released after use, by calling the [release] method.
  Colors$RGB? toRGB() {
    return _toRGB(reference.pointer, _id_toRGB as jni$_.JMethodIDPtr)
        .object<Colors$RGB?>();
  }
}

final class $Colors$Type$ extends jni$_.JType<Colors> {
  @jni$_.internal
  const $Colors$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/enums/Colors;';
}

/// from: `com.github.dart_lang.jnigen.generics.GenericTypeParams`
extension type GenericTypeParams<$S extends jni$_.JObject?,
        $K extends jni$_.JObject?>._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GenericTypeParams');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<GenericTypeParams> type = $GenericTypeParams$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory GenericTypeParams() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<GenericTypeParams<$S, $K>>();
  }
}

final class $GenericTypeParams$Type$ extends jni$_.JType<GenericTypeParams> {
  @jni$_.internal
  const $GenericTypeParams$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GenericTypeParams;';
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$Parent$Child`
extension type GrandParent$Parent$Child<$T extends jni$_.JObject?,
        $S extends jni$_.JObject?, $U extends jni$_.JObject?>._(
    jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$Parent$Child');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<GrandParent$Parent$Child> type =
      $GrandParent$Parent$Child$Type$();
  static final _id_grandParentValue = _class.instanceFieldId(
    r'grandParentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public T grandParentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get grandParentValue =>
      _id_grandParentValue.get(this, const jni$_.$JObject$Type$());

  /// from: `public T grandParentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set grandParentValue($T? value) =>
      _id_grandParentValue.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_parentValue = _class.instanceFieldId(
    r'parentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $S? get parentValue =>
      _id_parentValue.get(this, const jni$_.$JObject$Type$());

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($S? value) =>
      _id_parentValue.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  $U? get value => _id_value.get(this, const jni$_.$JObject$Type$());

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($U? value) =>
      _id_value.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.GrandParent$Parent<T, S> $outerClass, U object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent$Parent$Child(
    GrandParent$Parent<$T?, $S?> $outerClass,
    $U? object,
  ) {
    final _$$outerClass = $outerClass.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
            _$$outerClass.pointer, _$object.pointer)
        .object<GrandParent$Parent$Child<$T, $S, $U>>();
  }
}

final class $GrandParent$Parent$Child$Type$
    extends jni$_.JType<GrandParent$Parent$Child> {
  @jni$_.internal
  const $GrandParent$Parent$Child$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent$Child;';
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$Parent`
extension type GrandParent$Parent<$T extends jni$_.JObject?,
        $S extends jni$_.JObject?>._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$Parent');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<GrandParent$Parent> type =
      $GrandParent$Parent$Type$();
  static final _id_parentValue = _class.instanceFieldId(
    r'parentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public T parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get parentValue =>
      _id_parentValue.get(this, const jni$_.$JObject$Type$());

  /// from: `public T parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($T? value) =>
      _id_parentValue.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  $S? get value => _id_value.get(this, const jni$_.$JObject$Type$());

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($S? value) =>
      _id_value.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/GrandParent;Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.GrandParent<T> $outerClass, S object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent$Parent(
    GrandParent<$T?> $outerClass,
    $S? object,
  ) {
    final _$$outerClass = $outerClass.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
            _$$outerClass.pointer, _$object.pointer)
        .object<GrandParent$Parent<$T, $S>>();
  }
}

final class $GrandParent$Parent$Type$ extends jni$_.JType<GrandParent$Parent> {
  @jni$_.internal
  const $GrandParent$Parent$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;';
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$StaticParent$Child`
extension type GrandParent$StaticParent$Child<$S extends jni$_.JObject?,
        $U extends jni$_.JObject?>._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<GrandParent$StaticParent$Child> type =
      $GrandParent$StaticParent$Child$Type$();
  static final _id_parentValue = _class.instanceFieldId(
    r'parentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $S? get parentValue =>
      _id_parentValue.get(this, const jni$_.$JObject$Type$());

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($S? value) =>
      _id_parentValue.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  $U? get value => _id_value.get(this, const jni$_.$JObject$Type$());

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($U? value) =>
      _id_value.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.GrandParent$StaticParent<S> $outerClass, S object, U object1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent$StaticParent$Child(
    GrandParent$StaticParent<$S?> $outerClass,
    $S? object,
    $U? object1,
  ) {
    final _$$outerClass = $outerClass.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
            _$$outerClass.pointer, _$object.pointer, _$object1.pointer)
        .object<GrandParent$StaticParent$Child<$S, $U>>();
  }
}

final class $GrandParent$StaticParent$Child$Type$
    extends jni$_.JType<GrandParent$StaticParent$Child> {
  @jni$_.internal
  const $GrandParent$StaticParent$Child$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child;';
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$StaticParent`
extension type GrandParent$StaticParent<$S extends jni$_.JObject?>._(
    jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$StaticParent');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<GrandParent$StaticParent> type =
      $GrandParent$StaticParent$Type$();
  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  $S? get value => _id_value.get(this, const jni$_.$JObject$Type$());

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($S? value) =>
      _id_value.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(S object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent$StaticParent(
    $S? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<GrandParent$StaticParent<$S>>();
  }
}

final class $GrandParent$StaticParent$Type$
    extends jni$_.JType<GrandParent$StaticParent> {
  @jni$_.internal
  const $GrandParent$StaticParent$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;';
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent`
extension type GrandParent<$T extends jni$_.JObject?>._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/generics/GrandParent');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<GrandParent> type = $GrandParent$Type$();
  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public T value`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get value => _id_value.get(this, const jni$_.$JObject$Type$());

  /// from: `public T value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($T? value) =>
      _id_value.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(T object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent(
    $T? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<GrandParent<$T>>();
  }

  static final _id_stringParent = _class.instanceMethodId(
    r'stringParent',
    r'()Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;',
  );

  static final _stringParent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.generics.GrandParent$Parent<T, java.lang.String> stringParent()`
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent$Parent<$T?, jni$_.JString?>? stringParent() {
    return _stringParent(
            reference.pointer, _id_stringParent as jni$_.JMethodIDPtr)
        .object<GrandParent$Parent<$T?, jni$_.JString?>?>();
  }

  static final _id_varParent = _class.instanceMethodId(
    r'varParent',
    r'(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;',
  );

  static final _varParent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public com.github.dart_lang.jnigen.generics.GrandParent$Parent<T, S> varParent(S object)`
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent$Parent<$T?, $S?>? varParent<$S extends jni$_.JObject?>(
    $S? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _varParent(reference.pointer, _id_varParent as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<GrandParent$Parent<$T?, $S?>?>();
  }

  static final _id_stringStaticParent = _class.staticMethodId(
    r'stringStaticParent',
    r'()Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;',
  );

  static final _stringStaticParent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.generics.GrandParent$StaticParent<java.lang.String> stringStaticParent()`
  /// The returned object must be released after use, by calling the [release] method.
  static GrandParent$StaticParent<jni$_.JString?>? stringStaticParent() {
    return _stringStaticParent(_class.reference.pointer,
            _id_stringStaticParent as jni$_.JMethodIDPtr)
        .object<GrandParent$StaticParent<jni$_.JString?>?>();
  }

  static final _id_varStaticParent = _class.staticMethodId(
    r'varStaticParent',
    r'(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;',
  );

  static final _varStaticParent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.GrandParent$StaticParent<S> varStaticParent(S object)`
  /// The returned object must be released after use, by calling the [release] method.
  static GrandParent$StaticParent<$S?>?
      varStaticParent<$S extends jni$_.JObject?>(
    $S? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _varStaticParent(_class.reference.pointer,
            _id_varStaticParent as jni$_.JMethodIDPtr, _$object.pointer)
        .object<GrandParent$StaticParent<$S?>?>();
  }

  static final _id_staticParentWithSameType = _class.instanceMethodId(
    r'staticParentWithSameType',
    r'()Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;',
  );

  static final _staticParentWithSameType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.generics.GrandParent$StaticParent<T> staticParentWithSameType()`
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent$StaticParent<$T?>? staticParentWithSameType() {
    return _staticParentWithSameType(reference.pointer,
            _id_staticParentWithSameType as jni$_.JMethodIDPtr)
        .object<GrandParent$StaticParent<$T?>?>();
  }
}

final class $GrandParent$Type$ extends jni$_.JType<GrandParent> {
  @jni$_.internal
  const $GrandParent$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/GrandParent;';
}

/// from: `com.github.dart_lang.jnigen.generics.MyMap$MyEntry`
extension type MyMap$MyEntry<$K extends jni$_.JObject?,
        $V extends jni$_.JObject?>._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/MyMap$MyEntry');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<MyMap$MyEntry> type = $MyMap$MyEntry$Type$();
  static final _id_key = _class.instanceFieldId(
    r'key',
    r'Ljava/lang/Object;',
  );

  /// from: `public K key`
  /// The returned object must be released after use, by calling the [release] method.
  $K? get key => _id_key.get(this, const jni$_.$JObject$Type$());

  /// from: `public K key`
  /// The returned object must be released after use, by calling the [release] method.
  set key($K? value) => _id_key.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public V value`
  /// The returned object must be released after use, by calling the [release] method.
  $V? get value => _id_value.get(this, const jni$_.$JObject$Type$());

  /// from: `public V value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($V? value) =>
      _id_value.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/MyMap;Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.MyMap<K, V> $outerClass, K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyMap$MyEntry(
    MyMap<$K?, $V?> $outerClass,
    $K? object,
    $V? object1,
  ) {
    final _$$outerClass = $outerClass.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
            _$$outerClass.pointer, _$object.pointer, _$object1.pointer)
        .object<MyMap$MyEntry<$K, $V>>();
  }
}

final class $MyMap$MyEntry$Type$ extends jni$_.JType<MyMap$MyEntry> {
  @jni$_.internal
  const $MyMap$MyEntry$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/MyMap$MyEntry;';
}

/// from: `com.github.dart_lang.jnigen.generics.MyMap`
extension type MyMap<$K extends jni$_.JObject?, $V extends jni$_.JObject?>._(
    jni$_.JObject _$this) implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/generics/MyMap');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<MyMap> type = $MyMap$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyMap() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<MyMap<$K, $V>>();
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _get = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V get(K object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? get(
    $K? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _get(
            reference.pointer, _id_get as jni$_.JMethodIDPtr, _$object.pointer)
        .object<$V?>();
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _put = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V put(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? put(
    $K? object,
    $V? object1,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _put(reference.pointer, _id_put as jni$_.JMethodIDPtr,
            _$object.pointer, _$object1.pointer)
        .object<$V?>();
  }

  static final _id_entryStack = _class.instanceMethodId(
    r'entryStack',
    r'()Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _entryStack = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.generics.MyStack<com.github.dart_lang.jnigen.generics.MyMap$MyEntry<K, V>> entryStack()`
  /// The returned object must be released after use, by calling the [release] method.
  MyStack<MyMap$MyEntry<$K?, $V?>?>? entryStack() {
    return _entryStack(reference.pointer, _id_entryStack as jni$_.JMethodIDPtr)
        .object<MyStack<MyMap$MyEntry<$K?, $V?>?>?>();
  }
}

final class $MyMap$Type$ extends jni$_.JType<MyMap> {
  @jni$_.internal
  const $MyMap$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/MyMap;';
}

/// from: `com.github.dart_lang.jnigen.generics.MyStack`
extension type MyStack<$T extends jni$_.JObject?>._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/generics/MyStack');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<MyStack> type = $MyStack$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyStack() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<MyStack<$T>>();
  }

  static final _id_fromArray = _class.staticMethodId(
    r'fromArray',
    r'([Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _fromArray = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<T> fromArray(T[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T?>? fromArray<$T extends jni$_.JObject?>(
    jni$_.JArray<$T?>? objects,
  ) {
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _fromArray(_class.reference.pointer,
            _id_fromArray as jni$_.JMethodIDPtr, _$objects.pointer)
        .object<MyStack<$T?>?>();
  }

  static final _id_fromArrayOfArrayOfGrandParents = _class.staticMethodId(
    r'fromArrayOfArrayOfGrandParents',
    r'([[Lcom/github/dart_lang/jnigen/generics/GrandParent;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _fromArrayOfArrayOfGrandParents =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<S> fromArrayOfArrayOfGrandParents(com.github.dart_lang.jnigen.generics.GrandParent[][] grandParents)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$S?>?
      fromArrayOfArrayOfGrandParents<$S extends jni$_.JObject?>(
    jni$_.JArray<jni$_.JArray<GrandParent<$S?>?>?>? grandParents,
  ) {
    final _$grandParents = grandParents?.reference ?? jni$_.jNullReference;
    return _fromArrayOfArrayOfGrandParents(
            _class.reference.pointer,
            _id_fromArrayOfArrayOfGrandParents as jni$_.JMethodIDPtr,
            _$grandParents.pointer)
        .object<MyStack<$S?>?>();
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'()Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _of = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<T> of()`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T?>? of<$T extends jni$_.JObject?>() {
    return _of(_class.reference.pointer, _id_of as jni$_.JMethodIDPtr)
        .object<MyStack<$T?>?>();
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _of$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<T> of(T object)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T?>? of$1<$T extends jni$_.JObject?>(
    $T? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _of$1(_class.reference.pointer, _id_of$1 as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<MyStack<$T?>?>();
  }

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _of$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<T> of(T object, T object1)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T?>? of$2<$T extends jni$_.JObject?>(
    $T? object,
    $T? object1,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _of$2(_class.reference.pointer, _id_of$2 as jni$_.JMethodIDPtr,
            _$object.pointer, _$object1.pointer)
        .object<MyStack<$T?>?>();
  }

  static final _id_push = _class.instanceMethodId(
    r'push',
    r'(Ljava/lang/Object;)V',
  );

  static final _push = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void push(T object)`
  void push(
    $T? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _push(reference.pointer, _id_push as jni$_.JMethodIDPtr, _$object.pointer)
        .check();
  }

  static final _id_pop = _class.instanceMethodId(
    r'pop',
    r'()Ljava/lang/Object;',
  );

  static final _pop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public T pop()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? pop() {
    return _pop(reference.pointer, _id_pop as jni$_.JMethodIDPtr).object<$T?>();
  }

  static final _id_size = _class.instanceMethodId(
    r'size',
    r'()I',
  );

  static final _size = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int size()`
  int size() {
    return _size(reference.pointer, _id_size as jni$_.JMethodIDPtr).integer;
  }
}

final class $MyStack$Type$ extends jni$_.JType<MyStack> {
  @jni$_.internal
  const $MyStack$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/MyStack;';
}

/// from: `com.github.dart_lang.jnigen.generics.StringKeyedMap`
extension type StringKeyedMap<$V extends jni$_.JObject?>._(jni$_.JObject _$this)
    implements MyMap<jni$_.JString?, $V?> {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/StringKeyedMap');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<StringKeyedMap> type = $StringKeyedMap$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringKeyedMap() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<StringKeyedMap<$V>>();
  }
}

final class $StringKeyedMap$Type$ extends jni$_.JType<StringKeyedMap> {
  @jni$_.internal
  const $StringKeyedMap$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/StringKeyedMap;';
}

/// from: `com.github.dart_lang.jnigen.generics.StringMap`
extension type StringMap._(jni$_.JObject _$this)
    implements StringKeyedMap<jni$_.JString?> {
  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/generics/StringMap');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<StringMap> type = $StringMap$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringMap() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<StringMap>();
  }
}

final class $StringMap$Type$ extends jni$_.JType<StringMap> {
  @jni$_.internal
  const $StringMap$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/StringMap;';
}

/// from: `com.github.dart_lang.jnigen.generics.StringStack`
extension type StringStack._(jni$_.JObject _$this)
    implements MyStack<jni$_.JString?> {
  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/generics/StringStack');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<StringStack> type = $StringStack$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringStack() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<StringStack>();
  }
}

final class $StringStack$Type$ extends jni$_.JType<StringStack> {
  @jni$_.internal
  const $StringStack$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/StringStack;';
}

/// from: `com.github.dart_lang.jnigen.generics.StringValuedMap`
extension type StringValuedMap<$K extends jni$_.JObject?>._(
    jni$_.JObject _$this) implements MyMap<$K?, jni$_.JString?> {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/StringValuedMap');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<StringValuedMap> type = $StringValuedMap$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringValuedMap() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<StringValuedMap<$K>>();
  }
}

final class $StringValuedMap$Type$ extends jni$_.JType<StringValuedMap> {
  @jni$_.internal
  const $StringValuedMap$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/StringValuedMap;';
}

/// from: `com.github.dart_lang.jnigen.interfaces.GenericInterface`
extension type GenericInterface<$T extends jni$_.JObject?>._(
    jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/GenericInterface');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<GenericInterface> type = $GenericInterface$Type$();
  static final _id_genericArrayOf = _class.instanceMethodId(
    r'genericArrayOf',
    r'(Ljava/lang/Object;)[Ljava/lang/Object;',
  );

  static final _genericArrayOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract U[] genericArrayOf(U object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<$U?>? genericArrayOf<$U extends jni$_.JObject?>(
    $U? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _genericArrayOf(reference.pointer,
            _id_genericArrayOf as jni$_.JMethodIDPtr, _$object.pointer)
        .object<jni$_.JArray<$U?>?>();
  }

  static final _id_arrayOf = _class.instanceMethodId(
    r'arrayOf',
    r'(Ljava/lang/Object;)[Ljava/lang/Object;',
  );

  static final _arrayOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract T[] arrayOf(T object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<$T?>? arrayOf(
    $T? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _arrayOf(reference.pointer, _id_arrayOf as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<jni$_.JArray<$T?>?>();
  }

  static final _id_mapOf = _class.instanceMethodId(
    r'mapOf',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/Map;',
  );

  static final _mapOf = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map<T, U> mapOf(T object, U object1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<$T?, $U?>? mapOf<$U extends jni$_.JObject?>(
    $T? object,
    $U? object1,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _mapOf(reference.pointer, _id_mapOf as jni$_.JMethodIDPtr,
            _$object.pointer, _$object1.pointer)
        .object<jni$_.JMap<$T?, $U?>?>();
  }

  static final _id_firstOfGenericArray = _class.instanceMethodId(
    r'firstOfGenericArray',
    r'([Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _firstOfGenericArray = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract U firstOfGenericArray(U[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  $U? firstOfGenericArray<$U extends jni$_.JObject?>(
    jni$_.JArray<$U?>? objects,
  ) {
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _firstOfGenericArray(reference.pointer,
            _id_firstOfGenericArray as jni$_.JMethodIDPtr, _$objects.pointer)
        .object<$U?>();
  }

  static final _id_firstOfArray = _class.instanceMethodId(
    r'firstOfArray',
    r'([Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _firstOfArray = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract T firstOfArray(T[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstOfArray(
    jni$_.JArray<$T?>? objects,
  ) {
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _firstOfArray(reference.pointer,
            _id_firstOfArray as jni$_.JMethodIDPtr, _$objects.pointer)
        .object<$T?>();
  }

  static final _id_firstKeyOf = _class.instanceMethodId(
    r'firstKeyOf',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstKeyOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract T firstKeyOf(java.util.Map<T, U> map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstKeyOf<$U extends jni$_.JObject?>(
    jni$_.JMap<$T?, $U?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _firstKeyOf(reference.pointer, _id_firstKeyOf as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<$T?>();
  }

  static final _id_firstValueOf = _class.instanceMethodId(
    r'firstValueOf',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract U firstValueOf(java.util.Map<T, U> map)`
  /// The returned object must be released after use, by calling the [release] method.
  $U? firstValueOf<$U extends jni$_.JObject?>(
    jni$_.JMap<$T?, $U?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _firstValueOf(reference.pointer,
            _id_firstValueOf as jni$_.JMethodIDPtr, _$map.pointer)
        .object<$U?>();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $GenericInterface> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'genericArrayOf(Ljava/lang/Object;)[Ljava/lang/Object;') {
        final $r = _$impls[$p]!.genericArrayOf(
          $a![0],
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'arrayOf(Ljava/lang/Object;)[Ljava/lang/Object;') {
        final $r = _$impls[$p]!.arrayOf(
          $a![0],
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'mapOf(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.mapOf(
          $a![0],
          $a![1],
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'firstOfGenericArray([Ljava/lang/Object;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.firstOfGenericArray(
          $a![0],
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'firstOfArray([Ljava/lang/Object;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.firstOfArray(
          $a![0],
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'firstKeyOf(Ljava/util/Map;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.firstKeyOf(
          $a![0],
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'firstValueOf(Ljava/util/Map;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.firstValueOf(
          $a![0],
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$T extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $GenericInterface<$T> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.interfaces.GenericInterface',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory GenericInterface.implement(
    $GenericInterface<$T> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<GenericInterface<$T>>();
  }
}

abstract base mixin class $GenericInterface<$T extends jni$_.JObject?> {
  factory $GenericInterface({
    required jni$_.JArray<jni$_.JObject?>? Function(jni$_.JObject? object)
        genericArrayOf,
    required jni$_.JArray<jni$_.JObject?>? Function($T? object) arrayOf,
    required jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? Function(
            $T? object, jni$_.JObject? object1)
        mapOf,
    required jni$_.JObject? Function(jni$_.JArray<jni$_.JObject?>? objects)
        firstOfGenericArray,
    required $T? Function(jni$_.JArray<jni$_.JObject?>? objects) firstOfArray,
    required $T? Function(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
        firstKeyOf,
    required jni$_.JObject? Function(
            jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
        firstValueOf,
  }) = _$GenericInterface<$T>;

  jni$_.JArray<jni$_.JObject?>? genericArrayOf(jni$_.JObject? object);
  jni$_.JArray<jni$_.JObject?>? arrayOf($T? object);
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? mapOf(
      $T? object, jni$_.JObject? object1);
  jni$_.JObject? firstOfGenericArray(jni$_.JArray<jni$_.JObject?>? objects);
  $T? firstOfArray(jni$_.JArray<jni$_.JObject?>? objects);
  $T? firstKeyOf(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map);
  jni$_.JObject? firstValueOf(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map);
}

final class _$GenericInterface<$T extends jni$_.JObject?>
    with $GenericInterface<$T> {
  _$GenericInterface({
    required jni$_.JArray<jni$_.JObject?>? Function(jni$_.JObject? object)
        genericArrayOf,
    required jni$_.JArray<jni$_.JObject?>? Function($T? object) arrayOf,
    required jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? Function(
            $T? object, jni$_.JObject? object1)
        mapOf,
    required jni$_.JObject? Function(jni$_.JArray<jni$_.JObject?>? objects)
        firstOfGenericArray,
    required $T? Function(jni$_.JArray<jni$_.JObject?>? objects) firstOfArray,
    required $T? Function(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
        firstKeyOf,
    required jni$_.JObject? Function(
            jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
        firstValueOf,
  })  : _genericArrayOf = genericArrayOf,
        _arrayOf = arrayOf,
        _mapOf = mapOf,
        _firstOfGenericArray = firstOfGenericArray,
        _firstOfArray = firstOfArray,
        _firstKeyOf = firstKeyOf,
        _firstValueOf = firstValueOf;

  final jni$_.JArray<jni$_.JObject?>? Function(jni$_.JObject? object)
      _genericArrayOf;
  final jni$_.JArray<jni$_.JObject?>? Function($T? object) _arrayOf;
  final jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? Function(
      $T? object, jni$_.JObject? object1) _mapOf;
  final jni$_.JObject? Function(jni$_.JArray<jni$_.JObject?>? objects)
      _firstOfGenericArray;
  final $T? Function(jni$_.JArray<jni$_.JObject?>? objects) _firstOfArray;
  final $T? Function(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
      _firstKeyOf;
  final jni$_.JObject? Function(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
      _firstValueOf;

  jni$_.JArray<jni$_.JObject?>? genericArrayOf(jni$_.JObject? object) {
    return _genericArrayOf(object);
  }

  jni$_.JArray<jni$_.JObject?>? arrayOf($T? object) {
    return _arrayOf(object);
  }

  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? mapOf(
      $T? object, jni$_.JObject? object1) {
    return _mapOf(object, object1);
  }

  jni$_.JObject? firstOfGenericArray(jni$_.JArray<jni$_.JObject?>? objects) {
    return _firstOfGenericArray(objects);
  }

  $T? firstOfArray(jni$_.JArray<jni$_.JObject?>? objects) {
    return _firstOfArray(objects);
  }

  $T? firstKeyOf(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map) {
    return _firstKeyOf(map);
  }

  jni$_.JObject? firstValueOf(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map) {
    return _firstValueOf(map);
  }
}

final class $GenericInterface$Type$ extends jni$_.JType<GenericInterface> {
  @jni$_.internal
  const $GenericInterface$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/GenericInterface;';
}

/// from: `com.github.dart_lang.jnigen.interfaces.InheritedFromMyInterface`
extension type InheritedFromMyInterface._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/InheritedFromMyInterface');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<InheritedFromMyInterface> type =
      $InheritedFromMyInterface$Type$();
  static final _id_voidCallback = _class.instanceMethodId(
    r'voidCallback',
    r'(Ljava/lang/String;)V',
  );

  static final _voidCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void voidCallback(java.lang.String string)`
  void voidCallback(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _voidCallback(reference.pointer, _id_voidCallback as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_stringCallback = _class.instanceMethodId(
    r'stringCallback',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _stringCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String stringCallback(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? stringCallback(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _stringCallback(reference.pointer,
            _id_stringCallback as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>();
  }

  static final _id_varCallback = _class.instanceMethodId(
    r'varCallback',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _varCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String varCallback(java.lang.String object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? varCallback(
    jni$_.JString? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _varCallback(reference.pointer,
            _id_varCallback as jni$_.JMethodIDPtr, _$object.pointer)
        .object<jni$_.JString?>();
  }

  static final _id_manyPrimitives = _class.instanceMethodId(
    r'manyPrimitives',
    r'(IZCD)J',
  );

  static final _manyPrimitives = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Double
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, double)>();

  /// from: `public abstract long manyPrimitives(int i, boolean z, char c, double d)`
  int manyPrimitives(
    int i,
    core$_.bool z,
    int c,
    double d,
  ) {
    return _manyPrimitives(reference.pointer,
            _id_manyPrimitives as jni$_.JMethodIDPtr, i, z ? 1 : 0, c, d)
        .long;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $InheritedFromMyInterface> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'voidCallback(Ljava/lang/String;)V') {
        _$impls[$p]!.voidCallback(
          $a![0],
        );
        return jni$_.nullptr;
      }
      if ($d == r'stringCallback(Ljava/lang/String;)Ljava/lang/String;') {
        final $r = _$impls[$p]!.stringCallback(
          $a![0],
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'varCallback(Ljava/lang/String;)Ljava/lang/String;') {
        final $r = _$impls[$p]!.varCallback(
          $a![0],
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'manyPrimitives(IZCD)J') {
        final $r = _$impls[$p]!.manyPrimitives(
          ($a![0] as jni$_.JInteger).intValue(releaseOriginal: true),
          ($a![1] as jni$_.JBoolean).booleanValue(releaseOriginal: true),
          ($a![2] as jni$_.JCharacter).charValue(releaseOriginal: true),
          ($a![3] as jni$_.JDouble).doubleValue(releaseOriginal: true),
        );
        return jni$_.JLong($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $InheritedFromMyInterface $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.interfaces.InheritedFromMyInterface',
      $p,
      _$invokePointer,
      [
        if ($impl.voidCallback$async) r'voidCallback(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory InheritedFromMyInterface.implement(
    $InheritedFromMyInterface $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<InheritedFromMyInterface>();
  }
}

abstract base mixin class $InheritedFromMyInterface {
  factory $InheritedFromMyInterface({
    required void Function(jni$_.JString? string) voidCallback,
    core$_.bool voidCallback$async,
    required jni$_.JString? Function(jni$_.JString? string) stringCallback,
    required jni$_.JString? Function(jni$_.JString? object) varCallback,
    required int Function(int i, core$_.bool z, int c, double d) manyPrimitives,
  }) = _$InheritedFromMyInterface;

  void voidCallback(jni$_.JString? string);
  core$_.bool get voidCallback$async => false;
  jni$_.JString? stringCallback(jni$_.JString? string);
  jni$_.JString? varCallback(jni$_.JString? object);
  int manyPrimitives(int i, core$_.bool z, int c, double d);
}

final class _$InheritedFromMyInterface with $InheritedFromMyInterface {
  _$InheritedFromMyInterface({
    required void Function(jni$_.JString? string) voidCallback,
    this.voidCallback$async = false,
    required jni$_.JString? Function(jni$_.JString? string) stringCallback,
    required jni$_.JString? Function(jni$_.JString? object) varCallback,
    required int Function(int i, core$_.bool z, int c, double d) manyPrimitives,
  })  : _voidCallback = voidCallback,
        _stringCallback = stringCallback,
        _varCallback = varCallback,
        _manyPrimitives = manyPrimitives;

  final void Function(jni$_.JString? string) _voidCallback;
  final core$_.bool voidCallback$async;
  final jni$_.JString? Function(jni$_.JString? string) _stringCallback;
  final jni$_.JString? Function(jni$_.JString? object) _varCallback;
  final int Function(int i, core$_.bool z, int c, double d) _manyPrimitives;

  void voidCallback(jni$_.JString? string) {
    return _voidCallback(string);
  }

  jni$_.JString? stringCallback(jni$_.JString? string) {
    return _stringCallback(string);
  }

  jni$_.JString? varCallback(jni$_.JString? object) {
    return _varCallback(object);
  }

  int manyPrimitives(int i, core$_.bool z, int c, double d) {
    return _manyPrimitives(i, z, c, d);
  }
}

final class $InheritedFromMyInterface$Type$
    extends jni$_.JType<InheritedFromMyInterface> {
  @jni$_.internal
  const $InheritedFromMyInterface$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/InheritedFromMyInterface;';
}

/// from: `com.github.dart_lang.jnigen.interfaces.InheritedFromMyRunnable`
extension type InheritedFromMyRunnable._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/InheritedFromMyRunnable');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<InheritedFromMyRunnable> type =
      $InheritedFromMyRunnable$Type$();
  static final _id_run = _class.instanceMethodId(
    r'run',
    r'()V',
  );

  static final _run = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void run()`
  void run() {
    _run(reference.pointer, _id_run as jni$_.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $InheritedFromMyRunnable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'run()V') {
        _$impls[$p]!.run();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $InheritedFromMyRunnable $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.interfaces.InheritedFromMyRunnable',
      $p,
      _$invokePointer,
      [
        if ($impl.run$async) r'run()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory InheritedFromMyRunnable.implement(
    $InheritedFromMyRunnable $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<InheritedFromMyRunnable>();
  }
}

abstract base mixin class $InheritedFromMyRunnable {
  factory $InheritedFromMyRunnable({
    required void Function() run,
    core$_.bool run$async,
  }) = _$InheritedFromMyRunnable;

  void run();
  core$_.bool get run$async => false;
}

final class _$InheritedFromMyRunnable with $InheritedFromMyRunnable {
  _$InheritedFromMyRunnable({
    required void Function() run,
    this.run$async = false,
  }) : _run = run;

  final void Function() _run;
  final core$_.bool run$async;

  void run() {
    return _run();
  }
}

final class $InheritedFromMyRunnable$Type$
    extends jni$_.JType<InheritedFromMyRunnable> {
  @jni$_.internal
  const $InheritedFromMyRunnable$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/InheritedFromMyRunnable;';
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyInterface`
extension type MyInterface<$T extends jni$_.JObject?>._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyInterface');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<MyInterface> type = $MyInterface$Type$();
  static final _id_voidCallback = _class.instanceMethodId(
    r'voidCallback',
    r'(Ljava/lang/String;)V',
  );

  static final _voidCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void voidCallback(java.lang.String string)`
  void voidCallback(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _voidCallback(reference.pointer, _id_voidCallback as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_stringCallback = _class.instanceMethodId(
    r'stringCallback',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _stringCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String stringCallback(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? stringCallback(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _stringCallback(reference.pointer,
            _id_stringCallback as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>();
  }

  static final _id_varCallback = _class.instanceMethodId(
    r'varCallback',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _varCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract T varCallback(T object)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? varCallback(
    $T? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _varCallback(reference.pointer,
            _id_varCallback as jni$_.JMethodIDPtr, _$object.pointer)
        .object<$T?>();
  }

  static final _id_manyPrimitives = _class.instanceMethodId(
    r'manyPrimitives',
    r'(IZCD)J',
  );

  static final _manyPrimitives = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Double
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, double)>();

  /// from: `public abstract long manyPrimitives(int i, boolean z, char c, double d)`
  int manyPrimitives(
    int i,
    core$_.bool z,
    int c,
    double d,
  ) {
    return _manyPrimitives(reference.pointer,
            _id_manyPrimitives as jni$_.JMethodIDPtr, i, z ? 1 : 0, c, d)
        .long;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MyInterface> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'voidCallback(Ljava/lang/String;)V') {
        _$impls[$p]!.voidCallback(
          $a![0],
        );
        return jni$_.nullptr;
      }
      if ($d == r'stringCallback(Ljava/lang/String;)Ljava/lang/String;') {
        final $r = _$impls[$p]!.stringCallback(
          $a![0],
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'varCallback(Ljava/lang/Object;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.varCallback(
          $a![0],
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'manyPrimitives(IZCD)J') {
        final $r = _$impls[$p]!.manyPrimitives(
          ($a![0] as jni$_.JInteger).intValue(releaseOriginal: true),
          ($a![1] as jni$_.JBoolean).booleanValue(releaseOriginal: true),
          ($a![2] as jni$_.JCharacter).charValue(releaseOriginal: true),
          ($a![3] as jni$_.JDouble).doubleValue(releaseOriginal: true),
        );
        return jni$_.JLong($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$T extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $MyInterface<$T> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.interfaces.MyInterface',
      $p,
      _$invokePointer,
      [
        if ($impl.voidCallback$async) r'voidCallback(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MyInterface.implement(
    $MyInterface<$T> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<MyInterface<$T>>();
  }
  static core$_.Map<int, $MyInterface> get $impls => _$impls;
}

abstract base mixin class $MyInterface<$T extends jni$_.JObject?> {
  factory $MyInterface({
    required void Function(jni$_.JString? string) voidCallback,
    core$_.bool voidCallback$async,
    required jni$_.JString? Function(jni$_.JString? string) stringCallback,
    required $T? Function($T? object) varCallback,
    required int Function(int i, core$_.bool z, int c, double d) manyPrimitives,
  }) = _$MyInterface<$T>;

  void voidCallback(jni$_.JString? string);
  core$_.bool get voidCallback$async => false;
  jni$_.JString? stringCallback(jni$_.JString? string);
  $T? varCallback($T? object);
  int manyPrimitives(int i, core$_.bool z, int c, double d);
}

final class _$MyInterface<$T extends jni$_.JObject?> with $MyInterface<$T> {
  _$MyInterface({
    required void Function(jni$_.JString? string) voidCallback,
    this.voidCallback$async = false,
    required jni$_.JString? Function(jni$_.JString? string) stringCallback,
    required $T? Function($T? object) varCallback,
    required int Function(int i, core$_.bool z, int c, double d) manyPrimitives,
  })  : _voidCallback = voidCallback,
        _stringCallback = stringCallback,
        _varCallback = varCallback,
        _manyPrimitives = manyPrimitives;

  final void Function(jni$_.JString? string) _voidCallback;
  final core$_.bool voidCallback$async;
  final jni$_.JString? Function(jni$_.JString? string) _stringCallback;
  final $T? Function($T? object) _varCallback;
  final int Function(int i, core$_.bool z, int c, double d) _manyPrimitives;

  void voidCallback(jni$_.JString? string) {
    return _voidCallback(string);
  }

  jni$_.JString? stringCallback(jni$_.JString? string) {
    return _stringCallback(string);
  }

  $T? varCallback($T? object) {
    return _varCallback(object);
  }

  int manyPrimitives(int i, core$_.bool z, int c, double d) {
    return _manyPrimitives(i, z, c, d);
  }
}

final class $MyInterface$Type$ extends jni$_.JType<MyInterface> {
  @jni$_.internal
  const $MyInterface$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyInterface;';
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyInterfaceConsumer`
extension type MyInterfaceConsumer._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyInterfaceConsumer');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<MyInterfaceConsumer> type =
      $MyInterfaceConsumer$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyInterfaceConsumer() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<MyInterfaceConsumer>();
  }

  static final _id_consumeOnAnotherThread = _class.staticMethodId(
    r'consumeOnAnotherThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/MyInterface;Ljava/lang/String;IZCDLjava/lang/Object;)V',
  );

  static final _consumeOnAnotherThread = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void consumeOnAnotherThread(com.github.dart_lang.jnigen.interfaces.MyInterface<T> myInterface, java.lang.String string, int i, boolean z, char c, double d, T object)`
  static void consumeOnAnotherThread<$T extends jni$_.JObject?>(
    MyInterface<$T?>? myInterface,
    jni$_.JString? string,
    int i,
    core$_.bool z,
    int c,
    double d,
    $T? object,
  ) {
    final _$myInterface = myInterface?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _consumeOnAnotherThread(
            _class.reference.pointer,
            _id_consumeOnAnotherThread as jni$_.JMethodIDPtr,
            _$myInterface.pointer,
            _$string.pointer,
            i,
            z ? 1 : 0,
            c,
            d,
            _$object.pointer)
        .check();
  }

  static final _id_consumeOnSameThread = _class.staticMethodId(
    r'consumeOnSameThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/MyInterface;Ljava/lang/String;IZCDLjava/lang/Object;)V',
  );

  static final _consumeOnSameThread = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void consumeOnSameThread(com.github.dart_lang.jnigen.interfaces.MyInterface<T> myInterface, java.lang.String string, int i, boolean z, char c, double d, T object)`
  static void consumeOnSameThread<$T extends jni$_.JObject?>(
    MyInterface<$T?>? myInterface,
    jni$_.JString? string,
    int i,
    core$_.bool z,
    int c,
    double d,
    $T? object,
  ) {
    final _$myInterface = myInterface?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _consumeOnSameThread(
            _class.reference.pointer,
            _id_consumeOnSameThread as jni$_.JMethodIDPtr,
            _$myInterface.pointer,
            _$string.pointer,
            i,
            z ? 1 : 0,
            c,
            d,
            _$object.pointer)
        .check();
  }
}

final class $MyInterfaceConsumer$Type$
    extends jni$_.JType<MyInterfaceConsumer> {
  @jni$_.internal
  const $MyInterfaceConsumer$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyInterfaceConsumer;';
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyRunnable`
extension type MyRunnable._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyRunnable');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<MyRunnable> type = $MyRunnable$Type$();
  static final _id_run = _class.instanceMethodId(
    r'run',
    r'()V',
  );

  static final _run = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void run()`
  void run() {
    _run(reference.pointer, _id_run as jni$_.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MyRunnable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'run()V') {
        _$impls[$p]!.run();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MyRunnable $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.interfaces.MyRunnable',
      $p,
      _$invokePointer,
      [
        if ($impl.run$async) r'run()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MyRunnable.implement(
    $MyRunnable $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<MyRunnable>();
  }
  static core$_.Map<int, $MyRunnable> get $impls => _$impls;
}

abstract base mixin class $MyRunnable {
  factory $MyRunnable({
    required void Function() run,
    core$_.bool run$async,
  }) = _$MyRunnable;

  void run();
  core$_.bool get run$async => false;
}

final class _$MyRunnable with $MyRunnable {
  _$MyRunnable({
    required void Function() run,
    this.run$async = false,
  }) : _run = run;

  final void Function() _run;
  final core$_.bool run$async;

  void run() {
    return _run();
  }
}

final class $MyRunnable$Type$ extends jni$_.JType<MyRunnable> {
  @jni$_.internal
  const $MyRunnable$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyRunnable;';
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyRunnableRunner`
extension type MyRunnableRunner._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyRunnableRunner');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<MyRunnableRunner> type = $MyRunnableRunner$Type$();
  static final _id_error = _class.instanceFieldId(
    r'error',
    r'Ljava/lang/Throwable;',
  );

  /// from: `public java.lang.Throwable error`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get error => _id_error.get(this, const jni$_.$JObject$Type$());

  /// from: `public java.lang.Throwable error`
  /// The returned object must be released after use, by calling the [release] method.
  set error(jni$_.JObject? value) =>
      _id_error.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/interfaces/MyRunnable;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.interfaces.MyRunnable myRunnable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyRunnableRunner(
    MyRunnable? myRunnable,
  ) {
    final _$myRunnable = myRunnable?.reference ?? jni$_.jNullReference;
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
            _$myRunnable.pointer)
        .object<MyRunnableRunner>();
  }

  static final _id_runOnSameThread = _class.instanceMethodId(
    r'runOnSameThread',
    r'()V',
  );

  static final _runOnSameThread = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void runOnSameThread()`
  void runOnSameThread() {
    _runOnSameThread(
            reference.pointer, _id_runOnSameThread as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_runOnAnotherThread = _class.instanceMethodId(
    r'runOnAnotherThread',
    r'()V',
  );

  static final _runOnAnotherThread = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void runOnAnotherThread()`
  void runOnAnotherThread() {
    _runOnAnotherThread(
            reference.pointer, _id_runOnAnotherThread as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_runOnAnotherThreadAndJoin = _class.instanceMethodId(
    r'runOnAnotherThreadAndJoin',
    r'()V',
  );

  static final _runOnAnotherThreadAndJoin = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void runOnAnotherThreadAndJoin()`
  void runOnAnotherThreadAndJoin() {
    _runOnAnotherThreadAndJoin(reference.pointer,
            _id_runOnAnotherThreadAndJoin as jni$_.JMethodIDPtr)
        .check();
  }
}

final class $MyRunnableRunner$Type$ extends jni$_.JType<MyRunnableRunner> {
  @jni$_.internal
  const $MyRunnableRunner$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyRunnableRunner;';
}

/// from: `com.github.dart_lang.jnigen.interfaces.StringConversionException`
extension type StringConversionException._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/StringConversionException');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<StringConversionException> type =
      $StringConversionException$Type$();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringConversionException(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<StringConversionException>();
  }
}

final class $StringConversionException$Type$
    extends jni$_.JType<StringConversionException> {
  @jni$_.internal
  const $StringConversionException$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConversionException;';
}

/// from: `com.github.dart_lang.jnigen.interfaces.StringConverter`
extension type StringConverter._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/StringConverter');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<StringConverter> type = $StringConverter$Type$();
  static final _id_parseToInt = _class.instanceMethodId(
    r'parseToInt',
    r'(Ljava/lang/String;)I',
  );

  static final _parseToInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract int parseToInt(java.lang.String string)`
  int parseToInt(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _parseToInt(reference.pointer, _id_parseToInt as jni$_.JMethodIDPtr,
            _$string.pointer)
        .integer;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $StringConverter> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'parseToInt(Ljava/lang/String;)I') {
        final $r = _$impls[$p]!.parseToInt(
          $a![0],
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $StringConverter $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.interfaces.StringConverter',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory StringConverter.implement(
    $StringConverter $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<StringConverter>();
  }
}

abstract base mixin class $StringConverter {
  factory $StringConverter({
    required int Function(jni$_.JString? string) parseToInt,
  }) = _$StringConverter;

  int parseToInt(jni$_.JString? string);
}

final class _$StringConverter with $StringConverter {
  _$StringConverter({
    required int Function(jni$_.JString? string) parseToInt,
  }) : _parseToInt = parseToInt;

  final int Function(jni$_.JString? string) _parseToInt;

  int parseToInt(jni$_.JString? string) {
    return _parseToInt(string);
  }
}

final class $StringConverter$Type$ extends jni$_.JType<StringConverter> {
  @jni$_.internal
  const $StringConverter$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConverter;';
}

/// from: `com.github.dart_lang.jnigen.interfaces.StringConverterConsumer`
extension type StringConverterConsumer._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/StringConverterConsumer');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<StringConverterConsumer> type =
      $StringConverterConsumer$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringConverterConsumer() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<StringConverterConsumer>();
  }

  static final _id_consumeOnSameThread = _class.staticMethodId(
    r'consumeOnSameThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/StringConverter;Ljava/lang/String;)Ljava/lang/Integer;',
  );

  static final _consumeOnSameThread = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.lang.Integer consumeOnSameThread(com.github.dart_lang.jnigen.interfaces.StringConverter stringConverter, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JInteger? consumeOnSameThread(
    StringConverter? stringConverter,
    jni$_.JString? string,
  ) {
    final _$stringConverter =
        stringConverter?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _consumeOnSameThread(
            _class.reference.pointer,
            _id_consumeOnSameThread as jni$_.JMethodIDPtr,
            _$stringConverter.pointer,
            _$string.pointer)
        .object<jni$_.JInteger?>();
  }

  static final _id_consumeOnAnotherThread = _class.staticMethodId(
    r'consumeOnAnotherThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/StringConverter;Ljava/lang/String;)Ljava/util/concurrent/Future;',
  );

  static final _consumeOnAnotherThread = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.Future<java.lang.Integer> consumeOnAnotherThread(com.github.dart_lang.jnigen.interfaces.StringConverter stringConverter, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? consumeOnAnotherThread(
    StringConverter? stringConverter,
    jni$_.JString? string,
  ) {
    final _$stringConverter =
        stringConverter?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _consumeOnAnotherThread(
            _class.reference.pointer,
            _id_consumeOnAnotherThread as jni$_.JMethodIDPtr,
            _$stringConverter.pointer,
            _$string.pointer)
        .object<jni$_.JObject?>();
  }
}

final class $StringConverterConsumer$Type$
    extends jni$_.JType<StringConverterConsumer> {
  @jni$_.internal
  const $StringConverterConsumer$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConverterConsumer;';
}

/// from: `com.github.dart_lang.jnigen.inheritance.BaseClass`
extension type BaseClass<$T extends jni$_.JObject?>._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/inheritance/BaseClass');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<BaseClass> type = $BaseClass$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory BaseClass() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<BaseClass<$T>>();
  }
}

final class $BaseClass$Type$ extends jni$_.JType<BaseClass> {
  @jni$_.internal
  const $BaseClass$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/BaseClass;';
}

/// from: `com.github.dart_lang.jnigen.inheritance.BaseGenericInterface`
extension type BaseGenericInterface<$T extends jni$_.JObject?>._(
    jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/inheritance/BaseGenericInterface');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<BaseGenericInterface> type =
      $BaseGenericInterface$Type$();
  static final _id_foo = _class.instanceMethodId(
    r'foo',
    r'()Ljava/lang/Object;',
  );

  static final _foo = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract T foo()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? foo() {
    return _foo(reference.pointer, _id_foo as jni$_.JMethodIDPtr).object<$T?>();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $BaseGenericInterface> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'foo()Ljava/lang/Object;') {
        final $r = _$impls[$p]!.foo();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$T extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $BaseGenericInterface<$T> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.inheritance.BaseGenericInterface',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory BaseGenericInterface.implement(
    $BaseGenericInterface<$T> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<BaseGenericInterface<$T>>();
  }
}

abstract base mixin class $BaseGenericInterface<$T extends jni$_.JObject?> {
  factory $BaseGenericInterface({
    required $T? Function() foo,
  }) = _$BaseGenericInterface<$T>;

  $T? foo();
}

final class _$BaseGenericInterface<$T extends jni$_.JObject?>
    with $BaseGenericInterface<$T> {
  _$BaseGenericInterface({
    required $T? Function() foo,
  }) : _foo = foo;

  final $T? Function() _foo;

  $T? foo() {
    return _foo();
  }
}

final class $BaseGenericInterface$Type$
    extends jni$_.JType<BaseGenericInterface> {
  @jni$_.internal
  const $BaseGenericInterface$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/BaseGenericInterface;';
}

/// from: `com.github.dart_lang.jnigen.inheritance.BaseInterface`
extension type BaseInterface._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/inheritance/BaseInterface');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<BaseInterface> type = $BaseInterface$Type$();
  static final _id_foo = _class.instanceMethodId(
    r'foo',
    r'()Ljava/lang/String;',
  );

  static final _foo = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String foo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? foo() {
    return _foo(reference.pointer, _id_foo as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $BaseInterface> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'foo()Ljava/lang/String;') {
        final $r = _$impls[$p]!.foo();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $BaseInterface $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.inheritance.BaseInterface',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory BaseInterface.implement(
    $BaseInterface $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<BaseInterface>();
  }
}

abstract base mixin class $BaseInterface {
  factory $BaseInterface({
    required jni$_.JString? Function() foo,
  }) = _$BaseInterface;

  jni$_.JString? foo();
}

final class _$BaseInterface with $BaseInterface {
  _$BaseInterface({
    required jni$_.JString? Function() foo,
  }) : _foo = foo;

  final jni$_.JString? Function() _foo;

  jni$_.JString? foo() {
    return _foo();
  }
}

final class $BaseInterface$Type$ extends jni$_.JType<BaseInterface> {
  @jni$_.internal
  const $BaseInterface$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/BaseInterface;';
}

/// from: `com.github.dart_lang.jnigen.inheritance.DerivedInterface`
extension type DerivedInterface._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/inheritance/DerivedInterface');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<DerivedInterface> type = $DerivedInterface$Type$();
  static final _id_foo = _class.instanceMethodId(
    r'foo',
    r'()Ljava/lang/String;',
  );

  static final _foo = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String foo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? foo() {
    return _foo(reference.pointer, _id_foo as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $DerivedInterface> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'foo()Ljava/lang/String;') {
        final $r = _$impls[$p]!.foo();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $DerivedInterface $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.inheritance.DerivedInterface',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory DerivedInterface.implement(
    $DerivedInterface $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<DerivedInterface>();
  }
}

abstract base mixin class $DerivedInterface {
  factory $DerivedInterface({
    required jni$_.JString? Function() foo,
  }) = _$DerivedInterface;

  jni$_.JString? foo();
}

final class _$DerivedInterface with $DerivedInterface {
  _$DerivedInterface({
    required jni$_.JString? Function() foo,
  }) : _foo = foo;

  final jni$_.JString? Function() _foo;

  jni$_.JString? foo() {
    return _foo();
  }
}

final class $DerivedInterface$Type$ extends jni$_.JType<DerivedInterface> {
  @jni$_.internal
  const $DerivedInterface$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/DerivedInterface;';
}

/// from: `com.github.dart_lang.jnigen.inheritance.GenericDerivedClass`
extension type GenericDerivedClass<$T extends jni$_.JObject?>._(
    jni$_.JObject _$this) implements BaseClass<$T?> {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/inheritance/GenericDerivedClass');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<GenericDerivedClass> type =
      $GenericDerivedClass$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory GenericDerivedClass() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<GenericDerivedClass<$T>>();
  }
}

final class $GenericDerivedClass$Type$
    extends jni$_.JType<GenericDerivedClass> {
  @jni$_.internal
  const $GenericDerivedClass$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/GenericDerivedClass;';
}

/// from: `com.github.dart_lang.jnigen.inheritance.SpecificDerivedClass`
extension type SpecificDerivedClass._(jni$_.JObject _$this)
    implements BaseClass<jni$_.JString?> {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/inheritance/SpecificDerivedClass');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<SpecificDerivedClass> type =
      $SpecificDerivedClass$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SpecificDerivedClass() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<SpecificDerivedClass>();
  }
}

final class $SpecificDerivedClass$Type$
    extends jni$_.JType<SpecificDerivedClass> {
  @jni$_.internal
  const $SpecificDerivedClass$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/SpecificDerivedClass;';
}

/// from: `com.github.dart_lang.jnigen.annotations.Annotated$Nested`
extension type Annotated$Nested<
        $T extends jni$_.JObject?,
        $U extends jni$_.JObject,
        $W extends jni$_.JObject,
        $V extends jni$_.JObject?>._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/Annotated$Nested');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Annotated$Nested> type = $Annotated$Nested$Type$();
  static final _id_v = _class.instanceFieldId(
    r'v',
    r'Ljava/lang/Object;',
  );

  /// from: `public V v`
  /// The returned object must be released after use, by calling the [release] method.
  $V? get v => _id_v.get(this, const jni$_.$JObject$Type$());

  /// from: `public V v`
  /// The returned object must be released after use, by calling the [release] method.
  set v($V? value) => _id_v.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_u = _class.instanceFieldId(
    r'u',
    r'Ljava/lang/Object;',
  );

  /// from: `public U u`
  /// The returned object must be released after use, by calling the [release] method.
  $U get u => _id_u.get(this, const jni$_.$JObject$Type$());

  /// from: `public U u`
  /// The returned object must be released after use, by calling the [release] method.
  set u($U value) => _id_u.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/annotations/Annotated;Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.annotations.Annotated<T, U, W> $outerClass, V object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Annotated$Nested(
    Annotated<$T?, $U, $W> $outerClass,
    $V? object,
  ) {
    final _$$outerClass = $outerClass.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
            _$$outerClass.pointer, _$object.pointer)
        .object<Annotated$Nested<$T, $U, $W, $V>>();
  }
}

final class $Annotated$Nested$Type$ extends jni$_.JType<Annotated$Nested> {
  @jni$_.internal
  const $Annotated$Nested$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/Annotated$Nested;';
}

/// from: `com.github.dart_lang.jnigen.annotations.Annotated`
extension type Annotated<$T extends jni$_.JObject?, $U extends jni$_.JObject,
    $W extends jni$_.JObject>._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/Annotated');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Annotated> type = $Annotated$Type$();
  static final _id_t = _class.instanceFieldId(
    r't',
    r'Ljava/lang/Object;',
  );

  /// from: `public T t`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get t => _id_t.get(this, const jni$_.$JObject$Type$());

  /// from: `public T t`
  /// The returned object must be released after use, by calling the [release] method.
  set t($T? value) => _id_t.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_u = _class.instanceFieldId(
    r'u',
    r'Ljava/lang/Object;',
  );

  /// from: `public U u`
  /// The returned object must be released after use, by calling the [release] method.
  $U get u => _id_u.get(this, const jni$_.$JObject$Type$());

  /// from: `public U u`
  /// The returned object must be released after use, by calling the [release] method.
  set u($U value) => _id_u.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_w = _class.instanceFieldId(
    r'w',
    r'Ljava/lang/Object;',
  );

  /// from: `public W w`
  /// The returned object must be released after use, by calling the [release] method.
  $W get w => _id_w.get(this, const jni$_.$JObject$Type$());

  /// from: `public W w`
  /// The returned object must be released after use, by calling the [release] method.
  set w($W value) => _id_w.set(this, const jni$_.$JObject$Type$(), value);

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(T object, U object1, W object2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Annotated(
    $T? object,
    $U object1,
    $W object2,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1.reference;
    final _$object2 = object2.reference;
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
            _$object.pointer, _$object1.pointer, _$object2.pointer)
        .object<Annotated<$T, $U, $W>>();
  }

  static final _id_staticHello = _class.staticMethodId(
    r'staticHello',
    r'()Ljava/lang/String;',
  );

  static final _staticHello = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String staticHello()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString staticHello() {
    return _staticHello(
            _class.reference.pointer, _id_staticHello as jni$_.JMethodIDPtr)
        .object<jni$_.JString>();
  }

  static final _id_hello = _class.instanceMethodId(
    r'hello',
    r'()Ljava/lang/String;',
  );

  static final _hello = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String hello()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString hello() {
    return _hello(reference.pointer, _id_hello as jni$_.JMethodIDPtr)
        .object<jni$_.JString>();
  }

  static final _id_nullableHello = _class.instanceMethodId(
    r'nullableHello',
    r'(Z)Ljava/lang/String;',
  );

  static final _nullableHello = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.lang.String nullableHello(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? nullableHello(
    core$_.bool z,
  ) {
    return _nullableHello(reference.pointer,
            _id_nullableHello as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JString?>();
  }

  static final _id_echo = _class.instanceMethodId(
    r'echo',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String echo(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echo(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echo(
            reference.pointer, _id_echo as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString>();
  }

  static final _id_nullableEcho = _class.instanceMethodId(
    r'nullableEcho',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _nullableEcho = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String nullableEcho(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? nullableEcho(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _nullableEcho(reference.pointer,
            _id_nullableEcho as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>();
  }

  static final _id_array = _class.instanceMethodId(
    r'array',
    r'()[Ljava/lang/String;',
  );

  static final _array = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String[] array()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString> array() {
    return _array(reference.pointer, _id_array as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JString>>();
  }

  static final _id_arrayOfNullable = _class.instanceMethodId(
    r'arrayOfNullable',
    r'()[Ljava/lang/String;',
  );

  static final _arrayOfNullable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String[] arrayOfNullable()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?> arrayOfNullable() {
    return _arrayOfNullable(
            reference.pointer, _id_arrayOfNullable as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JString?>>();
  }

  static final _id_nullableArray = _class.instanceMethodId(
    r'nullableArray',
    r'(Z)[Ljava/lang/String;',
  );

  static final _nullableArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.lang.String[] nullableArray(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString>? nullableArray(
    core$_.bool z,
  ) {
    return _nullableArray(reference.pointer,
            _id_nullableArray as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JArray<jni$_.JString>?>();
  }

  static final _id_nullableArrayOfNullable = _class.instanceMethodId(
    r'nullableArrayOfNullable',
    r'(Z)[Ljava/lang/String;',
  );

  static final _nullableArrayOfNullable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.lang.String[] nullableArrayOfNullable(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? nullableArrayOfNullable(
    core$_.bool z,
  ) {
    return _nullableArrayOfNullable(reference.pointer,
            _id_nullableArrayOfNullable as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JArray<jni$_.JString?>?>();
  }

  static final _id_list = _class.instanceMethodId(
    r'list',
    r'()Ljava/util/List;',
  );

  static final _list = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> list()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString> list() {
    return _list(reference.pointer, _id_list as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString>>();
  }

  static final _id_listOfNullable = _class.instanceMethodId(
    r'listOfNullable',
    r'()Ljava/util/List;',
  );

  static final _listOfNullable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> listOfNullable()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> listOfNullable() {
    return _listOfNullable(
            reference.pointer, _id_listOfNullable as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>>();
  }

  static final _id_nullableList = _class.instanceMethodId(
    r'nullableList',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.util.List<java.lang.String> nullableList(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString>? nullableList(
    core$_.bool z,
  ) {
    return _nullableList(reference.pointer,
            _id_nullableList as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JList<jni$_.JString>?>();
  }

  static final _id_nullableListOfNullable = _class.instanceMethodId(
    r'nullableListOfNullable',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableListOfNullable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.util.List<java.lang.String> nullableListOfNullable(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? nullableListOfNullable(
    core$_.bool z,
  ) {
    return _nullableListOfNullable(reference.pointer,
            _id_nullableListOfNullable as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JList<jni$_.JString?>?>();
  }

  static final _id_classGenericEcho = _class.instanceMethodId(
    r'classGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _classGenericEcho = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T classGenericEcho(T object)`
  /// The returned object must be released after use, by calling the [release] method.
  $T classGenericEcho(
    $T object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _classGenericEcho(reference.pointer,
            _id_classGenericEcho as jni$_.JMethodIDPtr, _$object.pointer)
        .object<$T>();
  }

  static final _id_nullableClassGenericEcho = _class.instanceMethodId(
    r'nullableClassGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _nullableClassGenericEcho = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T nullableClassGenericEcho(T object)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? nullableClassGenericEcho(
    $T? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _nullableClassGenericEcho(
            reference.pointer,
            _id_nullableClassGenericEcho as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<$T?>();
  }

  static final _id_methodGenericEcho = _class.instanceMethodId(
    r'methodGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _methodGenericEcho = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V methodGenericEcho(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V methodGenericEcho<$V extends jni$_.JObject?>(
    $V object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _methodGenericEcho(reference.pointer,
            _id_methodGenericEcho as jni$_.JMethodIDPtr, _$object.pointer)
        .object<$V>();
  }

  static final _id_methodGenericEcho2 = _class.instanceMethodId(
    r'methodGenericEcho2',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _methodGenericEcho2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V methodGenericEcho2(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V methodGenericEcho2<$V extends jni$_.JObject>(
    $V object,
  ) {
    final _$object = object.reference;
    return _methodGenericEcho2(reference.pointer,
            _id_methodGenericEcho2 as jni$_.JMethodIDPtr, _$object.pointer)
        .object<$V>();
  }

  static final _id_methodGenericEcho3 = _class.instanceMethodId(
    r'methodGenericEcho3',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _methodGenericEcho3 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V methodGenericEcho3(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V methodGenericEcho3<$V extends jni$_.JObject>(
    $V object,
  ) {
    final _$object = object.reference;
    return _methodGenericEcho3(reference.pointer,
            _id_methodGenericEcho3 as jni$_.JMethodIDPtr, _$object.pointer)
        .object<$V>();
  }

  static final _id_nullableReturnMethodGenericEcho = _class.instanceMethodId(
    r'nullableReturnMethodGenericEcho',
    r'(Ljava/lang/Object;Z)Ljava/lang/Object;',
  );

  static final _nullableReturnMethodGenericEcho =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public V nullableReturnMethodGenericEcho(V object, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? nullableReturnMethodGenericEcho<$V extends jni$_.JObject?>(
    $V object,
    core$_.bool z,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _nullableReturnMethodGenericEcho(
            reference.pointer,
            _id_nullableReturnMethodGenericEcho as jni$_.JMethodIDPtr,
            _$object.pointer,
            z ? 1 : 0)
        .object<$V?>();
  }

  static final _id_nullableReturnMethodGenericEcho2 = _class.instanceMethodId(
    r'nullableReturnMethodGenericEcho2',
    r'(Ljava/lang/Object;Z)Ljava/lang/Object;',
  );

  static final _nullableReturnMethodGenericEcho2 =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public V nullableReturnMethodGenericEcho2(V object, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? nullableReturnMethodGenericEcho2<$V extends jni$_.JObject>(
    $V object,
    core$_.bool z,
  ) {
    final _$object = object.reference;
    return _nullableReturnMethodGenericEcho2(
            reference.pointer,
            _id_nullableReturnMethodGenericEcho2 as jni$_.JMethodIDPtr,
            _$object.pointer,
            z ? 1 : 0)
        .object<$V?>();
  }

  static final _id_nullableMethodGenericEcho = _class.instanceMethodId(
    r'nullableMethodGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _nullableMethodGenericEcho = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V nullableMethodGenericEcho(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V nullableMethodGenericEcho<$V extends jni$_.JObject?>(
    $V object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _nullableMethodGenericEcho(
            reference.pointer,
            _id_nullableMethodGenericEcho as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<$V>();
  }

  static final _id_noAnnotationMethodGenericEcho = _class.instanceMethodId(
    r'noAnnotationMethodGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _noAnnotationMethodGenericEcho =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V noAnnotationMethodGenericEcho(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? noAnnotationMethodGenericEcho<$V extends jni$_.JObject?>(
    $V? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _noAnnotationMethodGenericEcho(
            reference.pointer,
            _id_noAnnotationMethodGenericEcho as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<$V?>();
  }

  static final _id_nullableArgMethodGenericEcho = _class.instanceMethodId(
    r'nullableArgMethodGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _nullableArgMethodGenericEcho =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V nullableArgMethodGenericEcho(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V nullableArgMethodGenericEcho<$V extends jni$_.JObject>(
    $V? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _nullableArgMethodGenericEcho(
            reference.pointer,
            _id_nullableArgMethodGenericEcho as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<$V>();
  }

  static final _id_classGenericList = _class.instanceMethodId(
    r'classGenericList',
    r'()Ljava/util/List;',
  );

  static final _classGenericList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<T> classGenericList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$T> classGenericList() {
    return _classGenericList(
            reference.pointer, _id_classGenericList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<$T>>();
  }

  static final _id_classGenericListOfNullable = _class.instanceMethodId(
    r'classGenericListOfNullable',
    r'()Ljava/util/List;',
  );

  static final _classGenericListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.util.List<T> classGenericListOfNullable()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$T?> classGenericListOfNullable() {
    return _classGenericListOfNullable(reference.pointer,
            _id_classGenericListOfNullable as jni$_.JMethodIDPtr)
        .object<jni$_.JList<$T?>>();
  }

  static final _id_nullableClassGenericList = _class.instanceMethodId(
    r'nullableClassGenericList',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableClassGenericList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.util.List<T> nullableClassGenericList(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$T>? nullableClassGenericList(
    core$_.bool z,
  ) {
    return _nullableClassGenericList(reference.pointer,
            _id_nullableClassGenericList as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JList<$T>?>();
  }

  static final _id_nullableClassGenericListOfNullable = _class.instanceMethodId(
    r'nullableClassGenericListOfNullable',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableClassGenericListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.util.List<T> nullableClassGenericListOfNullable(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$T?>? nullableClassGenericListOfNullable(
    core$_.bool z,
  ) {
    return _nullableClassGenericListOfNullable(
            reference.pointer,
            _id_nullableClassGenericListOfNullable as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .object<jni$_.JList<$T?>?>();
  }

  static final _id_methodGenericList = _class.instanceMethodId(
    r'methodGenericList',
    r'(Ljava/lang/Object;)Ljava/util/List;',
  );

  static final _methodGenericList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List<V> methodGenericList(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$V> methodGenericList<$V extends jni$_.JObject?>(
    $V object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _methodGenericList(reference.pointer,
            _id_methodGenericList as jni$_.JMethodIDPtr, _$object.pointer)
        .object<jni$_.JList<$V>>();
  }

  static final _id_methodGenericListOfNullable = _class.instanceMethodId(
    r'methodGenericListOfNullable',
    r'()Ljava/util/List;',
  );

  static final _methodGenericListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.util.List<V> methodGenericListOfNullable()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$V?> methodGenericListOfNullable<$V extends jni$_.JObject?>() {
    return _methodGenericListOfNullable(reference.pointer,
            _id_methodGenericListOfNullable as jni$_.JMethodIDPtr)
        .object<jni$_.JList<$V?>>();
  }

  static final _id_nullableMethodGenericList = _class.instanceMethodId(
    r'nullableMethodGenericList',
    r'(Ljava/lang/Object;Z)Ljava/util/List;',
  );

  static final _nullableMethodGenericList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public java.util.List<V> nullableMethodGenericList(V object, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$V>? nullableMethodGenericList<$V extends jni$_.JObject?>(
    $V object,
    core$_.bool z,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _nullableMethodGenericList(
            reference.pointer,
            _id_nullableMethodGenericList as jni$_.JMethodIDPtr,
            _$object.pointer,
            z ? 1 : 0)
        .object<jni$_.JList<$V>?>();
  }

  static final _id_nullableMethodGenericListOfNullable =
      _class.instanceMethodId(
    r'nullableMethodGenericListOfNullable',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableMethodGenericListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.util.List<V> nullableMethodGenericListOfNullable(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$V?>?
      nullableMethodGenericListOfNullable<$V extends jni$_.JObject?>(
    core$_.bool z,
  ) {
    return _nullableMethodGenericListOfNullable(
            reference.pointer,
            _id_nullableMethodGenericListOfNullable as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .object<jni$_.JList<$V?>?>();
  }

  static final _id_firstOfClassGenericList = _class.instanceMethodId(
    r'firstOfClassGenericList',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfClassGenericList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstOfClassGenericList(java.util.List<T> list)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstOfClassGenericList(
    jni$_.JList<$T> list,
  ) {
    final _$list = list.reference;
    return _firstOfClassGenericList(reference.pointer,
            _id_firstOfClassGenericList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<$T?>();
  }

  static final _id_firstOfClassGenericNullableList = _class.instanceMethodId(
    r'firstOfClassGenericNullableList',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfClassGenericNullableList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstOfClassGenericNullableList(java.util.List<T> list)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstOfClassGenericNullableList(
    jni$_.JList<$T>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _firstOfClassGenericNullableList(
            reference.pointer,
            _id_firstOfClassGenericNullableList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<$T?>();
  }

  static final _id_firstOfClassGenericListOfNullable = _class.instanceMethodId(
    r'firstOfClassGenericListOfNullable',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfClassGenericListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstOfClassGenericListOfNullable(java.util.List<T> list)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstOfClassGenericListOfNullable(
    jni$_.JList<$T?> list,
  ) {
    final _$list = list.reference;
    return _firstOfClassGenericListOfNullable(
            reference.pointer,
            _id_firstOfClassGenericListOfNullable as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<$T?>();
  }

  static final _id_firstOfClassGenericNullableListOfNullable =
      _class.instanceMethodId(
    r'firstOfClassGenericNullableListOfNullable',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfClassGenericNullableListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstOfClassGenericNullableListOfNullable(java.util.List<T> list)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstOfClassGenericNullableListOfNullable(
    jni$_.JList<$T?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _firstOfClassGenericNullableListOfNullable(
            reference.pointer,
            _id_firstOfClassGenericNullableListOfNullable as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<$T?>();
  }

  static final _id_firstOfMethodGenericList = _class.instanceMethodId(
    r'firstOfMethodGenericList',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfMethodGenericList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstOfMethodGenericList(java.util.List<V> list)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstOfMethodGenericList<$V extends jni$_.JObject?>(
    jni$_.JList<$V> list,
  ) {
    final _$list = list.reference;
    return _firstOfMethodGenericList(reference.pointer,
            _id_firstOfMethodGenericList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<$V?>();
  }

  static final _id_firstOfMethodGenericNullableList = _class.instanceMethodId(
    r'firstOfMethodGenericNullableList',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfMethodGenericNullableList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstOfMethodGenericNullableList(java.util.List<V> list)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstOfMethodGenericNullableList<$V extends jni$_.JObject?>(
    jni$_.JList<$V>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _firstOfMethodGenericNullableList(
            reference.pointer,
            _id_firstOfMethodGenericNullableList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<$V?>();
  }

  static final _id_firstOfMethodGenericListOfNullable = _class.instanceMethodId(
    r'firstOfMethodGenericListOfNullable',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfMethodGenericListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstOfMethodGenericListOfNullable(java.util.List<V> list)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstOfMethodGenericListOfNullable<$V extends jni$_.JObject?>(
    jni$_.JList<$V?> list,
  ) {
    final _$list = list.reference;
    return _firstOfMethodGenericListOfNullable(
            reference.pointer,
            _id_firstOfMethodGenericListOfNullable as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<$V?>();
  }

  static final _id_firstOfMethodGenericNullableListOfNullable =
      _class.instanceMethodId(
    r'firstOfMethodGenericNullableListOfNullable',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfMethodGenericNullableListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstOfMethodGenericNullableListOfNullable(java.util.List<V> list)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstOfMethodGenericNullableListOfNullable<$V extends jni$_.JObject?>(
    jni$_.JList<$V?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _firstOfMethodGenericNullableListOfNullable(
            reference.pointer,
            _id_firstOfMethodGenericNullableListOfNullable
                as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<$V?>();
  }

  static final _id_firstKeyOfComboMap = _class.instanceMethodId(
    r'firstKeyOfComboMap',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstKeyOfComboMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstKeyOfComboMap(java.util.Map<T, V> map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstKeyOfComboMap<$V extends jni$_.JObject?>(
    jni$_.JMap<$T, $V> map,
  ) {
    final _$map = map.reference;
    return _firstKeyOfComboMap(reference.pointer,
            _id_firstKeyOfComboMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<$T?>();
  }

  static final _id_firstValueOfComboMap = _class.instanceMethodId(
    r'firstValueOfComboMap',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOfComboMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstValueOfComboMap(java.util.Map<T, V> map)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstValueOfComboMap<$V extends jni$_.JObject?>(
    jni$_.JMap<$T, $V> map,
  ) {
    final _$map = map.reference;
    return _firstValueOfComboMap(reference.pointer,
            _id_firstValueOfComboMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<$V?>();
  }

  static final _id_firstKeyOfComboMapNullableKey = _class.instanceMethodId(
    r'firstKeyOfComboMapNullableKey',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstKeyOfComboMapNullableKey =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstKeyOfComboMapNullableKey(java.util.Map<T, V> map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstKeyOfComboMapNullableKey<$V extends jni$_.JObject?>(
    jni$_.JMap<$T?, $V> map,
  ) {
    final _$map = map.reference;
    return _firstKeyOfComboMapNullableKey(
            reference.pointer,
            _id_firstKeyOfComboMapNullableKey as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<$T?>();
  }

  static final _id_firstValueOfComboMapNullableKey = _class.instanceMethodId(
    r'firstValueOfComboMapNullableKey',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOfComboMapNullableKey =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstValueOfComboMapNullableKey(java.util.Map<T, V> map)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstValueOfComboMapNullableKey<$V extends jni$_.JObject?>(
    jni$_.JMap<$T?, $V> map,
  ) {
    final _$map = map.reference;
    return _firstValueOfComboMapNullableKey(
            reference.pointer,
            _id_firstValueOfComboMapNullableKey as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<$V?>();
  }

  static final _id_firstKeyOfComboMapNullableValue = _class.instanceMethodId(
    r'firstKeyOfComboMapNullableValue',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstKeyOfComboMapNullableValue =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstKeyOfComboMapNullableValue(java.util.Map<T, V> map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstKeyOfComboMapNullableValue<$V extends jni$_.JObject?>(
    jni$_.JMap<$T, $V?> map,
  ) {
    final _$map = map.reference;
    return _firstKeyOfComboMapNullableValue(
            reference.pointer,
            _id_firstKeyOfComboMapNullableValue as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<$T?>();
  }

  static final _id_firstValueOfComboMapNullableValue = _class.instanceMethodId(
    r'firstValueOfComboMapNullableValue',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOfComboMapNullableValue =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstValueOfComboMapNullableValue(java.util.Map<T, V> map)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstValueOfComboMapNullableValue<$V extends jni$_.JObject?>(
    jni$_.JMap<$T, $V?> map,
  ) {
    final _$map = map.reference;
    return _firstValueOfComboMapNullableValue(
            reference.pointer,
            _id_firstValueOfComboMapNullableValue as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<$V?>();
  }

  static final _id_firstKeyOfComboMapNullableKeyAndValue =
      _class.instanceMethodId(
    r'firstKeyOfComboMapNullableKeyAndValue',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstKeyOfComboMapNullableKeyAndValue =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstKeyOfComboMapNullableKeyAndValue(java.util.Map<T, V> map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstKeyOfComboMapNullableKeyAndValue<$V extends jni$_.JObject?>(
    jni$_.JMap<$T?, $V?> map,
  ) {
    final _$map = map.reference;
    return _firstKeyOfComboMapNullableKeyAndValue(
            reference.pointer,
            _id_firstKeyOfComboMapNullableKeyAndValue as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<$T?>();
  }

  static final _id_firstValueOfComboMapNullableKeyAndValue =
      _class.instanceMethodId(
    r'firstValueOfComboMapNullableKeyAndValue',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOfComboMapNullableKeyAndValue =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstValueOfComboMapNullableKeyAndValue(java.util.Map<T, V> map)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstValueOfComboMapNullableKeyAndValue<$V extends jni$_.JObject?>(
    jni$_.JMap<$T?, $V?> map,
  ) {
    final _$map = map.reference;
    return _firstValueOfComboMapNullableKeyAndValue(
            reference.pointer,
            _id_firstValueOfComboMapNullableKeyAndValue as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<$V?>();
  }

  static final _id_firstEntryOfComboMap = _class.instanceMethodId(
    r'firstEntryOfComboMap',
    r'(Ljava/util/Map;)Ljava/util/Map$Entry;',
  );

  static final _firstEntryOfComboMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map$Entry<T, V> firstEntryOfComboMap(java.util.Map<T, V> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? firstEntryOfComboMap<$V extends jni$_.JObject?>(
    jni$_.JMap<$T, $V> map,
  ) {
    final _$map = map.reference;
    return _firstEntryOfComboMap(reference.pointer,
            _id_firstEntryOfComboMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JObject?>();
  }

  static final _id_getW = _class.instanceMethodId(
    r'getW',
    r'()Ljava/lang/Object;',
  );

  static final _getW = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public W getW()`
  /// The returned object must be released after use, by calling the [release] method.
  $W getW() {
    return _getW(reference.pointer, _id_getW as jni$_.JMethodIDPtr)
        .object<$W>();
  }

  static final _id_nullableGetW = _class.instanceMethodId(
    r'nullableGetW',
    r'(Z)Ljava/lang/Object;',
  );

  static final _nullableGetW = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public W nullableGetW(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  $W? nullableGetW(
    core$_.bool z,
  ) {
    return _nullableGetW(reference.pointer,
            _id_nullableGetW as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<$W?>();
  }

  static final _id_list3dOfT = _class.instanceMethodId(
    r'list3dOfT',
    r'()Ljava/util/List;',
  );

  static final _list3dOfT = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.util.List<java.util.List<T>>> list3dOfT()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JList<$T?>>> list3dOfT() {
    return _list3dOfT(reference.pointer, _id_list3dOfT as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JList<$T?>>>>();
  }

  static final _id_list3dOfU = _class.instanceMethodId(
    r'list3dOfU',
    r'()Ljava/util/List;',
  );

  static final _list3dOfU = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.util.List<java.util.List<U>>> list3dOfU()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JList<$U>>> list3dOfU() {
    return _list3dOfU(reference.pointer, _id_list3dOfU as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JList<$U>>>>();
  }

  static final _id_list3dOfW = _class.instanceMethodId(
    r'list3dOfW',
    r'()Ljava/util/List;',
  );

  static final _list3dOfW = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.util.List<java.util.List<W>>> list3dOfW()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JList<$W>>> list3dOfW() {
    return _list3dOfW(reference.pointer, _id_list3dOfW as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JList<$W>>>>();
  }

  static final _id_list3dOfNullableU = _class.instanceMethodId(
    r'list3dOfNullableU',
    r'(Z)Ljava/util/List;',
  );

  static final _list3dOfNullableU = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.util.List<java.util.List<java.util.List<U>>> list3dOfNullableU(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JList<$U?>>> list3dOfNullableU(
    core$_.bool z,
  ) {
    return _list3dOfNullableU(reference.pointer,
            _id_list3dOfNullableU as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JList<jni$_.JList<jni$_.JList<$U?>>>>();
  }

  static final _id_list3dOfNullableW = _class.instanceMethodId(
    r'list3dOfNullableW',
    r'(Z)Ljava/util/List;',
  );

  static final _list3dOfNullableW = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.util.List<java.util.List<java.util.List<W>>> list3dOfNullableW(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JList<$W?>>> list3dOfNullableW(
    core$_.bool z,
  ) {
    return _list3dOfNullableW(reference.pointer,
            _id_list3dOfNullableW as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JList<jni$_.JList<jni$_.JList<$W?>>>>();
  }

  static final _id_nested = _class.instanceMethodId(
    r'nested',
    r'()Lcom/github/dart_lang/jnigen/annotations/Annotated$Nested;',
  );

  static final _nested = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.annotations.Annotated$Nested<T, U, W, java.lang.Integer> nested()`
  /// The returned object must be released after use, by calling the [release] method.
  Annotated$Nested<$T?, $U, $W, jni$_.JInteger>? nested() {
    return _nested(reference.pointer, _id_nested as jni$_.JMethodIDPtr)
        .object<Annotated$Nested<$T?, $U, $W, jni$_.JInteger>?>();
  }

  static final _id_intList = _class.instanceMethodId(
    r'intList',
    r'()Ljava/util/List;',
  );

  static final _intList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<? extends java.lang.Integer> intList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JInteger> intList() {
    return _intList(reference.pointer, _id_intList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JInteger>>();
  }
}

final class $Annotated$Type$ extends jni$_.JType<Annotated> {
  @jni$_.internal
  const $Annotated$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/Annotated;';
}

/// from: `com.github.dart_lang.jnigen.annotations.JsonSerializable$Case`
extension type JsonSerializable$Case._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/JsonSerializable$Case');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<JsonSerializable$Case> type =
      $JsonSerializable$Case$Type$();
  static final _id_SNAKE_CASE = _class.staticFieldId(
    r'SNAKE_CASE',
    r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.annotations.JsonSerializable$Case SNAKE_CASE`
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable$Case get SNAKE_CASE =>
      _id_SNAKE_CASE.get(_class, const jni$_.$JObject$Type$());

  static final _id_KEBAB_CASE = _class.staticFieldId(
    r'KEBAB_CASE',
    r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.annotations.JsonSerializable$Case KEBAB_CASE`
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable$Case get KEBAB_CASE =>
      _id_KEBAB_CASE.get(_class, const jni$_.$JObject$Type$());

  static final _id_CAMEL_CASE = _class.staticFieldId(
    r'CAMEL_CASE',
    r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.annotations.JsonSerializable$Case CAMEL_CASE`
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable$Case get CAMEL_CASE =>
      _id_CAMEL_CASE.get(_class, const jni$_.$JObject$Type$());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.annotations.JsonSerializable$Case[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<JsonSerializable$Case?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<JsonSerializable$Case?>?>();
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.annotations.JsonSerializable$Case valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable$Case? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<JsonSerializable$Case?>();
  }
}

final class $JsonSerializable$Case$Type$
    extends jni$_.JType<JsonSerializable$Case> {
  @jni$_.internal
  const $JsonSerializable$Case$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;';
}

/// from: `com.github.dart_lang.jnigen.annotations.JsonSerializable`
extension type JsonSerializable._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/JsonSerializable');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<JsonSerializable> type = $JsonSerializable$Type$();
  static final _id_value = _class.instanceMethodId(
    r'value',
    r'()Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _value = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract com.github.dart_lang.jnigen.annotations.JsonSerializable$Case value()`
  /// The returned object must be released after use, by calling the [release] method.
  JsonSerializable$Case? value() {
    return _value(reference.pointer, _id_value as jni$_.JMethodIDPtr)
        .object<JsonSerializable$Case?>();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $JsonSerializable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'value()Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;') {
        final $r = _$impls[$p]!.value();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $JsonSerializable $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.annotations.JsonSerializable',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory JsonSerializable.implement(
    $JsonSerializable $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<JsonSerializable>();
  }
}

abstract base mixin class $JsonSerializable {
  factory $JsonSerializable({
    required JsonSerializable$Case? Function() value,
  }) = _$JsonSerializable;

  JsonSerializable$Case? value();
}

final class _$JsonSerializable with $JsonSerializable {
  _$JsonSerializable({
    required JsonSerializable$Case? Function() value,
  }) : _value = value;

  final JsonSerializable$Case? Function() _value;

  JsonSerializable$Case? value() {
    return _value();
  }
}

final class $JsonSerializable$Type$ extends jni$_.JType<JsonSerializable> {
  @jni$_.internal
  const $JsonSerializable$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable;';
}

/// from: `com.github.dart_lang.jnigen.annotations.MyDataClass`
extension type MyDataClass._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/MyDataClass');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<MyDataClass> type = $MyDataClass$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyDataClass() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<MyDataClass>();
  }
}

final class $MyDataClass$Type$ extends jni$_.JType<MyDataClass> {
  @jni$_.internal
  const $MyDataClass$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/MyDataClass;';
}

/// from: `com.github.dart_lang.jnigen.annotations.NotNull`
extension type NotNull._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/annotations/NotNull');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<NotNull> type = $NotNull$Type$();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $NotNull> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $NotNull $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.annotations.NotNull',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory NotNull.implement(
    $NotNull $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<NotNull>();
  }
}

abstract base mixin class $NotNull {
  factory $NotNull() = _$NotNull;
}

final class _$NotNull with $NotNull {
  _$NotNull();
}

final class $NotNull$Type$ extends jni$_.JType<NotNull> {
  @jni$_.internal
  const $NotNull$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/annotations/NotNull;';
}

/// from: `com.github.dart_lang.jnigen.annotations.Nullable`
extension type Nullable._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/annotations/Nullable');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Nullable> type = $Nullable$Type$();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Nullable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Nullable $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.annotations.Nullable',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Nullable.implement(
    $Nullable $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<Nullable>();
  }
}

abstract base mixin class $Nullable {
  factory $Nullable() = _$Nullable;
}

final class _$Nullable with $Nullable {
  _$Nullable();
}

final class $Nullable$Type$ extends jni$_.JType<Nullable> {
  @jni$_.internal
  const $Nullable$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/annotations/Nullable;';
}

/// from: `com.github.dart_lang.jnigen.regressions.R2250$Child`
extension type R2250$Child._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/regressions/R2250$Child');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<R2250$Child> type = $R2250$Child$Type$();
  static final _id_foo = _class.instanceMethodId(
    r'foo',
    r'(Ljava/lang/Object;)V',
  );

  static final _foo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void foo(java.lang.Object object)`
  void foo(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _foo(reference.pointer, _id_foo as jni$_.JMethodIDPtr, _$object.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $R2250$Child> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'foo(Ljava/lang/Object;)V') {
        _$impls[$p]!.foo(
          $a![0],
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $R2250$Child $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.regressions.R2250$Child',
      $p,
      _$invokePointer,
      [
        if ($impl.foo$async) r'foo(Ljava/lang/Object;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory R2250$Child.implement(
    $R2250$Child $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<R2250$Child>();
  }
}

abstract base mixin class $R2250$Child {
  factory $R2250$Child({
    required void Function(jni$_.JObject? object) foo,
    core$_.bool foo$async,
  }) = _$R2250$Child;

  void foo(jni$_.JObject? object);
  core$_.bool get foo$async => false;
}

final class _$R2250$Child with $R2250$Child {
  _$R2250$Child({
    required void Function(jni$_.JObject? object) foo,
    this.foo$async = false,
  }) : _foo = foo;

  final void Function(jni$_.JObject? object) _foo;
  final core$_.bool foo$async;

  void foo(jni$_.JObject? object) {
    return _foo(object);
  }
}

final class $R2250$Child$Type$ extends jni$_.JType<R2250$Child> {
  @jni$_.internal
  const $R2250$Child$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/regressions/R2250$Child;';
}

/// from: `com.github.dart_lang.jnigen.regressions.R2250`
extension type R2250<$T extends jni$_.JObject?>._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/regressions/R2250');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<R2250> type = $R2250$Type$();
  static final _id_foo = _class.instanceMethodId(
    r'foo',
    r'(Ljava/lang/Object;)V',
  );

  static final _foo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void foo(T object)`
  void foo(
    $T? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _foo(reference.pointer, _id_foo as jni$_.JMethodIDPtr, _$object.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $R2250> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'foo(Ljava/lang/Object;)V') {
        _$impls[$p]!.foo(
          $a![0],
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$T extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $R2250<$T> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.regressions.R2250',
      $p,
      _$invokePointer,
      [
        if ($impl.foo$async) r'foo(Ljava/lang/Object;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory R2250.implement(
    $R2250<$T> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<R2250<$T>>();
  }
}

abstract base mixin class $R2250<$T extends jni$_.JObject?> {
  factory $R2250({
    required void Function($T? object) foo,
    core$_.bool foo$async,
  }) = _$R2250<$T>;

  void foo($T? object);
  core$_.bool get foo$async => false;
}

final class _$R2250<$T extends jni$_.JObject?> with $R2250<$T> {
  _$R2250({
    required void Function($T? object) foo,
    this.foo$async = false,
  }) : _foo = foo;

  final void Function($T? object) _foo;
  final core$_.bool foo$async;

  void foo($T? object) {
    return _foo(object);
  }
}

final class $R2250$Type$ extends jni$_.JType<R2250> {
  @jni$_.internal
  const $R2250$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/regressions/R2250;';
}

/// from: `com.github.dart_lang.jnigen.regressions.R693$Child`
extension type R693$Child._(jni$_.JObject _$this) implements R693<R693$Child?> {
  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/regressions/R693$Child');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<R693$Child> type = $R693$Child$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory R693$Child() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<R693$Child>();
  }
}

final class $R693$Child$Type$ extends jni$_.JType<R693$Child> {
  @jni$_.internal
  const $R693$Child$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/regressions/R693$Child;';
}

/// from: `com.github.dart_lang.jnigen.regressions.R693`
extension type R693<$T extends jni$_.JObject?>._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/regressions/R693');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<R693> type = $R693$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory R693() {
    return _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
        .object<R693<$T>>();
  }
}

final class $R693$Type$ extends jni$_.JType<R693> {
  @jni$_.internal
  const $R693$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/regressions/R693;';
}
