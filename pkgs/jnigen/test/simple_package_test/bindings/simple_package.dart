// Copyright (c) 2022, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as _$core;

import 'package:jni/_internal.dart' as _$jni;
import 'package:jni/jni.dart' as _$jni;

/// from: `com.github.dart_lang.jnigen.annotations.Annotated$Nested`
class Annotated_Nested<$T extends _$jni.JObject?, $U extends _$jni.JObject?,
    $W extends _$jni.JObject, $V extends _$jni.JObject?> extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Annotated_Nested<$T, $U, $W, $V>> $type;

  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  final _$jni.JObjType<$U> U;

  @_$jni.internal
  final _$jni.JObjType<$W> W;

  @_$jni.internal
  final _$jni.JObjType<$V> V;

  @_$jni.internal
  Annotated_Nested.fromReference(
    this.T,
    this.U,
    this.W,
    this.V,
    _$jni.JReference reference,
  )   : $type = type(T, U, W, V),
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/Annotated$Nested');

  /// The type which includes information such as the signature of this class.
  static $Annotated_Nested$Type<$T, $U, $W, $V> type<
      $T extends _$jni.JObject?,
      $U extends _$jni.JObject?,
      $W extends _$jni.JObject,
      $V extends _$jni.JObject?>(
    _$jni.JObjType<$T> T,
    _$jni.JObjType<$U> U,
    _$jni.JObjType<$W> W,
    _$jni.JObjType<$V> V,
  ) {
    return $Annotated_Nested$Type(
      T,
      U,
      W,
      V,
    );
  }

  static final _id_v = _class.instanceFieldId(
    r'v',
    r'Ljava/lang/Object;',
  );

  /// from: `public V v`
  /// The returned object must be released after use, by calling the [release] method.
  $V? get v => _id_v.get(this, V);

  /// from: `public V v`
  /// The returned object must be released after use, by calling the [release] method.
  set v($V? value) => _id_v.set(this, V, value);

  static final _id_u = _class.instanceFieldId(
    r'u',
    r'Ljava/lang/Object;',
  );

  /// from: `public U u`
  /// The returned object must be released after use, by calling the [release] method.
  $U get u => _id_u.get(this, U);

  /// from: `public U u`
  /// The returned object must be released after use, by calling the [release] method.
  set u($U value) => _id_u.set(this, U, value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/annotations/Annotated;Ljava/lang/Object;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.annotations.Annotated annotated, V object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Annotated_Nested(
    Annotated<_$jni.JObject, _$jni.JObject, _$jni.JObject>? annotated,
    $V? object, {
    required _$jni.JObjType<$T> T,
    required _$jni.JObjType<$U> U,
    required _$jni.JObjType<$W> W,
    required _$jni.JObjType<$V> V,
  }) {
    final _annotated = annotated?.reference;
    final _object = object?.reference;
    return Annotated_Nested.fromReference(
        T,
        U,
        W,
        V,
        _new$(
                _class.reference.pointer,
                _id_new$ as _$jni.JMethodIDPtr,
                _annotated?.pointer ?? _$jni.nullptr,
                _object?.pointer ?? _$jni.nullptr)
            .reference);
  }
}

final class $Annotated_Nested$Type<
        $T extends _$jni.JObject?,
        $U extends _$jni.JObject?,
        $W extends _$jni.JObject,
        $V extends _$jni.JObject?>
    extends _$jni.JObjType<Annotated_Nested<$T, $U, $W, $V>> {
  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  final _$jni.JObjType<$U> U;

  @_$jni.internal
  final _$jni.JObjType<$W> W;

  @_$jni.internal
  final _$jni.JObjType<$V> V;

  @_$jni.internal
  const $Annotated_Nested$Type(
    this.T,
    this.U,
    this.W,
    this.V,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/Annotated$Nested;';

  @_$jni.internal
  @_$core.override
  Annotated_Nested<$T, $U, $W, $V> fromReference(_$jni.JReference reference) =>
      Annotated_Nested.fromReference(T, U, W, V, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($Annotated_Nested$Type, T, U, W, V);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Annotated_Nested$Type<$T, $U, $W, $V>) &&
        other is $Annotated_Nested$Type<$T, $U, $W, $V> &&
        T == other.T &&
        U == other.U &&
        W == other.W &&
        V == other.V;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.Annotated`
class Annotated<$T extends _$jni.JObject?, $U extends _$jni.JObject?,
    $W extends _$jni.JObject> extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Annotated<$T, $U, $W>> $type;

  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  final _$jni.JObjType<$U> U;

  @_$jni.internal
  final _$jni.JObjType<$W> W;

  @_$jni.internal
  Annotated.fromReference(
    this.T,
    this.U,
    this.W,
    _$jni.JReference reference,
  )   : $type = type(T, U, W),
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/Annotated');

  /// The type which includes information such as the signature of this class.
  static $Annotated$Type<$T, $U, $W> type<$T extends _$jni.JObject?,
      $U extends _$jni.JObject?, $W extends _$jni.JObject>(
    _$jni.JObjType<$T> T,
    _$jni.JObjType<$U> U,
    _$jni.JObjType<$W> W,
  ) {
    return $Annotated$Type(
      T,
      U,
      W,
    );
  }

  static final _id_t = _class.instanceFieldId(
    r't',
    r'Ljava/lang/Object;',
  );

  /// from: `public T t`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get t => _id_t.get(this, T);

  /// from: `public T t`
  /// The returned object must be released after use, by calling the [release] method.
  set t($T? value) => _id_t.set(this, T, value);

  static final _id_u = _class.instanceFieldId(
    r'u',
    r'Ljava/lang/Object;',
  );

  /// from: `public U u`
  /// The returned object must be released after use, by calling the [release] method.
  $U? get u => _id_u.get(this, U);

  /// from: `public U u`
  /// The returned object must be released after use, by calling the [release] method.
  set u($U? value) => _id_u.set(this, U, value);

  static final _id_w = _class.instanceFieldId(
    r'w',
    r'Ljava/lang/Object;',
  );

  /// from: `public W w`
  /// The returned object must be released after use, by calling the [release] method.
  $W? get w => _id_w.get(this, W);

  /// from: `public W w`
  /// The returned object must be released after use, by calling the [release] method.
  set w($W? value) => _id_w.set(this, W, value);

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(T object, U object1, W object2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Annotated(
    $T? object,
    $U? object1,
    $W? object2, {
    required _$jni.JObjType<$T> T,
    required _$jni.JObjType<$U> U,
    required _$jni.JObjType<$W> W,
  }) {
    final _object = object?.reference;
    final _object1 = object1?.reference;
    final _object2 = object2?.reference;
    return Annotated.fromReference(
        T,
        U,
        W,
        _new$(
                _class.reference.pointer,
                _id_new$ as _$jni.JMethodIDPtr,
                _object?.pointer ?? _$jni.nullptr,
                _object1?.pointer ?? _$jni.nullptr,
                _object2?.pointer ?? _$jni.nullptr)
            .reference);
  }

  static final _id_hello = _class.instanceMethodId(
    r'hello',
    r'()Ljava/lang/String;',
  );

  static final _hello = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String hello()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JString hello() {
    return _hello(reference.pointer, _id_hello as _$jni.JMethodIDPtr)
        .object(const _$jni.JStringType());
  }

  static final _id_nullableHello = _class.instanceMethodId(
    r'nullableHello',
    r'(Z)Ljava/lang/String;',
  );

  static final _nullableHello = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public java.lang.String nullableHello(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JString? nullableHello(
    bool z,
  ) {
    return _nullableHello(reference.pointer,
            _id_nullableHello as _$jni.JMethodIDPtr, z ? 1 : 0)
        .object(const _$jni.JStringType());
  }

  static final _id_echo = _class.instanceMethodId(
    r'echo',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echo = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public java.lang.String echo(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JString echo(
    _$jni.JString string,
  ) {
    final _string = string?.reference;
    return _echo(
            reference.pointer, _id_echo as _$jni.JMethodIDPtr, _string.pointer)
        .object(const _$jni.JStringType());
  }

  static final _id_nullableEcho = _class.instanceMethodId(
    r'nullableEcho',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _nullableEcho = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public java.lang.String nullableEcho(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JString? nullableEcho(
    _$jni.JString? string,
  ) {
    final _string = string?.reference;
    return _nullableEcho(
            reference.pointer,
            _id_nullableEcho as _$jni.JMethodIDPtr,
            _string?.pointer ?? _$jni.nullptr)
        .object(const _$jni.JStringType());
  }

  static final _id_array = _class.instanceMethodId(
    r'array',
    r'()[Ljava/lang/String;',
  );

  static final _array = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String[] array()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JArray<_$jni.JString> array() {
    return _array(reference.pointer, _id_array as _$jni.JMethodIDPtr)
        .object(const _$jni.JArrayType(_$jni.JStringType()));
  }

  static final _id_arrayOfNullable = _class.instanceMethodId(
    r'arrayOfNullable',
    r'()[Ljava/lang/String;',
  );

  static final _arrayOfNullable = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String[] arrayOfNullable()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JArray<_$jni.JString?> arrayOfNullable() {
    return _arrayOfNullable(
            reference.pointer, _id_arrayOfNullable as _$jni.JMethodIDPtr)
        .object(const _$jni.JArrayType(_$jni.JStringType()));
  }

  static final _id_nullableArray = _class.instanceMethodId(
    r'nullableArray',
    r'(Z)[Ljava/lang/String;',
  );

  static final _nullableArray = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public java.lang.String[] nullableArray(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JArray<_$jni.JString>? nullableArray(
    bool z,
  ) {
    return _nullableArray(reference.pointer,
            _id_nullableArray as _$jni.JMethodIDPtr, z ? 1 : 0)
        .object(const _$jni.JArrayType(_$jni.JStringType()));
  }

  static final _id_nullableArrayOfNullable = _class.instanceMethodId(
    r'nullableArrayOfNullable',
    r'(Z)[Ljava/lang/String;',
  );

  static final _nullableArrayOfNullable = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public java.lang.String[] nullableArrayOfNullable(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JArray<_$jni.JString?>? nullableArrayOfNullable(
    bool z,
  ) {
    return _nullableArrayOfNullable(reference.pointer,
            _id_nullableArrayOfNullable as _$jni.JMethodIDPtr, z ? 1 : 0)
        .object(const _$jni.JArrayType(_$jni.JStringType()));
  }

  static final _id_list = _class.instanceMethodId(
    r'list',
    r'()Ljava/util/List;',
  );

  static final _list = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List list()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JString> list() {
    return _list(reference.pointer, _id_list as _$jni.JMethodIDPtr)
        .object(const _$jni.JListType(_$jni.JStringType()));
  }

  static final _id_listOfNullable = _class.instanceMethodId(
    r'listOfNullable',
    r'()Ljava/util/List;',
  );

  static final _listOfNullable = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List listOfNullable()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JString?> listOfNullable() {
    return _listOfNullable(
            reference.pointer, _id_listOfNullable as _$jni.JMethodIDPtr)
        .object(const _$jni.JListType(_$jni.JStringType()));
  }

  static final _id_nullableList = _class.instanceMethodId(
    r'nullableList',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableList = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public java.util.List nullableList(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JString>? nullableList(
    bool z,
  ) {
    return _nullableList(reference.pointer,
            _id_nullableList as _$jni.JMethodIDPtr, z ? 1 : 0)
        .object(const _$jni.JListType(_$jni.JStringType()));
  }

  static final _id_nullableListOfNullable = _class.instanceMethodId(
    r'nullableListOfNullable',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableListOfNullable = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public java.util.List nullableListOfNullable(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JString?>? nullableListOfNullable(
    bool z,
  ) {
    return _nullableListOfNullable(reference.pointer,
            _id_nullableListOfNullable as _$jni.JMethodIDPtr, z ? 1 : 0)
        .object(const _$jni.JListType(_$jni.JStringType()));
  }

  static final _id_classGenericEcho = _class.instanceMethodId(
    r'classGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _classGenericEcho = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public T classGenericEcho(T object)`
  /// The returned object must be released after use, by calling the [release] method.
  $T classGenericEcho(
    $T object,
  ) {
    final _object = object?.reference;
    return _classGenericEcho(reference.pointer,
            _id_classGenericEcho as _$jni.JMethodIDPtr, _object.pointer)
        .object(T);
  }

  static final _id_nullableClassGenericEcho = _class.instanceMethodId(
    r'nullableClassGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _nullableClassGenericEcho = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public T nullableClassGenericEcho(T object)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? nullableClassGenericEcho(
    $T? object,
  ) {
    final _object = object?.reference;
    return _nullableClassGenericEcho(
            reference.pointer,
            _id_nullableClassGenericEcho as _$jni.JMethodIDPtr,
            _object?.pointer ?? _$jni.nullptr)
        .object(T);
  }

  static final _id_methodGenericEcho = _class.instanceMethodId(
    r'methodGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _methodGenericEcho = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V methodGenericEcho(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V methodGenericEcho<$V extends _$jni.JObject?>(
    $V object, {
    _$jni.JObjType<$V>? V,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      (lt.$type as _$jni.JListType<_$core.dynamic>).E,
      t.$type,
    ]) as _$jni.JObjType<$T>;
    _methodWithSeveralParams(
            reference.pointer,
            _id_methodGenericEcho2 as _$jni.JMethodIDPtr,
            _object?.pointer ?? _$jni.nullptr)
        .object(V);
  }

  static final _id_methodGenericEcho3 = _class.instanceMethodId(
    r'methodGenericEcho3',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _methodGenericEcho3 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V methodGenericEcho3(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? methodGenericEcho3<$V extends _$jni.JObject?>(
    $V? object, {
    required _$jni.JObjType<$V> V,
  }) {
    final _object = object?.reference;
    return _methodGenericEcho3(
            reference.pointer,
            _id_methodGenericEcho3 as _$jni.JMethodIDPtr,
            _object?.pointer ?? _$jni.nullptr)
        .object(V);
  }

  static final _id_nullableReturnMethodGenericEcho = _class.instanceMethodId(
    r'nullableReturnMethodGenericEcho',
    r'(Ljava/lang/Object;Z)Ljava/lang/Object;',
  );

  static final _nullableReturnMethodGenericEcho =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<
                          (
                            _$jni.Pointer<_$jni.Void>,
                            _$jni.Int32
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int)>();

  /// from: `public V nullableReturnMethodGenericEcho(V object, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? nullableReturnMethodGenericEcho<$V extends _$jni.JObject?>(
    $V object,
    bool z, {
    _$jni.JObjType<$V>? V,
  }) {
    V ??= _$jni.lowestCommonSuperType([
      object.$type,
    ]) as _$jni.JObjType<$V>;
    final _object = object?.reference;
    return _nullableReturnMethodGenericEcho(
            reference.pointer,
            _id_nullableReturnMethodGenericEcho as _$jni.JMethodIDPtr,
            _object.pointer,
            z ? 1 : 0)
        .object(V);
  }

  static final _id_nullableMethodGenericEcho = _class.instanceMethodId(
    r'nullableMethodGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _nullableMethodGenericEcho = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V nullableMethodGenericEcho(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? nullableMethodGenericEcho<$V extends _$jni.JObject?>(
    $V? object, {
    required _$jni.JObjType<$V> V,
  }) {
    final _object = object?.reference;
    return _nullableMethodGenericEcho(
            reference.pointer,
            _id_nullableMethodGenericEcho as _$jni.JMethodIDPtr,
            _object?.pointer ?? _$jni.nullptr)
        .object(V);
  }

  static final _id_nullableArgMethodGenericEcho = _class.instanceMethodId(
    r'nullableArgMethodGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _nullableArgMethodGenericEcho =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V nullableArgMethodGenericEcho(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V nullableArgMethodGenericEcho<$V extends _$jni.JObject?>(
    $V? object, {
    required _$jni.JObjType<$V> V,
  }) {
    final _object = object?.reference;
    return _nullableArgMethodGenericEcho(
            reference.pointer,
            _id_nullableArgMethodGenericEcho as _$jni.JMethodIDPtr,
            _object?.pointer ?? _$jni.nullptr)
        .object(V);
  }

  static final _id_classGenericList = _class.instanceMethodId(
    r'classGenericList',
    r'()Ljava/util/List;',
  );

  static final _classGenericList = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List classGenericList()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<$T> classGenericList() {
    return _classGenericList(
            reference.pointer, _id_classGenericList as _$jni.JMethodIDPtr)
        .object(_$jni.JListType(T));
  }

  static final _id_classGenericListOfNullable = _class.instanceMethodId(
    r'classGenericListOfNullable',
    r'()Ljava/util/List;',
  );

  static final _classGenericListOfNullable =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public java.util.List classGenericListOfNullable()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<$T?> classGenericListOfNullable() {
    return _classGenericListOfNullable(reference.pointer,
            _id_classGenericListOfNullable as _$jni.JMethodIDPtr)
        .object(_$jni.JListType(T));
  }

  static final _id_nullableClassGenericList = _class.instanceMethodId(
    r'nullableClassGenericList',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableClassGenericList = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public java.util.List nullableClassGenericList(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_Parent_Child(
    GrandParent_Parent<$T, $S> $parent,
    $U newValue, {
    _$jni.JObjType<$T>? T,
    _$jni.JObjType<$S>? S,
    _$jni.JObjType<$U>? U,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      ($parent.$type
              as $GrandParent_Parent$Type<_$core.dynamic, _$core.dynamic>)
          .T,
    ]) as _$jni.JObjType<$T>;
    S ??= _$jni.lowestCommonSuperType([
      ($parent.$type
              as $GrandParent_Parent$Type<_$core.dynamic, _$core.dynamic>)
          .S,
    ]) as _$jni.JObjType<$S>;
    U ??= _$jni.lowestCommonSuperType([
      newValue.$type,
    ]) as _$jni.JObjType<$U>;
    return GrandParent_Parent_Child.fromReference(
        T,
        S,
        U,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr,
                $parent.reference.pointer, newValue.reference.pointer)
            .reference);
  }
}

final class $GrandParent_Parent_Child$Type<$T extends _$jni.JObject,
        $S extends _$jni.JObject, $U extends _$jni.JObject>
    extends _$jni.JObjType<GrandParent_Parent_Child<$T, $S, $U>> {
  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  final _$jni.JObjType<$U> U;

  @_$jni.internal
  const $GrandParent_Parent_Child$Type(
    this.T,
    this.S,
    this.U,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent$Child;';

  @_$jni.internal
  @_$core.override
  GrandParent_Parent_Child<$T, $S, $U> fromReference(
          _$jni.JReference reference) =>
      GrandParent_Parent_Child.fromReference(T, S, U, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($GrandParent_Parent_Child$Type, T, S, U);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent_Parent_Child$Type<$T, $S, $U>) &&
        other is $GrandParent_Parent_Child$Type<$T, $S, $U> &&
        T == other.T &&
        S == other.S &&
        U == other.U;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$Parent`
class GrandParent_Parent<$T extends _$jni.JObject, $S extends _$jni.JObject>
    extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<GrandParent_Parent<$T, $S>> $type;

  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  GrandParent_Parent.fromReference(
    this.T,
    this.S,
    _$jni.JReference reference,
  )   : $type = type(T, S),
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$Parent');

  /// The type which includes information such as the signature of this class.
  static $GrandParent_Parent$Type<$T, $S>
      type<$T extends _$jni.JObject, $S extends _$jni.JObject>(
    _$jni.JObjType<$T> T,
    _$jni.JObjType<$S> S,
  ) {
    return _nullableClassGenericList(reference.pointer,
            _id_nullableClassGenericList as _$jni.JMethodIDPtr, z ? 1 : 0)
        .object(_$jni.JListType(T));
  }

  static final _id_nullableClassGenericListOfNullable = _class.instanceMethodId(
    r'nullableClassGenericListOfNullable',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableClassGenericListOfNullable =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public java.util.List nullableClassGenericListOfNullable(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_Parent(
    GrandParent<$T> $parent,
    $S newValue, {
    _$jni.JObjType<$T>? T,
    _$jni.JObjType<$S>? S,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      ($parent.$type as $GrandParent$Type<_$core.dynamic>).T,
    ]) as _$jni.JObjType<$T>;
    S ??= _$jni.lowestCommonSuperType([
      newValue.$type,
    ]) as _$jni.JObjType<$S>;
    return GrandParent_Parent.fromReference(
        T,
        S,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr,
                $parent.reference.pointer, newValue.reference.pointer)
            .reference);
  }
}

final class $GrandParent_Parent$Type<$T extends _$jni.JObject,
        $S extends _$jni.JObject>
    extends _$jni.JObjType<GrandParent_Parent<$T, $S>> {
  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  const $GrandParent_Parent$Type(
    this.T,
    this.S,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;';

  @_$jni.internal
  @_$core.override
  GrandParent_Parent<$T, $S> fromReference(_$jni.JReference reference) =>
      GrandParent_Parent.fromReference(T, S, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($GrandParent_Parent$Type, T, S);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent_Parent$Type<$T, $S>) &&
        other is $GrandParent_Parent$Type<$T, $S> &&
        T == other.T &&
        S == other.S;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$StaticParent$Child`
class GrandParent_StaticParent_Child<$S extends _$jni.JObject,
    $U extends _$jni.JObject> extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<GrandParent_StaticParent_Child<$S, $U>> $type;

  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  final _$jni.JObjType<$U> U;

  @_$jni.internal
  GrandParent_StaticParent_Child.fromReference(
    this.S,
    this.U,
    _$jni.JReference reference,
  )   : $type = type(S, U),
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child');

  /// The type which includes information such as the signature of this class.
  static $GrandParent_StaticParent_Child$Type<$S, $U>
      type<$S extends _$jni.JObject, $U extends _$jni.JObject>(
    _$jni.JObjType<$S> S,
    _$jni.JObjType<$U> U,
  ) {
    return _nullableClassGenericListOfNullable(
            reference.pointer,
            _id_nullableClassGenericListOfNullable as _$jni.JMethodIDPtr,
            z ? 1 : 0)
        .object(_$jni.JListType(T));
  }

  static final _id_methodGenericList = _class.instanceMethodId(
    r'methodGenericList',
    r'(Ljava/lang/Object;)Ljava/util/List;',
  );

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $S get parentValue => _id_parentValue.get(this, S);

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($S value) => _id_parentValue.set(this, S, value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  $U get value => _id_value.get(this, U);

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($U value) => _id_value.set(this, U, value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.GrandParent$StaticParent $parent, S parentValue, U value)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_StaticParent_Child(
    GrandParent_StaticParent<$S> $parent,
    $S parentValue,
    $U value, {
    _$jni.JObjType<$S>? S,
    _$jni.JObjType<$U>? U,
  }) {
    S ??= _$jni.lowestCommonSuperType([
      parentValue.$type,
      ($parent.$type as $GrandParent_StaticParent$Type<_$core.dynamic>).S,
    ]) as _$jni.JObjType<$S>;
    U ??= _$jni.lowestCommonSuperType([
      value.$type,
    ]) as _$jni.JObjType<$U>;
    return GrandParent_StaticParent_Child.fromReference(
        S,
        U,
        _new$(
                _class.reference.pointer,
                _id_new$ as _$jni.JMethodIDPtr,
                $parent.reference.pointer,
                parentValue.reference.pointer,
                value.reference.pointer)
            .reference);
  }
}

final class $GrandParent_StaticParent_Child$Type<$S extends _$jni.JObject,
        $U extends _$jni.JObject>
    extends _$jni.JObjType<GrandParent_StaticParent_Child<$S, $U>> {
  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  final _$jni.JObjType<$U> U;

  @_$jni.internal
  const $GrandParent_StaticParent_Child$Type(
    this.S,
    this.U,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child;';

  @_$jni.internal
  @_$core.override
  GrandParent_StaticParent_Child<$S, $U> fromReference(
          _$jni.JReference reference) =>
      GrandParent_StaticParent_Child.fromReference(S, U, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($GrandParent_StaticParent_Child$Type, S, U);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($GrandParent_StaticParent_Child$Type<$S, $U>) &&
        other is $GrandParent_StaticParent_Child$Type<$S, $U> &&
        S == other.S &&
        U == other.U;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$StaticParent`
class GrandParent_StaticParent<$S extends _$jni.JObject> extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<GrandParent_StaticParent<$S>> $type;

  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  GrandParent_StaticParent.fromReference(
    this.S,
    _$jni.JReference reference,
  )   : $type = type(S),
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$StaticParent');

  /// The type which includes information such as the signature of this class.
  static $GrandParent_StaticParent$Type<$S> type<$S extends _$jni.JObject>(
    _$jni.JObjType<$S> S,
  ) {
    return $GrandParent_StaticParent$Type(
      S,
    );
  }

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  $S get value => _id_value.get(this, S);

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($S value) => _id_value.set(this, S, value);

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(S value)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_StaticParent(
    $S value, {
    _$jni.JObjType<$S>? S,
  }) {
    S ??= _$jni.lowestCommonSuperType([
      value.$type,
    ]) as _$jni.JObjType<$S>;
    return GrandParent_StaticParent.fromReference(
        S,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr,
                value.reference.pointer)
            .reference);
  }
}

final class $GrandParent_StaticParent$Type<$S extends _$jni.JObject>
    extends _$jni.JObjType<GrandParent_StaticParent<$S>> {
  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  const $GrandParent_StaticParent$Type(
    this.S,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;';

  @_$jni.internal
  @_$core.override
  GrandParent_StaticParent<$S> fromReference(_$jni.JReference reference) =>
      GrandParent_StaticParent.fromReference(S, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($GrandParent_StaticParent$Type, S);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent_StaticParent$Type<$S>) &&
        other is $GrandParent_StaticParent$Type<$S> &&
        S == other.S;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent`
class GrandParent<$T extends _$jni.JObject> extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<GrandParent<$T>> $type;

  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  GrandParent.fromReference(
    this.T,
    _$jni.JReference reference,
  )   : $type = type(T),
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'com/github/dart_lang/jnigen/generics/GrandParent');

  /// The type which includes information such as the signature of this class.
  static $GrandParent$Type<$T> type<$T extends _$jni.JObject>(
    _$jni.JObjType<$T> T,
  ) {
    return $GrandParent$Type(
      T,
    );
  }

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public T value`
  /// The returned object must be released after use, by calling the [release] method.
  $T get value => _id_value.get(this, T);

  /// from: `public T value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($T value) => _id_value.set(this, T, value);

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(T value)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent(
    $T value, {
    _$jni.JObjType<$T>? T,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      value.$type,
    ]) as _$jni.JObjType<$T>;
    return GrandParent.fromReference(
        T,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr,
                value.reference.pointer)
            .reference);
  }

  static final _id_stringParent = _class.instanceMethodId(
    r'stringParent',
    r'()Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;',
  );

  static final _stringParent = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.generics.GrandParent<T>.Parent<java.lang.String> stringParent()`
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent_Parent<_$jni.JObject, _$jni.JString> stringParent() {
    return _stringParent(
            reference.pointer, _id_stringParent as _$jni.JMethodIDPtr)
        .object(const $GrandParent_Parent$Type(
            _$jni.JObjectType(), _$jni.JStringType()));
  }

  static final _id_varParent = _class.instanceMethodId(
    r'varParent',
    r'(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;',
  );

  static final _varParent = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public java.util.List methodGenericList(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<$V> methodGenericList<$V extends _$jni.JObject?>(
    $V object, {
    _$jni.JObjType<$V>? V,
  }) {
    K ??= _$jni.lowestCommonSuperType([
      key.$type,
      ($parent.$type as $MyMap$Type<_$core.dynamic, _$core.dynamic>).K,
    ]) as _$jni.JObjType<$K>;
    V ??= _$jni.lowestCommonSuperType([
      value.$type,
      ($parent.$type as $MyMap$Type<_$core.dynamic, _$core.dynamic>).V,
    ]) as _$jni.JObjType<$V>;
    final _object = object?.reference;
    return _methodGenericList(reference.pointer,
            _id_methodGenericList as _$jni.JMethodIDPtr, _object.pointer)
        .object(_$jni.JListType(V));
  }

  static final _id_methodGenericListOfNullable = _class.instanceMethodId(
    r'methodGenericListOfNullable',
    r'()Ljava/util/List;',
  );

  static final _methodGenericListOfNullable =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public java.util.List methodGenericListOfNullable()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<$V?> methodGenericListOfNullable<$V extends _$jni.JObject?>({
    required _$jni.JObjType<$V> V,
  }) {
    return _methodGenericListOfNullable(reference.pointer,
            _id_methodGenericListOfNullable as _$jni.JMethodIDPtr)
        .object(_$jni.JListType(V));
  }

  static final _id_nullableMethodGenericList = _class.instanceMethodId(
    r'nullableMethodGenericList',
    r'(Ljava/lang/Object;Z)Ljava/util/List;',
  );

  static final _nullableMethodGenericList = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni
                          .VarArgs<(_$jni.Pointer<_$jni.Void>, _$jni.Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int)>();

  /// from: `public java.util.List nullableMethodGenericList(V object, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<$V>? nullableMethodGenericList<$V extends _$jni.JObject?>(
    $V object,
    bool z, {
    _$jni.JObjType<$V>? V,
  }) {
    V ??= _$jni.lowestCommonSuperType([
      object.$type,
    ]) as _$jni.JObjType<$V>;
    final _object = object?.reference;
    return _nullableMethodGenericList(
            reference.pointer,
            _id_nullableMethodGenericList as _$jni.JMethodIDPtr,
            _object.pointer,
            z ? 1 : 0)
        .object(_$jni.JListType(V));
  }

  static final _id_nullableMethodGenericListOfNullable =
      _class.instanceMethodId(
    r'nullableMethodGenericListOfNullable',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableMethodGenericListOfNullable =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public java.util.List nullableMethodGenericListOfNullable(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<$V?>?
      nullableMethodGenericListOfNullable<$V extends _$jni.JObject?>(
    bool z, {
    required _$jni.JObjType<$V> V,
  }) {
    return _nullableMethodGenericListOfNullable(
            reference.pointer,
            _id_nullableMethodGenericListOfNullable as _$jni.JMethodIDPtr,
            z ? 1 : 0)
        .object(_$jni.JListType(V));
  }

  static final _id_firstOfClassGenericList = _class.instanceMethodId(
    r'firstOfClassGenericList',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfClassGenericList = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public T firstOfClassGenericList(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstOfClassGenericList(
    _$jni.JList<$T> list,
  ) {
    final _list = list?.reference;
    return _firstOfClassGenericList(reference.pointer,
            _id_firstOfClassGenericList as _$jni.JMethodIDPtr, _list.pointer)
        .object(T);
  }

  static final _id_firstOfClassGenericNullableList = _class.instanceMethodId(
    r'firstOfClassGenericNullableList',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfClassGenericNullableList =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public T firstOfClassGenericNullableList(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$S> fromArrayOfArrayOfGrandParents<$S extends _$jni.JObject>(
    _$jni.JArray<_$jni.JArray<GrandParent<$S>>> arr, {
    _$jni.JObjType<$S>? S,
  }) {
    S ??= _$jni.lowestCommonSuperType([
      (((((arr.$type as _$jni.JArrayType).elementType as _$jni.JObjType)
                      as _$jni.JArrayType)
                  .elementType as _$jni.JObjType)
              as $GrandParent$Type<_$core.dynamic>)
          .T,
    ]) as _$jni.JObjType<$S>;
    return _fromArrayOfArrayOfGrandParents(
            _class.reference.pointer,
            _id_fromArrayOfArrayOfGrandParents as _$jni.JMethodIDPtr,
            arr.reference.pointer)
        .object($MyStack$Type(S));
  }

  static final _id_firstOfClassGenericListOfNullable = _class.instanceMethodId(
    r'firstOfClassGenericListOfNullable',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfClassGenericListOfNullable =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public T firstOfClassGenericListOfNullable(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstOfClassGenericListOfNullable(
    _$jni.JList<$T?> list,
  ) {
    final _list = list?.reference;
    return _firstOfClassGenericListOfNullable(
            reference.pointer,
            _id_firstOfClassGenericListOfNullable as _$jni.JMethodIDPtr,
            _list.pointer)
        .object(T);
  }

  static final _id_firstOfClassGenericNullableListOfNullable =
      _class.instanceMethodId(
    r'firstOfClassGenericNullableListOfNullable',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfClassGenericNullableListOfNullable =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public T firstOfClassGenericNullableListOfNullable(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstOfClassGenericNullableListOfNullable(
    _$jni.JList<$T?>? list,
  ) {
    final _list = list?.reference;
    return _firstOfClassGenericNullableListOfNullable(
            reference.pointer,
            _id_firstOfClassGenericNullableListOfNullable as _$jni.JMethodIDPtr,
            _list?.pointer ?? _$jni.nullptr)
        .object(T);
  }

  static final _id_firstOfMethodGenericList = _class.instanceMethodId(
    r'firstOfMethodGenericList',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfMethodGenericList = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V firstOfMethodGenericList(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstOfMethodGenericList<$V extends _$jni.JObject?>(
    _$jni.JList<$V> list, {
    _$jni.JObjType<$V>? V,
  }) {
    V ??= _$jni.lowestCommonSuperType([
      (list.$type as _$jni.JListType).E,
    ]) as _$jni.JObjType<$V>;
    final _list = list?.reference;
    return _firstOfMethodGenericList(reference.pointer,
            _id_firstOfMethodGenericList as _$jni.JMethodIDPtr, _list.pointer)
        .object(V);
  }

  static final _id_firstOfMethodGenericNullableList = _class.instanceMethodId(
    r'firstOfMethodGenericNullableList',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfMethodGenericNullableList =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V firstOfMethodGenericNullableList(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstOfMethodGenericNullableList<$V extends _$jni.JObject?>(
    _$jni.JList<$V>? list, {
    required _$jni.JObjType<$V> V,
  }) {
    final _list = list?.reference;
    return _firstOfMethodGenericNullableList(
            reference.pointer,
            _id_firstOfMethodGenericNullableList as _$jni.JMethodIDPtr,
            _list?.pointer ?? _$jni.nullptr)
        .object(V);
  }

  static final _id_firstOfMethodGenericListOfNullable = _class.instanceMethodId(
    r'firstOfMethodGenericListOfNullable',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfMethodGenericListOfNullable =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V firstOfMethodGenericListOfNullable(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstOfMethodGenericListOfNullable<$V extends _$jni.JObject?>(
    _$jni.JList<$V?> list, {
    _$jni.JObjType<$V>? V,
  }) {
    V ??= _$jni.lowestCommonSuperType([
      (list.$type as _$jni.JListType).E,
    ]) as _$jni.JObjType<$V>;
    final _list = list?.reference;
    return _firstOfMethodGenericListOfNullable(
            reference.pointer,
            _id_firstOfMethodGenericListOfNullable as _$jni.JMethodIDPtr,
            _list.pointer)
        .object(V);
  }

  static final _id_firstOfMethodGenericNullableListOfNullable =
      _class.instanceMethodId(
    r'firstOfMethodGenericNullableListOfNullable',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfMethodGenericNullableListOfNullable =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V firstOfMethodGenericNullableListOfNullable(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstOfMethodGenericNullableListOfNullable<$V extends _$jni.JObject?>(
    _$jni.JList<$V?>? list, {
    required _$jni.JObjType<$V> V,
  }) {
    final _list = list?.reference;
    return _firstOfMethodGenericNullableListOfNullable(
            reference.pointer,
            _id_firstOfMethodGenericNullableListOfNullable
                as _$jni.JMethodIDPtr,
            _list?.pointer ?? _$jni.nullptr)
        .object(V);
  }

  static final _id_firstKeyOfComboMap = _class.instanceMethodId(
    r'firstKeyOfComboMap',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstKeyOfComboMap = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public T firstKeyOfComboMap(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstKeyOfComboMap<$V extends _$jni.JObject?>(
    _$jni.JMap<$T, $V> map, {
    _$jni.JObjType<$V>? V,
  }) {
    V ??= _$jni.lowestCommonSuperType([
      (map.$type as _$jni.JMapType).V,
    ]) as _$jni.JObjType<$V>;
    final _map = map?.reference;
    return _firstKeyOfComboMap(reference.pointer,
            _id_firstKeyOfComboMap as _$jni.JMethodIDPtr, _map.pointer)
        .object(T);
  }

  static final _id_firstValueOfComboMap = _class.instanceMethodId(
    r'firstValueOfComboMap',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOfComboMap = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V firstValueOfComboMap(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstValueOfComboMap<$V extends _$jni.JObject?>(
    _$jni.JMap<$T, $V> map, {
    _$jni.JObjType<$V>? V,
  }) {
    V ??= _$jni.lowestCommonSuperType([
      (map.$type as _$jni.JMapType).V,
    ]) as _$jni.JObjType<$V>;
    final _map = map?.reference;
    return _firstValueOfComboMap(reference.pointer,
            _id_firstValueOfComboMap as _$jni.JMethodIDPtr, _map.pointer)
        .object(V);
  }

  static final _id_firstKeyOfComboMapNullableKey = _class.instanceMethodId(
    r'firstKeyOfComboMapNullableKey',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstKeyOfComboMapNullableKey =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public T firstKeyOfComboMapNullableKey(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstKeyOfComboMapNullableKey<$V extends _$jni.JObject?>(
    _$jni.JMap<$T?, $V> map, {
    _$jni.JObjType<$V>? V,
  }) {
    V ??= _$jni.lowestCommonSuperType([
      (map.$type as _$jni.JMapType).V,
    ]) as _$jni.JObjType<$V>;
    final _map = map?.reference;
    return _firstKeyOfComboMapNullableKey(
            reference.pointer,
            _id_firstKeyOfComboMapNullableKey as _$jni.JMethodIDPtr,
            _map.pointer)
        .object(T);
  }

  static final _id_firstValueOfComboMapNullableKey = _class.instanceMethodId(
    r'firstValueOfComboMapNullableKey',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOfComboMapNullableKey =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V firstValueOfComboMapNullableKey(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstValueOfComboMapNullableKey<$V extends _$jni.JObject?>(
    _$jni.JMap<$T?, $V> map, {
    _$jni.JObjType<$V>? V,
  }) {
    V ??= _$jni.lowestCommonSuperType([
      (map.$type as _$jni.JMapType).V,
    ]) as _$jni.JObjType<$V>;
    final _map = map?.reference;
    return _firstValueOfComboMapNullableKey(
            reference.pointer,
            _id_firstValueOfComboMapNullableKey as _$jni.JMethodIDPtr,
            _map.pointer)
        .object(V);
  }

  static final _id_firstKeyOfComboMapNullableValue = _class.instanceMethodId(
    r'firstKeyOfComboMapNullableValue',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstKeyOfComboMapNullableValue =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public T firstKeyOfComboMapNullableValue(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstKeyOfComboMapNullableValue<$V extends _$jni.JObject?>(
    _$jni.JMap<$T, $V?> map, {
    _$jni.JObjType<$V>? V,
  }) {
    V ??= _$jni.lowestCommonSuperType([
      (map.$type as _$jni.JMapType).V,
    ]) as _$jni.JObjType<$V>;
    final _map = map?.reference;
    return _firstKeyOfComboMapNullableValue(
            reference.pointer,
            _id_firstKeyOfComboMapNullableValue as _$jni.JMethodIDPtr,
            _map.pointer)
        .object(T);
  }

  static final _id_firstValueOfComboMapNullableValue = _class.instanceMethodId(
    r'firstValueOfComboMapNullableValue',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOfComboMapNullableValue =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V firstValueOfComboMapNullableValue(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstValueOfComboMapNullableValue<$V extends _$jni.JObject?>(
    _$jni.JMap<$T, $V?> map, {
    _$jni.JObjType<$V>? V,
  }) {
    V ??= _$jni.lowestCommonSuperType([
      (map.$type as _$jni.JMapType).V,
    ]) as _$jni.JObjType<$V>;
    final _map = map?.reference;
    return _firstValueOfComboMapNullableValue(
            reference.pointer,
            _id_firstValueOfComboMapNullableValue as _$jni.JMethodIDPtr,
            _map.pointer)
        .object(V);
  }

  static final _id_firstKeyOfComboMapNullableKeyAndValue =
      _class.instanceMethodId(
    r'firstKeyOfComboMapNullableKeyAndValue',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstKeyOfComboMapNullableKeyAndValue =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public T firstKeyOfComboMapNullableKeyAndValue(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstKeyOfComboMapNullableKeyAndValue<$V extends _$jni.JObject?>(
    _$jni.JMap<$T?, $V?> map, {
    _$jni.JObjType<$V>? V,
  }) {
    V ??= _$jni.lowestCommonSuperType([
      (map.$type as _$jni.JMapType).V,
    ]) as _$jni.JObjType<$V>;
    final _map = map?.reference;
    return _firstKeyOfComboMapNullableKeyAndValue(
            reference.pointer,
            _id_firstKeyOfComboMapNullableKeyAndValue as _$jni.JMethodIDPtr,
            _map.pointer)
        .object(T);
  }

  static final _id_firstValueOfComboMapNullableKeyAndValue =
      _class.instanceMethodId(
    r'firstValueOfComboMapNullableKeyAndValue',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOfComboMapNullableKeyAndValue =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V firstValueOfComboMapNullableKeyAndValue(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstValueOfComboMapNullableKeyAndValue<$V extends _$jni.JObject?>(
    _$jni.JMap<$T?, $V?> map, {
    _$jni.JObjType<$V>? V,
  }) {
    V ??= _$jni.lowestCommonSuperType([
      (map.$type as _$jni.JMapType).V,
    ]) as _$jni.JObjType<$V>;
    final _map = map?.reference;
    return _firstValueOfComboMapNullableKeyAndValue(
            reference.pointer,
            _id_firstValueOfComboMapNullableKeyAndValue as _$jni.JMethodIDPtr,
            _map.pointer)
        .object(V);
  }

  static final _id_firstEntryOfComboMap = _class.instanceMethodId(
    r'firstEntryOfComboMap',
    r'(Ljava/util/Map;)Ljava/util/Map$Entry;',
  );

  static final _firstEntryOfComboMap = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public java.util.Map$Entry firstEntryOfComboMap(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject? firstEntryOfComboMap<$V extends _$jni.JObject?>(
    _$jni.JMap<$T, $V> map, {
    _$jni.JObjType<$V>? V,
  }) {
    V ??= _$jni.lowestCommonSuperType([
      (map.$type as _$jni.JMapType).V,
    ]) as _$jni.JObjType<$V>;
    final _map = map?.reference;
    return _firstEntryOfComboMap(reference.pointer,
            _id_firstEntryOfComboMap as _$jni.JMethodIDPtr, _map.pointer)
        .object(const _$jni.JObjectType());
  }

  static final _id_getW = _class.instanceMethodId(
    r'getW',
    r'()Ljava/lang/Object;',
  );

  static final _getW = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public W getW()`
  /// The returned object must be released after use, by calling the [release] method.
  $W? getW() {
    return _getW(reference.pointer, _id_getW as _$jni.JMethodIDPtr).object(W);
  }

  static final _id_nullableGetW = _class.instanceMethodId(
    r'nullableGetW',
    r'(Z)Ljava/lang/Object;',
  );

  static final _nullableGetW = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public W nullableGetW(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  $W? nullableGetW(
    bool z,
  ) {
    return _nullableGetW(reference.pointer,
            _id_nullableGetW as _$jni.JMethodIDPtr, z ? 1 : 0)
        .object(W);
  }

  static final _id_list3dOfT = _class.instanceMethodId(
    r'list3dOfT',
    r'()Ljava/util/List;',
  );

  static final _firstKeyOf = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract T firstKeyOf(java.util.Map<T,U> map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T firstKeyOf<$U extends _$jni.JObject>(
    _$jni.JMap<$T, $U> map, {
    _$jni.JObjType<$U>? U,
  }) {
    U ??= _$jni.lowestCommonSuperType([
      (map.$type as _$jni.JMapType<_$core.dynamic, _$core.dynamic>).V,
    ]) as _$jni.JObjType<$U>;
    return _firstKeyOf(reference.pointer, _id_firstKeyOf as _$jni.JMethodIDPtr,
            map.reference.pointer)
        .object(T);
  }

  static final _id_firstValueOf = _class.instanceMethodId(
    r'firstValueOf',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOf = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract U firstValueOf(java.util.Map<T,U> map)`
  /// The returned object must be released after use, by calling the [release] method.
  $U firstValueOf<$U extends _$jni.JObject>(
    _$jni.JMap<$T, $U> map, {
    _$jni.JObjType<$U>? U,
  }) {
    U ??= _$jni.lowestCommonSuperType([
      (map.$type as _$jni.JMapType<_$core.dynamic, _$core.dynamic>).V,
    ]) as _$jni.JObjType<$U>;
    return _firstValueOf(reference.pointer,
            _id_firstValueOf as _$jni.JMethodIDPtr, map.reference.pointer)
        .object(U);
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $GenericInterface> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List list3dOfT()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JList<_$jni.JList<$T?>>> list3dOfT() {
    return _list3dOfT(reference.pointer, _id_list3dOfT as _$jni.JMethodIDPtr)
        .object(_$jni.JListType(_$jni.JListType(_$jni.JListType(T))));
  }

  static final _id_list3dOfU = _class.instanceMethodId(
    r'list3dOfU',
    r'()Ljava/util/List;',
  );

  static final _list3dOfU = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List list3dOfU()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JList<_$jni.JList<$U?>>> list3dOfU() {
    return _list3dOfU(reference.pointer, _id_list3dOfU as _$jni.JMethodIDPtr)
        .object(_$jni.JListType(_$jni.JListType(_$jni.JListType(U))));
  }

  static final _id_list3dOfW = _class.instanceMethodId(
    r'list3dOfW',
    r'()Ljava/util/List;',
  );

  static final _list3dOfW = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List list3dOfW()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JList<_$jni.JList<$W?>>> list3dOfW() {
    return _list3dOfW(reference.pointer, _id_list3dOfW as _$jni.JMethodIDPtr)
        .object(_$jni.JListType(_$jni.JListType(_$jni.JListType(W))));
  }

  static final _id_list3dOfNullableU = _class.instanceMethodId(
    r'list3dOfNullableU',
    r'(Z)Ljava/util/List;',
  );

  static final _list3dOfNullableU = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public java.util.List list3dOfNullableU(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyInterfaceConsumer() {
    return MyInterfaceConsumer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }

  static final _id_consumeOnAnotherThread = _class.staticMethodId(
    r'consumeOnAnotherThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/MyInterface;Ljava/lang/String;IZCDLjava/lang/Object;)V',
  );

  static final _consumeOnAnotherThread = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Double,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              int,
              int,
              int,
              double,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public void consumeOnAnotherThread(com.github.dart_lang.jnigen.interfaces.MyInterface<T> myInterface, java.lang.String s, int a, boolean b, char c, double d, T t)`
  static void consumeOnAnotherThread<$T extends _$jni.JObject>(
    MyInterface<$T> myInterface,
    _$jni.JString s,
    int a,
    bool b,
    int c,
    double d,
    $T t, {
    _$jni.JObjType<$T>? T,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      t.$type,
      (myInterface.$type as $MyInterface$Type<_$core.dynamic>).T,
    ]) as _$jni.JObjType<$T>;
    _consumeOnAnotherThread(
            _class.reference.pointer,
            _id_consumeOnAnotherThread as _$jni.JMethodIDPtr,
            myInterface.reference.pointer,
            s.reference.pointer,
            a,
            b ? 1 : 0,
            c,
            d,
            t.reference.pointer)
        .check();
  }

  static final _id_consumeOnSameThread = _class.staticMethodId(
    r'consumeOnSameThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/MyInterface;Ljava/lang/String;IZCDLjava/lang/Object;)V',
  );

  static final _consumeOnSameThread = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Double,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              int,
              int,
              int,
              double,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public void consumeOnSameThread(com.github.dart_lang.jnigen.interfaces.MyInterface<T> myInterface, java.lang.String s, int a, boolean b, char c, double d, T t)`
  static void consumeOnSameThread<$T extends _$jni.JObject>(
    MyInterface<$T> myInterface,
    _$jni.JString s,
    int a,
    bool b,
    int c,
    double d,
    $T t, {
    _$jni.JObjType<$T>? T,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      t.$type,
      (myInterface.$type as $MyInterface$Type<_$core.dynamic>).T,
    ]) as _$jni.JObjType<$T>;
    _consumeOnSameThread(
            _class.reference.pointer,
            _id_consumeOnSameThread as _$jni.JMethodIDPtr,
            myInterface.reference.pointer,
            s.reference.pointer,
            a,
            b ? 1 : 0,
            c,
            d,
            t.reference.pointer)
        .check();
  }
}

final class $MyInterfaceConsumer$Type
    extends _$jni.JObjType<MyInterfaceConsumer> {
  @_$jni.internal
  const $MyInterfaceConsumer$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyInterfaceConsumer;';

  @_$jni.internal
  @_$core.override
  MyInterfaceConsumer fromReference(_$jni.JReference reference) =>
      MyInterfaceConsumer.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MyInterfaceConsumer$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyInterfaceConsumer$Type) &&
        other is $MyInterfaceConsumer$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyRunnable`
class MyRunnable extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MyRunnable> $type;

  @_$jni.internal
  MyRunnable.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyRunnable');

  /// The type which includes information such as the signature of this class.
  static const type = $MyRunnable$Type();
  static final _id_run = _class.instanceMethodId(
    r'run',
    r'()V',
  );

  static final _run = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void run()`
  void run() {
    _run(reference.pointer, _id_run as _$jni.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MyRunnable> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _list3dOfNullableU(reference.pointer,
            _id_list3dOfNullableU as _$jni.JMethodIDPtr, z ? 1 : 0)
        .object(_$jni.JListType(_$jni.JListType(_$jni.JListType(U))));
  }

  static final _id_list3dOfNullableW = _class.instanceMethodId(
    r'list3dOfNullableW',
    r'(Z)Ljava/util/List;',
  );

  static final _list3dOfNullableW = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public java.util.List list3dOfNullableW(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JList<_$jni.JList<$W?>>> list3dOfNullableW(
    bool z,
  ) {
    return _list3dOfNullableW(reference.pointer,
            _id_list3dOfNullableW as _$jni.JMethodIDPtr, z ? 1 : 0)
        .object(_$jni.JListType(_$jni.JListType(_$jni.JListType(W))));
  }

  static final _id_nested = _class.instanceMethodId(
    r'nested',
    r'()Lcom/github/dart_lang/jnigen/annotations/Annotated$Nested;',
  );

  static final _nested = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.annotations.Annotated.Nested nested()`
  /// The returned object must be released after use, by calling the [release] method.
  Annotated_Nested<$T?, $U?, $W?, _$jni.JInteger>? nested() {
    return _nested(reference.pointer, _id_nested as _$jni.JMethodIDPtr)
        .object($Annotated_Nested$Type(T, U, W, const _$jni.JIntegerType()));
  }

  static final _id_intList = _class.instanceMethodId(
    r'intList',
    r'()Ljava/util/List;',
  );

  static final _intList = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List intList()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> intList() {
    return _intList(reference.pointer, _id_intList as _$jni.JMethodIDPtr)
        .object(const _$jni.JListType(_$jni.JObjectType()));
  }
}

final class $Annotated$Type<
    $T extends _$jni.JObject?,
    $U extends _$jni.JObject?,
    $W extends _$jni.JObject> extends _$jni.JObjType<Annotated<$T, $U, $W>> {
  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  final _$jni.JObjType<$U> U;

  @_$jni.internal
  final _$jni.JObjType<$W> W;

  @_$jni.internal
  const $Annotated$Type(
    this.T,
    this.U,
    this.W,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/Annotated;';

  @_$jni.internal
  @_$core.override
  Annotated<$T, $U, $W> fromReference(_$jni.JReference reference) =>
      Annotated.fromReference(T, U, W, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($Annotated$Type, T, U, W);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Annotated$Type<$T, $U, $W>) &&
        other is $Annotated$Type<$T, $U, $W> &&
        T == other.T &&
        U == other.U &&
        W == other.W;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.JsonSerializable$Case`
class JsonSerializable_Case extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<JsonSerializable_Case> $type;

  @_$jni.internal
  JsonSerializable_Case.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/JsonSerializable$Case');

  /// The type which includes information such as the signature of this class.
  static const type = $JsonSerializable_Case$Type();
  static final _id_SNAKE_CASE = _class.staticFieldId(
    r'SNAKE_CASE',
    r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.annotations.JsonSerializable$Case SNAKE_CASE`
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable_Case? get SNAKE_CASE =>
      _id_SNAKE_CASE.get(_class, const $JsonSerializable_Case$Type());

  static final _id_KEBAB_CASE = _class.staticFieldId(
    r'KEBAB_CASE',
    r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.annotations.JsonSerializable$Case KEBAB_CASE`
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable_Case? get KEBAB_CASE =>
      _id_KEBAB_CASE.get(_class, const $JsonSerializable_Case$Type());

  static final _id_CAMEL_CASE = _class.staticFieldId(
    r'CAMEL_CASE',
    r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.annotations.JsonSerializable$Case CAMEL_CASE`
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable_Case? get CAMEL_CASE =>
      _id_CAMEL_CASE.get(_class, const $JsonSerializable_Case$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _values = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.annotations.JsonSerializable$Case[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JArray<JsonSerializable_Case?>? values() {
    return _values(_class.reference.pointer, _id_values as _$jni.JMethodIDPtr)
        .object(const _$jni.JArrayType($JsonSerializable_Case$Type()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _valueOf = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.annotations.JsonSerializable$Case valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable_Case? valueOf(
    _$jni.JString? string,
  ) {
    final _string = string?.reference;
    return _valueOf(_class.reference.pointer, _id_valueOf as _$jni.JMethodIDPtr,
            _string?.pointer ?? _$jni.nullptr)
        .object(const $JsonSerializable_Case$Type());
  }
}

final class $JsonSerializable_Case$Type
    extends _$jni.JObjType<JsonSerializable_Case> {
  @_$jni.internal
  const $JsonSerializable_Case$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;';

  @_$jni.internal
  @_$core.override
  JsonSerializable_Case fromReference(_$jni.JReference reference) =>
      JsonSerializable_Case.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($JsonSerializable_Case$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JsonSerializable_Case$Type) &&
        other is $JsonSerializable_Case$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.JsonSerializable`
class JsonSerializable extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<JsonSerializable> $type;

  @_$jni.internal
  JsonSerializable.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/JsonSerializable');

  /// The type which includes information such as the signature of this class.
  static const type = $JsonSerializable$Type();
  static final _id_value = _class.instanceMethodId(
    r'value',
    r'()Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _value = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public abstract com.github.dart_lang.jnigen.annotations.JsonSerializable$Case value()`
  /// The returned object must be released after use, by calling the [release] method.
  JsonSerializable_Case? value() {
    return _value(reference.pointer, _id_value as _$jni.JMethodIDPtr)
        .object(const $JsonSerializable_Case$Type());
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $JsonSerializable> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'value()Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;') {
        final $r = _$impls[$p]!.value();
        return ($r as _$jni.JObject)
            .as(const _$jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $JsonSerializable $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.annotations.JsonSerializable',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory JsonSerializable.implement(
    $JsonSerializable $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return JsonSerializable.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $JsonSerializable {
  factory $JsonSerializable({
    required JsonSerializable_Case? Function() value,
  }) = _$JsonSerializable;

  JsonSerializable_Case? value();
}

final class _$JsonSerializable with $JsonSerializable {
  _$JsonSerializable({
    required JsonSerializable_Case? Function() value,
  }) : _value = value;

  final JsonSerializable_Case? Function() _value;

  JsonSerializable_Case? value() {
    return _value();
  }
}

final class $JsonSerializable$Type extends _$jni.JObjType<JsonSerializable> {
  @_$jni.internal
  const $JsonSerializable$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable;';

  @_$jni.internal
  @_$core.override
  JsonSerializable fromReference(_$jni.JReference reference) =>
      JsonSerializable.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($JsonSerializable$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JsonSerializable$Type) &&
        other is $JsonSerializable$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.MyDataClass`
class MyDataClass extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MyDataClass> $type;

  @_$jni.internal
  MyDataClass.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/MyDataClass');

  /// The type which includes information such as the signature of this class.
  static const type = $MyDataClass$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyDataClass() {
    return MyDataClass.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $MyDataClass$Type extends _$jni.JObjType<MyDataClass> {
  @_$jni.internal
  const $MyDataClass$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/MyDataClass;';

  @_$jni.internal
  @_$core.override
  MyDataClass fromReference(_$jni.JReference reference) =>
      MyDataClass.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MyDataClass$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyDataClass$Type) &&
        other is $MyDataClass$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.NotNull`
class NotNull extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<NotNull> $type;

  @_$jni.internal
  NotNull.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'com/github/dart_lang/jnigen/annotations/NotNull');

  /// The type which includes information such as the signature of this class.
  static const type = $NotNull$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $NotNull> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $NotNull $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.annotations.NotNull',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory NotNull.implement(
    $NotNull $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return NotNull.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $NotNull {
  factory $NotNull() = _$NotNull;
}

final class _$NotNull with $NotNull {
  _$NotNull();
}

final class $NotNull$Type extends _$jni.JObjType<NotNull> {
  @_$jni.internal
  const $NotNull$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/github/dart_lang/jnigen/annotations/NotNull;';

  @_$jni.internal
  @_$core.override
  NotNull fromReference(_$jni.JReference reference) =>
      NotNull.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($NotNull$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NotNull$Type) && other is $NotNull$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.Nullable`
class Nullable extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Nullable> $type;

  @_$jni.internal
  Nullable.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'com/github/dart_lang/jnigen/annotations/Nullable');

  /// The type which includes information such as the signature of this class.
  static const type = $Nullable$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $Nullable> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $Nullable $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.annotations.Nullable',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Nullable.implement(
    $Nullable $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return Nullable.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Nullable {
  factory $Nullable() = _$Nullable;
}

final class _$Nullable with $Nullable {
  _$Nullable();
}

final class $Nullable$Type extends _$jni.JObjType<Nullable> {
  @_$jni.internal
  const $Nullable$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/github/dart_lang/jnigen/annotations/Nullable;';

  @_$jni.internal
  @_$core.override
  Nullable fromReference(_$jni.JReference reference) =>
      Nullable.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Nullable$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Nullable$Type) && other is $Nullable$Type;
  }
}
