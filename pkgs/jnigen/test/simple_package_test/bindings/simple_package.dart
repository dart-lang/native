// Copyright (c) 2022, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as _$core;

import 'package:jni/_internal.dart' as _$jni;
import 'package:jni/jni.dart' as _$jni;

/// from: `com.github.dart_lang.jnigen.simple_package.Color`
class Color extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Color> $type;

  @_$jni.internal
  Color.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'com/github/dart_lang/jnigen/simple_package/Color');

  /// The type which includes information such as the signature of this class.
  static const type = $Color$Type();
  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lcom/github/dart_lang/jnigen/simple_package/Color;',
  );

  static final _values = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.simple_package.Color[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JArray<Color> values() {
    return _values(_class.reference.pointer, _id_values as _$jni.JMethodIDPtr)
        .object(const _$jni.JArrayType($Color$Type()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lcom/github/dart_lang/jnigen/simple_package/Color;',
  );

  static final _valueOf = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.simple_package.Color valueOf(java.lang.String name)`
  /// The returned object must be released after use, by calling the [release] method.
  static Color valueOf(
    _$jni.JString name,
  ) {
    return _valueOf(_class.reference.pointer, _id_valueOf as _$jni.JMethodIDPtr,
            name.reference.pointer)
        .object(const $Color$Type());
  }
}

final class $Color$Type extends _$jni.JObjType<Color> {
  @_$jni.internal
  const $Color$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/github/dart_lang/jnigen/simple_package/Color;';

  @_$jni.internal
  @_$core.override
  Color fromReference(_$jni.JReference reference) =>
      Color.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Color$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Color$Type) && other is $Color$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Example$Nested$NestedTwice`
class Example_Nested_NestedTwice extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Example_Nested_NestedTwice> $type;

  @_$jni.internal
  Example_Nested_NestedTwice.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example$Nested$NestedTwice');

  /// The type which includes information such as the signature of this class.
  static const type = $Example_Nested_NestedTwice$Type();
  static final _id_ZERO = _class.staticFieldId(
    r'ZERO',
    r'I',
  );

  /// from: `static public int ZERO`
  static int get ZERO => _id_ZERO.get(_class, const _$jni.jintType());

  /// from: `static public int ZERO`
  static set ZERO(int value) =>
      _id_ZERO.set(_class, const _$jni.jintType(), value);

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example_Nested_NestedTwice() {
    return Example_Nested_NestedTwice.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $Example_Nested_NestedTwice$Type
    extends _$jni.JObjType<Example_Nested_NestedTwice> {
  @_$jni.internal
  const $Example_Nested_NestedTwice$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$Nested$NestedTwice;';

  @_$jni.internal
  @_$core.override
  Example_Nested_NestedTwice fromReference(_$jni.JReference reference) =>
      Example_Nested_NestedTwice.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Example_Nested_NestedTwice$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example_Nested_NestedTwice$Type) &&
        other is $Example_Nested_NestedTwice$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Example$Nested`
class Example_Nested extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Example_Nested> $type;

  @_$jni.internal
  Example_Nested.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example$Nested');

  /// The type which includes information such as the signature of this class.
  static const type = $Example_Nested$Type();
  static final _id_new$ = _class.constructorId(
    r'(Z)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void <init>(boolean value)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example_Nested(
    bool value,
  ) {
    return Example_Nested.fromReference(_new$(_class.reference.pointer,
            _id_new$ as _$jni.JMethodIDPtr, value ? 1 : 0)
        .reference);
  }

  static final _id_usesAnonymousInnerClass = _class.instanceMethodId(
    r'usesAnonymousInnerClass',
    r'()V',
  );

  static final _usesAnonymousInnerClass = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void usesAnonymousInnerClass()`
  void usesAnonymousInnerClass() {
    _usesAnonymousInnerClass(reference.pointer,
            _id_usesAnonymousInnerClass as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_getValue = _class.instanceMethodId(
    r'getValue',
    r'()Z',
  );

  static final _getValue = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getValue()`
  bool getValue() {
    return _getValue(reference.pointer, _id_getValue as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setValue = _class.instanceMethodId(
    r'setValue',
    r'(Z)V',
  );

  static final _setValue = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void setValue(boolean value)`
  void setValue(
    bool value,
  ) {
    _setValue(reference.pointer, _id_setValue as _$jni.JMethodIDPtr,
            value ? 1 : 0)
        .check();
  }
}

final class $Example_Nested$Type extends _$jni.JObjType<Example_Nested> {
  @_$jni.internal
  const $Example_Nested$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;';

  @_$jni.internal
  @_$core.override
  Example_Nested fromReference(_$jni.JReference reference) =>
      Example_Nested.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Example_Nested$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example_Nested$Type) &&
        other is $Example_Nested$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Example$NonStaticNested`
class Example_NonStaticNested extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Example_NonStaticNested> $type;

  @_$jni.internal
  Example_NonStaticNested.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example$NonStaticNested');

  /// The type which includes information such as the signature of this class.
  static const type = $Example_NonStaticNested$Type();
  static final _id_ok = _class.instanceFieldId(
    r'ok',
    r'Z',
  );

  /// from: `public boolean ok`
  bool get ok => _id_ok.get(this, const _$jni.jbooleanType());

  /// from: `public boolean ok`
  set ok(bool value) => _id_ok.set(this, const _$jni.jbooleanType(), value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/simple_package/Example;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.simple_package.Example $parent)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example_NonStaticNested(
    Example $parent,
  ) {
    return Example_NonStaticNested.fromReference(_new$(_class.reference.pointer,
            _id_new$ as _$jni.JMethodIDPtr, $parent.reference.pointer)
        .reference);
  }
}

final class $Example_NonStaticNested$Type
    extends _$jni.JObjType<Example_NonStaticNested> {
  @_$jni.internal
  const $Example_NonStaticNested$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$NonStaticNested;';

  @_$jni.internal
  @_$core.override
  Example_NonStaticNested fromReference(_$jni.JReference reference) =>
      Example_NonStaticNested.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Example_NonStaticNested$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example_NonStaticNested$Type) &&
        other is $Example_NonStaticNested$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Example`
class Example extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Example> $type;

  @_$jni.internal
  Example.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example');

  /// The type which includes information such as the signature of this class.
  static const type = $Example$Type();

  /// from: `static public final int ON`
  static const ON = 1;

  /// from: `static public final int OFF`
  static const OFF = 0;

  /// from: `static public final double PI`
  static const PI = 3.14159;

  /// from: `static public final char SEMICOLON`
  static const SEMICOLON = 59;
  static final _id_SEMICOLON_STRING = _class.staticFieldId(
    r'SEMICOLON_STRING',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SEMICOLON_STRING`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get SEMICOLON_STRING =>
      _id_SEMICOLON_STRING.get(_class, const _$jni.JStringType());

  static final _id_unusedRandom = _class.staticFieldId(
    r'unusedRandom',
    r'Ljava/util/Random;',
  );

  /// from: `static public final java.util.Random unusedRandom`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JObject get unusedRandom =>
      _id_unusedRandom.get(_class, const _$jni.JObjectType());

  static final _id_getAmount = _class.staticMethodId(
    r'getAmount',
    r'()I',
  );

  static final _getAmount = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public int getAmount()`
  static int getAmount() {
    return _getAmount(
            _class.reference.pointer, _id_getAmount as _$jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getPi = _class.staticMethodId(
    r'getPi',
    r'()D',
  );

  static final _getPi = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticDoubleMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public double getPi()`
  static double getPi() {
    return _getPi(_class.reference.pointer, _id_getPi as _$jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getAsterisk = _class.staticMethodId(
    r'getAsterisk',
    r'()C',
  );

  static final _getAsterisk = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticCharMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public char getAsterisk()`
  static int getAsterisk() {
    return _getAsterisk(
            _class.reference.pointer, _id_getAsterisk as _$jni.JMethodIDPtr)
        .char;
  }

  static final _id_getName = _class.staticMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString getName() {
    return _getName(_class.reference.pointer, _id_getName as _$jni.JMethodIDPtr)
        .object(const _$jni.JStringType());
  }

  static final _id_getNestedInstance = _class.staticMethodId(
    r'getNestedInstance',
    r'()Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;',
  );

  static final _getNestedInstance = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.simple_package.Example.Nested getNestedInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static Example_Nested getNestedInstance() {
    return _getNestedInstance(_class.reference.pointer,
            _id_getNestedInstance as _$jni.JMethodIDPtr)
        .object(const $Example_Nested$Type());
  }

  static final _id_setAmount = _class.staticMethodId(
    r'setAmount',
    r'(I)V',
  );

  static final _setAmount = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Int32,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `static public void setAmount(int newAmount)`
  static void setAmount(
    int newAmount,
  ) {
    _setAmount(_class.reference.pointer, _id_setAmount as _$jni.JMethodIDPtr,
            newAmount)
        .check();
  }

  static final _id_setName = _class.staticMethodId(
    r'setName',
    r'(Ljava/lang/String;)V',
  );

  static final _setName = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public void setName(java.lang.String newName)`
  static void setName(
    _$jni.JString newName,
  ) {
    _setName(_class.reference.pointer, _id_setName as _$jni.JMethodIDPtr,
            newName.reference.pointer)
        .check();
  }

  static final _id_setNestedInstance = _class.staticMethodId(
    r'setNestedInstance',
    r'(Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;)V',
  );

  static final _setNestedInstance = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public void setNestedInstance(com.github.dart_lang.jnigen.simple_package.Example.Nested newNested)`
  static void setNestedInstance(
    Example_Nested newNested,
  ) {
    _setNestedInstance(
            _class.reference.pointer,
            _id_setNestedInstance as _$jni.JMethodIDPtr,
            newNested.reference.pointer)
        .check();
  }

  static final _id_max4 = _class.staticMethodId(
    r'max4',
    r'(IIII)I',
  );

  static final _max4 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32
                      )>)>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, int, int, int, int)>();

  /// from: `static public int max4(int a, int b, int c, int d)`
  static int max4(
    int a,
    int b,
    int c,
    int d,
  ) {
    return _max4(_class.reference.pointer, _id_max4 as _$jni.JMethodIDPtr, a, b,
            c, d)
        .integer;
  }

  static final _id_max8 = _class.staticMethodId(
    r'max8',
    r'(IIIIIIII)I',
  );

  static final _max8 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32
                      )>)>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, int, int, int, int, int, int, int, int)>();

  /// from: `static public int max8(int a, int b, int c, int d, int e, int f, int g, int h)`
  static int max8(
    int a,
    int b,
    int c,
    int d,
    int e,
    int f,
    int g,
    int h,
  ) {
    return _max8(_class.reference.pointer, _id_max8 as _$jni.JMethodIDPtr, a, b,
            c, d, e, f, g, h)
        .integer;
  }

  static final _id_getNumber = _class.instanceMethodId(
    r'getNumber',
    r'()I',
  );

  static final _getNumber = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int getNumber()`
  int getNumber() {
    return _getNumber(reference.pointer, _id_getNumber as _$jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setNumber = _class.instanceMethodId(
    r'setNumber',
    r'(I)V',
  );

  static final _setNumber = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void setNumber(int number)`
  void setNumber(
    int number,
  ) {
    _setNumber(reference.pointer, _id_setNumber as _$jni.JMethodIDPtr, number)
        .check();
  }

  static final _id_getIsUp = _class.instanceMethodId(
    r'getIsUp',
    r'()Z',
  );

  static final _getIsUp = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getIsUp()`
  bool getIsUp() {
    return _getIsUp(reference.pointer, _id_getIsUp as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setUp = _class.instanceMethodId(
    r'setUp',
    r'(Z)V',
  );

  static final _setUp = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void setUp(boolean isUp)`
  void setUp(
    bool isUp,
  ) {
    _setUp(reference.pointer, _id_setUp as _$jni.JMethodIDPtr, isUp ? 1 : 0)
        .check();
  }

  static final _id_getCodename = _class.instanceMethodId(
    r'getCodename',
    r'()Ljava/lang/String;',
  );

  static final _getCodename = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getCodename()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JString getCodename() {
    return _getCodename(
            reference.pointer, _id_getCodename as _$jni.JMethodIDPtr)
        .object(const _$jni.JStringType());
  }

  static final _id_setCodename = _class.instanceMethodId(
    r'setCodename',
    r'(Ljava/lang/String;)V',
  );

  static final _setCodename = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setCodename(java.lang.String codename)`
  void setCodename(
    _$jni.JString codename,
  ) {
    _setCodename(reference.pointer, _id_setCodename as _$jni.JMethodIDPtr,
            codename.reference.pointer)
        .check();
  }

  static final _id_getRandom = _class.instanceMethodId(
    r'getRandom',
    r'()Ljava/util/Random;',
  );

  static final _getRandom = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.Random getRandom()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject getRandom() {
    return _getRandom(reference.pointer, _id_getRandom as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_setRandom = _class.instanceMethodId(
    r'setRandom',
    r'(Ljava/util/Random;)V',
  );

  static final _setRandom = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setRandom(java.util.Random random)`
  void setRandom(
    _$jni.JObject random,
  ) {
    _setRandom(reference.pointer, _id_setRandom as _$jni.JMethodIDPtr,
            random.reference.pointer)
        .check();
  }

  static final _id_getRandomLong = _class.instanceMethodId(
    r'getRandomLong',
    r'()J',
  );

  static final _getRandomLong = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public long getRandomLong()`
  int getRandomLong() {
    return _getRandomLong(
            reference.pointer, _id_getRandomLong as _$jni.JMethodIDPtr)
        .long;
  }

  static final _id_add4Longs = _class.instanceMethodId(
    r'add4Longs',
    r'(JJJJ)J',
  );

  static final _add4Longs = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Int64,
                        _$jni.Int64,
                        _$jni.Int64,
                        _$jni.Int64
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, int, int, int, int)>();

  /// from: `public long add4Longs(long a, long b, long c, long d)`
  int add4Longs(
    int a,
    int b,
    int c,
    int d,
  ) {
    return _add4Longs(
            reference.pointer, _id_add4Longs as _$jni.JMethodIDPtr, a, b, c, d)
        .long;
  }

  static final _id_add8Longs = _class.instanceMethodId(
    r'add8Longs',
    r'(JJJJJJJJ)J',
  );

  static final _add8Longs = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Int64,
                        _$jni.Int64,
                        _$jni.Int64,
                        _$jni.Int64,
                        _$jni.Int64,
                        _$jni.Int64,
                        _$jni.Int64,
                        _$jni.Int64
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, int, int, int, int, int, int, int, int)>();

  /// from: `public long add8Longs(long a, long b, long c, long d, long e, long f, long g, long h)`
  int add8Longs(
    int a,
    int b,
    int c,
    int d,
    int e,
    int f,
    int g,
    int h,
  ) {
    return _add8Longs(reference.pointer, _id_add8Longs as _$jni.JMethodIDPtr, a,
            b, c, d, e, f, g, h)
        .long;
  }

  static final _id_getRandomNumericString = _class.instanceMethodId(
    r'getRandomNumericString',
    r'(Ljava/util/Random;)Ljava/lang/String;',
  );

  static final _getRandomNumericString = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public java.lang.String getRandomNumericString(java.util.Random random)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JString getRandomNumericString(
    _$jni.JObject random,
  ) {
    return _getRandomNumericString(
            reference.pointer,
            _id_getRandomNumericString as _$jni.JMethodIDPtr,
            random.reference.pointer)
        .object(const _$jni.JStringType());
  }

  static final _id_finalMethod = _class.instanceMethodId(
    r'finalMethod',
    r'()V',
  );

  static final _finalMethod = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public final void finalMethod()`
  void finalMethod() {
    _finalMethod(reference.pointer, _id_finalMethod as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JString> getList() {
    return _getList(reference.pointer, _id_getList as _$jni.JMethodIDPtr)
        .object(const _$jni.JListType(_$jni.JStringType()));
  }

  static final _id_joinStrings = _class.instanceMethodId(
    r'joinStrings',
    r'(Ljava/util/List;Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _joinStrings = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public java.lang.String joinStrings(java.util.List<java.lang.String> values, java.lang.String delim)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Joins the strings in the list using the given delimiter.
  _$jni.JString joinStrings(
    _$jni.JList<_$jni.JString> values,
    _$jni.JString delim,
  ) {
    return _joinStrings(
            reference.pointer,
            _id_joinStrings as _$jni.JMethodIDPtr,
            values.reference.pointer,
            delim.reference.pointer)
        .object(const _$jni.JStringType());
  }

  static final _id_methodWithSeveralParams = _class.instanceMethodId(
    r'methodWithSeveralParams',
    r'(CLjava/lang/String;[ILjava/lang/CharSequence;Ljava/util/List;Ljava/util/Map;)V',
  );

  static final _methodWithSeveralParams = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Int32,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              int,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void methodWithSeveralParams(char ch, java.lang.String s, int[] a, T t, java.util.List<T> lt, java.util.Map<java.lang.String,? extends java.lang.CharSequence> wm)`
  void methodWithSeveralParams<$T extends _$jni.JObject>(
    int ch,
    _$jni.JString s,
    _$jni.JArray<_$jni.jint> a,
    $T t,
    _$jni.JList<$T> lt,
    _$jni.JMap<_$jni.JString, _$jni.JObject> wm, {
    _$jni.JObjType<$T>? T,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      (lt.$type as _$jni.JListType).E,
      t.$type,
    ]) as _$jni.JObjType<$T>;
    _methodWithSeveralParams(
            reference.pointer,
            _id_methodWithSeveralParams as _$jni.JMethodIDPtr,
            ch,
            s.reference.pointer,
            a.reference.pointer,
            t.reference.pointer,
            lt.reference.pointer,
            wm.reference.pointer)
        .check();
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example() {
    return Example.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(I)V',
  );

  static final _new$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void <init>(int number)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new$1(
    int number,
  ) {
    return Example.fromReference(_new$1(
            _class.reference.pointer, _id_new$1 as _$jni.JMethodIDPtr, number)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(IZ)V',
  );

  static final _new$2 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Int32, _$jni.Int32)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int, int)>();

  /// from: `public void <init>(int number, boolean isUp)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new$2(
    int number,
    bool isUp,
  ) {
    return Example.fromReference(_new$2(_class.reference.pointer,
            _id_new$2 as _$jni.JMethodIDPtr, number, isUp ? 1 : 0)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(IZLjava/lang/String;)V',
  );

  static final _new$3 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, int, int, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(int number, boolean isUp, java.lang.String codename)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new$3(
    int number,
    bool isUp,
    _$jni.JString codename,
  ) {
    return Example.fromReference(_new$3(
            _class.reference.pointer,
            _id_new$3 as _$jni.JMethodIDPtr,
            number,
            isUp ? 1 : 0,
            codename.reference.pointer)
        .reference);
  }

  static final _id_new$4 = _class.constructorId(
    r'(IIIIIIII)V',
  );

  static final _new$4 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, int, int, int, int, int, int, int, int)>();

  /// from: `public void <init>(int a, int b, int c, int d, int e, int f, int g, int h)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new$4(
    int a,
    int b,
    int c,
    int d,
    int e,
    int f,
    int g,
    int h,
  ) {
    return Example.fromReference(_new$4(_class.reference.pointer,
            _id_new$4 as _$jni.JMethodIDPtr, a, b, c, d, e, f, g, h)
        .reference);
  }

  static final _id_whichExample = _class.instanceMethodId(
    r'whichExample',
    r'()I',
  );

  static final _whichExample = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int whichExample()`
  int whichExample() {
    return _whichExample(
            reference.pointer, _id_whichExample as _$jni.JMethodIDPtr)
        .integer;
  }

  static final _id_addInts = _class.staticMethodId(
    r'addInts',
    r'(II)I',
  );

  static final _addInts = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Int32, _$jni.Int32)>)>>(
          'globalEnv_CallStaticIntMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int, int)>();

  /// from: `static public int addInts(int a, int b)`
  static int addInts(
    int a,
    int b,
  ) {
    return _addInts(
            _class.reference.pointer, _id_addInts as _$jni.JMethodIDPtr, a, b)
        .integer;
  }

  static final _id_getArr = _class.staticMethodId(
    r'getArr',
    r'()[I',
  );

  static final _getArr = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public int[] getArr()`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JArray<_$jni.jint> getArr() {
    return _getArr(_class.reference.pointer, _id_getArr as _$jni.JMethodIDPtr)
        .object(const _$jni.JArrayType(_$jni.jintType()));
  }

  static final _id_addAll = _class.staticMethodId(
    r'addAll',
    r'([I)I',
  );

  static final _addAll = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticIntMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public int addAll(int[] arr)`
  static int addAll(
    _$jni.JArray<_$jni.jint> arr,
  ) {
    return _addAll(_class.reference.pointer, _id_addAll as _$jni.JMethodIDPtr,
            arr.reference.pointer)
        .integer;
  }

  static final _id_getSelf = _class.instanceMethodId(
    r'getSelf',
    r'()Lcom/github/dart_lang/jnigen/simple_package/Example;',
  );

  static final _getSelf = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.simple_package.Example getSelf()`
  /// The returned object must be released after use, by calling the [release] method.
  Example getSelf() {
    return _getSelf(reference.pointer, _id_getSelf as _$jni.JMethodIDPtr)
        .object(const $Example$Type());
  }

  static final _id_throwException = _class.staticMethodId(
    r'throwException',
    r'()V',
  );

  static final _throwException = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public void throwException()`
  static void throwException() {
    _throwException(
            _class.reference.pointer, _id_throwException as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_overloaded = _class.instanceMethodId(
    r'overloaded',
    r'()V',
  );

  static final _overloaded = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void overloaded()`
  void overloaded() {
    _overloaded(reference.pointer, _id_overloaded as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_overloaded$1 = _class.instanceMethodId(
    r'overloaded',
    r'(ILjava/lang/String;)V',
  );

  static final _overloaded$1 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni
                          .VarArgs<(_$jni.Int32, _$jni.Pointer<_$jni.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, int, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void overloaded(int a, java.lang.String b)`
  void overloaded$1(
    int a,
    _$jni.JString b,
  ) {
    _overloaded$1(reference.pointer, _id_overloaded$1 as _$jni.JMethodIDPtr, a,
            b.reference.pointer)
        .check();
  }

  static final _id_overloaded$2 = _class.instanceMethodId(
    r'overloaded',
    r'(I)V',
  );

  static final _overloaded$2 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void overloaded(int a)`
  void overloaded$2(
    int a,
  ) {
    _overloaded$2(reference.pointer, _id_overloaded$2 as _$jni.JMethodIDPtr, a)
        .check();
  }

  static final _id_overloaded$3 = _class.instanceMethodId(
    r'overloaded',
    r'(Ljava/util/List;Ljava/lang/String;)V',
  );

  static final _overloaded$3 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void overloaded(java.util.List<java.lang.Integer> a, java.lang.String b)`
  void overloaded$3(
    _$jni.JList<_$jni.JInteger> a,
    _$jni.JString b,
  ) {
    _overloaded$3(reference.pointer, _id_overloaded$3 as _$jni.JMethodIDPtr,
            a.reference.pointer, b.reference.pointer)
        .check();
  }

  static final _id_overloaded$4 = _class.instanceMethodId(
    r'overloaded',
    r'(Ljava/util/List;)V',
  );

  static final _overloaded$4 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void overloaded(java.util.List<java.lang.Integer> a)`
  void overloaded$4(
    _$jni.JList<_$jni.JInteger> a,
  ) {
    _overloaded$4(reference.pointer, _id_overloaded$4 as _$jni.JMethodIDPtr,
            a.reference.pointer)
        .check();
  }
}

final class $Example$Type extends _$jni.JObjType<Example> {
  @_$jni.internal
  const $Example$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example;';

  @_$jni.internal
  @_$core.override
  Example fromReference(_$jni.JReference reference) =>
      Example.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Example$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Type) && other is $Example$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Exceptions`
class Exceptions extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Exceptions> $type;

  @_$jni.internal
  Exceptions.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Exceptions');

  /// The type which includes information such as the signature of this class.
  static const type = $Exceptions$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions() {
    return Exceptions.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(F)V',
  );

  static final _new$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Double,)>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, double)>();

  /// from: `public void <init>(float x)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions.new$1(
    double x,
  ) {
    return Exceptions.fromReference(
        _new$1(_class.reference.pointer, _id_new$1 as _$jni.JMethodIDPtr, x)
            .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(IIIIII)V',
  );

  static final _new$2 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, int, int, int, int, int, int)>();

  /// from: `public void <init>(int a, int b, int c, int d, int e, int f)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions.new$2(
    int a,
    int b,
    int c,
    int d,
    int e,
    int f,
  ) {
    return Exceptions.fromReference(_new$2(_class.reference.pointer,
            _id_new$2 as _$jni.JMethodIDPtr, a, b, c, d, e, f)
        .reference);
  }

  static final _id_staticObjectMethod = _class.staticMethodId(
    r'staticObjectMethod',
    r'()Ljava/lang/Object;',
  );

  static final _staticObjectMethod = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.Object staticObjectMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JObject staticObjectMethod() {
    return _staticObjectMethod(_class.reference.pointer,
            _id_staticObjectMethod as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_staticIntMethod = _class.staticMethodId(
    r'staticIntMethod',
    r'()I',
  );

  static final _staticIntMethod = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public int staticIntMethod()`
  static int staticIntMethod() {
    return _staticIntMethod(
            _class.reference.pointer, _id_staticIntMethod as _$jni.JMethodIDPtr)
        .integer;
  }

  static final _id_staticObjectArrayMethod = _class.staticMethodId(
    r'staticObjectArrayMethod',
    r'()[Ljava/lang/Object;',
  );

  static final _staticObjectArrayMethod = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.Object[] staticObjectArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JArray<_$jni.JObject> staticObjectArrayMethod() {
    return _staticObjectArrayMethod(_class.reference.pointer,
            _id_staticObjectArrayMethod as _$jni.JMethodIDPtr)
        .object(const _$jni.JArrayType(_$jni.JObjectType()));
  }

  static final _id_staticIntArrayMethod = _class.staticMethodId(
    r'staticIntArrayMethod',
    r'()[I',
  );

  static final _staticIntArrayMethod = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public int[] staticIntArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JArray<_$jni.jint> staticIntArrayMethod() {
    return _staticIntArrayMethod(_class.reference.pointer,
            _id_staticIntArrayMethod as _$jni.JMethodIDPtr)
        .object(const _$jni.JArrayType(_$jni.jintType()));
  }

  static final _id_objectMethod = _class.instanceMethodId(
    r'objectMethod',
    r'()Ljava/lang/Object;',
  );

  static final _objectMethod = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object objectMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject objectMethod() {
    return _objectMethod(
            reference.pointer, _id_objectMethod as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_intMethod = _class.instanceMethodId(
    r'intMethod',
    r'()I',
  );

  static final _intMethod = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int intMethod()`
  int intMethod() {
    return _intMethod(reference.pointer, _id_intMethod as _$jni.JMethodIDPtr)
        .integer;
  }

  static final _id_objectArrayMethod = _class.instanceMethodId(
    r'objectArrayMethod',
    r'()[Ljava/lang/Object;',
  );

  static final _objectArrayMethod = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object[] objectArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JArray<_$jni.JObject> objectArrayMethod() {
    return _objectArrayMethod(
            reference.pointer, _id_objectArrayMethod as _$jni.JMethodIDPtr)
        .object(const _$jni.JArrayType(_$jni.JObjectType()));
  }

  static final _id_intArrayMethod = _class.instanceMethodId(
    r'intArrayMethod',
    r'()[I',
  );

  static final _intArrayMethod = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int[] intArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JArray<_$jni.jint> intArrayMethod() {
    return _intArrayMethod(
            reference.pointer, _id_intArrayMethod as _$jni.JMethodIDPtr)
        .object(const _$jni.JArrayType(_$jni.jintType()));
  }

  static final _id_throwNullPointerException = _class.instanceMethodId(
    r'throwNullPointerException',
    r'()I',
  );

  static final _throwNullPointerException = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int throwNullPointerException()`
  int throwNullPointerException() {
    return _throwNullPointerException(reference.pointer,
            _id_throwNullPointerException as _$jni.JMethodIDPtr)
        .integer;
  }

  static final _id_throwFileNotFoundException = _class.instanceMethodId(
    r'throwFileNotFoundException',
    r'()Ljava/io/InputStream;',
  );

  static final _throwFileNotFoundException =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public java.io.InputStream throwFileNotFoundException()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject throwFileNotFoundException() {
    return _throwFileNotFoundException(reference.pointer,
            _id_throwFileNotFoundException as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_throwClassCastException = _class.instanceMethodId(
    r'throwClassCastException',
    r'()Ljava/io/FileInputStream;',
  );

  static final _throwClassCastException = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.io.FileInputStream throwClassCastException()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject throwClassCastException() {
    return _throwClassCastException(reference.pointer,
            _id_throwClassCastException as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_throwArrayIndexException = _class.instanceMethodId(
    r'throwArrayIndexException',
    r'()I',
  );

  static final _throwArrayIndexException = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int throwArrayIndexException()`
  int throwArrayIndexException() {
    return _throwArrayIndexException(reference.pointer,
            _id_throwArrayIndexException as _$jni.JMethodIDPtr)
        .integer;
  }

  static final _id_throwArithmeticException = _class.instanceMethodId(
    r'throwArithmeticException',
    r'()I',
  );

  static final _throwArithmeticException = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int throwArithmeticException()`
  int throwArithmeticException() {
    return _throwArithmeticException(reference.pointer,
            _id_throwArithmeticException as _$jni.JMethodIDPtr)
        .integer;
  }

  static final _id_throwLoremIpsum = _class.staticMethodId(
    r'throwLoremIpsum',
    r'()V',
  );

  static final _throwLoremIpsum = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public void throwLoremIpsum()`
  static void throwLoremIpsum() {
    _throwLoremIpsum(
            _class.reference.pointer, _id_throwLoremIpsum as _$jni.JMethodIDPtr)
        .check();
  }
}

final class $Exceptions$Type extends _$jni.JObjType<Exceptions> {
  @_$jni.internal
  const $Exceptions$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Exceptions;';

  @_$jni.internal
  @_$core.override
  Exceptions fromReference(_$jni.JReference reference) =>
      Exceptions.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Exceptions$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Exceptions$Type) && other is $Exceptions$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Fields$Nested`
class Fields_Nested extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Fields_Nested> $type;

  @_$jni.internal
  Fields_Nested.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Fields$Nested');

  /// The type which includes information such as the signature of this class.
  static const type = $Fields_Nested$Type();
  static final _id_hundred = _class.instanceFieldId(
    r'hundred',
    r'J',
  );

  /// from: `public long hundred`
  int get hundred => _id_hundred.get(this, const _$jni.jlongType());

  /// from: `public long hundred`
  set hundred(int value) =>
      _id_hundred.set(this, const _$jni.jlongType(), value);

  static final _id_BEST_GOD = _class.staticFieldId(
    r'BEST_GOD',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String BEST_GOD`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get BEST_GOD =>
      _id_BEST_GOD.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String BEST_GOD`
  /// The returned object must be released after use, by calling the [release] method.
  static set BEST_GOD(_$jni.JString value) =>
      _id_BEST_GOD.set(_class, const _$jni.JStringType(), value);

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Fields_Nested() {
    return Fields_Nested.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $Fields_Nested$Type extends _$jni.JObjType<Fields_Nested> {
  @_$jni.internal
  const $Fields_Nested$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Fields$Nested;';

  @_$jni.internal
  @_$core.override
  Fields_Nested fromReference(_$jni.JReference reference) =>
      Fields_Nested.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Fields_Nested$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Fields_Nested$Type) &&
        other is $Fields_Nested$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Fields`
class Fields extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Fields> $type;

  @_$jni.internal
  Fields.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Fields');

  /// The type which includes information such as the signature of this class.
  static const type = $Fields$Type();
  static final _id_amount = _class.staticFieldId(
    r'amount',
    r'I',
  );

  /// from: `static public int amount`
  static int get amount => _id_amount.get(_class, const _$jni.jintType());

  /// from: `static public int amount`
  static set amount(int value) =>
      _id_amount.set(_class, const _$jni.jintType(), value);

  static final _id_pi = _class.staticFieldId(
    r'pi',
    r'D',
  );

  /// from: `static public double pi`
  static double get pi => _id_pi.get(_class, const _$jni.jdoubleType());

  /// from: `static public double pi`
  static set pi(double value) =>
      _id_pi.set(_class, const _$jni.jdoubleType(), value);

  static final _id_asterisk = _class.staticFieldId(
    r'asterisk',
    r'C',
  );

  /// from: `static public char asterisk`
  static int get asterisk => _id_asterisk.get(_class, const _$jni.jcharType());

  /// from: `static public char asterisk`
  static set asterisk(int value) =>
      _id_asterisk.set(_class, const _$jni.jcharType(), value);

  static final _id_name = _class.staticFieldId(
    r'name',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String name`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get name =>
      _id_name.get(_class, const _$jni.JStringType());

  /// from: `static public java.lang.String name`
  /// The returned object must be released after use, by calling the [release] method.
  static set name(_$jni.JString value) =>
      _id_name.set(_class, const _$jni.JStringType(), value);

  static final _id_i = _class.instanceFieldId(
    r'i',
    r'Ljava/lang/Integer;',
  );

  /// from: `public java.lang.Integer i`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JInteger get i => _id_i.get(this, const _$jni.JIntegerType());

  /// from: `public java.lang.Integer i`
  /// The returned object must be released after use, by calling the [release] method.
  set i(_$jni.JInteger value) =>
      _id_i.set(this, const _$jni.JIntegerType(), value);

  static final _id_trillion = _class.instanceFieldId(
    r'trillion',
    r'J',
  );

  /// from: `public long trillion`
  int get trillion => _id_trillion.get(this, const _$jni.jlongType());

  /// from: `public long trillion`
  set trillion(int value) =>
      _id_trillion.set(this, const _$jni.jlongType(), value);

  static final _id_isAchillesDead = _class.instanceFieldId(
    r'isAchillesDead',
    r'Z',
  );

  /// from: `public boolean isAchillesDead`
  bool get isAchillesDead =>
      _id_isAchillesDead.get(this, const _$jni.jbooleanType());

  /// from: `public boolean isAchillesDead`
  set isAchillesDead(bool value) =>
      _id_isAchillesDead.set(this, const _$jni.jbooleanType(), value);

  static final _id_bestFighterInGreece = _class.instanceFieldId(
    r'bestFighterInGreece',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String bestFighterInGreece`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JString get bestFighterInGreece =>
      _id_bestFighterInGreece.get(this, const _$jni.JStringType());

  /// from: `public java.lang.String bestFighterInGreece`
  /// The returned object must be released after use, by calling the [release] method.
  set bestFighterInGreece(_$jni.JString value) =>
      _id_bestFighterInGreece.set(this, const _$jni.JStringType(), value);

  static final _id_random = _class.instanceFieldId(
    r'random',
    r'Ljava/util/Random;',
  );

  /// from: `public java.util.Random random`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject get random => _id_random.get(this, const _$jni.JObjectType());

  /// from: `public java.util.Random random`
  /// The returned object must be released after use, by calling the [release] method.
  set random(_$jni.JObject value) =>
      _id_random.set(this, const _$jni.JObjectType(), value);

  static final _id_euroSymbol = _class.staticFieldId(
    r'euroSymbol',
    r'C',
  );

  /// from: `static public char euroSymbol`
  static int get euroSymbol =>
      _id_euroSymbol.get(_class, const _$jni.jcharType());

  /// from: `static public char euroSymbol`
  static set euroSymbol(int value) =>
      _id_euroSymbol.set(_class, const _$jni.jcharType(), value);

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Fields() {
    return Fields.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $Fields$Type extends _$jni.JObjType<Fields> {
  @_$jni.internal
  const $Fields$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Fields;';

  @_$jni.internal
  @_$core.override
  Fields fromReference(_$jni.JReference reference) =>
      Fields.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Fields$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Fields$Type) && other is $Fields$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.pkg2.C2`
class C2 extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<C2> $type;

  @_$jni.internal
  C2.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'com/github/dart_lang/jnigen/pkg2/C2');

  /// The type which includes information such as the signature of this class.
  static const type = $C2$Type();
  static final _id_CONSTANT = _class.staticFieldId(
    r'CONSTANT',
    r'I',
  );

  /// from: `static public int CONSTANT`
  static int get CONSTANT => _id_CONSTANT.get(_class, const _$jni.jintType());

  /// from: `static public int CONSTANT`
  static set CONSTANT(int value) =>
      _id_CONSTANT.set(_class, const _$jni.jintType(), value);

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory C2() {
    return C2.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $C2$Type extends _$jni.JObjType<C2> {
  @_$jni.internal
  const $C2$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/github/dart_lang/jnigen/pkg2/C2;';

  @_$jni.internal
  @_$core.override
  C2 fromReference(_$jni.JReference reference) => C2.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($C2$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($C2$Type) && other is $C2$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.pkg2.Example`
class Example$1 extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Example$1> $type;

  @_$jni.internal
  Example$1.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'com/github/dart_lang/jnigen/pkg2/Example');

  /// The type which includes information such as the signature of this class.
  static const type = $Example$1$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example$1() {
    return Example$1.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }

  static final _id_whichExample = _class.instanceMethodId(
    r'whichExample',
    r'()I',
  );

  static final _whichExample = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int whichExample()`
  int whichExample() {
    return _whichExample(
            reference.pointer, _id_whichExample as _$jni.JMethodIDPtr)
        .integer;
  }
}

final class $Example$1$Type extends _$jni.JObjType<Example$1> {
  @_$jni.internal
  const $Example$1$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/github/dart_lang/jnigen/pkg2/Example;';

  @_$jni.internal
  @_$core.override
  Example$1 fromReference(_$jni.JReference reference) =>
      Example$1.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Example$1$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$1$Type) && other is $Example$1$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GenericTypeParams`
class GenericTypeParams<$S extends _$jni.JObject, $K extends _$jni.JObject>
    extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<GenericTypeParams<$S, $K>> $type;

  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  final _$jni.JObjType<$K> K;

  @_$jni.internal
  GenericTypeParams.fromReference(
    this.S,
    this.K,
    _$jni.JReference reference,
  )   : $type = type(S, K),
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GenericTypeParams');

  /// The type which includes information such as the signature of this class.
  static $GenericTypeParams$Type<$S, $K>
      type<$S extends _$jni.JObject, $K extends _$jni.JObject>(
    _$jni.JObjType<$S> S,
    _$jni.JObjType<$K> K,
  ) {
    return $GenericTypeParams$Type(
      S,
      K,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory GenericTypeParams({
    required _$jni.JObjType<$S> S,
    required _$jni.JObjType<$K> K,
  }) {
    return GenericTypeParams.fromReference(
        S,
        K,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $GenericTypeParams$Type<$S extends _$jni.JObject,
        $K extends _$jni.JObject>
    extends _$jni.JObjType<GenericTypeParams<$S, $K>> {
  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  final _$jni.JObjType<$K> K;

  @_$jni.internal
  const $GenericTypeParams$Type(
    this.S,
    this.K,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GenericTypeParams;';

  @_$jni.internal
  @_$core.override
  GenericTypeParams<$S, $K> fromReference(_$jni.JReference reference) =>
      GenericTypeParams.fromReference(S, K, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($GenericTypeParams$Type, S, K);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GenericTypeParams$Type<$S, $K>) &&
        other is $GenericTypeParams$Type<$S, $K> &&
        S == other.S &&
        K == other.K;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$Parent$Child`
class GrandParent_Parent_Child<$T extends _$jni.JObject,
    $S extends _$jni.JObject, $U extends _$jni.JObject> extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<GrandParent_Parent_Child<$T, $S, $U>> $type;

  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  final _$jni.JObjType<$U> U;

  @_$jni.internal
  GrandParent_Parent_Child.fromReference(
    this.T,
    this.S,
    this.U,
    _$jni.JReference reference,
  )   : $type = type(T, S, U),
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$Parent$Child');

  /// The type which includes information such as the signature of this class.
  static $GrandParent_Parent_Child$Type<$T, $S, $U> type<
      $T extends _$jni.JObject,
      $S extends _$jni.JObject,
      $U extends _$jni.JObject>(
    _$jni.JObjType<$T> T,
    _$jni.JObjType<$S> S,
    _$jni.JObjType<$U> U,
  ) {
    return $GrandParent_Parent_Child$Type(
      T,
      S,
      U,
    );
  }

  static final _id_grandParentValue = _class.instanceFieldId(
    r'grandParentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public T grandParentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $T get grandParentValue => _id_grandParentValue.get(this, T);

  /// from: `public T grandParentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set grandParentValue($T value) => _id_grandParentValue.set(this, T, value);

  static final _id_parentValue = _class.instanceFieldId(
    r'parentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $S get parentValue => _id_parentValue.get(this, S);

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($S value) => _id_parentValue.set(this, S, value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  $U get value => _id_value.get(this, U);

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($U value) => _id_value.set(this, U, value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;Ljava/lang/Object;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.GrandParent$Parent $parent, U newValue)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_Parent_Child(
    GrandParent_Parent<$T, $S> $parent,
    $U newValue, {
    _$jni.JObjType<$T>? T,
    _$jni.JObjType<$S>? S,
    _$jni.JObjType<$U>? U,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      ($parent.$type as $GrandParent_Parent$Type).T,
    ]) as _$jni.JObjType<$T>;
    S ??= _$jni.lowestCommonSuperType([
      ($parent.$type as $GrandParent_Parent$Type).S,
    ]) as _$jni.JObjType<$S>;
    U ??= _$jni.lowestCommonSuperType([
      newValue.$type,
    ]) as _$jni.JObjType<$U>;
    return GrandParent_Parent_Child.fromReference(
        T,
        S,
        U,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr,
                $parent.reference.pointer, newValue.reference.pointer)
            .reference);
  }
}

final class $GrandParent_Parent_Child$Type<$T extends _$jni.JObject,
        $S extends _$jni.JObject, $U extends _$jni.JObject>
    extends _$jni.JObjType<GrandParent_Parent_Child<$T, $S, $U>> {
  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  final _$jni.JObjType<$U> U;

  @_$jni.internal
  const $GrandParent_Parent_Child$Type(
    this.T,
    this.S,
    this.U,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent$Child;';

  @_$jni.internal
  @_$core.override
  GrandParent_Parent_Child<$T, $S, $U> fromReference(
          _$jni.JReference reference) =>
      GrandParent_Parent_Child.fromReference(T, S, U, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($GrandParent_Parent_Child$Type, T, S, U);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent_Parent_Child$Type<$T, $S, $U>) &&
        other is $GrandParent_Parent_Child$Type<$T, $S, $U> &&
        T == other.T &&
        S == other.S &&
        U == other.U;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$Parent`
class GrandParent_Parent<$T extends _$jni.JObject, $S extends _$jni.JObject>
    extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<GrandParent_Parent<$T, $S>> $type;

  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  GrandParent_Parent.fromReference(
    this.T,
    this.S,
    _$jni.JReference reference,
  )   : $type = type(T, S),
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$Parent');

  /// The type which includes information such as the signature of this class.
  static $GrandParent_Parent$Type<$T, $S>
      type<$T extends _$jni.JObject, $S extends _$jni.JObject>(
    _$jni.JObjType<$T> T,
    _$jni.JObjType<$S> S,
  ) {
    return $GrandParent_Parent$Type(
      T,
      S,
    );
  }

  static final _id_parentValue = _class.instanceFieldId(
    r'parentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public T parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $T get parentValue => _id_parentValue.get(this, T);

  /// from: `public T parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($T value) => _id_parentValue.set(this, T, value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  $S get value => _id_value.get(this, S);

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($S value) => _id_value.set(this, S, value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/GrandParent;Ljava/lang/Object;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.GrandParent $parent, S newValue)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_Parent(
    GrandParent<$T> $parent,
    $S newValue, {
    _$jni.JObjType<$T>? T,
    _$jni.JObjType<$S>? S,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      ($parent.$type as $GrandParent$Type).T,
    ]) as _$jni.JObjType<$T>;
    S ??= _$jni.lowestCommonSuperType([
      newValue.$type,
    ]) as _$jni.JObjType<$S>;
    return GrandParent_Parent.fromReference(
        T,
        S,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr,
                $parent.reference.pointer, newValue.reference.pointer)
            .reference);
  }
}

final class $GrandParent_Parent$Type<$T extends _$jni.JObject,
        $S extends _$jni.JObject>
    extends _$jni.JObjType<GrandParent_Parent<$T, $S>> {
  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  const $GrandParent_Parent$Type(
    this.T,
    this.S,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;';

  @_$jni.internal
  @_$core.override
  GrandParent_Parent<$T, $S> fromReference(_$jni.JReference reference) =>
      GrandParent_Parent.fromReference(T, S, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($GrandParent_Parent$Type, T, S);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent_Parent$Type<$T, $S>) &&
        other is $GrandParent_Parent$Type<$T, $S> &&
        T == other.T &&
        S == other.S;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$StaticParent$Child`
class GrandParent_StaticParent_Child<$S extends _$jni.JObject,
    $U extends _$jni.JObject> extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<GrandParent_StaticParent_Child<$S, $U>> $type;

  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  final _$jni.JObjType<$U> U;

  @_$jni.internal
  GrandParent_StaticParent_Child.fromReference(
    this.S,
    this.U,
    _$jni.JReference reference,
  )   : $type = type(S, U),
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child');

  /// The type which includes information such as the signature of this class.
  static $GrandParent_StaticParent_Child$Type<$S, $U>
      type<$S extends _$jni.JObject, $U extends _$jni.JObject>(
    _$jni.JObjType<$S> S,
    _$jni.JObjType<$U> U,
  ) {
    return $GrandParent_StaticParent_Child$Type(
      S,
      U,
    );
  }

  static final _id_parentValue = _class.instanceFieldId(
    r'parentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $S get parentValue => _id_parentValue.get(this, S);

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($S value) => _id_parentValue.set(this, S, value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  $U get value => _id_value.get(this, U);

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($U value) => _id_value.set(this, U, value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.GrandParent$StaticParent $parent, S parentValue, U value)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_StaticParent_Child(
    GrandParent_StaticParent<$S> $parent,
    $S parentValue,
    $U value, {
    _$jni.JObjType<$S>? S,
    _$jni.JObjType<$U>? U,
  }) {
    S ??= _$jni.lowestCommonSuperType([
      parentValue.$type,
      ($parent.$type as $GrandParent_StaticParent$Type).S,
    ]) as _$jni.JObjType<$S>;
    U ??= _$jni.lowestCommonSuperType([
      value.$type,
    ]) as _$jni.JObjType<$U>;
    return GrandParent_StaticParent_Child.fromReference(
        S,
        U,
        _new$(
                _class.reference.pointer,
                _id_new$ as _$jni.JMethodIDPtr,
                $parent.reference.pointer,
                parentValue.reference.pointer,
                value.reference.pointer)
            .reference);
  }
}

final class $GrandParent_StaticParent_Child$Type<$S extends _$jni.JObject,
        $U extends _$jni.JObject>
    extends _$jni.JObjType<GrandParent_StaticParent_Child<$S, $U>> {
  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  final _$jni.JObjType<$U> U;

  @_$jni.internal
  const $GrandParent_StaticParent_Child$Type(
    this.S,
    this.U,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child;';

  @_$jni.internal
  @_$core.override
  GrandParent_StaticParent_Child<$S, $U> fromReference(
          _$jni.JReference reference) =>
      GrandParent_StaticParent_Child.fromReference(S, U, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($GrandParent_StaticParent_Child$Type, S, U);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($GrandParent_StaticParent_Child$Type<$S, $U>) &&
        other is $GrandParent_StaticParent_Child$Type<$S, $U> &&
        S == other.S &&
        U == other.U;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$StaticParent`
class GrandParent_StaticParent<$S extends _$jni.JObject> extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<GrandParent_StaticParent<$S>> $type;

  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  GrandParent_StaticParent.fromReference(
    this.S,
    _$jni.JReference reference,
  )   : $type = type(S),
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$StaticParent');

  /// The type which includes information such as the signature of this class.
  static $GrandParent_StaticParent$Type<$S> type<$S extends _$jni.JObject>(
    _$jni.JObjType<$S> S,
  ) {
    return $GrandParent_StaticParent$Type(
      S,
    );
  }

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  $S get value => _id_value.get(this, S);

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($S value) => _id_value.set(this, S, value);

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(S value)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_StaticParent(
    $S value, {
    _$jni.JObjType<$S>? S,
  }) {
    S ??= _$jni.lowestCommonSuperType([
      value.$type,
    ]) as _$jni.JObjType<$S>;
    return GrandParent_StaticParent.fromReference(
        S,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr,
                value.reference.pointer)
            .reference);
  }
}

final class $GrandParent_StaticParent$Type<$S extends _$jni.JObject>
    extends _$jni.JObjType<GrandParent_StaticParent<$S>> {
  @_$jni.internal
  final _$jni.JObjType<$S> S;

  @_$jni.internal
  const $GrandParent_StaticParent$Type(
    this.S,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;';

  @_$jni.internal
  @_$core.override
  GrandParent_StaticParent<$S> fromReference(_$jni.JReference reference) =>
      GrandParent_StaticParent.fromReference(S, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($GrandParent_StaticParent$Type, S);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent_StaticParent$Type<$S>) &&
        other is $GrandParent_StaticParent$Type<$S> &&
        S == other.S;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent`
class GrandParent<$T extends _$jni.JObject> extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<GrandParent<$T>> $type;

  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  GrandParent.fromReference(
    this.T,
    _$jni.JReference reference,
  )   : $type = type(T),
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'com/github/dart_lang/jnigen/generics/GrandParent');

  /// The type which includes information such as the signature of this class.
  static $GrandParent$Type<$T> type<$T extends _$jni.JObject>(
    _$jni.JObjType<$T> T,
  ) {
    return $GrandParent$Type(
      T,
    );
  }

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public T value`
  /// The returned object must be released after use, by calling the [release] method.
  $T get value => _id_value.get(this, T);

  /// from: `public T value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($T value) => _id_value.set(this, T, value);

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(T value)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent(
    $T value, {
    _$jni.JObjType<$T>? T,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      value.$type,
    ]) as _$jni.JObjType<$T>;
    return GrandParent.fromReference(
        T,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr,
                value.reference.pointer)
            .reference);
  }

  static final _id_stringParent = _class.instanceMethodId(
    r'stringParent',
    r'()Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;',
  );

  static final _stringParent = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.generics.GrandParent<T>.Parent<java.lang.String> stringParent()`
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent_Parent<_$jni.JObject, _$jni.JString> stringParent() {
    return _stringParent(
            reference.pointer, _id_stringParent as _$jni.JMethodIDPtr)
        .object(const $GrandParent_Parent$Type(
            _$jni.JObjectType(), _$jni.JStringType()));
  }

  static final _id_varParent = _class.instanceMethodId(
    r'varParent',
    r'(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;',
  );

  static final _varParent = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public com.github.dart_lang.jnigen.generics.GrandParent<T>.Parent<S> varParent(S nestedValue)`
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent_Parent<_$jni.JObject, $S> varParent<$S extends _$jni.JObject>(
    $S nestedValue, {
    _$jni.JObjType<$S>? S,
  }) {
    S ??= _$jni.lowestCommonSuperType([
      nestedValue.$type,
    ]) as _$jni.JObjType<$S>;
    return _varParent(reference.pointer, _id_varParent as _$jni.JMethodIDPtr,
            nestedValue.reference.pointer)
        .object($GrandParent_Parent$Type(const _$jni.JObjectType(), S));
  }

  static final _id_stringStaticParent = _class.staticMethodId(
    r'stringStaticParent',
    r'()Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;',
  );

  static final _stringStaticParent = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<java.lang.String> stringStaticParent()`
  /// The returned object must be released after use, by calling the [release] method.
  static GrandParent_StaticParent<_$jni.JString> stringStaticParent() {
    return _stringStaticParent(_class.reference.pointer,
            _id_stringStaticParent as _$jni.JMethodIDPtr)
        .object(const $GrandParent_StaticParent$Type(_$jni.JStringType()));
  }

  static final _id_varStaticParent = _class.staticMethodId(
    r'varStaticParent',
    r'(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;',
  );

  static final _varStaticParent = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<S> varStaticParent(S value)`
  /// The returned object must be released after use, by calling the [release] method.
  static GrandParent_StaticParent<$S> varStaticParent<$S extends _$jni.JObject>(
    $S value, {
    _$jni.JObjType<$S>? S,
  }) {
    S ??= _$jni.lowestCommonSuperType([
      value.$type,
    ]) as _$jni.JObjType<$S>;
    return _varStaticParent(_class.reference.pointer,
            _id_varStaticParent as _$jni.JMethodIDPtr, value.reference.pointer)
        .object($GrandParent_StaticParent$Type(S));
  }

  static final _id_staticParentWithSameType = _class.instanceMethodId(
    r'staticParentWithSameType',
    r'()Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;',
  );

  static final _staticParentWithSameType = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<T> staticParentWithSameType()`
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent_StaticParent<$T> staticParentWithSameType() {
    return _staticParentWithSameType(reference.pointer,
            _id_staticParentWithSameType as _$jni.JMethodIDPtr)
        .object($GrandParent_StaticParent$Type(T));
  }
}

final class $GrandParent$Type<$T extends _$jni.JObject>
    extends _$jni.JObjType<GrandParent<$T>> {
  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  const $GrandParent$Type(
    this.T,
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/GrandParent;';

  @_$jni.internal
  @_$core.override
  GrandParent<$T> fromReference(_$jni.JReference reference) =>
      GrandParent.fromReference(T, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($GrandParent$Type, T);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent$Type<$T>) &&
        other is $GrandParent$Type<$T> &&
        T == other.T;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.MyMap$MyEntry`
class MyMap_MyEntry<$K extends _$jni.JObject, $V extends _$jni.JObject>
    extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MyMap_MyEntry<$K, $V>> $type;

  @_$jni.internal
  final _$jni.JObjType<$K> K;

  @_$jni.internal
  final _$jni.JObjType<$V> V;

  @_$jni.internal
  MyMap_MyEntry.fromReference(
    this.K,
    this.V,
    _$jni.JReference reference,
  )   : $type = type(K, V),
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/MyMap$MyEntry');

  /// The type which includes information such as the signature of this class.
  static $MyMap_MyEntry$Type<$K, $V>
      type<$K extends _$jni.JObject, $V extends _$jni.JObject>(
    _$jni.JObjType<$K> K,
    _$jni.JObjType<$V> V,
  ) {
    return $MyMap_MyEntry$Type(
      K,
      V,
    );
  }

  static final _id_key = _class.instanceFieldId(
    r'key',
    r'Ljava/lang/Object;',
  );

  /// from: `public K key`
  /// The returned object must be released after use, by calling the [release] method.
  $K get key => _id_key.get(this, K);

  /// from: `public K key`
  /// The returned object must be released after use, by calling the [release] method.
  set key($K value) => _id_key.set(this, K, value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public V value`
  /// The returned object must be released after use, by calling the [release] method.
  $V get value => _id_value.get(this, V);

  /// from: `public V value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($V value) => _id_value.set(this, V, value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/MyMap;Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.MyMap $parent, K key, V value)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyMap_MyEntry(
    MyMap<$K, $V> $parent,
    $K key,
    $V value, {
    _$jni.JObjType<$K>? K,
    _$jni.JObjType<$V>? V,
  }) {
    K ??= _$jni.lowestCommonSuperType([
      key.$type,
      ($parent.$type as $MyMap$Type).K,
    ]) as _$jni.JObjType<$K>;
    V ??= _$jni.lowestCommonSuperType([
      value.$type,
      ($parent.$type as $MyMap$Type).V,
    ]) as _$jni.JObjType<$V>;
    return MyMap_MyEntry.fromReference(
        K,
        V,
        _new$(
                _class.reference.pointer,
                _id_new$ as _$jni.JMethodIDPtr,
                $parent.reference.pointer,
                key.reference.pointer,
                value.reference.pointer)
            .reference);
  }
}

final class $MyMap_MyEntry$Type<$K extends _$jni.JObject,
    $V extends _$jni.JObject> extends _$jni.JObjType<MyMap_MyEntry<$K, $V>> {
  @_$jni.internal
  final _$jni.JObjType<$K> K;

  @_$jni.internal
  final _$jni.JObjType<$V> V;

  @_$jni.internal
  const $MyMap_MyEntry$Type(
    this.K,
    this.V,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/MyMap$MyEntry;';

  @_$jni.internal
  @_$core.override
  MyMap_MyEntry<$K, $V> fromReference(_$jni.JReference reference) =>
      MyMap_MyEntry.fromReference(K, V, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($MyMap_MyEntry$Type, K, V);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyMap_MyEntry$Type<$K, $V>) &&
        other is $MyMap_MyEntry$Type<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.MyMap`
class MyMap<$K extends _$jni.JObject, $V extends _$jni.JObject>
    extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MyMap<$K, $V>> $type;

  @_$jni.internal
  final _$jni.JObjType<$K> K;

  @_$jni.internal
  final _$jni.JObjType<$V> V;

  @_$jni.internal
  MyMap.fromReference(
    this.K,
    this.V,
    _$jni.JReference reference,
  )   : $type = type(K, V),
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'com/github/dart_lang/jnigen/generics/MyMap');

  /// The type which includes information such as the signature of this class.
  static $MyMap$Type<$K, $V>
      type<$K extends _$jni.JObject, $V extends _$jni.JObject>(
    _$jni.JObjType<$K> K,
    _$jni.JObjType<$V> V,
  ) {
    return $MyMap$Type(
      K,
      V,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyMap({
    required _$jni.JObjType<$K> K,
    required _$jni.JObjType<$V> V,
  }) {
    return MyMap.fromReference(
        K,
        V,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _get = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V get(K key)`
  /// The returned object must be released after use, by calling the [release] method.
  $V get(
    $K key,
  ) {
    return _get(reference.pointer, _id_get as _$jni.JMethodIDPtr,
            key.reference.pointer)
        .object(V);
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _put = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V put(K key, V value)`
  /// The returned object must be released after use, by calling the [release] method.
  $V put(
    $K key,
    $V value,
  ) {
    return _put(reference.pointer, _id_put as _$jni.JMethodIDPtr,
            key.reference.pointer, value.reference.pointer)
        .object(V);
  }

  static final _id_entryStack = _class.instanceMethodId(
    r'entryStack',
    r'()Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _entryStack = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.generics.MyStack<com.github.dart_lang.jnigen.generics.MyMap<K,V>.MyEntry> entryStack()`
  /// The returned object must be released after use, by calling the [release] method.
  MyStack<MyMap_MyEntry<_$jni.JObject, _$jni.JObject>> entryStack() {
    return _entryStack(reference.pointer, _id_entryStack as _$jni.JMethodIDPtr)
        .object(const $MyStack$Type(
            $MyMap_MyEntry$Type(_$jni.JObjectType(), _$jni.JObjectType())));
  }
}

final class $MyMap$Type<$K extends _$jni.JObject, $V extends _$jni.JObject>
    extends _$jni.JObjType<MyMap<$K, $V>> {
  @_$jni.internal
  final _$jni.JObjType<$K> K;

  @_$jni.internal
  final _$jni.JObjType<$V> V;

  @_$jni.internal
  const $MyMap$Type(
    this.K,
    this.V,
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/MyMap;';

  @_$jni.internal
  @_$core.override
  MyMap<$K, $V> fromReference(_$jni.JReference reference) =>
      MyMap.fromReference(K, V, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($MyMap$Type, K, V);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyMap$Type<$K, $V>) &&
        other is $MyMap$Type<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.MyStack`
class MyStack<$T extends _$jni.JObject> extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MyStack<$T>> $type;

  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  MyStack.fromReference(
    this.T,
    _$jni.JReference reference,
  )   : $type = type(T),
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'com/github/dart_lang/jnigen/generics/MyStack');

  /// The type which includes information such as the signature of this class.
  static $MyStack$Type<$T> type<$T extends _$jni.JObject>(
    _$jni.JObjType<$T> T,
  ) {
    return $MyStack$Type(
      T,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyStack({
    required _$jni.JObjType<$T> T,
  }) {
    return MyStack.fromReference(
        T,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }

  static final _id_fromArray = _class.staticMethodId(
    r'fromArray',
    r'([Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _fromArray = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<T> fromArray(T[] arr)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T> fromArray<$T extends _$jni.JObject>(
    _$jni.JArray<$T> arr, {
    _$jni.JObjType<$T>? T,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      ((arr.$type as _$jni.JArrayType).elementType as _$jni.JObjType),
    ]) as _$jni.JObjType<$T>;
    return _fromArray(_class.reference.pointer,
            _id_fromArray as _$jni.JMethodIDPtr, arr.reference.pointer)
        .object($MyStack$Type(T));
  }

  static final _id_fromArrayOfArrayOfGrandParents = _class.staticMethodId(
    r'fromArrayOfArrayOfGrandParents',
    r'([[Lcom/github/dart_lang/jnigen/generics/GrandParent;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _fromArrayOfArrayOfGrandParents =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<S> fromArrayOfArrayOfGrandParents(com.github.dart_lang.jnigen.generics.GrandParent<S>[][] arr)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$S> fromArrayOfArrayOfGrandParents<$S extends _$jni.JObject>(
    _$jni.JArray<_$jni.JArray<GrandParent<$S>>> arr, {
    _$jni.JObjType<$S>? S,
  }) {
    S ??= _$jni.lowestCommonSuperType([
      (((((arr.$type as _$jni.JArrayType).elementType as _$jni.JObjType)
                  as _$jni.JArrayType)
              .elementType as _$jni.JObjType) as $GrandParent$Type)
          .T,
    ]) as _$jni.JObjType<$S>;
    return _fromArrayOfArrayOfGrandParents(
            _class.reference.pointer,
            _id_fromArrayOfArrayOfGrandParents as _$jni.JMethodIDPtr,
            arr.reference.pointer)
        .object($MyStack$Type(S));
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'()Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _of = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<T> of()`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T> of<$T extends _$jni.JObject>({
    required _$jni.JObjType<$T> T,
  }) {
    return _of(_class.reference.pointer, _id_of as _$jni.JMethodIDPtr)
        .object($MyStack$Type(T));
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _of$1 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<T> of(T obj)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T> of$1<$T extends _$jni.JObject>(
    $T obj, {
    _$jni.JObjType<$T>? T,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      obj.$type,
    ]) as _$jni.JObjType<$T>;
    return _of$1(_class.reference.pointer, _id_of$1 as _$jni.JMethodIDPtr,
            obj.reference.pointer)
        .object($MyStack$Type(T));
  }

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _of$2 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<T> of(T obj, T obj2)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T> of$2<$T extends _$jni.JObject>(
    $T obj,
    $T obj2, {
    _$jni.JObjType<$T>? T,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      obj2.$type,
      obj.$type,
    ]) as _$jni.JObjType<$T>;
    return _of$2(_class.reference.pointer, _id_of$2 as _$jni.JMethodIDPtr,
            obj.reference.pointer, obj2.reference.pointer)
        .object($MyStack$Type(T));
  }

  static final _id_push = _class.instanceMethodId(
    r'push',
    r'(Ljava/lang/Object;)V',
  );

  static final _push = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void push(T item)`
  void push(
    $T item,
  ) {
    _push(reference.pointer, _id_push as _$jni.JMethodIDPtr,
            item.reference.pointer)
        .check();
  }

  static final _id_pop = _class.instanceMethodId(
    r'pop',
    r'()Ljava/lang/Object;',
  );

  static final _pop = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public T pop()`
  /// The returned object must be released after use, by calling the [release] method.
  $T pop() {
    return _pop(reference.pointer, _id_pop as _$jni.JMethodIDPtr).object(T);
  }

  static final _id_size = _class.instanceMethodId(
    r'size',
    r'()I',
  );

  static final _size = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int size()`
  int size() {
    return _size(reference.pointer, _id_size as _$jni.JMethodIDPtr).integer;
  }
}

final class $MyStack$Type<$T extends _$jni.JObject>
    extends _$jni.JObjType<MyStack<$T>> {
  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  const $MyStack$Type(
    this.T,
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/MyStack;';

  @_$jni.internal
  @_$core.override
  MyStack<$T> fromReference(_$jni.JReference reference) =>
      MyStack.fromReference(T, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($MyStack$Type, T);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyStack$Type<$T>) &&
        other is $MyStack$Type<$T> &&
        T == other.T;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.StringKeyedMap`
class StringKeyedMap<$V extends _$jni.JObject>
    extends MyMap<_$jni.JString, $V> {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<StringKeyedMap<$V>> $type;

  @_$jni.internal
  final _$jni.JObjType<$V> V;

  @_$jni.internal
  StringKeyedMap.fromReference(
    this.V,
    _$jni.JReference reference,
  )   : $type = type(V),
        super.fromReference(const _$jni.JStringType(), V, reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/StringKeyedMap');

  /// The type which includes information such as the signature of this class.
  static $StringKeyedMap$Type<$V> type<$V extends _$jni.JObject>(
    _$jni.JObjType<$V> V,
  ) {
    return $StringKeyedMap$Type(
      V,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringKeyedMap({
    required _$jni.JObjType<$V> V,
  }) {
    return StringKeyedMap.fromReference(
        V,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $StringKeyedMap$Type<$V extends _$jni.JObject>
    extends _$jni.JObjType<StringKeyedMap<$V>> {
  @_$jni.internal
  final _$jni.JObjType<$V> V;

  @_$jni.internal
  const $StringKeyedMap$Type(
    this.V,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/StringKeyedMap;';

  @_$jni.internal
  @_$core.override
  StringKeyedMap<$V> fromReference(_$jni.JReference reference) =>
      StringKeyedMap.fromReference(V, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => $MyMap$Type(const _$jni.JStringType(), V);

  @_$jni.internal
  @_$core.override
  final superCount = 2;

  @_$core.override
  int get hashCode => Object.hash($StringKeyedMap$Type, V);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringKeyedMap$Type<$V>) &&
        other is $StringKeyedMap$Type<$V> &&
        V == other.V;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.StringMap`
class StringMap extends StringKeyedMap<_$jni.JString> {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<StringMap> $type;

  @_$jni.internal
  StringMap.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(const _$jni.JStringType(), reference);

  static final _class =
      _$jni.JClass.forName(r'com/github/dart_lang/jnigen/generics/StringMap');

  /// The type which includes information such as the signature of this class.
  static const type = $StringMap$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringMap() {
    return StringMap.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $StringMap$Type extends _$jni.JObjType<StringMap> {
  @_$jni.internal
  const $StringMap$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/StringMap;';

  @_$jni.internal
  @_$core.override
  StringMap fromReference(_$jni.JReference reference) =>
      StringMap.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType =>
      const $StringKeyedMap$Type(_$jni.JStringType());

  @_$jni.internal
  @_$core.override
  final superCount = 3;

  @_$core.override
  int get hashCode => ($StringMap$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringMap$Type) && other is $StringMap$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.StringStack`
class StringStack extends MyStack<_$jni.JString> {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<StringStack> $type;

  @_$jni.internal
  StringStack.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(const _$jni.JStringType(), reference);

  static final _class =
      _$jni.JClass.forName(r'com/github/dart_lang/jnigen/generics/StringStack');

  /// The type which includes information such as the signature of this class.
  static const type = $StringStack$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringStack() {
    return StringStack.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $StringStack$Type extends _$jni.JObjType<StringStack> {
  @_$jni.internal
  const $StringStack$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/StringStack;';

  @_$jni.internal
  @_$core.override
  StringStack fromReference(_$jni.JReference reference) =>
      StringStack.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const $MyStack$Type(_$jni.JStringType());

  @_$jni.internal
  @_$core.override
  final superCount = 2;

  @_$core.override
  int get hashCode => ($StringStack$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringStack$Type) &&
        other is $StringStack$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.StringValuedMap`
class StringValuedMap<$K extends _$jni.JObject>
    extends MyMap<$K, _$jni.JString> {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<StringValuedMap<$K>> $type;

  @_$jni.internal
  final _$jni.JObjType<$K> K;

  @_$jni.internal
  StringValuedMap.fromReference(
    this.K,
    _$jni.JReference reference,
  )   : $type = type(K),
        super.fromReference(K, const _$jni.JStringType(), reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/StringValuedMap');

  /// The type which includes information such as the signature of this class.
  static $StringValuedMap$Type<$K> type<$K extends _$jni.JObject>(
    _$jni.JObjType<$K> K,
  ) {
    return $StringValuedMap$Type(
      K,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringValuedMap({
    required _$jni.JObjType<$K> K,
  }) {
    return StringValuedMap.fromReference(
        K,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $StringValuedMap$Type<$K extends _$jni.JObject>
    extends _$jni.JObjType<StringValuedMap<$K>> {
  @_$jni.internal
  final _$jni.JObjType<$K> K;

  @_$jni.internal
  const $StringValuedMap$Type(
    this.K,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/StringValuedMap;';

  @_$jni.internal
  @_$core.override
  StringValuedMap<$K> fromReference(_$jni.JReference reference) =>
      StringValuedMap.fromReference(K, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => $MyMap$Type(K, const _$jni.JStringType());

  @_$jni.internal
  @_$core.override
  final superCount = 2;

  @_$core.override
  int get hashCode => Object.hash($StringValuedMap$Type, K);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringValuedMap$Type<$K>) &&
        other is $StringValuedMap$Type<$K> &&
        K == other.K;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyInterface`
class MyInterface<$T extends _$jni.JObject> extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MyInterface<$T>> $type;

  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  MyInterface.fromReference(
    this.T,
    _$jni.JReference reference,
  )   : $type = type(T),
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyInterface');

  /// The type which includes information such as the signature of this class.
  static $MyInterface$Type<$T> type<$T extends _$jni.JObject>(
    _$jni.JObjType<$T> T,
  ) {
    return $MyInterface$Type(
      T,
    );
  }

  static final _id_voidCallback = _class.instanceMethodId(
    r'voidCallback',
    r'(Ljava/lang/String;)V',
  );

  static final _voidCallback = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void voidCallback(java.lang.String s)`
  void voidCallback(
    _$jni.JString s,
  ) {
    _voidCallback(reference.pointer, _id_voidCallback as _$jni.JMethodIDPtr,
            s.reference.pointer)
        .check();
  }

  static final _id_stringCallback = _class.instanceMethodId(
    r'stringCallback',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _stringCallback = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract java.lang.String stringCallback(java.lang.String s)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JString stringCallback(
    _$jni.JString s,
  ) {
    return _stringCallback(reference.pointer,
            _id_stringCallback as _$jni.JMethodIDPtr, s.reference.pointer)
        .object(const _$jni.JStringType());
  }

  static final _id_varCallback = _class.instanceMethodId(
    r'varCallback',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _varCallback = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract T varCallback(T t)`
  /// The returned object must be released after use, by calling the [release] method.
  $T varCallback(
    $T t,
  ) {
    return _varCallback(reference.pointer,
            _id_varCallback as _$jni.JMethodIDPtr, t.reference.pointer)
        .object(T);
  }

  static final _id_manyPrimitives = _class.instanceMethodId(
    r'manyPrimitives',
    r'(IZCD)J',
  );

  static final _manyPrimitives = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Double
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, int, int, int, double)>();

  /// from: `public abstract long manyPrimitives(int a, boolean b, char c, double d)`
  int manyPrimitives(
    int a,
    bool b,
    int c,
    double d,
  ) {
    return _manyPrimitives(reference.pointer,
            _id_manyPrimitives as _$jni.JMethodIDPtr, a, b ? 1 : 0, c, d)
        .long;
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MyInterface> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'voidCallback(Ljava/lang/String;)V') {
        _$impls[$p]!.voidCallback(
          $a[0].as(const _$jni.JStringType(), releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
      if ($d == r'stringCallback(Ljava/lang/String;)Ljava/lang/String;') {
        final $r = _$impls[$p]!.stringCallback(
          $a[0].as(const _$jni.JStringType(), releaseOriginal: true),
        );
        return ($r as _$jni.JObject)
            .as(const _$jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'varCallback(Ljava/lang/Object;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.varCallback(
          $a[0].as(_$impls[$p]!.T, releaseOriginal: true),
        );
        return ($r as _$jni.JObject)
            .as(const _$jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'manyPrimitives(IZCD)J') {
        final $r = _$impls[$p]!.manyPrimitives(
          $a[0]
              .as(const _$jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[1]
              .as(const _$jni.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
          $a[2]
              .as(const _$jni.JCharacterType(), releaseOriginal: true)
              .charValue(releaseOriginal: true),
          $a[3]
              .as(const _$jni.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return _$jni.JLong($r).reference.toPointer();
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn<$T extends _$jni.JObject>(
    _$jni.JImplementer implementer,
    $MyInterface<$T> $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.interfaces.MyInterface',
      $p,
      _$invokePointer,
      [
        if ($impl.voidCallback$async) r'voidCallback(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MyInterface.implement(
    $MyInterface<$T> $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MyInterface.fromReference(
      $impl.T,
      $i.implementReference(),
    );
  }
  static _$core.Map<int, $MyInterface> get $impls => _$impls;
}

abstract mixin class $MyInterface<$T extends _$jni.JObject> {
  factory $MyInterface({
    required _$jni.JObjType<$T> T,
    required void Function(_$jni.JString s) voidCallback,
    bool voidCallback$async,
    required _$jni.JString Function(_$jni.JString s) stringCallback,
    required $T Function($T t) varCallback,
    required int Function(int a, bool b, int c, double d) manyPrimitives,
  }) = _$MyInterface;

  _$jni.JObjType<$T> get T;

  void voidCallback(_$jni.JString s);
  bool get voidCallback$async => false;
  _$jni.JString stringCallback(_$jni.JString s);
  $T varCallback($T t);
  int manyPrimitives(int a, bool b, int c, double d);
}

class _$MyInterface<$T extends _$jni.JObject> implements $MyInterface<$T> {
  _$MyInterface({
    required this.T,
    required void Function(_$jni.JString s) voidCallback,
    this.voidCallback$async = false,
    required _$jni.JString Function(_$jni.JString s) stringCallback,
    required $T Function($T t) varCallback,
    required int Function(int a, bool b, int c, double d) manyPrimitives,
  })  : _voidCallback = voidCallback,
        _stringCallback = stringCallback,
        _varCallback = varCallback,
        _manyPrimitives = manyPrimitives;

  @_$core.override
  final _$jni.JObjType<$T> T;

  final void Function(_$jni.JString s) _voidCallback;
  final bool voidCallback$async;
  final _$jni.JString Function(_$jni.JString s) _stringCallback;
  final $T Function($T t) _varCallback;
  final int Function(int a, bool b, int c, double d) _manyPrimitives;

  void voidCallback(_$jni.JString s) {
    return _voidCallback(s);
  }

  _$jni.JString stringCallback(_$jni.JString s) {
    return _stringCallback(s);
  }

  $T varCallback($T t) {
    return _varCallback(t);
  }

  int manyPrimitives(int a, bool b, int c, double d) {
    return _manyPrimitives(a, b, c, d);
  }
}

final class $MyInterface$Type<$T extends _$jni.JObject>
    extends _$jni.JObjType<MyInterface<$T>> {
  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  const $MyInterface$Type(
    this.T,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyInterface;';

  @_$jni.internal
  @_$core.override
  MyInterface<$T> fromReference(_$jni.JReference reference) =>
      MyInterface.fromReference(T, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($MyInterface$Type, T);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyInterface$Type<$T>) &&
        other is $MyInterface$Type<$T> &&
        T == other.T;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyInterfaceConsumer`
class MyInterfaceConsumer extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MyInterfaceConsumer> $type;

  @_$jni.internal
  MyInterfaceConsumer.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyInterfaceConsumer');

  /// The type which includes information such as the signature of this class.
  static const type = $MyInterfaceConsumer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyInterfaceConsumer() {
    return MyInterfaceConsumer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }

  static final _id_consumeOnAnotherThread = _class.staticMethodId(
    r'consumeOnAnotherThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/MyInterface;Ljava/lang/String;IZCDLjava/lang/Object;)V',
  );

  static final _consumeOnAnotherThread = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Double,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              int,
              int,
              int,
              double,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public void consumeOnAnotherThread(com.github.dart_lang.jnigen.interfaces.MyInterface<T> myInterface, java.lang.String s, int a, boolean b, char c, double d, T t)`
  static void consumeOnAnotherThread<$T extends _$jni.JObject>(
    MyInterface<$T> myInterface,
    _$jni.JString s,
    int a,
    bool b,
    int c,
    double d,
    $T t, {
    _$jni.JObjType<$T>? T,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      t.$type,
      (myInterface.$type as $MyInterface$Type).T,
    ]) as _$jni.JObjType<$T>;
    _consumeOnAnotherThread(
            _class.reference.pointer,
            _id_consumeOnAnotherThread as _$jni.JMethodIDPtr,
            myInterface.reference.pointer,
            s.reference.pointer,
            a,
            b ? 1 : 0,
            c,
            d,
            t.reference.pointer)
        .check();
  }

  static final _id_consumeOnSameThread = _class.staticMethodId(
    r'consumeOnSameThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/MyInterface;Ljava/lang/String;IZCDLjava/lang/Object;)V',
  );

  static final _consumeOnSameThread = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Double,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              int,
              int,
              int,
              double,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public void consumeOnSameThread(com.github.dart_lang.jnigen.interfaces.MyInterface<T> myInterface, java.lang.String s, int a, boolean b, char c, double d, T t)`
  static void consumeOnSameThread<$T extends _$jni.JObject>(
    MyInterface<$T> myInterface,
    _$jni.JString s,
    int a,
    bool b,
    int c,
    double d,
    $T t, {
    _$jni.JObjType<$T>? T,
  }) {
    T ??= _$jni.lowestCommonSuperType([
      t.$type,
      (myInterface.$type as $MyInterface$Type).T,
    ]) as _$jni.JObjType<$T>;
    _consumeOnSameThread(
            _class.reference.pointer,
            _id_consumeOnSameThread as _$jni.JMethodIDPtr,
            myInterface.reference.pointer,
            s.reference.pointer,
            a,
            b ? 1 : 0,
            c,
            d,
            t.reference.pointer)
        .check();
  }
}

final class $MyInterfaceConsumer$Type
    extends _$jni.JObjType<MyInterfaceConsumer> {
  @_$jni.internal
  const $MyInterfaceConsumer$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyInterfaceConsumer;';

  @_$jni.internal
  @_$core.override
  MyInterfaceConsumer fromReference(_$jni.JReference reference) =>
      MyInterfaceConsumer.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MyInterfaceConsumer$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyInterfaceConsumer$Type) &&
        other is $MyInterfaceConsumer$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyRunnable`
class MyRunnable extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MyRunnable> $type;

  @_$jni.internal
  MyRunnable.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyRunnable');

  /// The type which includes information such as the signature of this class.
  static const type = $MyRunnable$Type();
  static final _id_run = _class.instanceMethodId(
    r'run',
    r'()V',
  );

  static final _run = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void run()`
  void run() {
    _run(reference.pointer, _id_run as _$jni.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $MyRunnable> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'run()V') {
        _$impls[$p]!.run();
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $MyRunnable $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.interfaces.MyRunnable',
      $p,
      _$invokePointer,
      [
        if ($impl.run$async) r'run()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MyRunnable.implement(
    $MyRunnable $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return MyRunnable.fromReference(
      $i.implementReference(),
    );
  }
  static _$core.Map<int, $MyRunnable> get $impls => _$impls;
}

abstract mixin class $MyRunnable {
  factory $MyRunnable({
    required void Function() run,
    bool run$async,
  }) = _$MyRunnable;

  void run();
  bool get run$async => false;
}

class _$MyRunnable implements $MyRunnable {
  _$MyRunnable({
    required void Function() run,
    this.run$async = false,
  }) : _run = run;

  final void Function() _run;
  final bool run$async;

  void run() {
    return _run();
  }
}

final class $MyRunnable$Type extends _$jni.JObjType<MyRunnable> {
  @_$jni.internal
  const $MyRunnable$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyRunnable;';

  @_$jni.internal
  @_$core.override
  MyRunnable fromReference(_$jni.JReference reference) =>
      MyRunnable.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MyRunnable$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyRunnable$Type) && other is $MyRunnable$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyRunnableRunner`
class MyRunnableRunner extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MyRunnableRunner> $type;

  @_$jni.internal
  MyRunnableRunner.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyRunnableRunner');

  /// The type which includes information such as the signature of this class.
  static const type = $MyRunnableRunner$Type();
  static final _id_error = _class.instanceFieldId(
    r'error',
    r'Ljava/lang/Throwable;',
  );

  /// from: `public java.lang.Throwable error`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject get error => _id_error.get(this, const _$jni.JObjectType());

  /// from: `public java.lang.Throwable error`
  /// The returned object must be released after use, by calling the [release] method.
  set error(_$jni.JObject value) =>
      _id_error.set(this, const _$jni.JObjectType(), value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/interfaces/MyRunnable;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.interfaces.MyRunnable runnable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyRunnableRunner(
    MyRunnable runnable,
  ) {
    return MyRunnableRunner.fromReference(_new$(_class.reference.pointer,
            _id_new$ as _$jni.JMethodIDPtr, runnable.reference.pointer)
        .reference);
  }

  static final _id_runOnSameThread = _class.instanceMethodId(
    r'runOnSameThread',
    r'()V',
  );

  static final _runOnSameThread = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void runOnSameThread()`
  void runOnSameThread() {
    _runOnSameThread(
            reference.pointer, _id_runOnSameThread as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_runOnAnotherThread = _class.instanceMethodId(
    r'runOnAnotherThread',
    r'()V',
  );

  static final _runOnAnotherThread = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void runOnAnotherThread()`
  void runOnAnotherThread() {
    _runOnAnotherThread(
            reference.pointer, _id_runOnAnotherThread as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_runOnAnotherThreadAndJoin = _class.instanceMethodId(
    r'runOnAnotherThreadAndJoin',
    r'()V',
  );

  static final _runOnAnotherThreadAndJoin = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void runOnAnotherThreadAndJoin()`
  void runOnAnotherThreadAndJoin() {
    _runOnAnotherThreadAndJoin(reference.pointer,
            _id_runOnAnotherThreadAndJoin as _$jni.JMethodIDPtr)
        .check();
  }
}

final class $MyRunnableRunner$Type extends _$jni.JObjType<MyRunnableRunner> {
  @_$jni.internal
  const $MyRunnableRunner$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyRunnableRunner;';

  @_$jni.internal
  @_$core.override
  MyRunnableRunner fromReference(_$jni.JReference reference) =>
      MyRunnableRunner.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MyRunnableRunner$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyRunnableRunner$Type) &&
        other is $MyRunnableRunner$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.StringConversionException`
class StringConversionException extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<StringConversionException> $type;

  @_$jni.internal
  StringConversionException.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/StringConversionException');

  /// The type which includes information such as the signature of this class.
  static const type = $StringConversionException$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(java.lang.String message)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringConversionException(
    _$jni.JString message,
  ) {
    return StringConversionException.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as _$jni.JMethodIDPtr,
            message.reference.pointer)
        .reference);
  }
}

final class $StringConversionException$Type
    extends _$jni.JObjType<StringConversionException> {
  @_$jni.internal
  const $StringConversionException$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConversionException;';

  @_$jni.internal
  @_$core.override
  StringConversionException fromReference(_$jni.JReference reference) =>
      StringConversionException.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($StringConversionException$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringConversionException$Type) &&
        other is $StringConversionException$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.StringConverter`
class StringConverter extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<StringConverter> $type;

  @_$jni.internal
  StringConverter.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/StringConverter');

  /// The type which includes information such as the signature of this class.
  static const type = $StringConverter$Type();
  static final _id_parseToInt = _class.instanceMethodId(
    r'parseToInt',
    r'(Ljava/lang/String;)I',
  );

  static final _parseToInt = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract int parseToInt(java.lang.String s)`
  int parseToInt(
    _$jni.JString s,
  ) {
    return _parseToInt(reference.pointer, _id_parseToInt as _$jni.JMethodIDPtr,
            s.reference.pointer)
        .integer;
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $StringConverter> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'parseToInt(Ljava/lang/String;)I') {
        final $r = _$impls[$p]!.parseToInt(
          $a[0].as(const _$jni.JStringType(), releaseOriginal: true),
        );
        return _$jni.JInteger($r).reference.toPointer();
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $StringConverter $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.interfaces.StringConverter',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory StringConverter.implement(
    $StringConverter $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return StringConverter.fromReference(
      $i.implementReference(),
    );
  }
}

abstract mixin class $StringConverter {
  factory $StringConverter({
    required int Function(_$jni.JString s) parseToInt,
  }) = _$StringConverter;

  int parseToInt(_$jni.JString s);
}

class _$StringConverter implements $StringConverter {
  _$StringConverter({
    required int Function(_$jni.JString s) parseToInt,
  }) : _parseToInt = parseToInt;

  final int Function(_$jni.JString s) _parseToInt;

  int parseToInt(_$jni.JString s) {
    return _parseToInt(s);
  }
}

final class $StringConverter$Type extends _$jni.JObjType<StringConverter> {
  @_$jni.internal
  const $StringConverter$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConverter;';

  @_$jni.internal
  @_$core.override
  StringConverter fromReference(_$jni.JReference reference) =>
      StringConverter.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($StringConverter$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringConverter$Type) &&
        other is $StringConverter$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.StringConverterConsumer`
class StringConverterConsumer extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<StringConverterConsumer> $type;

  @_$jni.internal
  StringConverterConsumer.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/StringConverterConsumer');

  /// The type which includes information such as the signature of this class.
  static const type = $StringConverterConsumer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringConverterConsumer() {
    return StringConverterConsumer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }

  static final _id_consumeOnSameThread = _class.staticMethodId(
    r'consumeOnSameThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/StringConverter;Ljava/lang/String;)Ljava/lang/Integer;',
  );

  static final _consumeOnSameThread = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public java.lang.Integer consumeOnSameThread(com.github.dart_lang.jnigen.interfaces.StringConverter stringConverter, java.lang.String s)`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JInteger consumeOnSameThread(
    StringConverter stringConverter,
    _$jni.JString s,
  ) {
    return _consumeOnSameThread(
            _class.reference.pointer,
            _id_consumeOnSameThread as _$jni.JMethodIDPtr,
            stringConverter.reference.pointer,
            s.reference.pointer)
        .object(const _$jni.JIntegerType());
  }

  static final _id_consumeOnAnotherThread = _class.staticMethodId(
    r'consumeOnAnotherThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/StringConverter;Ljava/lang/String;)Ljava/util/concurrent/Future;',
  );

  static final _consumeOnAnotherThread = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public java.util.concurrent.Future<java.lang.Integer> consumeOnAnotherThread(com.github.dart_lang.jnigen.interfaces.StringConverter stringConverter, java.lang.String s)`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JObject consumeOnAnotherThread(
    StringConverter stringConverter,
    _$jni.JString s,
  ) {
    return _consumeOnAnotherThread(
            _class.reference.pointer,
            _id_consumeOnAnotherThread as _$jni.JMethodIDPtr,
            stringConverter.reference.pointer,
            s.reference.pointer)
        .object(const _$jni.JObjectType());
  }
}

final class $StringConverterConsumer$Type
    extends _$jni.JObjType<StringConverterConsumer> {
  @_$jni.internal
  const $StringConverterConsumer$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConverterConsumer;';

  @_$jni.internal
  @_$core.override
  StringConverterConsumer fromReference(_$jni.JReference reference) =>
      StringConverterConsumer.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($StringConverterConsumer$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringConverterConsumer$Type) &&
        other is $StringConverterConsumer$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.inheritance.BaseClass`
class BaseClass<$T extends _$jni.JObject> extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<BaseClass<$T>> $type;

  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  BaseClass.fromReference(
    this.T,
    _$jni.JReference reference,
  )   : $type = type(T),
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/inheritance/BaseClass');

  /// The type which includes information such as the signature of this class.
  static $BaseClass$Type<$T> type<$T extends _$jni.JObject>(
    _$jni.JObjType<$T> T,
  ) {
    return $BaseClass$Type(
      T,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory BaseClass({
    required _$jni.JObjType<$T> T,
  }) {
    return BaseClass.fromReference(
        T,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $BaseClass$Type<$T extends _$jni.JObject>
    extends _$jni.JObjType<BaseClass<$T>> {
  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  const $BaseClass$Type(
    this.T,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/BaseClass;';

  @_$jni.internal
  @_$core.override
  BaseClass<$T> fromReference(_$jni.JReference reference) =>
      BaseClass.fromReference(T, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($BaseClass$Type, T);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BaseClass$Type<$T>) &&
        other is $BaseClass$Type<$T> &&
        T == other.T;
  }
}

/// from: `com.github.dart_lang.jnigen.inheritance.GenericDerivedClass`
class GenericDerivedClass<$T extends _$jni.JObject> extends BaseClass<$T> {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<GenericDerivedClass<$T>> $type;

  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  GenericDerivedClass.fromReference(
    this.T,
    _$jni.JReference reference,
  )   : $type = type(T),
        super.fromReference(T, reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/inheritance/GenericDerivedClass');

  /// The type which includes information such as the signature of this class.
  static $GenericDerivedClass$Type<$T> type<$T extends _$jni.JObject>(
    _$jni.JObjType<$T> T,
  ) {
    return $GenericDerivedClass$Type(
      T,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory GenericDerivedClass({
    required _$jni.JObjType<$T> T,
  }) {
    return GenericDerivedClass.fromReference(
        T,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $GenericDerivedClass$Type<$T extends _$jni.JObject>
    extends _$jni.JObjType<GenericDerivedClass<$T>> {
  @_$jni.internal
  final _$jni.JObjType<$T> T;

  @_$jni.internal
  const $GenericDerivedClass$Type(
    this.T,
  );

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/GenericDerivedClass;';

  @_$jni.internal
  @_$core.override
  GenericDerivedClass<$T> fromReference(_$jni.JReference reference) =>
      GenericDerivedClass.fromReference(T, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => $BaseClass$Type(T);

  @_$jni.internal
  @_$core.override
  final superCount = 2;

  @_$core.override
  int get hashCode => Object.hash($GenericDerivedClass$Type, T);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GenericDerivedClass$Type<$T>) &&
        other is $GenericDerivedClass$Type<$T> &&
        T == other.T;
  }
}

/// from: `com.github.dart_lang.jnigen.inheritance.SpecificDerivedClass`
class SpecificDerivedClass extends BaseClass<_$jni.JString> {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<SpecificDerivedClass> $type;

  @_$jni.internal
  SpecificDerivedClass.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(const _$jni.JStringType(), reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/inheritance/SpecificDerivedClass');

  /// The type which includes information such as the signature of this class.
  static const type = $SpecificDerivedClass$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SpecificDerivedClass() {
    return SpecificDerivedClass.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $SpecificDerivedClass$Type
    extends _$jni.JObjType<SpecificDerivedClass> {
  @_$jni.internal
  const $SpecificDerivedClass$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/SpecificDerivedClass;';

  @_$jni.internal
  @_$core.override
  SpecificDerivedClass fromReference(_$jni.JReference reference) =>
      SpecificDerivedClass.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const $BaseClass$Type(_$jni.JStringType());

  @_$jni.internal
  @_$core.override
  final superCount = 2;

  @_$core.override
  int get hashCode => ($SpecificDerivedClass$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SpecificDerivedClass$Type) &&
        other is $SpecificDerivedClass$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.JsonSerializable$Case`
class JsonSerializable_Case extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<JsonSerializable_Case> $type;

  @_$jni.internal
  JsonSerializable_Case.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/JsonSerializable$Case');

  /// The type which includes information such as the signature of this class.
  static const type = $JsonSerializable_Case$Type();
  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _values = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.annotations.JsonSerializable.Case[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JArray<JsonSerializable_Case> values() {
    return _values(_class.reference.pointer, _id_values as _$jni.JMethodIDPtr)
        .object(const _$jni.JArrayType($JsonSerializable_Case$Type()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _valueOf = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.annotations.JsonSerializable.Case valueOf(java.lang.String name)`
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable_Case valueOf(
    _$jni.JString name,
  ) {
    return _valueOf(_class.reference.pointer, _id_valueOf as _$jni.JMethodIDPtr,
            name.reference.pointer)
        .object(const $JsonSerializable_Case$Type());
  }
}

final class $JsonSerializable_Case$Type
    extends _$jni.JObjType<JsonSerializable_Case> {
  @_$jni.internal
  const $JsonSerializable_Case$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;';

  @_$jni.internal
  @_$core.override
  JsonSerializable_Case fromReference(_$jni.JReference reference) =>
      JsonSerializable_Case.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($JsonSerializable_Case$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JsonSerializable_Case$Type) &&
        other is $JsonSerializable_Case$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.JsonSerializable`
class JsonSerializable extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<JsonSerializable> $type;

  @_$jni.internal
  JsonSerializable.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/JsonSerializable');

  /// The type which includes information such as the signature of this class.
  static const type = $JsonSerializable$Type();
  static final _id_value = _class.instanceMethodId(
    r'value',
    r'()Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _value = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public abstract com.github.dart_lang.jnigen.annotations.JsonSerializable$Case value()`
  /// The returned object must be released after use, by calling the [release] method.
  JsonSerializable_Case value() {
    return _value(reference.pointer, _id_value as _$jni.JMethodIDPtr)
        .object(const $JsonSerializable_Case$Type());
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $JsonSerializable> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'value()Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;') {
        final $r = _$impls[$p]!.value();
        return ($r as _$jni.JObject)
            .as(const _$jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $JsonSerializable $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.annotations.JsonSerializable',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory JsonSerializable.implement(
    $JsonSerializable $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return JsonSerializable.fromReference(
      $i.implementReference(),
    );
  }
}

abstract mixin class $JsonSerializable {
  factory $JsonSerializable({
    required JsonSerializable_Case Function() value,
  }) = _$JsonSerializable;

  JsonSerializable_Case value();
}

class _$JsonSerializable implements $JsonSerializable {
  _$JsonSerializable({
    required JsonSerializable_Case Function() value,
  }) : _value = value;

  final JsonSerializable_Case Function() _value;

  JsonSerializable_Case value() {
    return _value();
  }
}

final class $JsonSerializable$Type extends _$jni.JObjType<JsonSerializable> {
  @_$jni.internal
  const $JsonSerializable$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable;';

  @_$jni.internal
  @_$core.override
  JsonSerializable fromReference(_$jni.JReference reference) =>
      JsonSerializable.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($JsonSerializable$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JsonSerializable$Type) &&
        other is $JsonSerializable$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.MyDataClass`
class MyDataClass extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<MyDataClass> $type;

  @_$jni.internal
  MyDataClass.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/MyDataClass');

  /// The type which includes information such as the signature of this class.
  static const type = $MyDataClass$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyDataClass() {
    return MyDataClass.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $MyDataClass$Type extends _$jni.JObjType<MyDataClass> {
  @_$jni.internal
  const $MyDataClass$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/MyDataClass;';

  @_$jni.internal
  @_$core.override
  MyDataClass fromReference(_$jni.JReference reference) =>
      MyDataClass.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($MyDataClass$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyDataClass$Type) &&
        other is $MyDataClass$Type;
  }
}
