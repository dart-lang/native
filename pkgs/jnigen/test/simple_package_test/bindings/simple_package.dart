// Copyright (c) 2022, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

/// from: `com.github.dart_lang.jnigen.simple_package.Example$Nested$NestedTwice`
class Example_Nested_NestedTwice extends jni.JObject {
  @override
  late final jni.JObjType<Example_Nested_NestedTwice> $type = type;

  Example_Nested_NestedTwice.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example$Nested$NestedTwice');

  /// The type which includes information such as the signature of this class.
  static const type = $Example_Nested_NestedTwiceType();
  static final _id_ZERO = _class.staticFieldId(
    r'ZERO',
    r'I',
  );

  /// from: `static public int ZERO`
  static int get ZERO => _id_ZERO.get(_class, const jni.jintType());

  /// from: `static public int ZERO`
  static set ZERO(int value) =>
      _id_ZERO.set(_class, const jni.jintType(), value);

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example_Nested_NestedTwice() {
    return Example_Nested_NestedTwice.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $Example_Nested_NestedTwiceType
    extends jni.JObjType<Example_Nested_NestedTwice> {
  const $Example_Nested_NestedTwiceType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$Nested$NestedTwice;';

  @override
  Example_Nested_NestedTwice fromReference(jni.JReference reference) =>
      Example_Nested_NestedTwice.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Example_Nested_NestedTwiceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example_Nested_NestedTwiceType) &&
        other is $Example_Nested_NestedTwiceType;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Example$Nested`
class Example_Nested extends jni.JObject {
  @override
  late final jni.JObjType<Example_Nested> $type = type;

  Example_Nested.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example$Nested');

  /// The type which includes information such as the signature of this class.
  static const type = $Example_NestedType();
  static final _id_new0 = _class.constructorId(
    r'(Z)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void <init>(boolean value)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example_Nested(
    bool value,
  ) {
    return Example_Nested.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, value ? 1 : 0)
        .reference);
  }

  static final _id_usesAnonymousInnerClass = _class.instanceMethodId(
    r'usesAnonymousInnerClass',
    r'()V',
  );

  static final _usesAnonymousInnerClass = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void usesAnonymousInnerClass()`
  void usesAnonymousInnerClass() {
    _usesAnonymousInnerClass(
            reference.pointer, _id_usesAnonymousInnerClass as jni.JMethodIDPtr)
        .check();
  }

  static final _id_getValue = _class.instanceMethodId(
    r'getValue',
    r'()Z',
  );

  static final _getValue = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getValue()`
  bool getValue() {
    return _getValue(reference.pointer, _id_getValue as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setValue = _class.instanceMethodId(
    r'setValue',
    r'(Z)V',
  );

  static final _setValue = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setValue(boolean value)`
  void setValue(
    bool value,
  ) {
    _setValue(
            reference.pointer, _id_setValue as jni.JMethodIDPtr, value ? 1 : 0)
        .check();
  }
}

final class $Example_NestedType extends jni.JObjType<Example_Nested> {
  const $Example_NestedType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;';

  @override
  Example_Nested fromReference(jni.JReference reference) =>
      Example_Nested.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Example_NestedType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example_NestedType) &&
        other is $Example_NestedType;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Example$NonStaticNested`
class Example_NonStaticNested extends jni.JObject {
  @override
  late final jni.JObjType<Example_NonStaticNested> $type = type;

  Example_NonStaticNested.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example$NonStaticNested');

  /// The type which includes information such as the signature of this class.
  static const type = $Example_NonStaticNestedType();
  static final _id_ok = _class.instanceFieldId(
    r'ok',
    r'Z',
  );

  /// from: `public boolean ok`
  bool get ok => _id_ok.get(this, const jni.jbooleanType());

  /// from: `public boolean ok`
  set ok(bool value) => _id_ok.set(this, const jni.jbooleanType(), value);

  static final _id_new0 = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/simple_package/Example;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.simple_package.Example $parent)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example_NonStaticNested(
    Example $parent,
  ) {
    return Example_NonStaticNested.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, $parent.reference.pointer)
        .reference);
  }
}

final class $Example_NonStaticNestedType
    extends jni.JObjType<Example_NonStaticNested> {
  const $Example_NonStaticNestedType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$NonStaticNested;';

  @override
  Example_NonStaticNested fromReference(jni.JReference reference) =>
      Example_NonStaticNested.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Example_NonStaticNestedType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example_NonStaticNestedType) &&
        other is $Example_NonStaticNestedType;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Example`
class Example extends jni.JObject {
  @override
  late final jni.JObjType<Example> $type = type;

  Example.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/github/dart_lang/jnigen/simple_package/Example');

  /// The type which includes information such as the signature of this class.
  static const type = $ExampleType();

  /// from: `static public final int ON`
  static const ON = 1;

  /// from: `static public final int OFF`
  static const OFF = 0;

  /// from: `static public final double PI`
  static const PI = 3.14159;

  /// from: `static public final char SEMICOLON`
  static const SEMICOLON = 59;
  static final _id_SEMICOLON_STRING = _class.staticFieldId(
    r'SEMICOLON_STRING',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SEMICOLON_STRING`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SEMICOLON_STRING =>
      _id_SEMICOLON_STRING.get(_class, const jni.JStringType());

  static final _id_unusedRandom = _class.staticFieldId(
    r'unusedRandom',
    r'Ljava/util/Random;',
  );

  /// from: `static public final java.util.Random unusedRandom`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get unusedRandom =>
      _id_unusedRandom.get(_class, const jni.JObjectType());

  static final _id_protectedField = _class.instanceFieldId(
    r'protectedField',
    r'Ljava/util/Random;',
  );

  /// from: `protected java.util.Random protectedField`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject get protectedField =>
      _id_protectedField.get(this, const jni.JObjectType());

  /// from: `protected java.util.Random protectedField`
  /// The returned object must be released after use, by calling the [release] method.
  set protectedField(jni.JObject value) =>
      _id_protectedField.set(this, const jni.JObjectType(), value);

  static final _id_getAmount = _class.staticMethodId(
    r'getAmount',
    r'()I',
  );

  static final _getAmount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public int getAmount()`
  static int getAmount() {
    return _getAmount(
            _class.reference.pointer, _id_getAmount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getPi = _class.staticMethodId(
    r'getPi',
    r'()D',
  );

  static final _getPi = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticDoubleMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public double getPi()`
  static double getPi() {
    return _getPi(_class.reference.pointer, _id_getPi as jni.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getAsterisk = _class.staticMethodId(
    r'getAsterisk',
    r'()C',
  );

  static final _getAsterisk = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticCharMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public char getAsterisk()`
  static int getAsterisk() {
    return _getAsterisk(
            _class.reference.pointer, _id_getAsterisk as jni.JMethodIDPtr)
        .char;
  }

  static final _id_getName = _class.staticMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getName() {
    return _getName(_class.reference.pointer, _id_getName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getNestedInstance = _class.staticMethodId(
    r'getNestedInstance',
    r'()Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;',
  );

  static final _getNestedInstance = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.simple_package.Example.Nested getNestedInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static Example_Nested getNestedInstance() {
    return _getNestedInstance(
            _class.reference.pointer, _id_getNestedInstance as jni.JMethodIDPtr)
        .object(const $Example_NestedType());
  }

  static final _id_setAmount = _class.staticMethodId(
    r'setAmount',
    r'(I)V',
  );

  static final _setAmount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `static public void setAmount(int newAmount)`
  static void setAmount(
    int newAmount,
  ) {
    _setAmount(_class.reference.pointer, _id_setAmount as jni.JMethodIDPtr,
            newAmount)
        .check();
  }

  static final _id_setName = _class.staticMethodId(
    r'setName',
    r'(Ljava/lang/String;)V',
  );

  static final _setName = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public void setName(java.lang.String newName)`
  static void setName(
    jni.JString newName,
  ) {
    _setName(_class.reference.pointer, _id_setName as jni.JMethodIDPtr,
            newName.reference.pointer)
        .check();
  }

  static final _id_setNestedInstance = _class.staticMethodId(
    r'setNestedInstance',
    r'(Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;)V',
  );

  static final _setNestedInstance = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public void setNestedInstance(com.github.dart_lang.jnigen.simple_package.Example.Nested newNested)`
  static void setNestedInstance(
    Example_Nested newNested,
  ) {
    _setNestedInstance(
            _class.reference.pointer,
            _id_setNestedInstance as jni.JMethodIDPtr,
            newNested.reference.pointer)
        .check();
  }

  static final _id_max4 = _class.staticMethodId(
    r'max4',
    r'(IIII)I',
  );

  static final _max4 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, $Int32, $Int32)>)>>(
          'globalEnv_CallStaticIntMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int, int)>();

  /// from: `static public int max4(int a, int b, int c, int d)`
  static int max4(
    int a,
    int b,
    int c,
    int d,
  ) {
    return _max4(
            _class.reference.pointer, _id_max4 as jni.JMethodIDPtr, a, b, c, d)
        .integer;
  }

  static final _id_max8 = _class.staticMethodId(
    r'max8',
    r'(IIIIIIII)I',
  );

  static final _max8 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, int, int, int, int, int, int)>();

  /// from: `static public int max8(int a, int b, int c, int d, int e, int f, int g, int h)`
  static int max8(
    int a,
    int b,
    int c,
    int d,
    int e,
    int f,
    int g,
    int h,
  ) {
    return _max8(_class.reference.pointer, _id_max8 as jni.JMethodIDPtr, a, b,
            c, d, e, f, g, h)
        .integer;
  }

  static final _id_getNumber = _class.instanceMethodId(
    r'getNumber',
    r'()I',
  );

  static final _getNumber = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getNumber()`
  int getNumber() {
    return _getNumber(reference.pointer, _id_getNumber as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setNumber = _class.instanceMethodId(
    r'setNumber',
    r'(I)V',
  );

  static final _setNumber = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setNumber(int number)`
  void setNumber(
    int number,
  ) {
    _setNumber(reference.pointer, _id_setNumber as jni.JMethodIDPtr, number)
        .check();
  }

  static final _id_getIsUp = _class.instanceMethodId(
    r'getIsUp',
    r'()Z',
  );

  static final _getIsUp = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getIsUp()`
  bool getIsUp() {
    return _getIsUp(reference.pointer, _id_getIsUp as jni.JMethodIDPtr).boolean;
  }

  static final _id_setUp = _class.instanceMethodId(
    r'setUp',
    r'(Z)V',
  );

  static final _setUp = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setUp(boolean isUp)`
  void setUp(
    bool isUp,
  ) {
    _setUp(reference.pointer, _id_setUp as jni.JMethodIDPtr, isUp ? 1 : 0)
        .check();
  }

  static final _id_getCodename = _class.instanceMethodId(
    r'getCodename',
    r'()Ljava/lang/String;',
  );

  static final _getCodename = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getCodename()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getCodename() {
    return _getCodename(reference.pointer, _id_getCodename as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setCodename = _class.instanceMethodId(
    r'setCodename',
    r'(Ljava/lang/String;)V',
  );

  static final _setCodename = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setCodename(java.lang.String codename)`
  void setCodename(
    jni.JString codename,
  ) {
    _setCodename(reference.pointer, _id_setCodename as jni.JMethodIDPtr,
            codename.reference.pointer)
        .check();
  }

  static final _id_getRandom = _class.instanceMethodId(
    r'getRandom',
    r'()Ljava/util/Random;',
  );

  static final _getRandom = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.Random getRandom()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getRandom() {
    return _getRandom(reference.pointer, _id_getRandom as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setRandom = _class.instanceMethodId(
    r'setRandom',
    r'(Ljava/util/Random;)V',
  );

  static final _setRandom = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setRandom(java.util.Random random)`
  void setRandom(
    jni.JObject random,
  ) {
    _setRandom(reference.pointer, _id_setRandom as jni.JMethodIDPtr,
            random.reference.pointer)
        .check();
  }

  static final _id_getRandomLong = _class.instanceMethodId(
    r'getRandomLong',
    r'()J',
  );

  static final _getRandomLong = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public long getRandomLong()`
  int getRandomLong() {
    return _getRandomLong(
            reference.pointer, _id_getRandomLong as jni.JMethodIDPtr)
        .long;
  }

  static final _id_add4Longs = _class.instanceMethodId(
    r'add4Longs',
    r'(JJJJ)J',
  );

  static final _add4Longs = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int, int, int)>();

  /// from: `public long add4Longs(long a, long b, long c, long d)`
  int add4Longs(
    int a,
    int b,
    int c,
    int d,
  ) {
    return _add4Longs(
            reference.pointer, _id_add4Longs as jni.JMethodIDPtr, a, b, c, d)
        .long;
  }

  static final _id_add8Longs = _class.instanceMethodId(
    r'add8Longs',
    r'(JJJJJJJJ)J',
  );

  static final _add8Longs = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Int64
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, int, int, int, int, int, int)>();

  /// from: `public long add8Longs(long a, long b, long c, long d, long e, long f, long g, long h)`
  int add8Longs(
    int a,
    int b,
    int c,
    int d,
    int e,
    int f,
    int g,
    int h,
  ) {
    return _add8Longs(reference.pointer, _id_add8Longs as jni.JMethodIDPtr, a,
            b, c, d, e, f, g, h)
        .long;
  }

  static final _id_getRandomNumericString = _class.instanceMethodId(
    r'getRandomNumericString',
    r'(Ljava/util/Random;)Ljava/lang/String;',
  );

  static final _getRandomNumericString = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public java.lang.String getRandomNumericString(java.util.Random random)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getRandomNumericString(
    jni.JObject random,
  ) {
    return _getRandomNumericString(
            reference.pointer,
            _id_getRandomNumericString as jni.JMethodIDPtr,
            random.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_protectedMethod = _class.instanceMethodId(
    r'protectedMethod',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _protectedMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `protected void protectedMethod(java.lang.String a, java.lang.String b)`
  void protectedMethod(
    jni.JString a,
    jni.JString b,
  ) {
    _protectedMethod(reference.pointer, _id_protectedMethod as jni.JMethodIDPtr,
            a.reference.pointer, b.reference.pointer)
        .check();
  }

  static final _id_finalMethod = _class.instanceMethodId(
    r'finalMethod',
    r'()V',
  );

  static final _finalMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public final void finalMethod()`
  void finalMethod() {
    _finalMethod(reference.pointer, _id_finalMethod as jni.JMethodIDPtr)
        .check();
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<java.lang.String> getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> getList() {
    return _getList(reference.pointer, _id_getList as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _id_joinStrings = _class.instanceMethodId(
    r'joinStrings',
    r'(Ljava/util/List;Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _joinStrings = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public java.lang.String joinStrings(java.util.List<java.lang.String> values, java.lang.String delim)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Joins the strings in the list using the given delimiter.
  jni.JString joinStrings(
    jni.JList<jni.JString> values,
    jni.JString delim,
  ) {
    return _joinStrings(reference.pointer, _id_joinStrings as jni.JMethodIDPtr,
            values.reference.pointer, delim.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_methodWithSeveralParams = _class.instanceMethodId(
    r'methodWithSeveralParams',
    r'(CLjava/lang/String;[ILjava/lang/CharSequence;Ljava/util/List;Ljava/util/Map;)V',
  );

  static final _methodWithSeveralParams = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void methodWithSeveralParams(char ch, java.lang.String s, int[] a, T t, java.util.List<T> lt, java.util.Map<java.lang.String,? extends java.lang.CharSequence> wm)`
  void methodWithSeveralParams<$T extends jni.JObject>(
    int ch,
    jni.JString s,
    jni.JArray<jni.jint> a,
    $T t,
    jni.JList<$T> lt,
    jni.JMap<jni.JString, jni.JObject> wm, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      (lt.$type as jni.JListType).E,
      t.$type,
    ]) as jni.JObjType<$T>;
    _methodWithSeveralParams(
            reference.pointer,
            _id_methodWithSeveralParams as jni.JMethodIDPtr,
            ch,
            s.reference.pointer,
            a.reference.pointer,
            t.reference.pointer,
            lt.reference.pointer,
            wm.reference.pointer)
        .check();
  }

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example() {
    return Example.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(I)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void <init>(int number)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new1(
    int number,
  ) {
    return Example.fromReference(
        _new1(_class.reference.pointer, _id_new1 as jni.JMethodIDPtr, number)
            .reference);
  }

  static final _id_new2 = _class.constructorId(
    r'(IZ)V',
  );

  static final _new2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, $Int32)>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: `public void <init>(int number, boolean isUp)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new2(
    int number,
    bool isUp,
  ) {
    return Example.fromReference(_new2(_class.reference.pointer,
            _id_new2 as jni.JMethodIDPtr, number, isUp ? 1 : 0)
        .reference);
  }

  static final _id_new3 = _class.constructorId(
    r'(IZLjava/lang/String;)V',
  );

  static final _new3 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(int number, boolean isUp, java.lang.String codename)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new3(
    int number,
    bool isUp,
    jni.JString codename,
  ) {
    return Example.fromReference(_new3(
            _class.reference.pointer,
            _id_new3 as jni.JMethodIDPtr,
            number,
            isUp ? 1 : 0,
            codename.reference.pointer)
        .reference);
  }

  static final _id_new4 = _class.constructorId(
    r'(IIIIIIII)V',
  );

  static final _new4 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, int, int, int, int, int, int)>();

  /// from: `public void <init>(int a, int b, int c, int d, int e, int f, int g, int h)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new4(
    int a,
    int b,
    int c,
    int d,
    int e,
    int f,
    int g,
    int h,
  ) {
    return Example.fromReference(_new4(_class.reference.pointer,
            _id_new4 as jni.JMethodIDPtr, a, b, c, d, e, f, g, h)
        .reference);
  }

  static final _id_whichExample = _class.instanceMethodId(
    r'whichExample',
    r'()I',
  );

  static final _whichExample = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int whichExample()`
  int whichExample() {
    return _whichExample(
            reference.pointer, _id_whichExample as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_addInts = _class.staticMethodId(
    r'addInts',
    r'(II)I',
  );

  static final _addInts = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr, ffi.VarArgs<($Int32, $Int32)>)>>(
          'globalEnv_CallStaticIntMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: `static public int addInts(int a, int b)`
  static int addInts(
    int a,
    int b,
  ) {
    return _addInts(
            _class.reference.pointer, _id_addInts as jni.JMethodIDPtr, a, b)
        .integer;
  }

  static final _id_getArr = _class.staticMethodId(
    r'getArr',
    r'()[I',
  );

  static final _getArr = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public int[] getArr()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> getArr() {
    return _getArr(_class.reference.pointer, _id_getArr as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_addAll = _class.staticMethodId(
    r'addAll',
    r'([I)I',
  );

  static final _addAll = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public int addAll(int[] arr)`
  static int addAll(
    jni.JArray<jni.jint> arr,
  ) {
    return _addAll(_class.reference.pointer, _id_addAll as jni.JMethodIDPtr,
            arr.reference.pointer)
        .integer;
  }

  static final _id_getSelf = _class.instanceMethodId(
    r'getSelf',
    r'()Lcom/github/dart_lang/jnigen/simple_package/Example;',
  );

  static final _getSelf = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.simple_package.Example getSelf()`
  /// The returned object must be released after use, by calling the [release] method.
  Example getSelf() {
    return _getSelf(reference.pointer, _id_getSelf as jni.JMethodIDPtr)
        .object(const $ExampleType());
  }

  static final _id_throwException = _class.staticMethodId(
    r'throwException',
    r'()V',
  );

  static final _throwException = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public void throwException()`
  static void throwException() {
    _throwException(
            _class.reference.pointer, _id_throwException as jni.JMethodIDPtr)
        .check();
  }

  static final _id_overloaded = _class.instanceMethodId(
    r'overloaded',
    r'()V',
  );

  static final _overloaded = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void overloaded()`
  void overloaded() {
    _overloaded(reference.pointer, _id_overloaded as jni.JMethodIDPtr).check();
  }

  static final _id_overloaded1 = _class.instanceMethodId(
    r'overloaded',
    r'(ILjava/lang/String;)V',
  );

  static final _overloaded1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: `public void overloaded(int a, java.lang.String b)`
  void overloaded1(
    int a,
    jni.JString b,
  ) {
    _overloaded1(reference.pointer, _id_overloaded1 as jni.JMethodIDPtr, a,
            b.reference.pointer)
        .check();
  }

  static final _id_overloaded2 = _class.instanceMethodId(
    r'overloaded',
    r'(I)V',
  );

  static final _overloaded2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void overloaded(int a)`
  void overloaded2(
    int a,
  ) {
    _overloaded2(reference.pointer, _id_overloaded2 as jni.JMethodIDPtr, a)
        .check();
  }

  static final _id_overloaded3 = _class.instanceMethodId(
    r'overloaded',
    r'(Ljava/util/List;Ljava/lang/String;)V',
  );

  static final _overloaded3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public void overloaded(java.util.List<java.lang.Integer> a, java.lang.String b)`
  void overloaded3(
    jni.JList<jni.JInteger> a,
    jni.JString b,
  ) {
    _overloaded3(reference.pointer, _id_overloaded3 as jni.JMethodIDPtr,
            a.reference.pointer, b.reference.pointer)
        .check();
  }

  static final _id_overloaded4 = _class.instanceMethodId(
    r'overloaded',
    r'(Ljava/util/List;)V',
  );

  static final _overloaded4 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void overloaded(java.util.List<java.lang.Integer> a)`
  void overloaded4(
    jni.JList<jni.JInteger> a,
  ) {
    _overloaded4(reference.pointer, _id_overloaded4 as jni.JMethodIDPtr,
            a.reference.pointer)
        .check();
  }
}

final class $ExampleType extends jni.JObjType<Example> {
  const $ExampleType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example;';

  @override
  Example fromReference(jni.JReference reference) =>
      Example.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExampleType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ExampleType) && other is $ExampleType;
  }
}

/// from: `com.github.dart_lang.jnigen.pkg2.C2`
class C2 extends jni.JObject {
  @override
  late final jni.JObjType<C2> $type = type;

  C2.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/github/dart_lang/jnigen/pkg2/C2');

  /// The type which includes information such as the signature of this class.
  static const type = $C2Type();
  static final _id_CONSTANT = _class.staticFieldId(
    r'CONSTANT',
    r'I',
  );

  /// from: `static public int CONSTANT`
  static int get CONSTANT => _id_CONSTANT.get(_class, const jni.jintType());

  /// from: `static public int CONSTANT`
  static set CONSTANT(int value) =>
      _id_CONSTANT.set(_class, const jni.jintType(), value);

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory C2() {
    return C2.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $C2Type extends jni.JObjType<C2> {
  const $C2Type();

  @override
  String get signature => r'Lcom/github/dart_lang/jnigen/pkg2/C2;';

  @override
  C2 fromReference(jni.JReference reference) => C2.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($C2Type).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($C2Type) && other is $C2Type;
  }
}

/// from: `com.github.dart_lang.jnigen.pkg2.Example`
class Example1 extends jni.JObject {
  @override
  late final jni.JObjType<Example1> $type = type;

  Example1.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/github/dart_lang/jnigen/pkg2/Example');

  /// The type which includes information such as the signature of this class.
  static const type = $Example1Type();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example1() {
    return Example1.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_whichExample = _class.instanceMethodId(
    r'whichExample',
    r'()I',
  );

  static final _whichExample = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int whichExample()`
  int whichExample() {
    return _whichExample(
            reference.pointer, _id_whichExample as jni.JMethodIDPtr)
        .integer;
  }
}

final class $Example1Type extends jni.JObjType<Example1> {
  const $Example1Type();

  @override
  String get signature => r'Lcom/github/dart_lang/jnigen/pkg2/Example;';

  @override
  Example1 fromReference(jni.JReference reference) =>
      Example1.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Example1Type).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example1Type) && other is $Example1Type;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$Parent$Child`
class GrandParent_Parent_Child<$T extends jni.JObject, $S extends jni.JObject,
    $U extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<GrandParent_Parent_Child<$T, $S, $U>> $type =
      type(T, S, U);

  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  GrandParent_Parent_Child.fromReference(
    this.T,
    this.S,
    this.U,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$Parent$Child');

  /// The type which includes information such as the signature of this class.
  static $GrandParent_Parent_ChildType<$T, $S, $U> type<$T extends jni.JObject,
      $S extends jni.JObject, $U extends jni.JObject>(
    jni.JObjType<$T> T,
    jni.JObjType<$S> S,
    jni.JObjType<$U> U,
  ) {
    return $GrandParent_Parent_ChildType(
      T,
      S,
      U,
    );
  }

  static final _id_grandParentValue = _class.instanceFieldId(
    r'grandParentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public T grandParentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $T get grandParentValue => _id_grandParentValue.get(this, T);

  /// from: `public T grandParentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set grandParentValue($T value) => _id_grandParentValue.set(this, T, value);

  static final _id_parentValue = _class.instanceFieldId(
    r'parentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $S get parentValue => _id_parentValue.get(this, S);

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($S value) => _id_parentValue.set(this, S, value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  $U get value => _id_value.get(this, U);

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($U value) => _id_value.set(this, U, value);

  static final _id_new0 = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;Ljava/lang/Object;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.GrandParent$Parent $parent, U newValue)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_Parent_Child(
    GrandParent_Parent<$T, $S> $parent,
    $U newValue, {
    jni.JObjType<$T>? T,
    jni.JObjType<$S>? S,
    jni.JObjType<$U>? U,
  }) {
    T ??= jni.lowestCommonSuperType([
      ($parent.$type as $GrandParent_ParentType).T,
    ]) as jni.JObjType<$T>;
    S ??= jni.lowestCommonSuperType([
      ($parent.$type as $GrandParent_ParentType).S,
    ]) as jni.JObjType<$S>;
    U ??= jni.lowestCommonSuperType([
      newValue.$type,
    ]) as jni.JObjType<$U>;
    return GrandParent_Parent_Child.fromReference(
        T,
        S,
        U,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr,
                $parent.reference.pointer, newValue.reference.pointer)
            .reference);
  }
}

final class $GrandParent_Parent_ChildType<$T extends jni.JObject,
        $S extends jni.JObject, $U extends jni.JObject>
    extends jni.JObjType<GrandParent_Parent_Child<$T, $S, $U>> {
  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  const $GrandParent_Parent_ChildType(
    this.T,
    this.S,
    this.U,
  );

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent$Child;';

  @override
  GrandParent_Parent_Child<$T, $S, $U> fromReference(
          jni.JReference reference) =>
      GrandParent_Parent_Child.fromReference(T, S, U, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParent_Parent_ChildType, T, S, U);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent_Parent_ChildType<$T, $S, $U>) &&
        other is $GrandParent_Parent_ChildType<$T, $S, $U> &&
        T == other.T &&
        S == other.S &&
        U == other.U;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$Parent`
class GrandParent_Parent<$T extends jni.JObject, $S extends jni.JObject>
    extends jni.JObject {
  @override
  late final jni.JObjType<GrandParent_Parent<$T, $S>> $type = type(T, S);

  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;

  GrandParent_Parent.fromReference(
    this.T,
    this.S,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$Parent');

  /// The type which includes information such as the signature of this class.
  static $GrandParent_ParentType<$T, $S>
      type<$T extends jni.JObject, $S extends jni.JObject>(
    jni.JObjType<$T> T,
    jni.JObjType<$S> S,
  ) {
    return $GrandParent_ParentType(
      T,
      S,
    );
  }

  static final _id_parentValue = _class.instanceFieldId(
    r'parentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public T parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $T get parentValue => _id_parentValue.get(this, T);

  /// from: `public T parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($T value) => _id_parentValue.set(this, T, value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  $S get value => _id_value.get(this, S);

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($S value) => _id_value.set(this, S, value);

  static final _id_new0 = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/GrandParent;Ljava/lang/Object;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.GrandParent $parent, S newValue)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_Parent(
    GrandParent<$T> $parent,
    $S newValue, {
    jni.JObjType<$T>? T,
    jni.JObjType<$S>? S,
  }) {
    T ??= jni.lowestCommonSuperType([
      ($parent.$type as $GrandParentType).T,
    ]) as jni.JObjType<$T>;
    S ??= jni.lowestCommonSuperType([
      newValue.$type,
    ]) as jni.JObjType<$S>;
    return GrandParent_Parent.fromReference(
        T,
        S,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr,
                $parent.reference.pointer, newValue.reference.pointer)
            .reference);
  }
}

final class $GrandParent_ParentType<$T extends jni.JObject,
    $S extends jni.JObject> extends jni.JObjType<GrandParent_Parent<$T, $S>> {
  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;

  const $GrandParent_ParentType(
    this.T,
    this.S,
  );

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;';

  @override
  GrandParent_Parent<$T, $S> fromReference(jni.JReference reference) =>
      GrandParent_Parent.fromReference(T, S, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParent_ParentType, T, S);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent_ParentType<$T, $S>) &&
        other is $GrandParent_ParentType<$T, $S> &&
        T == other.T &&
        S == other.S;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$StaticParent$Child`
class GrandParent_StaticParent_Child<$S extends jni.JObject,
    $U extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<GrandParent_StaticParent_Child<$S, $U>> $type =
      type(S, U);

  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  GrandParent_StaticParent_Child.fromReference(
    this.S,
    this.U,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child');

  /// The type which includes information such as the signature of this class.
  static $GrandParent_StaticParent_ChildType<$S, $U>
      type<$S extends jni.JObject, $U extends jni.JObject>(
    jni.JObjType<$S> S,
    jni.JObjType<$U> U,
  ) {
    return $GrandParent_StaticParent_ChildType(
      S,
      U,
    );
  }

  static final _id_parentValue = _class.instanceFieldId(
    r'parentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $S get parentValue => _id_parentValue.get(this, S);

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($S value) => _id_parentValue.set(this, S, value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  $U get value => _id_value.get(this, U);

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($U value) => _id_value.set(this, U, value);

  static final _id_new0 = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.GrandParent$StaticParent $parent, S parentValue, U value)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_StaticParent_Child(
    GrandParent_StaticParent<$S> $parent,
    $S parentValue,
    $U value, {
    jni.JObjType<$S>? S,
    jni.JObjType<$U>? U,
  }) {
    S ??= jni.lowestCommonSuperType([
      parentValue.$type,
      ($parent.$type as $GrandParent_StaticParentType).S,
    ]) as jni.JObjType<$S>;
    U ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$U>;
    return GrandParent_StaticParent_Child.fromReference(
        S,
        U,
        _new0(
                _class.reference.pointer,
                _id_new0 as jni.JMethodIDPtr,
                $parent.reference.pointer,
                parentValue.reference.pointer,
                value.reference.pointer)
            .reference);
  }
}

final class $GrandParent_StaticParent_ChildType<$S extends jni.JObject,
        $U extends jni.JObject>
    extends jni.JObjType<GrandParent_StaticParent_Child<$S, $U>> {
  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  const $GrandParent_StaticParent_ChildType(
    this.S,
    this.U,
  );

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child;';

  @override
  GrandParent_StaticParent_Child<$S, $U> fromReference(
          jni.JReference reference) =>
      GrandParent_StaticParent_Child.fromReference(S, U, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParent_StaticParent_ChildType, S, U);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent_StaticParent_ChildType<$S, $U>) &&
        other is $GrandParent_StaticParent_ChildType<$S, $U> &&
        S == other.S &&
        U == other.U;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$StaticParent`
class GrandParent_StaticParent<$S extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<GrandParent_StaticParent<$S>> $type = type(S);

  final jni.JObjType<$S> S;

  GrandParent_StaticParent.fromReference(
    this.S,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$StaticParent');

  /// The type which includes information such as the signature of this class.
  static $GrandParent_StaticParentType<$S> type<$S extends jni.JObject>(
    jni.JObjType<$S> S,
  ) {
    return $GrandParent_StaticParentType(
      S,
    );
  }

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  $S get value => _id_value.get(this, S);

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($S value) => _id_value.set(this, S, value);

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/Object;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(S value)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent_StaticParent(
    $S value, {
    jni.JObjType<$S>? S,
  }) {
    S ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$S>;
    return GrandParent_StaticParent.fromReference(
        S,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr,
                value.reference.pointer)
            .reference);
  }
}

final class $GrandParent_StaticParentType<$S extends jni.JObject>
    extends jni.JObjType<GrandParent_StaticParent<$S>> {
  final jni.JObjType<$S> S;

  const $GrandParent_StaticParentType(
    this.S,
  );

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;';

  @override
  GrandParent_StaticParent<$S> fromReference(jni.JReference reference) =>
      GrandParent_StaticParent.fromReference(S, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParent_StaticParentType, S);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent_StaticParentType<$S>) &&
        other is $GrandParent_StaticParentType<$S> &&
        S == other.S;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent`
class GrandParent<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<GrandParent<$T>> $type = type(T);

  final jni.JObjType<$T> T;

  GrandParent.fromReference(
    this.T,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/github/dart_lang/jnigen/generics/GrandParent');

  /// The type which includes information such as the signature of this class.
  static $GrandParentType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $GrandParentType(
      T,
    );
  }

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public T value`
  /// The returned object must be released after use, by calling the [release] method.
  $T get value => _id_value.get(this, T);

  /// from: `public T value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($T value) => _id_value.set(this, T, value);

  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/Object;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(T value)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent(
    $T value, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$T>;
    return GrandParent.fromReference(
        T,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr,
                value.reference.pointer)
            .reference);
  }

  static final _id_stringParent = _class.instanceMethodId(
    r'stringParent',
    r'()Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;',
  );

  static final _stringParent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.generics.GrandParent<T>.Parent<java.lang.String> stringParent()`
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent_Parent<jni.JObject, jni.JString> stringParent() {
    return _stringParent(
            reference.pointer, _id_stringParent as jni.JMethodIDPtr)
        .object(const $GrandParent_ParentType(
            jni.JObjectType(), jni.JStringType()));
  }

  static final _id_varParent = _class.instanceMethodId(
    r'varParent',
    r'(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;',
  );

  static final _varParent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public com.github.dart_lang.jnigen.generics.GrandParent<T>.Parent<S> varParent(S nestedValue)`
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent_Parent<jni.JObject, $S> varParent<$S extends jni.JObject>(
    $S nestedValue, {
    jni.JObjType<$S>? S,
  }) {
    S ??= jni.lowestCommonSuperType([
      nestedValue.$type,
    ]) as jni.JObjType<$S>;
    return _varParent(reference.pointer, _id_varParent as jni.JMethodIDPtr,
            nestedValue.reference.pointer)
        .object($GrandParent_ParentType(const jni.JObjectType(), S));
  }

  static final _id_stringStaticParent = _class.staticMethodId(
    r'stringStaticParent',
    r'()Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;',
  );

  static final _stringStaticParent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<java.lang.String> stringStaticParent()`
  /// The returned object must be released after use, by calling the [release] method.
  static GrandParent_StaticParent<jni.JString> stringStaticParent() {
    return _stringStaticParent(_class.reference.pointer,
            _id_stringStaticParent as jni.JMethodIDPtr)
        .object(const $GrandParent_StaticParentType(jni.JStringType()));
  }

  static final _id_varStaticParent = _class.staticMethodId(
    r'varStaticParent',
    r'(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;',
  );

  static final _varStaticParent = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<S> varStaticParent(S value)`
  /// The returned object must be released after use, by calling the [release] method.
  static GrandParent_StaticParent<$S> varStaticParent<$S extends jni.JObject>(
    $S value, {
    jni.JObjType<$S>? S,
  }) {
    S ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$S>;
    return _varStaticParent(_class.reference.pointer,
            _id_varStaticParent as jni.JMethodIDPtr, value.reference.pointer)
        .object($GrandParent_StaticParentType(S));
  }

  static final _id_staticParentWithSameType = _class.instanceMethodId(
    r'staticParentWithSameType',
    r'()Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;',
  );

  static final _staticParentWithSameType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<T> staticParentWithSameType()`
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent_StaticParent<$T> staticParentWithSameType() {
    return _staticParentWithSameType(
            reference.pointer, _id_staticParentWithSameType as jni.JMethodIDPtr)
        .object($GrandParent_StaticParentType(T));
  }
}

final class $GrandParentType<$T extends jni.JObject>
    extends jni.JObjType<GrandParent<$T>> {
  final jni.JObjType<$T> T;

  const $GrandParentType(
    this.T,
  );

  @override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/GrandParent;';

  @override
  GrandParent<$T> fromReference(jni.JReference reference) =>
      GrandParent.fromReference(T, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParentType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParentType<$T>) &&
        other is $GrandParentType<$T> &&
        T == other.T;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.MyMap$MyEntry`
class MyMap_MyEntry<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObject {
  @override
  late final jni.JObjType<MyMap_MyEntry<$K, $V>> $type = type(K, V);

  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  MyMap_MyEntry.fromReference(
    this.K,
    this.V,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/github/dart_lang/jnigen/generics/MyMap$MyEntry');

  /// The type which includes information such as the signature of this class.
  static $MyMap_MyEntryType<$K, $V>
      type<$K extends jni.JObject, $V extends jni.JObject>(
    jni.JObjType<$K> K,
    jni.JObjType<$V> V,
  ) {
    return $MyMap_MyEntryType(
      K,
      V,
    );
  }

  static final _id_key = _class.instanceFieldId(
    r'key',
    r'Ljava/lang/Object;',
  );

  /// from: `public K key`
  /// The returned object must be released after use, by calling the [release] method.
  $K get key => _id_key.get(this, K);

  /// from: `public K key`
  /// The returned object must be released after use, by calling the [release] method.
  set key($K value) => _id_key.set(this, K, value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public V value`
  /// The returned object must be released after use, by calling the [release] method.
  $V get value => _id_value.get(this, V);

  /// from: `public V value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($V value) => _id_value.set(this, V, value);

  static final _id_new0 = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/MyMap;Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.MyMap $parent, K key, V value)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyMap_MyEntry(
    MyMap<$K, $V> $parent,
    $K key,
    $V value, {
    jni.JObjType<$K>? K,
    jni.JObjType<$V>? V,
  }) {
    K ??= jni.lowestCommonSuperType([
      key.$type,
      ($parent.$type as $MyMapType).K,
    ]) as jni.JObjType<$K>;
    V ??= jni.lowestCommonSuperType([
      value.$type,
      ($parent.$type as $MyMapType).V,
    ]) as jni.JObjType<$V>;
    return MyMap_MyEntry.fromReference(
        K,
        V,
        _new0(
                _class.reference.pointer,
                _id_new0 as jni.JMethodIDPtr,
                $parent.reference.pointer,
                key.reference.pointer,
                value.reference.pointer)
            .reference);
  }
}

final class $MyMap_MyEntryType<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObjType<MyMap_MyEntry<$K, $V>> {
  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  const $MyMap_MyEntryType(
    this.K,
    this.V,
  );

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/MyMap$MyEntry;';

  @override
  MyMap_MyEntry<$K, $V> fromReference(jni.JReference reference) =>
      MyMap_MyEntry.fromReference(K, V, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($MyMap_MyEntryType, K, V);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyMap_MyEntryType<$K, $V>) &&
        other is $MyMap_MyEntryType<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.MyMap`
class MyMap<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObject {
  @override
  late final jni.JObjType<MyMap<$K, $V>> $type = type(K, V);

  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  MyMap.fromReference(
    this.K,
    this.V,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/github/dart_lang/jnigen/generics/MyMap');

  /// The type which includes information such as the signature of this class.
  static $MyMapType<$K, $V>
      type<$K extends jni.JObject, $V extends jni.JObject>(
    jni.JObjType<$K> K,
    jni.JObjType<$V> V,
  ) {
    return $MyMapType(
      K,
      V,
    );
  }

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyMap({
    required jni.JObjType<$K> K,
    required jni.JObjType<$V> V,
  }) {
    return MyMap.fromReference(
        K,
        V,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_get0 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _get0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public V get(K key)`
  /// The returned object must be released after use, by calling the [release] method.
  $V get0(
    $K key,
  ) {
    return _get0(reference.pointer, _id_get0 as jni.JMethodIDPtr,
            key.reference.pointer)
        .object(V);
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _put = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public V put(K key, V value)`
  /// The returned object must be released after use, by calling the [release] method.
  $V put(
    $K key,
    $V value,
  ) {
    return _put(reference.pointer, _id_put as jni.JMethodIDPtr,
            key.reference.pointer, value.reference.pointer)
        .object(V);
  }

  static final _id_entryStack = _class.instanceMethodId(
    r'entryStack',
    r'()Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _entryStack = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.generics.MyStack<com.github.dart_lang.jnigen.generics.MyMap<K,V>.MyEntry> entryStack()`
  /// The returned object must be released after use, by calling the [release] method.
  MyStack<MyMap_MyEntry<jni.JObject, jni.JObject>> entryStack() {
    return _entryStack(reference.pointer, _id_entryStack as jni.JMethodIDPtr)
        .object(const $MyStackType(
            $MyMap_MyEntryType(jni.JObjectType(), jni.JObjectType())));
  }
}

final class $MyMapType<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObjType<MyMap<$K, $V>> {
  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  const $MyMapType(
    this.K,
    this.V,
  );

  @override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/MyMap;';

  @override
  MyMap<$K, $V> fromReference(jni.JReference reference) =>
      MyMap.fromReference(K, V, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($MyMapType, K, V);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyMapType<$K, $V>) &&
        other is $MyMapType<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.MyStack`
class MyStack<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<MyStack<$T>> $type = type(T);

  final jni.JObjType<$T> T;

  MyStack.fromReference(
    this.T,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/github/dart_lang/jnigen/generics/MyStack');

  /// The type which includes information such as the signature of this class.
  static $MyStackType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $MyStackType(
      T,
    );
  }

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyStack({
    required jni.JObjType<$T> T,
  }) {
    return MyStack.fromReference(
        T,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_fromArray = _class.staticMethodId(
    r'fromArray',
    r'([Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _fromArray = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<T> fromArray(T[] arr)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T> fromArray<$T extends jni.JObject>(
    jni.JArray<$T> arr, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      ((arr.$type as jni.JArrayType).elementType as jni.JObjType),
    ]) as jni.JObjType<$T>;
    return _fromArray(_class.reference.pointer,
            _id_fromArray as jni.JMethodIDPtr, arr.reference.pointer)
        .object($MyStackType(T));
  }

  static final _id_fromArrayOfArrayOfGrandParents = _class.staticMethodId(
    r'fromArrayOfArrayOfGrandParents',
    r'([[Lcom/github/dart_lang/jnigen/generics/GrandParent;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _fromArrayOfArrayOfGrandParents = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<S> fromArrayOfArrayOfGrandParents(com.github.dart_lang.jnigen.generics.GrandParent<S>[][] arr)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$S> fromArrayOfArrayOfGrandParents<$S extends jni.JObject>(
    jni.JArray<jni.JArray<GrandParent<$S>>> arr, {
    jni.JObjType<$S>? S,
  }) {
    S ??= jni.lowestCommonSuperType([
      (((((arr.$type as jni.JArrayType).elementType as jni.JObjType)
                  as jni.JArrayType)
              .elementType as jni.JObjType) as $GrandParentType)
          .T,
    ]) as jni.JObjType<$S>;
    return _fromArrayOfArrayOfGrandParents(
            _class.reference.pointer,
            _id_fromArrayOfArrayOfGrandParents as jni.JMethodIDPtr,
            arr.reference.pointer)
        .object($MyStackType(S));
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'()Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _of = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<T> of()`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T> of<$T extends jni.JObject>({
    required jni.JObjType<$T> T,
  }) {
    return _of(_class.reference.pointer, _id_of as jni.JMethodIDPtr)
        .object($MyStackType(T));
  }

  static final _id_of1 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _of1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<T> of(T obj)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T> of1<$T extends jni.JObject>(
    $T obj, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      obj.$type,
    ]) as jni.JObjType<$T>;
    return _of1(_class.reference.pointer, _id_of1 as jni.JMethodIDPtr,
            obj.reference.pointer)
        .object($MyStackType(T));
  }

  static final _id_of2 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _of2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack<T> of(T obj, T obj2)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T> of2<$T extends jni.JObject>(
    $T obj,
    $T obj2, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      obj2.$type,
      obj.$type,
    ]) as jni.JObjType<$T>;
    return _of2(_class.reference.pointer, _id_of2 as jni.JMethodIDPtr,
            obj.reference.pointer, obj2.reference.pointer)
        .object($MyStackType(T));
  }

  static final _id_push = _class.instanceMethodId(
    r'push',
    r'(Ljava/lang/Object;)V',
  );

  static final _push = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void push(T item)`
  void push(
    $T item,
  ) {
    _push(reference.pointer, _id_push as jni.JMethodIDPtr,
            item.reference.pointer)
        .check();
  }

  static final _id_pop = _class.instanceMethodId(
    r'pop',
    r'()Ljava/lang/Object;',
  );

  static final _pop = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public T pop()`
  /// The returned object must be released after use, by calling the [release] method.
  $T pop() {
    return _pop(reference.pointer, _id_pop as jni.JMethodIDPtr).object(T);
  }

  static final _id_size = _class.instanceMethodId(
    r'size',
    r'()I',
  );

  static final _size = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int size()`
  int size() {
    return _size(reference.pointer, _id_size as jni.JMethodIDPtr).integer;
  }
}

final class $MyStackType<$T extends jni.JObject>
    extends jni.JObjType<MyStack<$T>> {
  final jni.JObjType<$T> T;

  const $MyStackType(
    this.T,
  );

  @override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/MyStack;';

  @override
  MyStack<$T> fromReference(jni.JReference reference) =>
      MyStack.fromReference(T, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($MyStackType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyStackType<$T>) &&
        other is $MyStackType<$T> &&
        T == other.T;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.StringKeyedMap`
class StringKeyedMap<$V extends jni.JObject> extends MyMap<jni.JString, $V> {
  @override
  late final jni.JObjType<StringKeyedMap<$V>> $type = type(V);

  final jni.JObjType<$V> V;

  StringKeyedMap.fromReference(
    this.V,
    jni.JReference reference,
  ) : super.fromReference(const jni.JStringType(), V, reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/StringKeyedMap');

  /// The type which includes information such as the signature of this class.
  static $StringKeyedMapType<$V> type<$V extends jni.JObject>(
    jni.JObjType<$V> V,
  ) {
    return $StringKeyedMapType(
      V,
    );
  }

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringKeyedMap({
    required jni.JObjType<$V> V,
  }) {
    return StringKeyedMap.fromReference(
        V,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $StringKeyedMapType<$V extends jni.JObject>
    extends jni.JObjType<StringKeyedMap<$V>> {
  final jni.JObjType<$V> V;

  const $StringKeyedMapType(
    this.V,
  );

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/StringKeyedMap;';

  @override
  StringKeyedMap<$V> fromReference(jni.JReference reference) =>
      StringKeyedMap.fromReference(V, reference);

  @override
  jni.JObjType get superType => $MyMapType(const jni.JStringType(), V);

  @override
  final superCount = 2;

  @override
  int get hashCode => Object.hash($StringKeyedMapType, V);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringKeyedMapType<$V>) &&
        other is $StringKeyedMapType<$V> &&
        V == other.V;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.StringStack`
class StringStack extends MyStack<jni.JString> {
  @override
  late final jni.JObjType<StringStack> $type = type;

  StringStack.fromReference(
    jni.JReference reference,
  ) : super.fromReference(const jni.JStringType(), reference);

  static final _class =
      jni.JClass.forName(r'com/github/dart_lang/jnigen/generics/StringStack');

  /// The type which includes information such as the signature of this class.
  static const type = $StringStackType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringStack() {
    return StringStack.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $StringStackType extends jni.JObjType<StringStack> {
  const $StringStackType();

  @override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/StringStack;';

  @override
  StringStack fromReference(jni.JReference reference) =>
      StringStack.fromReference(reference);

  @override
  jni.JObjType get superType => const $MyStackType(jni.JStringType());

  @override
  final superCount = 2;

  @override
  int get hashCode => ($StringStackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringStackType) && other is $StringStackType;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.StringValuedMap`
class StringValuedMap<$K extends jni.JObject> extends MyMap<$K, jni.JString> {
  @override
  late final jni.JObjType<StringValuedMap<$K>> $type = type(K);

  final jni.JObjType<$K> K;

  StringValuedMap.fromReference(
    this.K,
    jni.JReference reference,
  ) : super.fromReference(K, const jni.JStringType(), reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/StringValuedMap');

  /// The type which includes information such as the signature of this class.
  static $StringValuedMapType<$K> type<$K extends jni.JObject>(
    jni.JObjType<$K> K,
  ) {
    return $StringValuedMapType(
      K,
    );
  }

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringValuedMap({
    required jni.JObjType<$K> K,
  }) {
    return StringValuedMap.fromReference(
        K,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $StringValuedMapType<$K extends jni.JObject>
    extends jni.JObjType<StringValuedMap<$K>> {
  final jni.JObjType<$K> K;

  const $StringValuedMapType(
    this.K,
  );

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/StringValuedMap;';

  @override
  StringValuedMap<$K> fromReference(jni.JReference reference) =>
      StringValuedMap.fromReference(K, reference);

  @override
  jni.JObjType get superType => $MyMapType(K, const jni.JStringType());

  @override
  final superCount = 2;

  @override
  int get hashCode => Object.hash($StringValuedMapType, K);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringValuedMapType<$K>) &&
        other is $StringValuedMapType<$K> &&
        K == other.K;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyInterface`
class MyInterface<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<MyInterface<$T>> $type = type(T);

  final jni.JObjType<$T> T;

  MyInterface.fromReference(
    this.T,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/github/dart_lang/jnigen/interfaces/MyInterface');

  /// The type which includes information such as the signature of this class.
  static $MyInterfaceType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $MyInterfaceType(
      T,
    );
  }

  static final _id_voidCallback = _class.instanceMethodId(
    r'voidCallback',
    r'(Ljava/lang/String;)V',
  );

  static final _voidCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void voidCallback(java.lang.String s)`
  void voidCallback(
    jni.JString s,
  ) {
    _voidCallback(reference.pointer, _id_voidCallback as jni.JMethodIDPtr,
            s.reference.pointer)
        .check();
  }

  static final _id_stringCallback = _class.instanceMethodId(
    r'stringCallback',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _stringCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract java.lang.String stringCallback(java.lang.String s)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString stringCallback(
    jni.JString s,
  ) {
    return _stringCallback(reference.pointer,
            _id_stringCallback as jni.JMethodIDPtr, s.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_varCallback = _class.instanceMethodId(
    r'varCallback',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _varCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract T varCallback(T t)`
  /// The returned object must be released after use, by calling the [release] method.
  $T varCallback(
    $T t,
  ) {
    return _varCallback(reference.pointer, _id_varCallback as jni.JMethodIDPtr,
            t.reference.pointer)
        .object(T);
  }

  static final _id_manyPrimitives = _class.instanceMethodId(
    r'manyPrimitives',
    r'(IZCD)J',
  );

  static final _manyPrimitives = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, $Int32, $Int32, ffi.Double)>)>>(
          'globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, int, double)>();

  /// from: `public abstract long manyPrimitives(int a, boolean b, char c, double d)`
  int manyPrimitives(
    int a,
    bool b,
    int c,
    double d,
  ) {
    return _manyPrimitives(reference.pointer,
            _id_manyPrimitives as jni.JMethodIDPtr, a, b ? 1 : 0, c, d)
        .long;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MyInterfaceImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'voidCallback(Ljava/lang/String;)V') {
        _$impls[$p]!.voidCallback(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'stringCallback(Ljava/lang/String;)Ljava/lang/String;') {
        final $r = _$impls[$p]!.stringCallback(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'varCallback(Ljava/lang/Object;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.varCallback(
          $a[0].castTo(_$impls[$p]!.T, releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'manyPrimitives(IZCD)J') {
        final $r = _$impls[$p]!.manyPrimitives(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
          $a[2]
              .castTo(const jni.JCharacterType(), releaseOriginal: true)
              .charValue(releaseOriginal: true),
          $a[3]
              .castTo(const jni.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return jni.JLong($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MyInterface.implement(
    $MyInterfaceImpl<$T> $impl,
  ) {
    final $p = ReceivePort();
    final $x = MyInterface.fromReference(
      $impl.T,
      ProtectedJniExtensions.newPortProxy(
        r'com.github.dart_lang.jnigen.interfaces.MyInterface',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
  static Map<int, $MyInterfaceImpl> get $impls => _$impls;
}

abstract interface class $MyInterfaceImpl<$T extends jni.JObject> {
  factory $MyInterfaceImpl({
    required jni.JObjType<$T> T,
    required void Function(jni.JString s) voidCallback,
    required jni.JString Function(jni.JString s) stringCallback,
    required $T Function($T t) varCallback,
    required int Function(int a, bool b, int c, double d) manyPrimitives,
  }) = _$MyInterfaceImpl;

  jni.JObjType<$T> get T;

  void voidCallback(jni.JString s);
  jni.JString stringCallback(jni.JString s);
  $T varCallback($T t);
  int manyPrimitives(int a, bool b, int c, double d);
}

class _$MyInterfaceImpl<$T extends jni.JObject>
    implements $MyInterfaceImpl<$T> {
  _$MyInterfaceImpl({
    required this.T,
    required void Function(jni.JString s) voidCallback,
    required jni.JString Function(jni.JString s) stringCallback,
    required $T Function($T t) varCallback,
    required int Function(int a, bool b, int c, double d) manyPrimitives,
  })  : _voidCallback = voidCallback,
        _stringCallback = stringCallback,
        _varCallback = varCallback,
        _manyPrimitives = manyPrimitives;

  @override
  final jni.JObjType<$T> T;

  final void Function(jni.JString s) _voidCallback;
  final jni.JString Function(jni.JString s) _stringCallback;
  final $T Function($T t) _varCallback;
  final int Function(int a, bool b, int c, double d) _manyPrimitives;

  void voidCallback(jni.JString s) {
    return _voidCallback(s);
  }

  jni.JString stringCallback(jni.JString s) {
    return _stringCallback(s);
  }

  $T varCallback($T t) {
    return _varCallback(t);
  }

  int manyPrimitives(int a, bool b, int c, double d) {
    return _manyPrimitives(a, b, c, d);
  }
}

final class $MyInterfaceType<$T extends jni.JObject>
    extends jni.JObjType<MyInterface<$T>> {
  final jni.JObjType<$T> T;

  const $MyInterfaceType(
    this.T,
  );

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyInterface;';

  @override
  MyInterface<$T> fromReference(jni.JReference reference) =>
      MyInterface.fromReference(T, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($MyInterfaceType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyInterfaceType<$T>) &&
        other is $MyInterfaceType<$T> &&
        T == other.T;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyInterfaceConsumer`
class MyInterfaceConsumer extends jni.JObject {
  @override
  late final jni.JObjType<MyInterfaceConsumer> $type = type;

  MyInterfaceConsumer.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyInterfaceConsumer');

  /// The type which includes information such as the signature of this class.
  static const type = $MyInterfaceConsumerType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyInterfaceConsumer() {
    return MyInterfaceConsumer.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_consumeOnAnotherThread = _class.staticMethodId(
    r'consumeOnAnotherThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/MyInterface;Ljava/lang/String;IZCDLjava/lang/Object;)V',
  );

  static final _consumeOnAnotherThread = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32,
                        ffi.Double,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              double,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public void consumeOnAnotherThread(com.github.dart_lang.jnigen.interfaces.MyInterface<T> myInterface, java.lang.String s, int a, boolean b, char c, double d, T t)`
  static void consumeOnAnotherThread<$T extends jni.JObject>(
    MyInterface<$T> myInterface,
    jni.JString s,
    int a,
    bool b,
    int c,
    double d,
    $T t, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      t.$type,
      (myInterface.$type as $MyInterfaceType).T,
    ]) as jni.JObjType<$T>;
    _consumeOnAnotherThread(
            _class.reference.pointer,
            _id_consumeOnAnotherThread as jni.JMethodIDPtr,
            myInterface.reference.pointer,
            s.reference.pointer,
            a,
            b ? 1 : 0,
            c,
            d,
            t.reference.pointer)
        .check();
  }

  static final _id_consumeOnSameThread = _class.staticMethodId(
    r'consumeOnSameThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/MyInterface;Ljava/lang/String;IZCDLjava/lang/Object;)V',
  );

  static final _consumeOnSameThread = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32,
                        ffi.Double,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              double,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public void consumeOnSameThread(com.github.dart_lang.jnigen.interfaces.MyInterface<T> myInterface, java.lang.String s, int a, boolean b, char c, double d, T t)`
  static void consumeOnSameThread<$T extends jni.JObject>(
    MyInterface<$T> myInterface,
    jni.JString s,
    int a,
    bool b,
    int c,
    double d,
    $T t, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      t.$type,
      (myInterface.$type as $MyInterfaceType).T,
    ]) as jni.JObjType<$T>;
    _consumeOnSameThread(
            _class.reference.pointer,
            _id_consumeOnSameThread as jni.JMethodIDPtr,
            myInterface.reference.pointer,
            s.reference.pointer,
            a,
            b ? 1 : 0,
            c,
            d,
            t.reference.pointer)
        .check();
  }
}

final class $MyInterfaceConsumerType extends jni.JObjType<MyInterfaceConsumer> {
  const $MyInterfaceConsumerType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyInterfaceConsumer;';

  @override
  MyInterfaceConsumer fromReference(jni.JReference reference) =>
      MyInterfaceConsumer.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyInterfaceConsumerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyInterfaceConsumerType) &&
        other is $MyInterfaceConsumerType;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyRunnable`
class MyRunnable extends jni.JObject {
  @override
  late final jni.JObjType<MyRunnable> $type = type;

  MyRunnable.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/github/dart_lang/jnigen/interfaces/MyRunnable');

  /// The type which includes information such as the signature of this class.
  static const type = $MyRunnableType();
  static final _id_run = _class.instanceMethodId(
    r'run',
    r'()V',
  );

  static final _run = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract void run()`
  void run() {
    _run(reference.pointer, _id_run as jni.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $MyRunnableImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'run()V') {
        _$impls[$p]!.run();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory MyRunnable.implement(
    $MyRunnableImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = MyRunnable.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.github.dart_lang.jnigen.interfaces.MyRunnable',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $MyRunnableImpl {
  factory $MyRunnableImpl({
    required void Function() run,
  }) = _$MyRunnableImpl;

  void run();
}

class _$MyRunnableImpl implements $MyRunnableImpl {
  _$MyRunnableImpl({
    required void Function() run,
  }) : _run = run;

  final void Function() _run;

  void run() {
    return _run();
  }
}

final class $MyRunnableType extends jni.JObjType<MyRunnable> {
  const $MyRunnableType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyRunnable;';

  @override
  MyRunnable fromReference(jni.JReference reference) =>
      MyRunnable.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyRunnableType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyRunnableType) && other is $MyRunnableType;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyRunnableRunner`
class MyRunnableRunner extends jni.JObject {
  @override
  late final jni.JObjType<MyRunnableRunner> $type = type;

  MyRunnableRunner.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyRunnableRunner');

  /// The type which includes information such as the signature of this class.
  static const type = $MyRunnableRunnerType();
  static final _id_error = _class.instanceFieldId(
    r'error',
    r'Ljava/lang/Throwable;',
  );

  /// from: `public java.lang.Throwable error`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject get error => _id_error.get(this, const jni.JObjectType());

  /// from: `public java.lang.Throwable error`
  /// The returned object must be released after use, by calling the [release] method.
  set error(jni.JObject value) =>
      _id_error.set(this, const jni.JObjectType(), value);

  static final _id_new0 = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/interfaces/MyRunnable;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.interfaces.MyRunnable runnable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyRunnableRunner(
    MyRunnable runnable,
  ) {
    return MyRunnableRunner.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, runnable.reference.pointer)
        .reference);
  }

  static final _id_runOnSameThread = _class.instanceMethodId(
    r'runOnSameThread',
    r'()V',
  );

  static final _runOnSameThread = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void runOnSameThread()`
  void runOnSameThread() {
    _runOnSameThread(reference.pointer, _id_runOnSameThread as jni.JMethodIDPtr)
        .check();
  }

  static final _id_runOnAnotherThread = _class.instanceMethodId(
    r'runOnAnotherThread',
    r'()V',
  );

  static final _runOnAnotherThread = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void runOnAnotherThread()`
  void runOnAnotherThread() {
    _runOnAnotherThread(
            reference.pointer, _id_runOnAnotherThread as jni.JMethodIDPtr)
        .check();
  }
}

final class $MyRunnableRunnerType extends jni.JObjType<MyRunnableRunner> {
  const $MyRunnableRunnerType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyRunnableRunner;';

  @override
  MyRunnableRunner fromReference(jni.JReference reference) =>
      MyRunnableRunner.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyRunnableRunnerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyRunnableRunnerType) &&
        other is $MyRunnableRunnerType;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.StringConversionException`
class StringConversionException extends jni.JObject {
  @override
  late final jni.JObjType<StringConversionException> $type = type;

  StringConversionException.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/StringConversionException');

  /// The type which includes information such as the signature of this class.
  static const type = $StringConversionExceptionType();
  static final _id_new0 = _class.constructorId(
    r'(Ljava/lang/String;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(java.lang.String message)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringConversionException(
    jni.JString message,
  ) {
    return StringConversionException.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            message.reference.pointer)
        .reference);
  }
}

final class $StringConversionExceptionType
    extends jni.JObjType<StringConversionException> {
  const $StringConversionExceptionType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConversionException;';

  @override
  StringConversionException fromReference(jni.JReference reference) =>
      StringConversionException.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($StringConversionExceptionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringConversionExceptionType) &&
        other is $StringConversionExceptionType;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.StringConverter`
class StringConverter extends jni.JObject {
  @override
  late final jni.JObjType<StringConverter> $type = type;

  StringConverter.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/StringConverter');

  /// The type which includes information such as the signature of this class.
  static const type = $StringConverterType();
  static final _id_parseToInt = _class.instanceMethodId(
    r'parseToInt',
    r'(Ljava/lang/String;)I',
  );

  static final _parseToInt = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract int parseToInt(java.lang.String s)`
  int parseToInt(
    jni.JString s,
  ) {
    return _parseToInt(reference.pointer, _id_parseToInt as jni.JMethodIDPtr,
            s.reference.pointer)
        .integer;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $StringConverterImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'parseToInt(Ljava/lang/String;)I') {
        final $r = _$impls[$p]!.parseToInt(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.JInteger($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory StringConverter.implement(
    $StringConverterImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = StringConverter.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.github.dart_lang.jnigen.interfaces.StringConverter',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $StringConverterImpl {
  factory $StringConverterImpl({
    required int Function(jni.JString s) parseToInt,
  }) = _$StringConverterImpl;

  int parseToInt(jni.JString s);
}

class _$StringConverterImpl implements $StringConverterImpl {
  _$StringConverterImpl({
    required int Function(jni.JString s) parseToInt,
  }) : _parseToInt = parseToInt;

  final int Function(jni.JString s) _parseToInt;

  int parseToInt(jni.JString s) {
    return _parseToInt(s);
  }
}

final class $StringConverterType extends jni.JObjType<StringConverter> {
  const $StringConverterType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConverter;';

  @override
  StringConverter fromReference(jni.JReference reference) =>
      StringConverter.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($StringConverterType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringConverterType) &&
        other is $StringConverterType;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.StringConverterConsumer`
class StringConverterConsumer extends jni.JObject {
  @override
  late final jni.JObjType<StringConverterConsumer> $type = type;

  StringConverterConsumer.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/StringConverterConsumer');

  /// The type which includes information such as the signature of this class.
  static const type = $StringConverterConsumerType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringConverterConsumer() {
    return StringConverterConsumer.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_consumeOnSameThread = _class.staticMethodId(
    r'consumeOnSameThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/StringConverter;Ljava/lang/String;)Ljava/lang/Integer;',
  );

  static final _consumeOnSameThread = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `static public java.lang.Integer consumeOnSameThread(com.github.dart_lang.jnigen.interfaces.StringConverter stringConverter, java.lang.String s)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JInteger consumeOnSameThread(
    StringConverter stringConverter,
    jni.JString s,
  ) {
    return _consumeOnSameThread(
            _class.reference.pointer,
            _id_consumeOnSameThread as jni.JMethodIDPtr,
            stringConverter.reference.pointer,
            s.reference.pointer)
        .object(const jni.JIntegerType());
  }

  static final _id_consumeOnAnotherThread = _class.staticMethodId(
    r'consumeOnAnotherThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/StringConverter;Ljava/lang/String;)Ljava/util/concurrent/Future;',
  );

  static final _consumeOnAnotherThread = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `static public java.util.concurrent.Future<java.lang.Integer> consumeOnAnotherThread(com.github.dart_lang.jnigen.interfaces.StringConverter stringConverter, java.lang.String s)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject consumeOnAnotherThread(
    StringConverter stringConverter,
    jni.JString s,
  ) {
    return _consumeOnAnotherThread(
            _class.reference.pointer,
            _id_consumeOnAnotherThread as jni.JMethodIDPtr,
            stringConverter.reference.pointer,
            s.reference.pointer)
        .object(const jni.JObjectType());
  }
}

final class $StringConverterConsumerType
    extends jni.JObjType<StringConverterConsumer> {
  const $StringConverterConsumerType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConverterConsumer;';

  @override
  StringConverterConsumer fromReference(jni.JReference reference) =>
      StringConverterConsumer.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($StringConverterConsumerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringConverterConsumerType) &&
        other is $StringConverterConsumerType;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.JsonSerializable$Case`
class JsonSerializable_Case extends jni.JObject {
  @override
  late final jni.JObjType<JsonSerializable_Case> $type = type;

  JsonSerializable_Case.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/JsonSerializable$Case');

  /// The type which includes information such as the signature of this class.
  static const type = $JsonSerializable_CaseType();
  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _values = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.annotations.JsonSerializable.Case[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<JsonSerializable_Case> values() {
    return _values(_class.reference.pointer, _id_values as jni.JMethodIDPtr)
        .object(const jni.JArrayType($JsonSerializable_CaseType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _valueOf = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.annotations.JsonSerializable.Case valueOf(java.lang.String name)`
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable_Case valueOf(
    jni.JString name,
  ) {
    return _valueOf(_class.reference.pointer, _id_valueOf as jni.JMethodIDPtr,
            name.reference.pointer)
        .object(const $JsonSerializable_CaseType());
  }
}

final class $JsonSerializable_CaseType
    extends jni.JObjType<JsonSerializable_Case> {
  const $JsonSerializable_CaseType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;';

  @override
  JsonSerializable_Case fromReference(jni.JReference reference) =>
      JsonSerializable_Case.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($JsonSerializable_CaseType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($JsonSerializable_CaseType) &&
        other is $JsonSerializable_CaseType;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.JsonSerializable`
class JsonSerializable extends jni.JObject {
  @override
  late final jni.JObjType<JsonSerializable> $type = type;

  JsonSerializable.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/JsonSerializable');

  /// The type which includes information such as the signature of this class.
  static const type = $JsonSerializableType();
  static final _id_value = _class.instanceMethodId(
    r'value',
    r'()Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _value = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public abstract com.github.dart_lang.jnigen.annotations.JsonSerializable$Case value()`
  /// The returned object must be released after use, by calling the [release] method.
  JsonSerializable_Case value() {
    return _value(reference.pointer, _id_value as jni.JMethodIDPtr)
        .object(const $JsonSerializable_CaseType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $JsonSerializableImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'value()Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;') {
        final $r = _$impls[$p]!.value();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory JsonSerializable.implement(
    $JsonSerializableImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = JsonSerializable.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.github.dart_lang.jnigen.annotations.JsonSerializable',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $JsonSerializableImpl {
  factory $JsonSerializableImpl({
    required JsonSerializable_Case Function() value,
  }) = _$JsonSerializableImpl;

  JsonSerializable_Case value();
}

class _$JsonSerializableImpl implements $JsonSerializableImpl {
  _$JsonSerializableImpl({
    required JsonSerializable_Case Function() value,
  }) : _value = value;

  final JsonSerializable_Case Function() _value;

  JsonSerializable_Case value() {
    return _value();
  }
}

final class $JsonSerializableType extends jni.JObjType<JsonSerializable> {
  const $JsonSerializableType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable;';

  @override
  JsonSerializable fromReference(jni.JReference reference) =>
      JsonSerializable.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($JsonSerializableType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($JsonSerializableType) &&
        other is $JsonSerializableType;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.MyDataClass`
class MyDataClass extends jni.JObject {
  @override
  late final jni.JObjType<MyDataClass> $type = type;

  MyDataClass.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/MyDataClass');

  /// The type which includes information such as the signature of this class.
  static const type = $MyDataClassType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyDataClass() {
    return MyDataClass.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $MyDataClassType extends jni.JObjType<MyDataClass> {
  const $MyDataClassType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/MyDataClass;';

  @override
  MyDataClass fromReference(jni.JReference reference) =>
      MyDataClass.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyDataClassType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyDataClassType) && other is $MyDataClassType;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Color`
class Color extends jni.JObject {
  @override
  late final jni.JObjType<Color> $type = type;

  Color.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/github/dart_lang/jnigen/simple_package/Color');

  /// The type which includes information such as the signature of this class.
  static const type = $ColorType();
  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lcom/github/dart_lang/jnigen/simple_package/Color;',
  );

  static final _values = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.simple_package.Color[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<Color> values() {
    return _values(_class.reference.pointer, _id_values as jni.JMethodIDPtr)
        .object(const jni.JArrayType($ColorType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lcom/github/dart_lang/jnigen/simple_package/Color;',
  );

  static final _valueOf = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.simple_package.Color valueOf(java.lang.String name)`
  /// The returned object must be released after use, by calling the [release] method.
  static Color valueOf(
    jni.JString name,
  ) {
    return _valueOf(_class.reference.pointer, _id_valueOf as jni.JMethodIDPtr,
            name.reference.pointer)
        .object(const $ColorType());
  }
}

final class $ColorType extends jni.JObjType<Color> {
  const $ColorType();

  @override
  String get signature => r'Lcom/github/dart_lang/jnigen/simple_package/Color;';

  @override
  Color fromReference(jni.JReference reference) =>
      Color.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ColorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ColorType) && other is $ColorType;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Exceptions`
class Exceptions extends jni.JObject {
  @override
  late final jni.JObjType<Exceptions> $type = type;

  Exceptions.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Exceptions');

  /// The type which includes information such as the signature of this class.
  static const type = $ExceptionsType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions() {
    return Exceptions.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(F)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public void <init>(float x)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions.new1(
    double x,
  ) {
    return Exceptions.fromReference(
        _new1(_class.reference.pointer, _id_new1 as jni.JMethodIDPtr, x)
            .reference);
  }

  static final _id_new2 = _class.constructorId(
    r'(IIIIII)V',
  );

  static final _new2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, int, int, int, int)>();

  /// from: `public void <init>(int a, int b, int c, int d, int e, int f)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions.new2(
    int a,
    int b,
    int c,
    int d,
    int e,
    int f,
  ) {
    return Exceptions.fromReference(_new2(_class.reference.pointer,
            _id_new2 as jni.JMethodIDPtr, a, b, c, d, e, f)
        .reference);
  }

  static final _id_staticObjectMethod = _class.staticMethodId(
    r'staticObjectMethod',
    r'()Ljava/lang/Object;',
  );

  static final _staticObjectMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.Object staticObjectMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject staticObjectMethod() {
    return _staticObjectMethod(_class.reference.pointer,
            _id_staticObjectMethod as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_staticIntMethod = _class.staticMethodId(
    r'staticIntMethod',
    r'()I',
  );

  static final _staticIntMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public int staticIntMethod()`
  static int staticIntMethod() {
    return _staticIntMethod(
            _class.reference.pointer, _id_staticIntMethod as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_staticObjectArrayMethod = _class.staticMethodId(
    r'staticObjectArrayMethod',
    r'()[Ljava/lang/Object;',
  );

  static final _staticObjectArrayMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.Object[] staticObjectArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JObject> staticObjectArrayMethod() {
    return _staticObjectArrayMethod(_class.reference.pointer,
            _id_staticObjectArrayMethod as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_staticIntArrayMethod = _class.staticMethodId(
    r'staticIntArrayMethod',
    r'()[I',
  );

  static final _staticIntArrayMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public int[] staticIntArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.jint> staticIntArrayMethod() {
    return _staticIntArrayMethod(_class.reference.pointer,
            _id_staticIntArrayMethod as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_objectMethod = _class.instanceMethodId(
    r'objectMethod',
    r'()Ljava/lang/Object;',
  );

  static final _objectMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object objectMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject objectMethod() {
    return _objectMethod(
            reference.pointer, _id_objectMethod as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_intMethod = _class.instanceMethodId(
    r'intMethod',
    r'()I',
  );

  static final _intMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int intMethod()`
  int intMethod() {
    return _intMethod(reference.pointer, _id_intMethod as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_objectArrayMethod = _class.instanceMethodId(
    r'objectArrayMethod',
    r'()[Ljava/lang/Object;',
  );

  static final _objectArrayMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object[] objectArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JObject> objectArrayMethod() {
    return _objectArrayMethod(
            reference.pointer, _id_objectArrayMethod as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_intArrayMethod = _class.instanceMethodId(
    r'intArrayMethod',
    r'()[I',
  );

  static final _intArrayMethod = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int[] intArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> intArrayMethod() {
    return _intArrayMethod(
            reference.pointer, _id_intArrayMethod as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_throwNullPointerException = _class.instanceMethodId(
    r'throwNullPointerException',
    r'()I',
  );

  static final _throwNullPointerException = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int throwNullPointerException()`
  int throwNullPointerException() {
    return _throwNullPointerException(reference.pointer,
            _id_throwNullPointerException as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_throwFileNotFoundException = _class.instanceMethodId(
    r'throwFileNotFoundException',
    r'()Ljava/io/InputStream;',
  );

  static final _throwFileNotFoundException = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.io.InputStream throwFileNotFoundException()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject throwFileNotFoundException() {
    return _throwFileNotFoundException(reference.pointer,
            _id_throwFileNotFoundException as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_throwClassCastException = _class.instanceMethodId(
    r'throwClassCastException',
    r'()Ljava/io/FileInputStream;',
  );

  static final _throwClassCastException = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.io.FileInputStream throwClassCastException()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject throwClassCastException() {
    return _throwClassCastException(
            reference.pointer, _id_throwClassCastException as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_throwArrayIndexException = _class.instanceMethodId(
    r'throwArrayIndexException',
    r'()I',
  );

  static final _throwArrayIndexException = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int throwArrayIndexException()`
  int throwArrayIndexException() {
    return _throwArrayIndexException(
            reference.pointer, _id_throwArrayIndexException as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_throwArithmeticException = _class.instanceMethodId(
    r'throwArithmeticException',
    r'()I',
  );

  static final _throwArithmeticException = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int throwArithmeticException()`
  int throwArithmeticException() {
    return _throwArithmeticException(
            reference.pointer, _id_throwArithmeticException as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_throwLoremIpsum = _class.staticMethodId(
    r'throwLoremIpsum',
    r'()V',
  );

  static final _throwLoremIpsum = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public void throwLoremIpsum()`
  static void throwLoremIpsum() {
    _throwLoremIpsum(
            _class.reference.pointer, _id_throwLoremIpsum as jni.JMethodIDPtr)
        .check();
  }
}

final class $ExceptionsType extends jni.JObjType<Exceptions> {
  const $ExceptionsType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Exceptions;';

  @override
  Exceptions fromReference(jni.JReference reference) =>
      Exceptions.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExceptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ExceptionsType) && other is $ExceptionsType;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Fields`
class Fields extends jni.JObject {
  @override
  late final jni.JObjType<Fields> $type = type;

  Fields.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/github/dart_lang/jnigen/simple_package/Fields');

  /// The type which includes information such as the signature of this class.
  static const type = $FieldsType();
  static final _id_amount = _class.staticFieldId(
    r'amount',
    r'I',
  );

  /// from: `static public int amount`
  static int get amount => _id_amount.get(_class, const jni.jintType());

  /// from: `static public int amount`
  static set amount(int value) =>
      _id_amount.set(_class, const jni.jintType(), value);

  static final _id_pi = _class.staticFieldId(
    r'pi',
    r'D',
  );

  /// from: `static public double pi`
  static double get pi => _id_pi.get(_class, const jni.jdoubleType());

  /// from: `static public double pi`
  static set pi(double value) =>
      _id_pi.set(_class, const jni.jdoubleType(), value);

  static final _id_asterisk = _class.staticFieldId(
    r'asterisk',
    r'C',
  );

  /// from: `static public char asterisk`
  static int get asterisk => _id_asterisk.get(_class, const jni.jcharType());

  /// from: `static public char asterisk`
  static set asterisk(int value) =>
      _id_asterisk.set(_class, const jni.jcharType(), value);

  static final _id_name = _class.staticFieldId(
    r'name',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String name`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get name => _id_name.get(_class, const jni.JStringType());

  /// from: `static public java.lang.String name`
  /// The returned object must be released after use, by calling the [release] method.
  static set name(jni.JString value) =>
      _id_name.set(_class, const jni.JStringType(), value);

  static final _id_i = _class.instanceFieldId(
    r'i',
    r'Ljava/lang/Integer;',
  );

  /// from: `public java.lang.Integer i`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JInteger get i => _id_i.get(this, const jni.JIntegerType());

  /// from: `public java.lang.Integer i`
  /// The returned object must be released after use, by calling the [release] method.
  set i(jni.JInteger value) => _id_i.set(this, const jni.JIntegerType(), value);

  static final _id_trillion = _class.instanceFieldId(
    r'trillion',
    r'J',
  );

  /// from: `public long trillion`
  int get trillion => _id_trillion.get(this, const jni.jlongType());

  /// from: `public long trillion`
  set trillion(int value) =>
      _id_trillion.set(this, const jni.jlongType(), value);

  static final _id_isAchillesDead = _class.instanceFieldId(
    r'isAchillesDead',
    r'Z',
  );

  /// from: `public boolean isAchillesDead`
  bool get isAchillesDead =>
      _id_isAchillesDead.get(this, const jni.jbooleanType());

  /// from: `public boolean isAchillesDead`
  set isAchillesDead(bool value) =>
      _id_isAchillesDead.set(this, const jni.jbooleanType(), value);

  static final _id_bestFighterInGreece = _class.instanceFieldId(
    r'bestFighterInGreece',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String bestFighterInGreece`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString get bestFighterInGreece =>
      _id_bestFighterInGreece.get(this, const jni.JStringType());

  /// from: `public java.lang.String bestFighterInGreece`
  /// The returned object must be released after use, by calling the [release] method.
  set bestFighterInGreece(jni.JString value) =>
      _id_bestFighterInGreece.set(this, const jni.JStringType(), value);

  static final _id_random = _class.instanceFieldId(
    r'random',
    r'Ljava/util/Random;',
  );

  /// from: `public java.util.Random random`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject get random => _id_random.get(this, const jni.JObjectType());

  /// from: `public java.util.Random random`
  /// The returned object must be released after use, by calling the [release] method.
  set random(jni.JObject value) =>
      _id_random.set(this, const jni.JObjectType(), value);

  static final _id_euroSymbol = _class.staticFieldId(
    r'euroSymbol',
    r'C',
  );

  /// from: `static public char euroSymbol`
  static int get euroSymbol =>
      _id_euroSymbol.get(_class, const jni.jcharType());

  /// from: `static public char euroSymbol`
  static set euroSymbol(int value) =>
      _id_euroSymbol.set(_class, const jni.jcharType(), value);

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Fields() {
    return Fields.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $FieldsType extends jni.JObjType<Fields> {
  const $FieldsType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Fields;';

  @override
  Fields fromReference(jni.JReference reference) =>
      Fields.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($FieldsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($FieldsType) && other is $FieldsType;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Fields$Nested`
class Fields_Nested extends jni.JObject {
  @override
  late final jni.JObjType<Fields_Nested> $type = type;

  Fields_Nested.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Fields$Nested');

  /// The type which includes information such as the signature of this class.
  static const type = $Fields_NestedType();
  static final _id_hundred = _class.instanceFieldId(
    r'hundred',
    r'J',
  );

  /// from: `public long hundred`
  int get hundred => _id_hundred.get(this, const jni.jlongType());

  /// from: `public long hundred`
  set hundred(int value) => _id_hundred.set(this, const jni.jlongType(), value);

  static final _id_BEST_GOD = _class.staticFieldId(
    r'BEST_GOD',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String BEST_GOD`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BEST_GOD =>
      _id_BEST_GOD.get(_class, const jni.JStringType());

  /// from: `static public java.lang.String BEST_GOD`
  /// The returned object must be released after use, by calling the [release] method.
  static set BEST_GOD(jni.JString value) =>
      _id_BEST_GOD.set(_class, const jni.JStringType(), value);

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Fields_Nested() {
    return Fields_Nested.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $Fields_NestedType extends jni.JObjType<Fields_Nested> {
  const $Fields_NestedType();

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Fields$Nested;';

  @override
  Fields_Nested fromReference(jni.JReference reference) =>
      Fields_Nested.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Fields_NestedType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Fields_NestedType) &&
        other is $Fields_NestedType;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GenericTypeParams`
class GenericTypeParams<$S extends jni.JObject, $K extends jni.JObject>
    extends jni.JObject {
  @override
  late final jni.JObjType<GenericTypeParams<$S, $K>> $type = type(S, K);

  final jni.JObjType<$S> S;
  final jni.JObjType<$K> K;

  GenericTypeParams.fromReference(
    this.S,
    this.K,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GenericTypeParams');

  /// The type which includes information such as the signature of this class.
  static $GenericTypeParamsType<$S, $K>
      type<$S extends jni.JObject, $K extends jni.JObject>(
    jni.JObjType<$S> S,
    jni.JObjType<$K> K,
  ) {
    return $GenericTypeParamsType(
      S,
      K,
    );
  }

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory GenericTypeParams({
    required jni.JObjType<$S> S,
    required jni.JObjType<$K> K,
  }) {
    return GenericTypeParams.fromReference(
        S,
        K,
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $GenericTypeParamsType<$S extends jni.JObject,
    $K extends jni.JObject> extends jni.JObjType<GenericTypeParams<$S, $K>> {
  final jni.JObjType<$S> S;
  final jni.JObjType<$K> K;

  const $GenericTypeParamsType(
    this.S,
    this.K,
  );

  @override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GenericTypeParams;';

  @override
  GenericTypeParams<$S, $K> fromReference(jni.JReference reference) =>
      GenericTypeParams.fromReference(S, K, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GenericTypeParamsType, S, K);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($GenericTypeParamsType<$S, $K>) &&
        other is $GenericTypeParamsType<$S, $K> &&
        S == other.S &&
        K == other.K;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.StringMap`
class StringMap extends StringKeyedMap<jni.JString> {
  @override
  late final jni.JObjType<StringMap> $type = type;

  StringMap.fromReference(
    jni.JReference reference,
  ) : super.fromReference(const jni.JStringType(), reference);

  static final _class =
      jni.JClass.forName(r'com/github/dart_lang/jnigen/generics/StringMap');

  /// The type which includes information such as the signature of this class.
  static const type = $StringMapType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringMap() {
    return StringMap.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $StringMapType extends jni.JObjType<StringMap> {
  const $StringMapType();

  @override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/StringMap;';

  @override
  StringMap fromReference(jni.JReference reference) =>
      StringMap.fromReference(reference);

  @override
  jni.JObjType get superType => const $StringKeyedMapType(jni.JStringType());

  @override
  final superCount = 3;

  @override
  int get hashCode => ($StringMapType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringMapType) && other is $StringMapType;
  }
}
