// Copyright (c) 2022, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `com.github.dart_lang.jnigen.simple_package.Example$Nested$NestedTwice`
class Example$Nested$NestedTwice extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Example$Nested$NestedTwice> $type;

  @jni$_.internal
  Example$Nested$NestedTwice.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example$Nested$NestedTwice');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Example$Nested$NestedTwice$NullableType();
  static const type = $Example$Nested$NestedTwice$Type();
  static final _id_ZERO = _class.staticFieldId(
    r'ZERO',
    r'I',
  );

  /// from: `static public int ZERO`
  static int get ZERO => _id_ZERO.get(_class, const jni$_.jintType());

  /// from: `static public int ZERO`
  static set ZERO(int value) =>
      _id_ZERO.set(_class, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example$Nested$NestedTwice() {
    return Example$Nested$NestedTwice.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $Example$Nested$NestedTwice$NullableType
    extends jni$_.JObjType<Example$Nested$NestedTwice?> {
  @jni$_.internal
  const $Example$Nested$NestedTwice$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$Nested$NestedTwice;';

  @jni$_.internal
  @core$_.override
  Example$Nested$NestedTwice? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Example$Nested$NestedTwice.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$Nested$NestedTwice?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Nested$NestedTwice$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Nested$NestedTwice$NullableType) &&
        other is $Example$Nested$NestedTwice$NullableType;
  }
}

final class $Example$Nested$NestedTwice$Type
    extends jni$_.JObjType<Example$Nested$NestedTwice> {
  @jni$_.internal
  const $Example$Nested$NestedTwice$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$Nested$NestedTwice;';

  @jni$_.internal
  @core$_.override
  Example$Nested$NestedTwice fromReference(jni$_.JReference reference) =>
      Example$Nested$NestedTwice.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$Nested$NestedTwice?> get nullableType =>
      const $Example$Nested$NestedTwice$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Nested$NestedTwice$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Nested$NestedTwice$Type) &&
        other is $Example$Nested$NestedTwice$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Example$Nested`
class Example$Nested extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Example$Nested> $type;

  @jni$_.internal
  Example$Nested.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example$Nested');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Example$Nested$NullableType();
  static const type = $Example$Nested$Type();
  static final _id_new$ = _class.constructorId(
    r'(Z)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void <init>(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example$Nested(
    bool z,
  ) {
    return Example$Nested.fromReference(_new$(
            _class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr, z ? 1 : 0)
        .reference);
  }

  static final _id_usesAnonymousInnerClass = _class.instanceMethodId(
    r'usesAnonymousInnerClass',
    r'()V',
  );

  static final _usesAnonymousInnerClass = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void usesAnonymousInnerClass()`
  void usesAnonymousInnerClass() {
    _usesAnonymousInnerClass(reference.pointer,
            _id_usesAnonymousInnerClass as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getValue = _class.instanceMethodId(
    r'getValue',
    r'()Z',
  );

  static final _getValue = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getValue()`
  bool getValue() {
    return _getValue(reference.pointer, _id_getValue as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setValue = _class.instanceMethodId(
    r'setValue',
    r'(Z)V',
  );

  static final _setValue = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setValue(boolean z)`
  void setValue(
    bool z,
  ) {
    _setValue(reference.pointer, _id_setValue as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }
}

final class $Example$Nested$NullableType
    extends jni$_.JObjType<Example$Nested?> {
  @jni$_.internal
  const $Example$Nested$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;';

  @jni$_.internal
  @core$_.override
  Example$Nested? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Example$Nested.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$Nested?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Nested$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Nested$NullableType) &&
        other is $Example$Nested$NullableType;
  }
}

final class $Example$Nested$Type extends jni$_.JObjType<Example$Nested> {
  @jni$_.internal
  const $Example$Nested$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;';

  @jni$_.internal
  @core$_.override
  Example$Nested fromReference(jni$_.JReference reference) =>
      Example$Nested.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$Nested?> get nullableType =>
      const $Example$Nested$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Nested$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Nested$Type) &&
        other is $Example$Nested$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Example$NonStaticNested`
class Example$NonStaticNested extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Example$NonStaticNested> $type;

  @jni$_.internal
  Example$NonStaticNested.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example$NonStaticNested');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Example$NonStaticNested$NullableType();
  static const type = $Example$NonStaticNested$Type();
  static final _id_ok = _class.instanceFieldId(
    r'ok',
    r'Z',
  );

  /// from: `public boolean ok`
  bool get ok => _id_ok.get(this, const jni$_.jbooleanType());

  /// from: `public boolean ok`
  set ok(bool value) => _id_ok.set(this, const jni$_.jbooleanType(), value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/simple_package/Example;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.simple_package.Example $outerClass)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example$NonStaticNested(
    Example $outerClass,
  ) {
    final _$$outerClass = $outerClass.reference;
    return Example$NonStaticNested.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$$outerClass.pointer)
        .reference);
  }
}

final class $Example$NonStaticNested$NullableType
    extends jni$_.JObjType<Example$NonStaticNested?> {
  @jni$_.internal
  const $Example$NonStaticNested$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$NonStaticNested;';

  @jni$_.internal
  @core$_.override
  Example$NonStaticNested? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Example$NonStaticNested.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$NonStaticNested?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$NonStaticNested$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$NonStaticNested$NullableType) &&
        other is $Example$NonStaticNested$NullableType;
  }
}

final class $Example$NonStaticNested$Type
    extends jni$_.JObjType<Example$NonStaticNested> {
  @jni$_.internal
  const $Example$NonStaticNested$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example$NonStaticNested;';

  @jni$_.internal
  @core$_.override
  Example$NonStaticNested fromReference(jni$_.JReference reference) =>
      Example$NonStaticNested.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$NonStaticNested?> get nullableType =>
      const $Example$NonStaticNested$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$NonStaticNested$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$NonStaticNested$Type) &&
        other is $Example$NonStaticNested$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Example`
class Example extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Example> $type;

  @jni$_.internal
  Example.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Example');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Example$NullableType();
  static const type = $Example$Type();

  /// from: `static public final int ON`
  static const ON = 1;

  /// from: `static public final int OFF`
  static const OFF = 0;

  /// from: `static public final double PI`
  static const PI = 3.14159;

  /// from: `static public final char SEMICOLON`
  static const SEMICOLON = 59;
  static final _id_SEMICOLON_STRING = _class.staticFieldId(
    r'SEMICOLON_STRING',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SEMICOLON_STRING`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SEMICOLON_STRING =>
      _id_SEMICOLON_STRING.get(_class, const jni$_.JStringNullableType());

  static final _id_unusedRandom = _class.staticFieldId(
    r'unusedRandom',
    r'Ljava/util/Random;',
  );

  /// from: `static public final java.util.Random unusedRandom`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? get unusedRandom =>
      _id_unusedRandom.get(_class, const jni$_.JObjectNullableType());

  static final _id_getAmount = _class.staticMethodId(
    r'getAmount',
    r'()I',
  );

  static final _getAmount = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public int getAmount()`
  static int getAmount() {
    return _getAmount(
            _class.reference.pointer, _id_getAmount as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getPi = _class.staticMethodId(
    r'getPi',
    r'()D',
  );

  static final _getPi = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticDoubleMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public double getPi()`
  static double getPi() {
    return _getPi(_class.reference.pointer, _id_getPi as jni$_.JMethodIDPtr)
        .doubleFloat;
  }

  static final _id_getAsterisk = _class.staticMethodId(
    r'getAsterisk',
    r'()C',
  );

  static final _getAsterisk = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticCharMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public char getAsterisk()`
  static int getAsterisk() {
    return _getAsterisk(
            _class.reference.pointer, _id_getAsterisk as jni$_.JMethodIDPtr)
        .char;
  }

  static final _id_getName = _class.staticMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? getName() {
    return _getName(_class.reference.pointer, _id_getName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getNestedInstance = _class.staticMethodId(
    r'getNestedInstance',
    r'()Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;',
  );

  static final _getNestedInstance = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.simple_package.Example$Nested getNestedInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static Example$Nested? getNestedInstance() {
    return _getNestedInstance(_class.reference.pointer,
            _id_getNestedInstance as jni$_.JMethodIDPtr)
        .object<Example$Nested?>(const $Example$Nested$NullableType());
  }

  static final _id_setAmount = _class.staticMethodId(
    r'setAmount',
    r'(I)V',
  );

  static final _setAmount = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public void setAmount(int i)`
  static void setAmount(
    int i,
  ) {
    _setAmount(_class.reference.pointer, _id_setAmount as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_setName = _class.staticMethodId(
    r'setName',
    r'(Ljava/lang/String;)V',
  );

  static final _setName = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setName(java.lang.String string)`
  static void setName(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setName(_class.reference.pointer, _id_setName as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_setNestedInstance = _class.staticMethodId(
    r'setNestedInstance',
    r'(Lcom/github/dart_lang/jnigen/simple_package/Example$Nested;)V',
  );

  static final _setNestedInstance = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setNestedInstance(com.github.dart_lang.jnigen.simple_package.Example$Nested nested)`
  static void setNestedInstance(
    Example$Nested? nested,
  ) {
    final _$nested = nested?.reference ?? jni$_.jNullReference;
    _setNestedInstance(_class.reference.pointer,
            _id_setNestedInstance as jni$_.JMethodIDPtr, _$nested.pointer)
        .check();
  }

  static final _id_max4 = _class.staticMethodId(
    r'max4',
    r'(IIII)I',
  );

  static final _max4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, int)>();

  /// from: `static public int max4(int i, int i1, int i2, int i3)`
  static int max4(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _max4(_class.reference.pointer, _id_max4 as jni$_.JMethodIDPtr, i,
            i1, i2, i3)
        .integer;
  }

  static final _id_max8 = _class.staticMethodId(
    r'max8',
    r'(IIIIIIII)I',
  );

  static final _max8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, int, int, int, int, int)>();

  /// from: `static public int max8(int i, int i1, int i2, int i3, int i4, int i5, int i6, int i7)`
  static int max8(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
    int i7,
  ) {
    return _max8(_class.reference.pointer, _id_max8 as jni$_.JMethodIDPtr, i,
            i1, i2, i3, i4, i5, i6, i7)
        .integer;
  }

  static final _id_getNumber = _class.instanceMethodId(
    r'getNumber',
    r'()I',
  );

  static final _getNumber = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getNumber()`
  int getNumber() {
    return _getNumber(reference.pointer, _id_getNumber as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setNumber = _class.instanceMethodId(
    r'setNumber',
    r'(I)V',
  );

  static final _setNumber = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setNumber(int i)`
  void setNumber(
    int i,
  ) {
    _setNumber(reference.pointer, _id_setNumber as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_getIsUp = _class.instanceMethodId(
    r'getIsUp',
    r'()Z',
  );

  static final _getIsUp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getIsUp()`
  bool getIsUp() {
    return _getIsUp(reference.pointer, _id_getIsUp as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setUp = _class.instanceMethodId(
    r'setUp',
    r'(Z)V',
  );

  static final _setUp = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setUp(boolean z)`
  void setUp(
    bool z,
  ) {
    _setUp(reference.pointer, _id_setUp as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_getCodename = _class.instanceMethodId(
    r'getCodename',
    r'()Ljava/lang/String;',
  );

  static final _getCodename = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getCodename()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCodename() {
    return _getCodename(
            reference.pointer, _id_getCodename as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setCodename = _class.instanceMethodId(
    r'setCodename',
    r'(Ljava/lang/String;)V',
  );

  static final _setCodename = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setCodename(java.lang.String string)`
  void setCodename(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setCodename(reference.pointer, _id_setCodename as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_getRandom = _class.instanceMethodId(
    r'getRandom',
    r'()Ljava/util/Random;',
  );

  static final _getRandom = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Random getRandom()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRandom() {
    return _getRandom(reference.pointer, _id_getRandom as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setRandom = _class.instanceMethodId(
    r'setRandom',
    r'(Ljava/util/Random;)V',
  );

  static final _setRandom = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setRandom(java.util.Random random)`
  void setRandom(
    jni$_.JObject? random,
  ) {
    final _$random = random?.reference ?? jni$_.jNullReference;
    _setRandom(reference.pointer, _id_setRandom as jni$_.JMethodIDPtr,
            _$random.pointer)
        .check();
  }

  static final _id_getRandomLong = _class.instanceMethodId(
    r'getRandomLong',
    r'()J',
  );

  static final _getRandomLong = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getRandomLong()`
  int getRandomLong() {
    return _getRandomLong(
            reference.pointer, _id_getRandomLong as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_add4Longs = _class.instanceMethodId(
    r'add4Longs',
    r'(JJJJ)J',
  );

  static final _add4Longs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, int)>();

  /// from: `public long add4Longs(long j, long j1, long j2, long j3)`
  int add4Longs(
    int j,
    int j1,
    int j2,
    int j3,
  ) {
    return _add4Longs(reference.pointer, _id_add4Longs as jni$_.JMethodIDPtr, j,
            j1, j2, j3)
        .long;
  }

  static final _id_add8Longs = _class.instanceMethodId(
    r'add8Longs',
    r'(JJJJJJJJ)J',
  );

  static final _add8Longs = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64,
                        jni$_.Int64
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, int, int, int, int, int)>();

  /// from: `public long add8Longs(long j, long j1, long j2, long j3, long j4, long j5, long j6, long j7)`
  int add8Longs(
    int j,
    int j1,
    int j2,
    int j3,
    int j4,
    int j5,
    int j6,
    int j7,
  ) {
    return _add8Longs(reference.pointer, _id_add8Longs as jni$_.JMethodIDPtr, j,
            j1, j2, j3, j4, j5, j6, j7)
        .long;
  }

  static final _id_getRandomNumericString = _class.instanceMethodId(
    r'getRandomNumericString',
    r'(Ljava/util/Random;)Ljava/lang/String;',
  );

  static final _getRandomNumericString = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String getRandomNumericString(java.util.Random random)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRandomNumericString(
    jni$_.JObject? random,
  ) {
    final _$random = random?.reference ?? jni$_.jNullReference;
    return _getRandomNumericString(reference.pointer,
            _id_getRandomNumericString as jni$_.JMethodIDPtr, _$random.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_finalMethod = _class.instanceMethodId(
    r'finalMethod',
    r'()V',
  );

  static final _finalMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final void finalMethod()`
  void finalMethod() {
    _finalMethod(reference.pointer, _id_finalMethod as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getList = _class.instanceMethodId(
    r'getList',
    r'()Ljava/util/List;',
  );

  static final _getList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List getList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getList() {
    return _getList(reference.pointer, _id_getList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_joinStrings = _class.instanceMethodId(
    r'joinStrings',
    r'(Ljava/util/List;Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _joinStrings = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String joinStrings(java.util.List list, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? joinStrings(
    jni$_.JList<jni$_.JString?>? list,
    jni$_.JString? string,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _joinStrings(
            reference.pointer,
            _id_joinStrings as jni$_.JMethodIDPtr,
            _$list.pointer,
            _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_methodWithSeveralParams = _class.instanceMethodId(
    r'methodWithSeveralParams',
    r'(CLjava/lang/String;[ILjava/lang/CharSequence;Ljava/util/List;Ljava/util/Map;)V',
  );

  static final _methodWithSeveralParams = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void methodWithSeveralParams(char c, java.lang.String string, java.lang.Object[] is, T charSequence, java.util.List list, java.util.Map map)`
  void methodWithSeveralParams<$T extends jni$_.JObject?>(
    int c,
    jni$_.JString? string,
    jni$_.JIntArray? is$,
    $T? charSequence,
    jni$_.JList<$T?>? list,
    jni$_.JMap<jni$_.JString?, jni$_.JObject?>? map, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    _methodWithSeveralParams(
            reference.pointer,
            _id_methodWithSeveralParams as jni$_.JMethodIDPtr,
            c,
            _$string.pointer,
            _$is$.pointer,
            _$charSequence.pointer,
            _$list.pointer,
            _$map.pointer)
        .check();
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example() {
    return Example.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(I)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new$1(
    int i,
  ) {
    return Example.fromReference(
        _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr, i)
            .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(IZ)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public void <init>(int i, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new$2(
    int i,
    bool z,
  ) {
    return Example.fromReference(_new$2(_class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr, i, z ? 1 : 0)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(IZLjava/lang/String;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(int i, boolean z, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new$3(
    int i,
    bool z,
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return Example.fromReference(_new$3(_class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr, i, z ? 1 : 0, _$string.pointer)
        .reference);
  }

  static final _id_new$4 = _class.constructorId(
    r'(IIIIIIII)V',
  );

  static final _new$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, int, int, int, int, int)>();

  /// from: `public void <init>(int i, int i1, int i2, int i3, int i4, int i5, int i6, int i7)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example.new$4(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
    int i7,
  ) {
    return Example.fromReference(_new$4(_class.reference.pointer,
            _id_new$4 as jni$_.JMethodIDPtr, i, i1, i2, i3, i4, i5, i6, i7)
        .reference);
  }

  static final _id_whichExample = _class.instanceMethodId(
    r'whichExample',
    r'()I',
  );

  static final _whichExample = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int whichExample()`
  int whichExample() {
    return _whichExample(
            reference.pointer, _id_whichExample as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_addInts = _class.staticMethodId(
    r'addInts',
    r'(II)I',
  );

  static final _addInts = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `static public int addInts(int i, int i1)`
  static int addInts(
    int i,
    int i1,
  ) {
    return _addInts(
            _class.reference.pointer, _id_addInts as jni$_.JMethodIDPtr, i, i1)
        .integer;
  }

  static final _id_getArr = _class.staticMethodId(
    r'getArr',
    r'()[I',
  );

  static final _getArr = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public int[] getArr()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JIntArray? getArr() {
    return _getArr(_class.reference.pointer, _id_getArr as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_addAll = _class.staticMethodId(
    r'addAll',
    r'([I)I',
  );

  static final _addAll = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public int addAll(int[] is)`
  static int addAll(
    jni$_.JIntArray? is$,
  ) {
    final _$is$ = is$?.reference ?? jni$_.jNullReference;
    return _addAll(_class.reference.pointer, _id_addAll as jni$_.JMethodIDPtr,
            _$is$.pointer)
        .integer;
  }

  static final _id_getSelf = _class.instanceMethodId(
    r'getSelf',
    r'()Lcom/github/dart_lang/jnigen/simple_package/Example;',
  );

  static final _getSelf = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.simple_package.Example getSelf()`
  /// The returned object must be released after use, by calling the [release] method.
  Example? getSelf() {
    return _getSelf(reference.pointer, _id_getSelf as jni$_.JMethodIDPtr)
        .object<Example?>(const $Example$NullableType());
  }

  static final _id_throwException = _class.staticMethodId(
    r'throwException',
    r'()V',
  );

  static final _throwException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void throwException()`
  static void throwException() {
    _throwException(
            _class.reference.pointer, _id_throwException as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_overloaded = _class.instanceMethodId(
    r'overloaded',
    r'()V',
  );

  static final _overloaded = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void overloaded()`
  void overloaded() {
    _overloaded(reference.pointer, _id_overloaded as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_overloaded$1 = _class.instanceMethodId(
    r'overloaded',
    r'(ILjava/lang/String;)V',
  );

  static final _overloaded$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void overloaded(int i, java.lang.String string)`
  void overloaded$1(
    int i,
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _overloaded$1(reference.pointer, _id_overloaded$1 as jni$_.JMethodIDPtr, i,
            _$string.pointer)
        .check();
  }

  static final _id_overloaded$2 = _class.instanceMethodId(
    r'overloaded',
    r'(I)V',
  );

  static final _overloaded$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void overloaded(int i)`
  void overloaded$2(
    int i,
  ) {
    _overloaded$2(reference.pointer, _id_overloaded$2 as jni$_.JMethodIDPtr, i)
        .check();
  }

  static final _id_overloaded$3 = _class.instanceMethodId(
    r'overloaded',
    r'(Ljava/util/List;Ljava/lang/String;)V',
  );

  static final _overloaded$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void overloaded(java.util.List list, java.lang.String string)`
  void overloaded$3(
    jni$_.JList<jni$_.JInteger?>? list,
    jni$_.JString? string,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _overloaded$3(reference.pointer, _id_overloaded$3 as jni$_.JMethodIDPtr,
            _$list.pointer, _$string.pointer)
        .check();
  }

  static final _id_overloaded$4 = _class.instanceMethodId(
    r'overloaded',
    r'(Ljava/util/List;)V',
  );

  static final _overloaded$4 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void overloaded(java.util.List list)`
  void overloaded$4(
    jni$_.JList<jni$_.JInteger?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    _overloaded$4(reference.pointer, _id_overloaded$4 as jni$_.JMethodIDPtr,
            _$list.pointer)
        .check();
  }
}

final class $Example$NullableType extends jni$_.JObjType<Example?> {
  @jni$_.internal
  const $Example$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example;';

  @jni$_.internal
  @core$_.override
  Example? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Example.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$NullableType) &&
        other is $Example$NullableType;
  }
}

final class $Example$Type extends jni$_.JObjType<Example> {
  @jni$_.internal
  const $Example$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Example;';

  @jni$_.internal
  @core$_.override
  Example fromReference(jni$_.JReference reference) => Example.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example?> get nullableType => const $Example$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Type) && other is $Example$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Exceptions`
class Exceptions extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Exceptions> $type;

  @jni$_.internal
  Exceptions.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Exceptions');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Exceptions$NullableType();
  static const type = $Exceptions$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions() {
    return Exceptions.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(F)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Double,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public void <init>(float f)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions.new$1(
    double f,
  ) {
    return Exceptions.fromReference(
        _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr, f)
            .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(IIIIII)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, int, int, int)>();

  /// from: `public void <init>(int i, int i1, int i2, int i3, int i4, int i5)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Exceptions.new$2(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    return Exceptions.fromReference(_new$2(_class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr, i, i1, i2, i3, i4, i5)
        .reference);
  }

  static final _id_staticObjectMethod = _class.staticMethodId(
    r'staticObjectMethod',
    r'()Ljava/lang/Object;',
  );

  static final _staticObjectMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.Object staticObjectMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? staticObjectMethod() {
    return _staticObjectMethod(_class.reference.pointer,
            _id_staticObjectMethod as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_staticIntMethod = _class.staticMethodId(
    r'staticIntMethod',
    r'()I',
  );

  static final _staticIntMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public int staticIntMethod()`
  static int staticIntMethod() {
    return _staticIntMethod(
            _class.reference.pointer, _id_staticIntMethod as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_staticObjectArrayMethod = _class.staticMethodId(
    r'staticObjectArrayMethod',
    r'()[Ljava/lang/Object;',
  );

  static final _staticObjectArrayMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.Object[] staticObjectArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JObject?>? staticObjectArrayMethod() {
    return _staticObjectArrayMethod(_class.reference.pointer,
            _id_staticObjectArrayMethod as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JObject?>?>(
            const jni$_.JArrayNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_staticIntArrayMethod = _class.staticMethodId(
    r'staticIntArrayMethod',
    r'()[I',
  );

  static final _staticIntArrayMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public int[] staticIntArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JIntArray? staticIntArrayMethod() {
    return _staticIntArrayMethod(_class.reference.pointer,
            _id_staticIntArrayMethod as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_objectMethod = _class.instanceMethodId(
    r'objectMethod',
    r'()Ljava/lang/Object;',
  );

  static final _objectMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object objectMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? objectMethod() {
    return _objectMethod(
            reference.pointer, _id_objectMethod as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_intMethod = _class.instanceMethodId(
    r'intMethod',
    r'()I',
  );

  static final _intMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int intMethod()`
  int intMethod() {
    return _intMethod(reference.pointer, _id_intMethod as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_objectArrayMethod = _class.instanceMethodId(
    r'objectArrayMethod',
    r'()[Ljava/lang/Object;',
  );

  static final _objectArrayMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object[] objectArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? objectArrayMethod() {
    return _objectArrayMethod(
            reference.pointer, _id_objectArrayMethod as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JObject?>?>(
            const jni$_.JArrayNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_intArrayMethod = _class.instanceMethodId(
    r'intArrayMethod',
    r'()[I',
  );

  static final _intArrayMethod = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int[] intArrayMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JIntArray? intArrayMethod() {
    return _intArrayMethod(
            reference.pointer, _id_intArrayMethod as jni$_.JMethodIDPtr)
        .object<jni$_.JIntArray?>(const jni$_.JIntArrayNullableType());
  }

  static final _id_throwNullPointerException = _class.instanceMethodId(
    r'throwNullPointerException',
    r'()I',
  );

  static final _throwNullPointerException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int throwNullPointerException()`
  int throwNullPointerException() {
    return _throwNullPointerException(reference.pointer,
            _id_throwNullPointerException as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_throwFileNotFoundException = _class.instanceMethodId(
    r'throwFileNotFoundException',
    r'()Ljava/io/InputStream;',
  );

  static final _throwFileNotFoundException =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.io.InputStream throwFileNotFoundException()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwFileNotFoundException() {
    return _throwFileNotFoundException(reference.pointer,
            _id_throwFileNotFoundException as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_throwClassCastException = _class.instanceMethodId(
    r'throwClassCastException',
    r'()Ljava/io/FileInputStream;',
  );

  static final _throwClassCastException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.io.FileInputStream throwClassCastException()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwClassCastException() {
    return _throwClassCastException(reference.pointer,
            _id_throwClassCastException as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_throwArrayIndexException = _class.instanceMethodId(
    r'throwArrayIndexException',
    r'()I',
  );

  static final _throwArrayIndexException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int throwArrayIndexException()`
  int throwArrayIndexException() {
    return _throwArrayIndexException(reference.pointer,
            _id_throwArrayIndexException as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_throwArithmeticException = _class.instanceMethodId(
    r'throwArithmeticException',
    r'()I',
  );

  static final _throwArithmeticException = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int throwArithmeticException()`
  int throwArithmeticException() {
    return _throwArithmeticException(reference.pointer,
            _id_throwArithmeticException as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_throwLoremIpsum = _class.staticMethodId(
    r'throwLoremIpsum',
    r'()V',
  );

  static final _throwLoremIpsum = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public void throwLoremIpsum()`
  static void throwLoremIpsum() {
    _throwLoremIpsum(
            _class.reference.pointer, _id_throwLoremIpsum as jni$_.JMethodIDPtr)
        .check();
  }
}

final class $Exceptions$NullableType extends jni$_.JObjType<Exceptions?> {
  @jni$_.internal
  const $Exceptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Exceptions;';

  @jni$_.internal
  @core$_.override
  Exceptions? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Exceptions.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Exceptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Exceptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Exceptions$NullableType) &&
        other is $Exceptions$NullableType;
  }
}

final class $Exceptions$Type extends jni$_.JObjType<Exceptions> {
  @jni$_.internal
  const $Exceptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Exceptions;';

  @jni$_.internal
  @core$_.override
  Exceptions fromReference(jni$_.JReference reference) =>
      Exceptions.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Exceptions?> get nullableType =>
      const $Exceptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Exceptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Exceptions$Type) && other is $Exceptions$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Fields$Nested`
class Fields$Nested extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Fields$Nested> $type;

  @jni$_.internal
  Fields$Nested.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Fields$Nested');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Fields$Nested$NullableType();
  static const type = $Fields$Nested$Type();
  static final _id_hundred = _class.instanceFieldId(
    r'hundred',
    r'J',
  );

  /// from: `public long hundred`
  int get hundred => _id_hundred.get(this, const jni$_.jlongType());

  /// from: `public long hundred`
  set hundred(int value) =>
      _id_hundred.set(this, const jni$_.jlongType(), value);

  static final _id_BEST_GOD = _class.staticFieldId(
    r'BEST_GOD',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String BEST_GOD`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BEST_GOD =>
      _id_BEST_GOD.get(_class, const jni$_.JStringNullableType());

  /// from: `static public java.lang.String BEST_GOD`
  /// The returned object must be released after use, by calling the [release] method.
  static set BEST_GOD(jni$_.JString? value) =>
      _id_BEST_GOD.set(_class, const jni$_.JStringNullableType(), value);

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Fields$Nested() {
    return Fields$Nested.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $Fields$Nested$NullableType extends jni$_.JObjType<Fields$Nested?> {
  @jni$_.internal
  const $Fields$Nested$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Fields$Nested;';

  @jni$_.internal
  @core$_.override
  Fields$Nested? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Fields$Nested.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Fields$Nested?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Fields$Nested$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Fields$Nested$NullableType) &&
        other is $Fields$Nested$NullableType;
  }
}

final class $Fields$Nested$Type extends jni$_.JObjType<Fields$Nested> {
  @jni$_.internal
  const $Fields$Nested$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Fields$Nested;';

  @jni$_.internal
  @core$_.override
  Fields$Nested fromReference(jni$_.JReference reference) =>
      Fields$Nested.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Fields$Nested?> get nullableType =>
      const $Fields$Nested$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Fields$Nested$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Fields$Nested$Type) &&
        other is $Fields$Nested$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.simple_package.Fields`
class Fields extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Fields> $type;

  @jni$_.internal
  Fields.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/simple_package/Fields');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Fields$NullableType();
  static const type = $Fields$Type();
  static final _id_amount = _class.staticFieldId(
    r'amount',
    r'I',
  );

  /// from: `static public int amount`
  static int get amount => _id_amount.get(_class, const jni$_.jintType());

  /// from: `static public int amount`
  static set amount(int value) =>
      _id_amount.set(_class, const jni$_.jintType(), value);

  static final _id_pi = _class.staticFieldId(
    r'pi',
    r'D',
  );

  /// from: `static public double pi`
  static double get pi => _id_pi.get(_class, const jni$_.jdoubleType());

  /// from: `static public double pi`
  static set pi(double value) =>
      _id_pi.set(_class, const jni$_.jdoubleType(), value);

  static final _id_asterisk = _class.staticFieldId(
    r'asterisk',
    r'C',
  );

  /// from: `static public char asterisk`
  static int get asterisk => _id_asterisk.get(_class, const jni$_.jcharType());

  /// from: `static public char asterisk`
  static set asterisk(int value) =>
      _id_asterisk.set(_class, const jni$_.jcharType(), value);

  static final _id_name = _class.staticFieldId(
    r'name',
    r'Ljava/lang/String;',
  );

  /// from: `static public java.lang.String name`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get name =>
      _id_name.get(_class, const jni$_.JStringNullableType());

  /// from: `static public java.lang.String name`
  /// The returned object must be released after use, by calling the [release] method.
  static set name(jni$_.JString? value) =>
      _id_name.set(_class, const jni$_.JStringNullableType(), value);

  static final _id_i = _class.instanceFieldId(
    r'i',
    r'Ljava/lang/Integer;',
  );

  /// from: `public java.lang.Integer i`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JInteger? get i => _id_i.get(this, const jni$_.JIntegerNullableType());

  /// from: `public java.lang.Integer i`
  /// The returned object must be released after use, by calling the [release] method.
  set i(jni$_.JInteger? value) =>
      _id_i.set(this, const jni$_.JIntegerNullableType(), value);

  static final _id_trillion = _class.instanceFieldId(
    r'trillion',
    r'J',
  );

  /// from: `public long trillion`
  int get trillion => _id_trillion.get(this, const jni$_.jlongType());

  /// from: `public long trillion`
  set trillion(int value) =>
      _id_trillion.set(this, const jni$_.jlongType(), value);

  static final _id_isAchillesDead = _class.instanceFieldId(
    r'isAchillesDead',
    r'Z',
  );

  /// from: `public boolean isAchillesDead`
  bool get isAchillesDead =>
      _id_isAchillesDead.get(this, const jni$_.jbooleanType());

  /// from: `public boolean isAchillesDead`
  set isAchillesDead(bool value) =>
      _id_isAchillesDead.set(this, const jni$_.jbooleanType(), value);

  static final _id_bestFighterInGreece = _class.instanceFieldId(
    r'bestFighterInGreece',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String bestFighterInGreece`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get bestFighterInGreece =>
      _id_bestFighterInGreece.get(this, const jni$_.JStringNullableType());

  /// from: `public java.lang.String bestFighterInGreece`
  /// The returned object must be released after use, by calling the [release] method.
  set bestFighterInGreece(jni$_.JString? value) => _id_bestFighterInGreece.set(
      this, const jni$_.JStringNullableType(), value);

  static final _id_random = _class.instanceFieldId(
    r'random',
    r'Ljava/util/Random;',
  );

  /// from: `public java.util.Random random`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get random =>
      _id_random.get(this, const jni$_.JObjectNullableType());

  /// from: `public java.util.Random random`
  /// The returned object must be released after use, by calling the [release] method.
  set random(jni$_.JObject? value) =>
      _id_random.set(this, const jni$_.JObjectNullableType(), value);

  static final _id_euroSymbol = _class.staticFieldId(
    r'euroSymbol',
    r'C',
  );

  /// from: `static public char euroSymbol`
  static int get euroSymbol =>
      _id_euroSymbol.get(_class, const jni$_.jcharType());

  /// from: `static public char euroSymbol`
  static set euroSymbol(int value) =>
      _id_euroSymbol.set(_class, const jni$_.jcharType(), value);

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Fields() {
    return Fields.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $Fields$NullableType extends jni$_.JObjType<Fields?> {
  @jni$_.internal
  const $Fields$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Fields;';

  @jni$_.internal
  @core$_.override
  Fields? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Fields.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Fields?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Fields$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Fields$NullableType) &&
        other is $Fields$NullableType;
  }
}

final class $Fields$Type extends jni$_.JObjType<Fields> {
  @jni$_.internal
  const $Fields$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/simple_package/Fields;';

  @jni$_.internal
  @core$_.override
  Fields fromReference(jni$_.JReference reference) => Fields.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Fields?> get nullableType => const $Fields$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Fields$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Fields$Type) && other is $Fields$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.pkg2.C2`
class C2 extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<C2> $type;

  @jni$_.internal
  C2.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/pkg2/C2');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $C2$NullableType();
  static const type = $C2$Type();
  static final _id_CONSTANT = _class.staticFieldId(
    r'CONSTANT',
    r'I',
  );

  /// from: `static public int CONSTANT`
  static int get CONSTANT => _id_CONSTANT.get(_class, const jni$_.jintType());

  /// from: `static public int CONSTANT`
  static set CONSTANT(int value) =>
      _id_CONSTANT.set(_class, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory C2() {
    return C2.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $C2$NullableType extends jni$_.JObjType<C2?> {
  @jni$_.internal
  const $C2$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/pkg2/C2;';

  @jni$_.internal
  @core$_.override
  C2? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : C2.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<C2?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($C2$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($C2$NullableType) && other is $C2$NullableType;
  }
}

final class $C2$Type extends jni$_.JObjType<C2> {
  @jni$_.internal
  const $C2$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/pkg2/C2;';

  @jni$_.internal
  @core$_.override
  C2 fromReference(jni$_.JReference reference) => C2.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<C2?> get nullableType => const $C2$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($C2$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($C2$Type) && other is $C2$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.pkg2.Example`
class Example$1 extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Example$1> $type;

  @jni$_.internal
  Example$1.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/pkg2/Example');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Example$1$NullableType();
  static const type = $Example$1$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example$1() {
    return Example$1.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_whichExample = _class.instanceMethodId(
    r'whichExample',
    r'()I',
  );

  static final _whichExample = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int whichExample()`
  int whichExample() {
    return _whichExample(
            reference.pointer, _id_whichExample as jni$_.JMethodIDPtr)
        .integer;
  }
}

final class $Example$1$NullableType extends jni$_.JObjType<Example$1?> {
  @jni$_.internal
  const $Example$1$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/pkg2/Example;';

  @jni$_.internal
  @core$_.override
  Example$1? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Example$1.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$1?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$1$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$1$NullableType) &&
        other is $Example$1$NullableType;
  }
}

final class $Example$1$Type extends jni$_.JObjType<Example$1> {
  @jni$_.internal
  const $Example$1$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/pkg2/Example;';

  @jni$_.internal
  @core$_.override
  Example$1 fromReference(jni$_.JReference reference) =>
      Example$1.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$1?> get nullableType =>
      const $Example$1$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$1$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$1$Type) && other is $Example$1$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.enums.Colors$RGB`
class Colors$RGB extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Colors$RGB> $type;

  @jni$_.internal
  Colors$RGB.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/enums/Colors$RGB');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Colors$RGB$NullableType();
  static const type = $Colors$RGB$Type();
  static final _id_red = _class.instanceFieldId(
    r'red',
    r'I',
  );

  /// from: `public int red`
  int get red => _id_red.get(this, const jni$_.jintType());

  /// from: `public int red`
  set red(int value) => _id_red.set(this, const jni$_.jintType(), value);

  static final _id_green = _class.instanceFieldId(
    r'green',
    r'I',
  );

  /// from: `public int green`
  int get green => _id_green.get(this, const jni$_.jintType());

  /// from: `public int green`
  set green(int value) => _id_green.set(this, const jni$_.jintType(), value);

  static final _id_blue = _class.instanceFieldId(
    r'blue',
    r'I',
  );

  /// from: `public int blue`
  int get blue => _id_blue.get(this, const jni$_.jintType());

  /// from: `public int blue`
  set blue(int value) => _id_blue.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(
    r'(III)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int, int)>();

  /// from: `public void <init>(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Colors$RGB(
    int i,
    int i1,
    int i2,
  ) {
    return Colors$RGB.fromReference(_new$(
            _class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr, i, i1, i2)
        .reference);
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }
}

final class $Colors$RGB$NullableType extends jni$_.JObjType<Colors$RGB?> {
  @jni$_.internal
  const $Colors$RGB$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/enums/Colors$RGB;';

  @jni$_.internal
  @core$_.override
  Colors$RGB? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Colors$RGB.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Colors$RGB?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Colors$RGB$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Colors$RGB$NullableType) &&
        other is $Colors$RGB$NullableType;
  }
}

final class $Colors$RGB$Type extends jni$_.JObjType<Colors$RGB> {
  @jni$_.internal
  const $Colors$RGB$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/enums/Colors$RGB;';

  @jni$_.internal
  @core$_.override
  Colors$RGB fromReference(jni$_.JReference reference) =>
      Colors$RGB.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Colors$RGB?> get nullableType =>
      const $Colors$RGB$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Colors$RGB$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Colors$RGB$Type) && other is $Colors$RGB$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.enums.Colors`
class Colors extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Colors> $type;

  @jni$_.internal
  Colors.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/enums/Colors');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Colors$NullableType();
  static const type = $Colors$Type();
  static final _id_red = _class.staticFieldId(
    r'red',
    r'Lcom/github/dart_lang/jnigen/enums/Colors;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.enums.Colors red`
  /// The returned object must be released after use, by calling the [release] method.
  static Colors get red => _id_red.get(_class, const $Colors$Type());

  static final _id_green = _class.staticFieldId(
    r'green',
    r'Lcom/github/dart_lang/jnigen/enums/Colors;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.enums.Colors green`
  /// The returned object must be released after use, by calling the [release] method.
  static Colors get green => _id_green.get(_class, const $Colors$Type());

  static final _id_blue = _class.staticFieldId(
    r'blue',
    r'Lcom/github/dart_lang/jnigen/enums/Colors;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.enums.Colors blue`
  /// The returned object must be released after use, by calling the [release] method.
  static Colors get blue => _id_blue.get(_class, const $Colors$Type());

  static final _id_code = _class.instanceFieldId(
    r'code',
    r'I',
  );

  /// from: `public final int code`
  int get code => _id_code.get(this, const jni$_.jintType());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lcom/github/dart_lang/jnigen/enums/Colors;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.enums.Colors[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Colors?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<Colors?>?>(
            const jni$_.JArrayNullableType<Colors?>($Colors$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lcom/github/dart_lang/jnigen/enums/Colors;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.enums.Colors valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Colors? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<Colors?>(const $Colors$NullableType());
  }

  static final _id_toRGB = _class.instanceMethodId(
    r'toRGB',
    r'()Lcom/github/dart_lang/jnigen/enums/Colors$RGB;',
  );

  static final _toRGB = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.enums.Colors$RGB toRGB()`
  /// The returned object must be released after use, by calling the [release] method.
  Colors$RGB? toRGB() {
    return _toRGB(reference.pointer, _id_toRGB as jni$_.JMethodIDPtr)
        .object<Colors$RGB?>(const $Colors$RGB$NullableType());
  }
}

final class $Colors$NullableType extends jni$_.JObjType<Colors?> {
  @jni$_.internal
  const $Colors$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/enums/Colors;';

  @jni$_.internal
  @core$_.override
  Colors? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Colors.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Colors?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Colors$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Colors$NullableType) &&
        other is $Colors$NullableType;
  }
}

final class $Colors$Type extends jni$_.JObjType<Colors> {
  @jni$_.internal
  const $Colors$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/enums/Colors;';

  @jni$_.internal
  @core$_.override
  Colors fromReference(jni$_.JReference reference) => Colors.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Colors?> get nullableType => const $Colors$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Colors$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Colors$Type) && other is $Colors$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GenericTypeParams`
class GenericTypeParams<$S extends jni$_.JObject?, $K extends jni$_.JObject?>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<GenericTypeParams<$S, $K>> $type;

  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  GenericTypeParams.fromReference(
    this.S,
    this.K,
    jni$_.JReference reference,
  )   : $type = type<$S, $K>(S, K),
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GenericTypeParams');

  /// The type which includes information such as the signature of this class.
  static $GenericTypeParams$NullableType<$S, $K>
      nullableType<$S extends jni$_.JObject?, $K extends jni$_.JObject?>(
    jni$_.JObjType<$S> S,
    jni$_.JObjType<$K> K,
  ) {
    return $GenericTypeParams$NullableType<$S, $K>(
      S,
      K,
    );
  }

  static $GenericTypeParams$Type<$S, $K>
      type<$S extends jni$_.JObject?, $K extends jni$_.JObject?>(
    jni$_.JObjType<$S> S,
    jni$_.JObjType<$K> K,
  ) {
    return $GenericTypeParams$Type<$S, $K>(
      S,
      K,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory GenericTypeParams({
    required jni$_.JObjType<$S> S,
    required jni$_.JObjType<$K> K,
  }) {
    return GenericTypeParams<$S, $K>.fromReference(
        S,
        K,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $GenericTypeParams$NullableType<$S extends jni$_.JObject?,
        $K extends jni$_.JObject?>
    extends jni$_.JObjType<GenericTypeParams<$S, $K>?> {
  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  const $GenericTypeParams$NullableType(
    this.S,
    this.K,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GenericTypeParams;';

  @jni$_.internal
  @core$_.override
  GenericTypeParams<$S, $K>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : GenericTypeParams<$S, $K>.fromReference(
              S,
              K,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GenericTypeParams<$S, $K>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($GenericTypeParams$NullableType, S, K);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GenericTypeParams$NullableType<$S, $K>) &&
        other is $GenericTypeParams$NullableType<$S, $K> &&
        S == other.S &&
        K == other.K;
  }
}

final class $GenericTypeParams$Type<$S extends jni$_.JObject?,
        $K extends jni$_.JObject?>
    extends jni$_.JObjType<GenericTypeParams<$S, $K>> {
  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  const $GenericTypeParams$Type(
    this.S,
    this.K,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GenericTypeParams;';

  @jni$_.internal
  @core$_.override
  GenericTypeParams<$S, $K> fromReference(jni$_.JReference reference) =>
      GenericTypeParams<$S, $K>.fromReference(
        S,
        K,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GenericTypeParams<$S, $K>?> get nullableType =>
      $GenericTypeParams$NullableType<$S, $K>(S, K);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($GenericTypeParams$Type, S, K);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GenericTypeParams$Type<$S, $K>) &&
        other is $GenericTypeParams$Type<$S, $K> &&
        S == other.S &&
        K == other.K;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$Parent$Child`
class GrandParent$Parent$Child<
    $T extends jni$_.JObject?,
    $S extends jni$_.JObject?,
    $U extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<GrandParent$Parent$Child<$T, $S, $U>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  final jni$_.JObjType<$U> U;

  @jni$_.internal
  GrandParent$Parent$Child.fromReference(
    this.T,
    this.S,
    this.U,
    jni$_.JReference reference,
  )   : $type = type<$T, $S, $U>(T, S, U),
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$Parent$Child');

  /// The type which includes information such as the signature of this class.
  static $GrandParent$Parent$Child$NullableType<$T, $S, $U> nullableType<
      $T extends jni$_.JObject?,
      $S extends jni$_.JObject?,
      $U extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
    jni$_.JObjType<$S> S,
    jni$_.JObjType<$U> U,
  ) {
    return $GrandParent$Parent$Child$NullableType<$T, $S, $U>(
      T,
      S,
      U,
    );
  }

  static $GrandParent$Parent$Child$Type<$T, $S, $U> type<
      $T extends jni$_.JObject?,
      $S extends jni$_.JObject?,
      $U extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
    jni$_.JObjType<$S> S,
    jni$_.JObjType<$U> U,
  ) {
    return $GrandParent$Parent$Child$Type<$T, $S, $U>(
      T,
      S,
      U,
    );
  }

  static final _id_grandParentValue = _class.instanceFieldId(
    r'grandParentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public T grandParentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get grandParentValue => _id_grandParentValue.get(this, T.nullableType);

  /// from: `public T grandParentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set grandParentValue($T? value) =>
      _id_grandParentValue.set(this, T.nullableType, value);

  static final _id_parentValue = _class.instanceFieldId(
    r'parentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $S? get parentValue => _id_parentValue.get(this, S.nullableType);

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($S? value) =>
      _id_parentValue.set(this, S.nullableType, value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  $U? get value => _id_value.get(this, U.nullableType);

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($U? value) => _id_value.set(this, U.nullableType, value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.GrandParent$Parent $outerClass, U object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent$Parent$Child(
    GrandParent$Parent<$T?, $S?> $outerClass,
    $U? object, {
    jni$_.JObjType<$T>? T,
    jni$_.JObjType<$S>? S,
    required jni$_.JObjType<$U> U,
  }) {
    T ??= jni$_.lowestCommonSuperType([
      ($outerClass.$type
              as $GrandParent$Parent$Type<core$_.dynamic, core$_.dynamic>)
          .T,
    ]) as jni$_.JObjType<$T>;
    S ??= jni$_.lowestCommonSuperType([
      ($outerClass.$type
              as $GrandParent$Parent$Type<core$_.dynamic, core$_.dynamic>)
          .S,
    ]) as jni$_.JObjType<$S>;
    final _$$outerClass = $outerClass.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return GrandParent$Parent$Child<$T, $S, $U>.fromReference(
        T,
        S,
        U,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
                _$$outerClass.pointer, _$object.pointer)
            .reference);
  }
}

final class $GrandParent$Parent$Child$NullableType<$T extends jni$_.JObject?,
        $S extends jni$_.JObject?, $U extends jni$_.JObject?>
    extends jni$_.JObjType<GrandParent$Parent$Child<$T, $S, $U>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  final jni$_.JObjType<$U> U;

  @jni$_.internal
  const $GrandParent$Parent$Child$NullableType(
    this.T,
    this.S,
    this.U,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent$Child;';

  @jni$_.internal
  @core$_.override
  GrandParent$Parent$Child<$T, $S, $U>? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : GrandParent$Parent$Child<$T, $S, $U>.fromReference(
              T,
              S,
              U,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GrandParent$Parent$Child<$T, $S, $U>?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      Object.hash($GrandParent$Parent$Child$NullableType, T, S, U);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($GrandParent$Parent$Child$NullableType<$T, $S, $U>) &&
        other is $GrandParent$Parent$Child$NullableType<$T, $S, $U> &&
        T == other.T &&
        S == other.S &&
        U == other.U;
  }
}

final class $GrandParent$Parent$Child$Type<$T extends jni$_.JObject?,
        $S extends jni$_.JObject?, $U extends jni$_.JObject?>
    extends jni$_.JObjType<GrandParent$Parent$Child<$T, $S, $U>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  final jni$_.JObjType<$U> U;

  @jni$_.internal
  const $GrandParent$Parent$Child$Type(
    this.T,
    this.S,
    this.U,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent$Child;';

  @jni$_.internal
  @core$_.override
  GrandParent$Parent$Child<$T, $S, $U> fromReference(
          jni$_.JReference reference) =>
      GrandParent$Parent$Child<$T, $S, $U>.fromReference(
        T,
        S,
        U,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GrandParent$Parent$Child<$T, $S, $U>?> get nullableType =>
      $GrandParent$Parent$Child$NullableType<$T, $S, $U>(T, S, U);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($GrandParent$Parent$Child$Type, T, S, U);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent$Parent$Child$Type<$T, $S, $U>) &&
        other is $GrandParent$Parent$Child$Type<$T, $S, $U> &&
        T == other.T &&
        S == other.S &&
        U == other.U;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$Parent`
class GrandParent$Parent<$T extends jni$_.JObject?, $S extends jni$_.JObject?>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<GrandParent$Parent<$T, $S>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  GrandParent$Parent.fromReference(
    this.T,
    this.S,
    jni$_.JReference reference,
  )   : $type = type<$T, $S>(T, S),
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$Parent');

  /// The type which includes information such as the signature of this class.
  static $GrandParent$Parent$NullableType<$T, $S>
      nullableType<$T extends jni$_.JObject?, $S extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
    jni$_.JObjType<$S> S,
  ) {
    return $GrandParent$Parent$NullableType<$T, $S>(
      T,
      S,
    );
  }

  static $GrandParent$Parent$Type<$T, $S>
      type<$T extends jni$_.JObject?, $S extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
    jni$_.JObjType<$S> S,
  ) {
    return $GrandParent$Parent$Type<$T, $S>(
      T,
      S,
    );
  }

  static final _id_parentValue = _class.instanceFieldId(
    r'parentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public T parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get parentValue => _id_parentValue.get(this, T.nullableType);

  /// from: `public T parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($T? value) =>
      _id_parentValue.set(this, T.nullableType, value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  $S? get value => _id_value.get(this, S.nullableType);

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($S? value) => _id_value.set(this, S.nullableType, value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/GrandParent;Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.GrandParent $outerClass, S object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent$Parent(
    GrandParent<$T?> $outerClass,
    $S? object, {
    jni$_.JObjType<$T>? T,
    required jni$_.JObjType<$S> S,
  }) {
    T ??= jni$_.lowestCommonSuperType([
      ($outerClass.$type as $GrandParent$Type<core$_.dynamic>).T,
    ]) as jni$_.JObjType<$T>;
    final _$$outerClass = $outerClass.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return GrandParent$Parent<$T, $S>.fromReference(
        T,
        S,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
                _$$outerClass.pointer, _$object.pointer)
            .reference);
  }
}

final class $GrandParent$Parent$NullableType<$T extends jni$_.JObject?,
        $S extends jni$_.JObject?>
    extends jni$_.JObjType<GrandParent$Parent<$T, $S>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  const $GrandParent$Parent$NullableType(
    this.T,
    this.S,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;';

  @jni$_.internal
  @core$_.override
  GrandParent$Parent<$T, $S>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : GrandParent$Parent<$T, $S>.fromReference(
              T,
              S,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GrandParent$Parent<$T, $S>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($GrandParent$Parent$NullableType, T, S);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent$Parent$NullableType<$T, $S>) &&
        other is $GrandParent$Parent$NullableType<$T, $S> &&
        T == other.T &&
        S == other.S;
  }
}

final class $GrandParent$Parent$Type<$T extends jni$_.JObject?,
        $S extends jni$_.JObject?>
    extends jni$_.JObjType<GrandParent$Parent<$T, $S>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  const $GrandParent$Parent$Type(
    this.T,
    this.S,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;';

  @jni$_.internal
  @core$_.override
  GrandParent$Parent<$T, $S> fromReference(jni$_.JReference reference) =>
      GrandParent$Parent<$T, $S>.fromReference(
        T,
        S,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GrandParent$Parent<$T, $S>?> get nullableType =>
      $GrandParent$Parent$NullableType<$T, $S>(T, S);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($GrandParent$Parent$Type, T, S);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent$Parent$Type<$T, $S>) &&
        other is $GrandParent$Parent$Type<$T, $S> &&
        T == other.T &&
        S == other.S;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$StaticParent$Child`
class GrandParent$StaticParent$Child<$S extends jni$_.JObject?,
    $U extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<GrandParent$StaticParent$Child<$S, $U>> $type;

  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  final jni$_.JObjType<$U> U;

  @jni$_.internal
  GrandParent$StaticParent$Child.fromReference(
    this.S,
    this.U,
    jni$_.JReference reference,
  )   : $type = type<$S, $U>(S, U),
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child');

  /// The type which includes information such as the signature of this class.
  static $GrandParent$StaticParent$Child$NullableType<$S, $U>
      nullableType<$S extends jni$_.JObject?, $U extends jni$_.JObject?>(
    jni$_.JObjType<$S> S,
    jni$_.JObjType<$U> U,
  ) {
    return $GrandParent$StaticParent$Child$NullableType<$S, $U>(
      S,
      U,
    );
  }

  static $GrandParent$StaticParent$Child$Type<$S, $U>
      type<$S extends jni$_.JObject?, $U extends jni$_.JObject?>(
    jni$_.JObjType<$S> S,
    jni$_.JObjType<$U> U,
  ) {
    return $GrandParent$StaticParent$Child$Type<$S, $U>(
      S,
      U,
    );
  }

  static final _id_parentValue = _class.instanceFieldId(
    r'parentValue',
    r'Ljava/lang/Object;',
  );

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  $S? get parentValue => _id_parentValue.get(this, S.nullableType);

  /// from: `public S parentValue`
  /// The returned object must be released after use, by calling the [release] method.
  set parentValue($S? value) =>
      _id_parentValue.set(this, S.nullableType, value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  $U? get value => _id_value.get(this, U.nullableType);

  /// from: `public U value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($U? value) => _id_value.set(this, U.nullableType, value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.GrandParent$StaticParent $outerClass, S object, U object1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent$StaticParent$Child(
    GrandParent$StaticParent<$S?> $outerClass,
    $S? object,
    $U? object1, {
    jni$_.JObjType<$S>? S,
    required jni$_.JObjType<$U> U,
  }) {
    S ??= jni$_.lowestCommonSuperType([
      ($outerClass.$type as $GrandParent$StaticParent$Type<core$_.dynamic>).S,
    ]) as jni$_.JObjType<$S>;
    final _$$outerClass = $outerClass.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return GrandParent$StaticParent$Child<$S, $U>.fromReference(
        S,
        U,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
                _$$outerClass.pointer, _$object.pointer, _$object1.pointer)
            .reference);
  }
}

final class $GrandParent$StaticParent$Child$NullableType<
        $S extends jni$_.JObject?, $U extends jni$_.JObject?>
    extends jni$_.JObjType<GrandParent$StaticParent$Child<$S, $U>?> {
  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  final jni$_.JObjType<$U> U;

  @jni$_.internal
  const $GrandParent$StaticParent$Child$NullableType(
    this.S,
    this.U,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child;';

  @jni$_.internal
  @core$_.override
  GrandParent$StaticParent$Child<$S, $U>? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : GrandParent$StaticParent$Child<$S, $U>.fromReference(
              S,
              U,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GrandParent$StaticParent$Child<$S, $U>?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      Object.hash($GrandParent$StaticParent$Child$NullableType, S, U);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($GrandParent$StaticParent$Child$NullableType<$S, $U>) &&
        other is $GrandParent$StaticParent$Child$NullableType<$S, $U> &&
        S == other.S &&
        U == other.U;
  }
}

final class $GrandParent$StaticParent$Child$Type<$S extends jni$_.JObject?,
        $U extends jni$_.JObject?>
    extends jni$_.JObjType<GrandParent$StaticParent$Child<$S, $U>> {
  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  final jni$_.JObjType<$U> U;

  @jni$_.internal
  const $GrandParent$StaticParent$Child$Type(
    this.S,
    this.U,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child;';

  @jni$_.internal
  @core$_.override
  GrandParent$StaticParent$Child<$S, $U> fromReference(
          jni$_.JReference reference) =>
      GrandParent$StaticParent$Child<$S, $U>.fromReference(
        S,
        U,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GrandParent$StaticParent$Child<$S, $U>?> get nullableType =>
      $GrandParent$StaticParent$Child$NullableType<$S, $U>(S, U);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($GrandParent$StaticParent$Child$Type, S, U);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($GrandParent$StaticParent$Child$Type<$S, $U>) &&
        other is $GrandParent$StaticParent$Child$Type<$S, $U> &&
        S == other.S &&
        U == other.U;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent$StaticParent`
class GrandParent$StaticParent<$S extends jni$_.JObject?>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<GrandParent$StaticParent<$S>> $type;

  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  GrandParent$StaticParent.fromReference(
    this.S,
    jni$_.JReference reference,
  )   : $type = type<$S>(S),
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/GrandParent$StaticParent');

  /// The type which includes information such as the signature of this class.
  static $GrandParent$StaticParent$NullableType<$S>
      nullableType<$S extends jni$_.JObject?>(
    jni$_.JObjType<$S> S,
  ) {
    return $GrandParent$StaticParent$NullableType<$S>(
      S,
    );
  }

  static $GrandParent$StaticParent$Type<$S> type<$S extends jni$_.JObject?>(
    jni$_.JObjType<$S> S,
  ) {
    return $GrandParent$StaticParent$Type<$S>(
      S,
    );
  }

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  $S? get value => _id_value.get(this, S.nullableType);

  /// from: `public S value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($S? value) => _id_value.set(this, S.nullableType, value);

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(S object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent$StaticParent(
    $S? object, {
    required jni$_.JObjType<$S> S,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return GrandParent$StaticParent<$S>.fromReference(
        S,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
                _$object.pointer)
            .reference);
  }
}

final class $GrandParent$StaticParent$NullableType<$S extends jni$_.JObject?>
    extends jni$_.JObjType<GrandParent$StaticParent<$S>?> {
  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  const $GrandParent$StaticParent$NullableType(
    this.S,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;';

  @jni$_.internal
  @core$_.override
  GrandParent$StaticParent<$S>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : GrandParent$StaticParent<$S>.fromReference(
              S,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GrandParent$StaticParent<$S>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($GrandParent$StaticParent$NullableType, S);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent$StaticParent$NullableType<$S>) &&
        other is $GrandParent$StaticParent$NullableType<$S> &&
        S == other.S;
  }
}

final class $GrandParent$StaticParent$Type<$S extends jni$_.JObject?>
    extends jni$_.JObjType<GrandParent$StaticParent<$S>> {
  @jni$_.internal
  final jni$_.JObjType<$S> S;

  @jni$_.internal
  const $GrandParent$StaticParent$Type(
    this.S,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;';

  @jni$_.internal
  @core$_.override
  GrandParent$StaticParent<$S> fromReference(jni$_.JReference reference) =>
      GrandParent$StaticParent<$S>.fromReference(
        S,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GrandParent$StaticParent<$S>?> get nullableType =>
      $GrandParent$StaticParent$NullableType<$S>(S);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($GrandParent$StaticParent$Type, S);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent$StaticParent$Type<$S>) &&
        other is $GrandParent$StaticParent$Type<$S> &&
        S == other.S;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.GrandParent`
class GrandParent<$T extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<GrandParent<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  GrandParent.fromReference(
    this.T,
    jni$_.JReference reference,
  )   : $type = type<$T>(T),
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/generics/GrandParent');

  /// The type which includes information such as the signature of this class.
  static $GrandParent$NullableType<$T> nullableType<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $GrandParent$NullableType<$T>(
      T,
    );
  }

  static $GrandParent$Type<$T> type<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $GrandParent$Type<$T>(
      T,
    );
  }

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public T value`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get value => _id_value.get(this, T.nullableType);

  /// from: `public T value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($T? value) => _id_value.set(this, T.nullableType, value);

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(T object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory GrandParent(
    $T? object, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return GrandParent<$T>.fromReference(
        T,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
                _$object.pointer)
            .reference);
  }

  static final _id_stringParent = _class.instanceMethodId(
    r'stringParent',
    r'()Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;',
  );

  static final _stringParent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.generics.GrandParent.Parent stringParent()`
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent$Parent<$T?, jni$_.JString?>? stringParent() {
    return _stringParent(
            reference.pointer, _id_stringParent as jni$_.JMethodIDPtr)
        .object<GrandParent$Parent<$T?, jni$_.JString?>?>(
            $GrandParent$Parent$NullableType<$T?, jni$_.JString?>(
                T.nullableType, const jni$_.JStringNullableType()));
  }

  static final _id_varParent = _class.instanceMethodId(
    r'varParent',
    r'(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;',
  );

  static final _varParent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public com.github.dart_lang.jnigen.generics.GrandParent.Parent varParent(S object)`
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent$Parent<$T?, $S?>? varParent<$S extends jni$_.JObject?>(
    $S? object, {
    required jni$_.JObjType<$S> S,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _varParent(reference.pointer, _id_varParent as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<GrandParent$Parent<$T?, $S?>?>(
            $GrandParent$Parent$NullableType<$T?, $S?>(
                T.nullableType, S.nullableType));
  }

  static final _id_stringStaticParent = _class.staticMethodId(
    r'stringStaticParent',
    r'()Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;',
  );

  static final _stringStaticParent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.generics.GrandParent$StaticParent stringStaticParent()`
  /// The returned object must be released after use, by calling the [release] method.
  static GrandParent$StaticParent<jni$_.JString?>? stringStaticParent() {
    return _stringStaticParent(_class.reference.pointer,
            _id_stringStaticParent as jni$_.JMethodIDPtr)
        .object<GrandParent$StaticParent<jni$_.JString?>?>(
            const $GrandParent$StaticParent$NullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_varStaticParent = _class.staticMethodId(
    r'varStaticParent',
    r'(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;',
  );

  static final _varStaticParent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.GrandParent$StaticParent varStaticParent(S object)`
  /// The returned object must be released after use, by calling the [release] method.
  static GrandParent$StaticParent<$S?>?
      varStaticParent<$S extends jni$_.JObject?>(
    $S? object, {
    required jni$_.JObjType<$S> S,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _varStaticParent(_class.reference.pointer,
            _id_varStaticParent as jni$_.JMethodIDPtr, _$object.pointer)
        .object<GrandParent$StaticParent<$S?>?>(
            $GrandParent$StaticParent$NullableType<$S?>(S.nullableType));
  }

  static final _id_staticParentWithSameType = _class.instanceMethodId(
    r'staticParentWithSameType',
    r'()Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;',
  );

  static final _staticParentWithSameType = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.generics.GrandParent$StaticParent staticParentWithSameType()`
  /// The returned object must be released after use, by calling the [release] method.
  GrandParent$StaticParent<$T?>? staticParentWithSameType() {
    return _staticParentWithSameType(reference.pointer,
            _id_staticParentWithSameType as jni$_.JMethodIDPtr)
        .object<GrandParent$StaticParent<$T?>?>(
            $GrandParent$StaticParent$NullableType<$T?>(T.nullableType));
  }
}

final class $GrandParent$NullableType<$T extends jni$_.JObject?>
    extends jni$_.JObjType<GrandParent<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $GrandParent$NullableType(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/GrandParent;';

  @jni$_.internal
  @core$_.override
  GrandParent<$T>? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : GrandParent<$T>.fromReference(
          T,
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GrandParent<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($GrandParent$NullableType, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent$NullableType<$T>) &&
        other is $GrandParent$NullableType<$T> &&
        T == other.T;
  }
}

final class $GrandParent$Type<$T extends jni$_.JObject?>
    extends jni$_.JObjType<GrandParent<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $GrandParent$Type(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/GrandParent;';

  @jni$_.internal
  @core$_.override
  GrandParent<$T> fromReference(jni$_.JReference reference) =>
      GrandParent<$T>.fromReference(
        T,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GrandParent<$T>?> get nullableType =>
      $GrandParent$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($GrandParent$Type, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GrandParent$Type<$T>) &&
        other is $GrandParent$Type<$T> &&
        T == other.T;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.MyMap$MyEntry`
class MyMap$MyEntry<$K extends jni$_.JObject?, $V extends jni$_.JObject?>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MyMap$MyEntry<$K, $V>> $type;

  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  MyMap$MyEntry.fromReference(
    this.K,
    this.V,
    jni$_.JReference reference,
  )   : $type = type<$K, $V>(K, V),
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/MyMap$MyEntry');

  /// The type which includes information such as the signature of this class.
  static $MyMap$MyEntry$NullableType<$K, $V>
      nullableType<$K extends jni$_.JObject?, $V extends jni$_.JObject?>(
    jni$_.JObjType<$K> K,
    jni$_.JObjType<$V> V,
  ) {
    return $MyMap$MyEntry$NullableType<$K, $V>(
      K,
      V,
    );
  }

  static $MyMap$MyEntry$Type<$K, $V>
      type<$K extends jni$_.JObject?, $V extends jni$_.JObject?>(
    jni$_.JObjType<$K> K,
    jni$_.JObjType<$V> V,
  ) {
    return $MyMap$MyEntry$Type<$K, $V>(
      K,
      V,
    );
  }

  static final _id_key = _class.instanceFieldId(
    r'key',
    r'Ljava/lang/Object;',
  );

  /// from: `public K key`
  /// The returned object must be released after use, by calling the [release] method.
  $K? get key => _id_key.get(this, K.nullableType);

  /// from: `public K key`
  /// The returned object must be released after use, by calling the [release] method.
  set key($K? value) => _id_key.set(this, K.nullableType, value);

  static final _id_value = _class.instanceFieldId(
    r'value',
    r'Ljava/lang/Object;',
  );

  /// from: `public V value`
  /// The returned object must be released after use, by calling the [release] method.
  $V? get value => _id_value.get(this, V.nullableType);

  /// from: `public V value`
  /// The returned object must be released after use, by calling the [release] method.
  set value($V? value) => _id_value.set(this, V.nullableType, value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/generics/MyMap;Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.generics.MyMap $outerClass, K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyMap$MyEntry(
    MyMap<$K?, $V?> $outerClass,
    $K? object,
    $V? object1, {
    jni$_.JObjType<$K>? K,
    jni$_.JObjType<$V>? V,
  }) {
    K ??= jni$_.lowestCommonSuperType([
      ($outerClass.$type as $MyMap$Type<core$_.dynamic, core$_.dynamic>).K,
    ]) as jni$_.JObjType<$K>;
    V ??= jni$_.lowestCommonSuperType([
      ($outerClass.$type as $MyMap$Type<core$_.dynamic, core$_.dynamic>).V,
    ]) as jni$_.JObjType<$V>;
    final _$$outerClass = $outerClass.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return MyMap$MyEntry<$K, $V>.fromReference(
        K,
        V,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
                _$$outerClass.pointer, _$object.pointer, _$object1.pointer)
            .reference);
  }
}

final class $MyMap$MyEntry$NullableType<$K extends jni$_.JObject?,
    $V extends jni$_.JObject?> extends jni$_.JObjType<MyMap$MyEntry<$K, $V>?> {
  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  const $MyMap$MyEntry$NullableType(
    this.K,
    this.V,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/MyMap$MyEntry;';

  @jni$_.internal
  @core$_.override
  MyMap$MyEntry<$K, $V>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MyMap$MyEntry<$K, $V>.fromReference(
              K,
              V,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyMap$MyEntry<$K, $V>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($MyMap$MyEntry$NullableType, K, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyMap$MyEntry$NullableType<$K, $V>) &&
        other is $MyMap$MyEntry$NullableType<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

final class $MyMap$MyEntry$Type<$K extends jni$_.JObject?,
    $V extends jni$_.JObject?> extends jni$_.JObjType<MyMap$MyEntry<$K, $V>> {
  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  const $MyMap$MyEntry$Type(
    this.K,
    this.V,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/MyMap$MyEntry;';

  @jni$_.internal
  @core$_.override
  MyMap$MyEntry<$K, $V> fromReference(jni$_.JReference reference) =>
      MyMap$MyEntry<$K, $V>.fromReference(
        K,
        V,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyMap$MyEntry<$K, $V>?> get nullableType =>
      $MyMap$MyEntry$NullableType<$K, $V>(K, V);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($MyMap$MyEntry$Type, K, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyMap$MyEntry$Type<$K, $V>) &&
        other is $MyMap$MyEntry$Type<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.MyMap`
class MyMap<$K extends jni$_.JObject?, $V extends jni$_.JObject?>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MyMap<$K, $V>> $type;

  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  MyMap.fromReference(
    this.K,
    this.V,
    jni$_.JReference reference,
  )   : $type = type<$K, $V>(K, V),
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/generics/MyMap');

  /// The type which includes information such as the signature of this class.
  static $MyMap$NullableType<$K, $V>
      nullableType<$K extends jni$_.JObject?, $V extends jni$_.JObject?>(
    jni$_.JObjType<$K> K,
    jni$_.JObjType<$V> V,
  ) {
    return $MyMap$NullableType<$K, $V>(
      K,
      V,
    );
  }

  static $MyMap$Type<$K, $V>
      type<$K extends jni$_.JObject?, $V extends jni$_.JObject?>(
    jni$_.JObjType<$K> K,
    jni$_.JObjType<$V> V,
  ) {
    return $MyMap$Type<$K, $V>(
      K,
      V,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyMap({
    required jni$_.JObjType<$K> K,
    required jni$_.JObjType<$V> V,
  }) {
    return MyMap<$K, $V>.fromReference(
        K,
        V,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _get = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V get(K object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? get(
    $K? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _get(
            reference.pointer, _id_get as jni$_.JMethodIDPtr, _$object.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _put = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V put(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? put(
    $K? object,
    $V? object1,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _put(reference.pointer, _id_put as jni$_.JMethodIDPtr,
            _$object.pointer, _$object1.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_entryStack = _class.instanceMethodId(
    r'entryStack',
    r'()Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _entryStack = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.generics.MyStack entryStack()`
  /// The returned object must be released after use, by calling the [release] method.
  MyStack<MyMap$MyEntry<$K?, $V?>?>? entryStack() {
    return _entryStack(reference.pointer, _id_entryStack as jni$_.JMethodIDPtr)
        .object<MyStack<MyMap$MyEntry<$K?, $V?>?>?>(
            $MyStack$NullableType<MyMap$MyEntry<$K?, $V?>?>(
                $MyMap$MyEntry$NullableType<$K?, $V?>(
                    K.nullableType, V.nullableType)));
  }
}

final class $MyMap$NullableType<$K extends jni$_.JObject?,
    $V extends jni$_.JObject?> extends jni$_.JObjType<MyMap<$K, $V>?> {
  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  const $MyMap$NullableType(
    this.K,
    this.V,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/MyMap;';

  @jni$_.internal
  @core$_.override
  MyMap<$K, $V>? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : MyMap<$K, $V>.fromReference(
          K,
          V,
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyMap<$K, $V>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($MyMap$NullableType, K, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyMap$NullableType<$K, $V>) &&
        other is $MyMap$NullableType<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

final class $MyMap$Type<$K extends jni$_.JObject?, $V extends jni$_.JObject?>
    extends jni$_.JObjType<MyMap<$K, $V>> {
  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  const $MyMap$Type(
    this.K,
    this.V,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/MyMap;';

  @jni$_.internal
  @core$_.override
  MyMap<$K, $V> fromReference(jni$_.JReference reference) =>
      MyMap<$K, $V>.fromReference(
        K,
        V,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyMap<$K, $V>?> get nullableType =>
      $MyMap$NullableType<$K, $V>(K, V);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($MyMap$Type, K, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyMap$Type<$K, $V>) &&
        other is $MyMap$Type<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.MyStack`
class MyStack<$T extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MyStack<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  MyStack.fromReference(
    this.T,
    jni$_.JReference reference,
  )   : $type = type<$T>(T),
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/generics/MyStack');

  /// The type which includes information such as the signature of this class.
  static $MyStack$NullableType<$T> nullableType<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $MyStack$NullableType<$T>(
      T,
    );
  }

  static $MyStack$Type<$T> type<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $MyStack$Type<$T>(
      T,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyStack({
    required jni$_.JObjType<$T> T,
  }) {
    return MyStack<$T>.fromReference(
        T,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_fromArray = _class.staticMethodId(
    r'fromArray',
    r'([Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _fromArray = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack fromArray(java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T?>? fromArray<$T extends jni$_.JObject?>(
    jni$_.JArray<$T?>? objects, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _fromArray(_class.reference.pointer,
            _id_fromArray as jni$_.JMethodIDPtr, _$objects.pointer)
        .object<MyStack<$T?>?>($MyStack$NullableType<$T?>(T.nullableType));
  }

  static final _id_fromArrayOfArrayOfGrandParents = _class.staticMethodId(
    r'fromArrayOfArrayOfGrandParents',
    r'([[Lcom/github/dart_lang/jnigen/generics/GrandParent;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _fromArrayOfArrayOfGrandParents =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack fromArrayOfArrayOfGrandParents(java.lang.Object[] grandParents)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$S?>?
      fromArrayOfArrayOfGrandParents<$S extends jni$_.JObject?>(
    jni$_.JArray<jni$_.JArray<GrandParent<$S?>?>?>? grandParents, {
    required jni$_.JObjType<$S> S,
  }) {
    final _$grandParents = grandParents?.reference ?? jni$_.jNullReference;
    return _fromArrayOfArrayOfGrandParents(
            _class.reference.pointer,
            _id_fromArrayOfArrayOfGrandParents as jni$_.JMethodIDPtr,
            _$grandParents.pointer)
        .object<MyStack<$S?>?>($MyStack$NullableType<$S?>(S.nullableType));
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'()Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _of = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack of()`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T?>? of<$T extends jni$_.JObject?>({
    required jni$_.JObjType<$T> T,
  }) {
    return _of(_class.reference.pointer, _id_of as jni$_.JMethodIDPtr)
        .object<MyStack<$T?>?>($MyStack$NullableType<$T?>(T.nullableType));
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _of$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack of(T object)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T?>? of$1<$T extends jni$_.JObject?>(
    $T? object, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _of$1(_class.reference.pointer, _id_of$1 as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<MyStack<$T?>?>($MyStack$NullableType<$T?>(T.nullableType));
  }

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Lcom/github/dart_lang/jnigen/generics/MyStack;',
  );

  static final _of$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.generics.MyStack of(T object, T object1)`
  /// The returned object must be released after use, by calling the [release] method.
  static MyStack<$T?>? of$2<$T extends jni$_.JObject?>(
    $T? object,
    $T? object1, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _of$2(_class.reference.pointer, _id_of$2 as jni$_.JMethodIDPtr,
            _$object.pointer, _$object1.pointer)
        .object<MyStack<$T?>?>($MyStack$NullableType<$T?>(T.nullableType));
  }

  static final _id_push = _class.instanceMethodId(
    r'push',
    r'(Ljava/lang/Object;)V',
  );

  static final _push = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void push(T object)`
  void push(
    $T? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _push(reference.pointer, _id_push as jni$_.JMethodIDPtr, _$object.pointer)
        .check();
  }

  static final _id_pop = _class.instanceMethodId(
    r'pop',
    r'()Ljava/lang/Object;',
  );

  static final _pop = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public T pop()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? pop() {
    return _pop(reference.pointer, _id_pop as jni$_.JMethodIDPtr)
        .object<$T?>(T.nullableType);
  }

  static final _id_size = _class.instanceMethodId(
    r'size',
    r'()I',
  );

  static final _size = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int size()`
  int size() {
    return _size(reference.pointer, _id_size as jni$_.JMethodIDPtr).integer;
  }
}

final class $MyStack$NullableType<$T extends jni$_.JObject?>
    extends jni$_.JObjType<MyStack<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $MyStack$NullableType(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/MyStack;';

  @jni$_.internal
  @core$_.override
  MyStack<$T>? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : MyStack<$T>.fromReference(
          T,
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyStack<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($MyStack$NullableType, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyStack$NullableType<$T>) &&
        other is $MyStack$NullableType<$T> &&
        T == other.T;
  }
}

final class $MyStack$Type<$T extends jni$_.JObject?>
    extends jni$_.JObjType<MyStack<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $MyStack$Type(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/MyStack;';

  @jni$_.internal
  @core$_.override
  MyStack<$T> fromReference(jni$_.JReference reference) =>
      MyStack<$T>.fromReference(
        T,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyStack<$T>?> get nullableType => $MyStack$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($MyStack$Type, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyStack$Type<$T>) &&
        other is $MyStack$Type<$T> &&
        T == other.T;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.StringKeyedMap`
class StringKeyedMap<$V extends jni$_.JObject?>
    extends MyMap<jni$_.JString?, $V?> {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StringKeyedMap<$V>> $type;

  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  StringKeyedMap.fromReference(
    this.V,
    jni$_.JReference reference,
  )   : $type = type<$V>(V),
        super.fromReference(
            const jni$_.JStringNullableType(), V.nullableType, reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/StringKeyedMap');

  /// The type which includes information such as the signature of this class.
  static $StringKeyedMap$NullableType<$V>
      nullableType<$V extends jni$_.JObject?>(
    jni$_.JObjType<$V> V,
  ) {
    return $StringKeyedMap$NullableType<$V>(
      V,
    );
  }

  static $StringKeyedMap$Type<$V> type<$V extends jni$_.JObject?>(
    jni$_.JObjType<$V> V,
  ) {
    return $StringKeyedMap$Type<$V>(
      V,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringKeyedMap({
    required jni$_.JObjType<$V> V,
  }) {
    return StringKeyedMap<$V>.fromReference(
        V,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $StringKeyedMap$NullableType<$V extends jni$_.JObject?>
    extends jni$_.JObjType<StringKeyedMap<$V>?> {
  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  const $StringKeyedMap$NullableType(
    this.V,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/StringKeyedMap;';

  @jni$_.internal
  @core$_.override
  StringKeyedMap<$V>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : StringKeyedMap<$V>.fromReference(
              V,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => $MyMap$NullableType<jni$_.JString?, $V?>(
      const jni$_.JStringNullableType(), V.nullableType);

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringKeyedMap<$V>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => Object.hash($StringKeyedMap$NullableType, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringKeyedMap$NullableType<$V>) &&
        other is $StringKeyedMap$NullableType<$V> &&
        V == other.V;
  }
}

final class $StringKeyedMap$Type<$V extends jni$_.JObject?>
    extends jni$_.JObjType<StringKeyedMap<$V>> {
  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  const $StringKeyedMap$Type(
    this.V,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/StringKeyedMap;';

  @jni$_.internal
  @core$_.override
  StringKeyedMap<$V> fromReference(jni$_.JReference reference) =>
      StringKeyedMap<$V>.fromReference(
        V,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => $MyMap$NullableType<jni$_.JString?, $V?>(
      const jni$_.JStringNullableType(), V.nullableType);

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringKeyedMap<$V>?> get nullableType =>
      $StringKeyedMap$NullableType<$V>(V);

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => Object.hash($StringKeyedMap$Type, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringKeyedMap$Type<$V>) &&
        other is $StringKeyedMap$Type<$V> &&
        V == other.V;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.StringMap`
class StringMap extends StringKeyedMap<jni$_.JString?> {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StringMap> $type;

  @jni$_.internal
  StringMap.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(const jni$_.JStringNullableType(), reference);

  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/generics/StringMap');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StringMap$NullableType();
  static const type = $StringMap$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringMap() {
    return StringMap.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $StringMap$NullableType extends jni$_.JObjType<StringMap?> {
  @jni$_.internal
  const $StringMap$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/StringMap;';

  @jni$_.internal
  @core$_.override
  StringMap? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : StringMap.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $StringKeyedMap$NullableType<jni$_.JString?>(
          jni$_.JStringNullableType());

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringMap?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($StringMap$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringMap$NullableType) &&
        other is $StringMap$NullableType;
  }
}

final class $StringMap$Type extends jni$_.JObjType<StringMap> {
  @jni$_.internal
  const $StringMap$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/StringMap;';

  @jni$_.internal
  @core$_.override
  StringMap fromReference(jni$_.JReference reference) =>
      StringMap.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $StringKeyedMap$NullableType<jni$_.JString?>(
          jni$_.JStringNullableType());

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringMap?> get nullableType =>
      const $StringMap$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($StringMap$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringMap$Type) && other is $StringMap$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.StringStack`
class StringStack extends MyStack<jni$_.JString?> {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StringStack> $type;

  @jni$_.internal
  StringStack.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(const jni$_.JStringNullableType(), reference);

  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/generics/StringStack');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StringStack$NullableType();
  static const type = $StringStack$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringStack() {
    return StringStack.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $StringStack$NullableType extends jni$_.JObjType<StringStack?> {
  @jni$_.internal
  const $StringStack$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/StringStack;';

  @jni$_.internal
  @core$_.override
  StringStack? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : StringStack.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $MyStack$NullableType<jni$_.JString?>(jni$_.JStringNullableType());

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringStack?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($StringStack$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringStack$NullableType) &&
        other is $StringStack$NullableType;
  }
}

final class $StringStack$Type extends jni$_.JObjType<StringStack> {
  @jni$_.internal
  const $StringStack$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/generics/StringStack;';

  @jni$_.internal
  @core$_.override
  StringStack fromReference(jni$_.JReference reference) =>
      StringStack.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $MyStack$NullableType<jni$_.JString?>(jni$_.JStringNullableType());

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringStack?> get nullableType =>
      const $StringStack$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($StringStack$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringStack$Type) &&
        other is $StringStack$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.generics.StringValuedMap`
class StringValuedMap<$K extends jni$_.JObject?>
    extends MyMap<$K?, jni$_.JString?> {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StringValuedMap<$K>> $type;

  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  StringValuedMap.fromReference(
    this.K,
    jni$_.JReference reference,
  )   : $type = type<$K>(K),
        super.fromReference(
            K.nullableType, const jni$_.JStringNullableType(), reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/generics/StringValuedMap');

  /// The type which includes information such as the signature of this class.
  static $StringValuedMap$NullableType<$K>
      nullableType<$K extends jni$_.JObject?>(
    jni$_.JObjType<$K> K,
  ) {
    return $StringValuedMap$NullableType<$K>(
      K,
    );
  }

  static $StringValuedMap$Type<$K> type<$K extends jni$_.JObject?>(
    jni$_.JObjType<$K> K,
  ) {
    return $StringValuedMap$Type<$K>(
      K,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringValuedMap({
    required jni$_.JObjType<$K> K,
  }) {
    return StringValuedMap<$K>.fromReference(
        K,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $StringValuedMap$NullableType<$K extends jni$_.JObject?>
    extends jni$_.JObjType<StringValuedMap<$K>?> {
  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  const $StringValuedMap$NullableType(
    this.K,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/StringValuedMap;';

  @jni$_.internal
  @core$_.override
  StringValuedMap<$K>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : StringValuedMap<$K>.fromReference(
              K,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => $MyMap$NullableType<$K?, jni$_.JString?>(
      K.nullableType, const jni$_.JStringNullableType());

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringValuedMap<$K>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => Object.hash($StringValuedMap$NullableType, K);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringValuedMap$NullableType<$K>) &&
        other is $StringValuedMap$NullableType<$K> &&
        K == other.K;
  }
}

final class $StringValuedMap$Type<$K extends jni$_.JObject?>
    extends jni$_.JObjType<StringValuedMap<$K>> {
  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  const $StringValuedMap$Type(
    this.K,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/generics/StringValuedMap;';

  @jni$_.internal
  @core$_.override
  StringValuedMap<$K> fromReference(jni$_.JReference reference) =>
      StringValuedMap<$K>.fromReference(
        K,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => $MyMap$NullableType<$K?, jni$_.JString?>(
      K.nullableType, const jni$_.JStringNullableType());

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringValuedMap<$K>?> get nullableType =>
      $StringValuedMap$NullableType<$K>(K);

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => Object.hash($StringValuedMap$Type, K);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringValuedMap$Type<$K>) &&
        other is $StringValuedMap$Type<$K> &&
        K == other.K;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.GenericInterface`
class GenericInterface<$T extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<GenericInterface<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  GenericInterface.fromReference(
    this.T,
    jni$_.JReference reference,
  )   : $type = type<$T>(T),
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/GenericInterface');

  /// The type which includes information such as the signature of this class.
  static $GenericInterface$NullableType<$T>
      nullableType<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $GenericInterface$NullableType<$T>(
      T,
    );
  }

  static $GenericInterface$Type<$T> type<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $GenericInterface$Type<$T>(
      T,
    );
  }

  static final _id_genericArrayOf = _class.instanceMethodId(
    r'genericArrayOf',
    r'(Ljava/lang/Object;)[Ljava/lang/Object;',
  );

  static final _genericArrayOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object[] genericArrayOf(U object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<$U?>? genericArrayOf<$U extends jni$_.JObject?>(
    $U? object, {
    required jni$_.JObjType<$U> U,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _genericArrayOf(reference.pointer,
            _id_genericArrayOf as jni$_.JMethodIDPtr, _$object.pointer)
        .object<jni$_.JArray<$U?>?>(
            jni$_.JArrayNullableType<$U?>(U.nullableType));
  }

  static final _id_arrayOf = _class.instanceMethodId(
    r'arrayOf',
    r'(Ljava/lang/Object;)[Ljava/lang/Object;',
  );

  static final _arrayOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.Object[] arrayOf(T object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<$T?>? arrayOf(
    $T? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _arrayOf(reference.pointer, _id_arrayOf as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<jni$_.JArray<$T?>?>(
            jni$_.JArrayNullableType<$T?>(T.nullableType));
  }

  static final _id_mapOf = _class.instanceMethodId(
    r'mapOf',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/Map;',
  );

  static final _mapOf = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.util.Map mapOf(T object, U object1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<$T?, $U?>? mapOf<$U extends jni$_.JObject?>(
    $T? object,
    $U? object1, {
    required jni$_.JObjType<$U> U,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _mapOf(reference.pointer, _id_mapOf as jni$_.JMethodIDPtr,
            _$object.pointer, _$object1.pointer)
        .object<jni$_.JMap<$T?, $U?>?>(
            jni$_.JMapNullableType<$T?, $U?>(T.nullableType, U.nullableType));
  }

  static final _id_firstOfGenericArray = _class.instanceMethodId(
    r'firstOfGenericArray',
    r'([Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _firstOfGenericArray = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract U firstOfGenericArray(java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  $U? firstOfGenericArray<$U extends jni$_.JObject?>(
    jni$_.JArray<$U?>? objects, {
    required jni$_.JObjType<$U> U,
  }) {
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _firstOfGenericArray(reference.pointer,
            _id_firstOfGenericArray as jni$_.JMethodIDPtr, _$objects.pointer)
        .object<$U?>(U.nullableType);
  }

  static final _id_firstOfArray = _class.instanceMethodId(
    r'firstOfArray',
    r'([Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _firstOfArray = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract T firstOfArray(java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstOfArray(
    jni$_.JArray<$T?>? objects,
  ) {
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _firstOfArray(reference.pointer,
            _id_firstOfArray as jni$_.JMethodIDPtr, _$objects.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_firstKeyOf = _class.instanceMethodId(
    r'firstKeyOf',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstKeyOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract T firstKeyOf(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstKeyOf<$U extends jni$_.JObject?>(
    jni$_.JMap<$T?, $U?>? map, {
    required jni$_.JObjType<$U> U,
  }) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _firstKeyOf(reference.pointer, _id_firstKeyOf as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_firstValueOf = _class.instanceMethodId(
    r'firstValueOf',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract U firstValueOf(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $U? firstValueOf<$U extends jni$_.JObject?>(
    jni$_.JMap<$T?, $U?>? map, {
    required jni$_.JObjType<$U> U,
  }) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _firstValueOf(reference.pointer,
            _id_firstValueOf as jni$_.JMethodIDPtr, _$map.pointer)
        .object<$U?>(U.nullableType);
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $GenericInterface> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'genericArrayOf(Ljava/lang/Object;)[Ljava/lang/Object;') {
        final $r = _$impls[$p]!.genericArrayOf(
          $a![0]?.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'arrayOf(Ljava/lang/Object;)[Ljava/lang/Object;') {
        final $r = _$impls[$p]!.arrayOf(
          $a![0]?.as(_$impls[$p]!.T, releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'mapOf(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/Map;') {
        final $r = _$impls[$p]!.mapOf(
          $a![0]?.as(_$impls[$p]!.T, releaseOriginal: true),
          $a![1]?.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'firstOfGenericArray([Ljava/lang/Object;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.firstOfGenericArray(
          $a![0]?.as(
              const jni$_.JArrayType<jni$_.JObject?>(
                  jni$_.JObjectNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'firstOfArray([Ljava/lang/Object;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.firstOfArray(
          $a![0]?.as(
              const jni$_.JArrayType<jni$_.JObject?>(
                  jni$_.JObjectNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'firstKeyOf(Ljava/util/Map;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.firstKeyOf(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                  jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'firstValueOf(Ljava/util/Map;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.firstValueOf(
          $a![0]?.as(
              const jni$_.JMapType<jni$_.JObject?, jni$_.JObject?>(
                  jni$_.JObjectNullableType(), jni$_.JObjectNullableType()),
              releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$T extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $GenericInterface<$T> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.interfaces.GenericInterface',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory GenericInterface.implement(
    $GenericInterface<$T> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return GenericInterface<$T>.fromReference(
      $impl.T,
      $i.implementReference(),
    );
  }
}

abstract base mixin class $GenericInterface<$T extends jni$_.JObject?> {
  factory $GenericInterface({
    required jni$_.JObjType<$T> T,
    required jni$_.JArray<jni$_.JObject?>? Function(jni$_.JObject? object)
        genericArrayOf,
    required jni$_.JArray<jni$_.JObject?>? Function($T? object) arrayOf,
    required jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? Function(
            $T? object, jni$_.JObject? object1)
        mapOf,
    required jni$_.JObject? Function(jni$_.JArray<jni$_.JObject?>? objects)
        firstOfGenericArray,
    required $T? Function(jni$_.JArray<jni$_.JObject?>? objects) firstOfArray,
    required $T? Function(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
        firstKeyOf,
    required jni$_.JObject? Function(
            jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
        firstValueOf,
  }) = _$GenericInterface<$T>;

  jni$_.JObjType<$T> get T;

  jni$_.JArray<jni$_.JObject?>? genericArrayOf(jni$_.JObject? object);
  jni$_.JArray<jni$_.JObject?>? arrayOf($T? object);
  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? mapOf(
      $T? object, jni$_.JObject? object1);
  jni$_.JObject? firstOfGenericArray(jni$_.JArray<jni$_.JObject?>? objects);
  $T? firstOfArray(jni$_.JArray<jni$_.JObject?>? objects);
  $T? firstKeyOf(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map);
  jni$_.JObject? firstValueOf(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map);
}

final class _$GenericInterface<$T extends jni$_.JObject?>
    with $GenericInterface<$T> {
  _$GenericInterface({
    required this.T,
    required jni$_.JArray<jni$_.JObject?>? Function(jni$_.JObject? object)
        genericArrayOf,
    required jni$_.JArray<jni$_.JObject?>? Function($T? object) arrayOf,
    required jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? Function(
            $T? object, jni$_.JObject? object1)
        mapOf,
    required jni$_.JObject? Function(jni$_.JArray<jni$_.JObject?>? objects)
        firstOfGenericArray,
    required $T? Function(jni$_.JArray<jni$_.JObject?>? objects) firstOfArray,
    required $T? Function(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
        firstKeyOf,
    required jni$_.JObject? Function(
            jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
        firstValueOf,
  })  : _genericArrayOf = genericArrayOf,
        _arrayOf = arrayOf,
        _mapOf = mapOf,
        _firstOfGenericArray = firstOfGenericArray,
        _firstOfArray = firstOfArray,
        _firstKeyOf = firstKeyOf,
        _firstValueOf = firstValueOf;

  @core$_.override
  final jni$_.JObjType<$T> T;

  final jni$_.JArray<jni$_.JObject?>? Function(jni$_.JObject? object)
      _genericArrayOf;
  final jni$_.JArray<jni$_.JObject?>? Function($T? object) _arrayOf;
  final jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? Function(
      $T? object, jni$_.JObject? object1) _mapOf;
  final jni$_.JObject? Function(jni$_.JArray<jni$_.JObject?>? objects)
      _firstOfGenericArray;
  final $T? Function(jni$_.JArray<jni$_.JObject?>? objects) _firstOfArray;
  final $T? Function(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
      _firstKeyOf;
  final jni$_.JObject? Function(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map)
      _firstValueOf;

  jni$_.JArray<jni$_.JObject?>? genericArrayOf(jni$_.JObject? object) {
    return _genericArrayOf(object);
  }

  jni$_.JArray<jni$_.JObject?>? arrayOf($T? object) {
    return _arrayOf(object);
  }

  jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? mapOf(
      $T? object, jni$_.JObject? object1) {
    return _mapOf(object, object1);
  }

  jni$_.JObject? firstOfGenericArray(jni$_.JArray<jni$_.JObject?>? objects) {
    return _firstOfGenericArray(objects);
  }

  $T? firstOfArray(jni$_.JArray<jni$_.JObject?>? objects) {
    return _firstOfArray(objects);
  }

  $T? firstKeyOf(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map) {
    return _firstKeyOf(map);
  }

  jni$_.JObject? firstValueOf(jni$_.JMap<jni$_.JObject?, jni$_.JObject?>? map) {
    return _firstValueOf(map);
  }
}

final class $GenericInterface$NullableType<$T extends jni$_.JObject?>
    extends jni$_.JObjType<GenericInterface<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $GenericInterface$NullableType(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/GenericInterface;';

  @jni$_.internal
  @core$_.override
  GenericInterface<$T>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : GenericInterface<$T>.fromReference(
              T,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GenericInterface<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($GenericInterface$NullableType, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GenericInterface$NullableType<$T>) &&
        other is $GenericInterface$NullableType<$T> &&
        T == other.T;
  }
}

final class $GenericInterface$Type<$T extends jni$_.JObject?>
    extends jni$_.JObjType<GenericInterface<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $GenericInterface$Type(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/GenericInterface;';

  @jni$_.internal
  @core$_.override
  GenericInterface<$T> fromReference(jni$_.JReference reference) =>
      GenericInterface<$T>.fromReference(
        T,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GenericInterface<$T>?> get nullableType =>
      $GenericInterface$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($GenericInterface$Type, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GenericInterface$Type<$T>) &&
        other is $GenericInterface$Type<$T> &&
        T == other.T;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyInterface`
class MyInterface<$T extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MyInterface<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  MyInterface.fromReference(
    this.T,
    jni$_.JReference reference,
  )   : $type = type<$T>(T),
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyInterface');

  /// The type which includes information such as the signature of this class.
  static $MyInterface$NullableType<$T> nullableType<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $MyInterface$NullableType<$T>(
      T,
    );
  }

  static $MyInterface$Type<$T> type<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $MyInterface$Type<$T>(
      T,
    );
  }

  static final _id_voidCallback = _class.instanceMethodId(
    r'voidCallback',
    r'(Ljava/lang/String;)V',
  );

  static final _voidCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void voidCallback(java.lang.String string)`
  void voidCallback(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _voidCallback(reference.pointer, _id_voidCallback as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }

  static final _id_stringCallback = _class.instanceMethodId(
    r'stringCallback',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _stringCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.lang.String stringCallback(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? stringCallback(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _stringCallback(reference.pointer,
            _id_stringCallback as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_varCallback = _class.instanceMethodId(
    r'varCallback',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _varCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract T varCallback(T object)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? varCallback(
    $T? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _varCallback(reference.pointer,
            _id_varCallback as jni$_.JMethodIDPtr, _$object.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_manyPrimitives = _class.instanceMethodId(
    r'manyPrimitives',
    r'(IZCD)J',
  );

  static final _manyPrimitives = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Double
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, int, int, double)>();

  /// from: `public abstract long manyPrimitives(int i, boolean z, char c, double d)`
  int manyPrimitives(
    int i,
    bool z,
    int c,
    double d,
  ) {
    return _manyPrimitives(reference.pointer,
            _id_manyPrimitives as jni$_.JMethodIDPtr, i, z ? 1 : 0, c, d)
        .long;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MyInterface> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'voidCallback(Ljava/lang/String;)V') {
        _$impls[$p]!.voidCallback(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'stringCallback(Ljava/lang/String;)Ljava/lang/String;') {
        final $r = _$impls[$p]!.stringCallback(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'varCallback(Ljava/lang/Object;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.varCallback(
          $a![0]?.as(_$impls[$p]!.T, releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'manyPrimitives(IZCD)J') {
        final $r = _$impls[$p]!.manyPrimitives(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JCharacterType(), releaseOriginal: true)
              .charValue(releaseOriginal: true),
          $a![3]!
              .as(const jni$_.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return jni$_.JLong($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$T extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $MyInterface<$T> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.interfaces.MyInterface',
      $p,
      _$invokePointer,
      [
        if ($impl.voidCallback$async) r'voidCallback(Ljava/lang/String;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MyInterface.implement(
    $MyInterface<$T> $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MyInterface<$T>.fromReference(
      $impl.T,
      $i.implementReference(),
    );
  }
  static core$_.Map<int, $MyInterface> get $impls => _$impls;
}

abstract base mixin class $MyInterface<$T extends jni$_.JObject?> {
  factory $MyInterface({
    required jni$_.JObjType<$T> T,
    required void Function(jni$_.JString? string) voidCallback,
    bool voidCallback$async,
    required jni$_.JString? Function(jni$_.JString? string) stringCallback,
    required $T? Function($T? object) varCallback,
    required int Function(int i, bool z, int c, double d) manyPrimitives,
  }) = _$MyInterface<$T>;

  jni$_.JObjType<$T> get T;

  void voidCallback(jni$_.JString? string);
  bool get voidCallback$async => false;
  jni$_.JString? stringCallback(jni$_.JString? string);
  $T? varCallback($T? object);
  int manyPrimitives(int i, bool z, int c, double d);
}

final class _$MyInterface<$T extends jni$_.JObject?> with $MyInterface<$T> {
  _$MyInterface({
    required this.T,
    required void Function(jni$_.JString? string) voidCallback,
    this.voidCallback$async = false,
    required jni$_.JString? Function(jni$_.JString? string) stringCallback,
    required $T? Function($T? object) varCallback,
    required int Function(int i, bool z, int c, double d) manyPrimitives,
  })  : _voidCallback = voidCallback,
        _stringCallback = stringCallback,
        _varCallback = varCallback,
        _manyPrimitives = manyPrimitives;

  @core$_.override
  final jni$_.JObjType<$T> T;

  final void Function(jni$_.JString? string) _voidCallback;
  final bool voidCallback$async;
  final jni$_.JString? Function(jni$_.JString? string) _stringCallback;
  final $T? Function($T? object) _varCallback;
  final int Function(int i, bool z, int c, double d) _manyPrimitives;

  void voidCallback(jni$_.JString? string) {
    return _voidCallback(string);
  }

  jni$_.JString? stringCallback(jni$_.JString? string) {
    return _stringCallback(string);
  }

  $T? varCallback($T? object) {
    return _varCallback(object);
  }

  int manyPrimitives(int i, bool z, int c, double d) {
    return _manyPrimitives(i, z, c, d);
  }
}

final class $MyInterface$NullableType<$T extends jni$_.JObject?>
    extends jni$_.JObjType<MyInterface<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $MyInterface$NullableType(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyInterface;';

  @jni$_.internal
  @core$_.override
  MyInterface<$T>? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : MyInterface<$T>.fromReference(
          T,
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyInterface<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($MyInterface$NullableType, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyInterface$NullableType<$T>) &&
        other is $MyInterface$NullableType<$T> &&
        T == other.T;
  }
}

final class $MyInterface$Type<$T extends jni$_.JObject?>
    extends jni$_.JObjType<MyInterface<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $MyInterface$Type(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyInterface;';

  @jni$_.internal
  @core$_.override
  MyInterface<$T> fromReference(jni$_.JReference reference) =>
      MyInterface<$T>.fromReference(
        T,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyInterface<$T>?> get nullableType =>
      $MyInterface$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($MyInterface$Type, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyInterface$Type<$T>) &&
        other is $MyInterface$Type<$T> &&
        T == other.T;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyInterfaceConsumer`
class MyInterfaceConsumer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MyInterfaceConsumer> $type;

  @jni$_.internal
  MyInterfaceConsumer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyInterfaceConsumer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MyInterfaceConsumer$NullableType();
  static const type = $MyInterfaceConsumer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyInterfaceConsumer() {
    return MyInterfaceConsumer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_consumeOnAnotherThread = _class.staticMethodId(
    r'consumeOnAnotherThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/MyInterface;Ljava/lang/String;IZCDLjava/lang/Object;)V',
  );

  static final _consumeOnAnotherThread = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void consumeOnAnotherThread(com.github.dart_lang.jnigen.interfaces.MyInterface myInterface, java.lang.String string, int i, boolean z, char c, double d, T object)`
  static void consumeOnAnotherThread<$T extends jni$_.JObject?>(
    MyInterface<$T?>? myInterface,
    jni$_.JString? string,
    int i,
    bool z,
    int c,
    double d,
    $T? object, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$myInterface = myInterface?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _consumeOnAnotherThread(
            _class.reference.pointer,
            _id_consumeOnAnotherThread as jni$_.JMethodIDPtr,
            _$myInterface.pointer,
            _$string.pointer,
            i,
            z ? 1 : 0,
            c,
            d,
            _$object.pointer)
        .check();
  }

  static final _id_consumeOnSameThread = _class.staticMethodId(
    r'consumeOnSameThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/MyInterface;Ljava/lang/String;IZCDLjava/lang/Object;)V',
  );

  static final _consumeOnSameThread = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Double,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void consumeOnSameThread(com.github.dart_lang.jnigen.interfaces.MyInterface myInterface, java.lang.String string, int i, boolean z, char c, double d, T object)`
  static void consumeOnSameThread<$T extends jni$_.JObject?>(
    MyInterface<$T?>? myInterface,
    jni$_.JString? string,
    int i,
    bool z,
    int c,
    double d,
    $T? object, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$myInterface = myInterface?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _consumeOnSameThread(
            _class.reference.pointer,
            _id_consumeOnSameThread as jni$_.JMethodIDPtr,
            _$myInterface.pointer,
            _$string.pointer,
            i,
            z ? 1 : 0,
            c,
            d,
            _$object.pointer)
        .check();
  }
}

final class $MyInterfaceConsumer$NullableType
    extends jni$_.JObjType<MyInterfaceConsumer?> {
  @jni$_.internal
  const $MyInterfaceConsumer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyInterfaceConsumer;';

  @jni$_.internal
  @core$_.override
  MyInterfaceConsumer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MyInterfaceConsumer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyInterfaceConsumer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MyInterfaceConsumer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyInterfaceConsumer$NullableType) &&
        other is $MyInterfaceConsumer$NullableType;
  }
}

final class $MyInterfaceConsumer$Type
    extends jni$_.JObjType<MyInterfaceConsumer> {
  @jni$_.internal
  const $MyInterfaceConsumer$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyInterfaceConsumer;';

  @jni$_.internal
  @core$_.override
  MyInterfaceConsumer fromReference(jni$_.JReference reference) =>
      MyInterfaceConsumer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyInterfaceConsumer?> get nullableType =>
      const $MyInterfaceConsumer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MyInterfaceConsumer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyInterfaceConsumer$Type) &&
        other is $MyInterfaceConsumer$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyRunnable`
class MyRunnable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MyRunnable> $type;

  @jni$_.internal
  MyRunnable.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyRunnable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MyRunnable$NullableType();
  static const type = $MyRunnable$Type();
  static final _id_run = _class.instanceMethodId(
    r'run',
    r'()V',
  );

  static final _run = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void run()`
  void run() {
    _run(reference.pointer, _id_run as jni$_.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $MyRunnable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'run()V') {
        _$impls[$p]!.run();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $MyRunnable $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.interfaces.MyRunnable',
      $p,
      _$invokePointer,
      [
        if ($impl.run$async) r'run()V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory MyRunnable.implement(
    $MyRunnable $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return MyRunnable.fromReference(
      $i.implementReference(),
    );
  }
  static core$_.Map<int, $MyRunnable> get $impls => _$impls;
}

abstract base mixin class $MyRunnable {
  factory $MyRunnable({
    required void Function() run,
    bool run$async,
  }) = _$MyRunnable;

  void run();
  bool get run$async => false;
}

final class _$MyRunnable with $MyRunnable {
  _$MyRunnable({
    required void Function() run,
    this.run$async = false,
  }) : _run = run;

  final void Function() _run;
  final bool run$async;

  void run() {
    return _run();
  }
}

final class $MyRunnable$NullableType extends jni$_.JObjType<MyRunnable?> {
  @jni$_.internal
  const $MyRunnable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyRunnable;';

  @jni$_.internal
  @core$_.override
  MyRunnable? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : MyRunnable.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyRunnable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MyRunnable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyRunnable$NullableType) &&
        other is $MyRunnable$NullableType;
  }
}

final class $MyRunnable$Type extends jni$_.JObjType<MyRunnable> {
  @jni$_.internal
  const $MyRunnable$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyRunnable;';

  @jni$_.internal
  @core$_.override
  MyRunnable fromReference(jni$_.JReference reference) =>
      MyRunnable.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyRunnable?> get nullableType =>
      const $MyRunnable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MyRunnable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyRunnable$Type) && other is $MyRunnable$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.MyRunnableRunner`
class MyRunnableRunner extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MyRunnableRunner> $type;

  @jni$_.internal
  MyRunnableRunner.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/MyRunnableRunner');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MyRunnableRunner$NullableType();
  static const type = $MyRunnableRunner$Type();
  static final _id_error = _class.instanceFieldId(
    r'error',
    r'Ljava/lang/Throwable;',
  );

  /// from: `public java.lang.Throwable error`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get error =>
      _id_error.get(this, const jni$_.JObjectNullableType());

  /// from: `public java.lang.Throwable error`
  /// The returned object must be released after use, by calling the [release] method.
  set error(jni$_.JObject? value) =>
      _id_error.set(this, const jni$_.JObjectNullableType(), value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/interfaces/MyRunnable;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.interfaces.MyRunnable myRunnable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyRunnableRunner(
    MyRunnable? myRunnable,
  ) {
    final _$myRunnable = myRunnable?.reference ?? jni$_.jNullReference;
    return MyRunnableRunner.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$myRunnable.pointer)
        .reference);
  }

  static final _id_runOnSameThread = _class.instanceMethodId(
    r'runOnSameThread',
    r'()V',
  );

  static final _runOnSameThread = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void runOnSameThread()`
  void runOnSameThread() {
    _runOnSameThread(
            reference.pointer, _id_runOnSameThread as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_runOnAnotherThread = _class.instanceMethodId(
    r'runOnAnotherThread',
    r'()V',
  );

  static final _runOnAnotherThread = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void runOnAnotherThread()`
  void runOnAnotherThread() {
    _runOnAnotherThread(
            reference.pointer, _id_runOnAnotherThread as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_runOnAnotherThreadAndJoin = _class.instanceMethodId(
    r'runOnAnotherThreadAndJoin',
    r'()V',
  );

  static final _runOnAnotherThreadAndJoin = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void runOnAnotherThreadAndJoin()`
  void runOnAnotherThreadAndJoin() {
    _runOnAnotherThreadAndJoin(reference.pointer,
            _id_runOnAnotherThreadAndJoin as jni$_.JMethodIDPtr)
        .check();
  }
}

final class $MyRunnableRunner$NullableType
    extends jni$_.JObjType<MyRunnableRunner?> {
  @jni$_.internal
  const $MyRunnableRunner$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyRunnableRunner;';

  @jni$_.internal
  @core$_.override
  MyRunnableRunner? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : MyRunnableRunner.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyRunnableRunner?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MyRunnableRunner$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyRunnableRunner$NullableType) &&
        other is $MyRunnableRunner$NullableType;
  }
}

final class $MyRunnableRunner$Type extends jni$_.JObjType<MyRunnableRunner> {
  @jni$_.internal
  const $MyRunnableRunner$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/MyRunnableRunner;';

  @jni$_.internal
  @core$_.override
  MyRunnableRunner fromReference(jni$_.JReference reference) =>
      MyRunnableRunner.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyRunnableRunner?> get nullableType =>
      const $MyRunnableRunner$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MyRunnableRunner$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyRunnableRunner$Type) &&
        other is $MyRunnableRunner$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.StringConversionException`
class StringConversionException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StringConversionException> $type;

  @jni$_.internal
  StringConversionException.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/StringConversionException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StringConversionException$NullableType();
  static const type = $StringConversionException$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringConversionException(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return StringConversionException.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$string.pointer)
        .reference);
  }
}

final class $StringConversionException$NullableType
    extends jni$_.JObjType<StringConversionException?> {
  @jni$_.internal
  const $StringConversionException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConversionException;';

  @jni$_.internal
  @core$_.override
  StringConversionException? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : StringConversionException.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringConversionException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StringConversionException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringConversionException$NullableType) &&
        other is $StringConversionException$NullableType;
  }
}

final class $StringConversionException$Type
    extends jni$_.JObjType<StringConversionException> {
  @jni$_.internal
  const $StringConversionException$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConversionException;';

  @jni$_.internal
  @core$_.override
  StringConversionException fromReference(jni$_.JReference reference) =>
      StringConversionException.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringConversionException?> get nullableType =>
      const $StringConversionException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StringConversionException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringConversionException$Type) &&
        other is $StringConversionException$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.StringConverter`
class StringConverter extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StringConverter> $type;

  @jni$_.internal
  StringConverter.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/StringConverter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StringConverter$NullableType();
  static const type = $StringConverter$Type();
  static final _id_parseToInt = _class.instanceMethodId(
    r'parseToInt',
    r'(Ljava/lang/String;)I',
  );

  static final _parseToInt = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract int parseToInt(java.lang.String string)`
  int parseToInt(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _parseToInt(reference.pointer, _id_parseToInt as jni$_.JMethodIDPtr,
            _$string.pointer)
        .integer;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $StringConverter> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'parseToInt(Ljava/lang/String;)I') {
        final $r = _$impls[$p]!.parseToInt(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $StringConverter $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.interfaces.StringConverter',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory StringConverter.implement(
    $StringConverter $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return StringConverter.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $StringConverter {
  factory $StringConverter({
    required int Function(jni$_.JString? string) parseToInt,
  }) = _$StringConverter;

  int parseToInt(jni$_.JString? string);
}

final class _$StringConverter with $StringConverter {
  _$StringConverter({
    required int Function(jni$_.JString? string) parseToInt,
  }) : _parseToInt = parseToInt;

  final int Function(jni$_.JString? string) _parseToInt;

  int parseToInt(jni$_.JString? string) {
    return _parseToInt(string);
  }
}

final class $StringConverter$NullableType
    extends jni$_.JObjType<StringConverter?> {
  @jni$_.internal
  const $StringConverter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConverter;';

  @jni$_.internal
  @core$_.override
  StringConverter? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : StringConverter.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringConverter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StringConverter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringConverter$NullableType) &&
        other is $StringConverter$NullableType;
  }
}

final class $StringConverter$Type extends jni$_.JObjType<StringConverter> {
  @jni$_.internal
  const $StringConverter$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConverter;';

  @jni$_.internal
  @core$_.override
  StringConverter fromReference(jni$_.JReference reference) =>
      StringConverter.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringConverter?> get nullableType =>
      const $StringConverter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StringConverter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringConverter$Type) &&
        other is $StringConverter$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.interfaces.StringConverterConsumer`
class StringConverterConsumer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StringConverterConsumer> $type;

  @jni$_.internal
  StringConverterConsumer.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/interfaces/StringConverterConsumer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StringConverterConsumer$NullableType();
  static const type = $StringConverterConsumer$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringConverterConsumer() {
    return StringConverterConsumer.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_consumeOnSameThread = _class.staticMethodId(
    r'consumeOnSameThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/StringConverter;Ljava/lang/String;)Ljava/lang/Integer;',
  );

  static final _consumeOnSameThread = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.lang.Integer consumeOnSameThread(com.github.dart_lang.jnigen.interfaces.StringConverter stringConverter, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JInteger? consumeOnSameThread(
    StringConverter? stringConverter,
    jni$_.JString? string,
  ) {
    final _$stringConverter =
        stringConverter?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _consumeOnSameThread(
            _class.reference.pointer,
            _id_consumeOnSameThread as jni$_.JMethodIDPtr,
            _$stringConverter.pointer,
            _$string.pointer)
        .object<jni$_.JInteger?>(const jni$_.JIntegerNullableType());
  }

  static final _id_consumeOnAnotherThread = _class.staticMethodId(
    r'consumeOnAnotherThread',
    r'(Lcom/github/dart_lang/jnigen/interfaces/StringConverter;Ljava/lang/String;)Ljava/util/concurrent/Future;',
  );

  static final _consumeOnAnotherThread = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.Future consumeOnAnotherThread(com.github.dart_lang.jnigen.interfaces.StringConverter stringConverter, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? consumeOnAnotherThread(
    StringConverter? stringConverter,
    jni$_.JString? string,
  ) {
    final _$stringConverter =
        stringConverter?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _consumeOnAnotherThread(
            _class.reference.pointer,
            _id_consumeOnAnotherThread as jni$_.JMethodIDPtr,
            _$stringConverter.pointer,
            _$string.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $StringConverterConsumer$NullableType
    extends jni$_.JObjType<StringConverterConsumer?> {
  @jni$_.internal
  const $StringConverterConsumer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConverterConsumer;';

  @jni$_.internal
  @core$_.override
  StringConverterConsumer? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : StringConverterConsumer.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringConverterConsumer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StringConverterConsumer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringConverterConsumer$NullableType) &&
        other is $StringConverterConsumer$NullableType;
  }
}

final class $StringConverterConsumer$Type
    extends jni$_.JObjType<StringConverterConsumer> {
  @jni$_.internal
  const $StringConverterConsumer$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/interfaces/StringConverterConsumer;';

  @jni$_.internal
  @core$_.override
  StringConverterConsumer fromReference(jni$_.JReference reference) =>
      StringConverterConsumer.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringConverterConsumer?> get nullableType =>
      const $StringConverterConsumer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StringConverterConsumer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringConverterConsumer$Type) &&
        other is $StringConverterConsumer$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.inheritance.BaseClass`
class BaseClass<$T extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<BaseClass<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  BaseClass.fromReference(
    this.T,
    jni$_.JReference reference,
  )   : $type = type<$T>(T),
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/inheritance/BaseClass');

  /// The type which includes information such as the signature of this class.
  static $BaseClass$NullableType<$T> nullableType<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $BaseClass$NullableType<$T>(
      T,
    );
  }

  static $BaseClass$Type<$T> type<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $BaseClass$Type<$T>(
      T,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory BaseClass({
    required jni$_.JObjType<$T> T,
  }) {
    return BaseClass<$T>.fromReference(
        T,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $BaseClass$NullableType<$T extends jni$_.JObject?>
    extends jni$_.JObjType<BaseClass<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $BaseClass$NullableType(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/BaseClass;';

  @jni$_.internal
  @core$_.override
  BaseClass<$T>? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : BaseClass<$T>.fromReference(
          T,
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BaseClass<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($BaseClass$NullableType, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BaseClass$NullableType<$T>) &&
        other is $BaseClass$NullableType<$T> &&
        T == other.T;
  }
}

final class $BaseClass$Type<$T extends jni$_.JObject?>
    extends jni$_.JObjType<BaseClass<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $BaseClass$Type(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/BaseClass;';

  @jni$_.internal
  @core$_.override
  BaseClass<$T> fromReference(jni$_.JReference reference) =>
      BaseClass<$T>.fromReference(
        T,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BaseClass<$T>?> get nullableType =>
      $BaseClass$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($BaseClass$Type, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BaseClass$Type<$T>) &&
        other is $BaseClass$Type<$T> &&
        T == other.T;
  }
}

/// from: `com.github.dart_lang.jnigen.inheritance.GenericDerivedClass`
class GenericDerivedClass<$T extends jni$_.JObject?> extends BaseClass<$T?> {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<GenericDerivedClass<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  GenericDerivedClass.fromReference(
    this.T,
    jni$_.JReference reference,
  )   : $type = type<$T>(T),
        super.fromReference(T.nullableType, reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/inheritance/GenericDerivedClass');

  /// The type which includes information such as the signature of this class.
  static $GenericDerivedClass$NullableType<$T>
      nullableType<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $GenericDerivedClass$NullableType<$T>(
      T,
    );
  }

  static $GenericDerivedClass$Type<$T> type<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) {
    return $GenericDerivedClass$Type<$T>(
      T,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory GenericDerivedClass({
    required jni$_.JObjType<$T> T,
  }) {
    return GenericDerivedClass<$T>.fromReference(
        T,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $GenericDerivedClass$NullableType<$T extends jni$_.JObject?>
    extends jni$_.JObjType<GenericDerivedClass<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $GenericDerivedClass$NullableType(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/GenericDerivedClass;';

  @jni$_.internal
  @core$_.override
  GenericDerivedClass<$T>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : GenericDerivedClass<$T>.fromReference(
              T,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => $BaseClass$NullableType<$T?>(T.nullableType);

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GenericDerivedClass<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => Object.hash($GenericDerivedClass$NullableType, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GenericDerivedClass$NullableType<$T>) &&
        other is $GenericDerivedClass$NullableType<$T> &&
        T == other.T;
  }
}

final class $GenericDerivedClass$Type<$T extends jni$_.JObject?>
    extends jni$_.JObjType<GenericDerivedClass<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $GenericDerivedClass$Type(
    this.T,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/GenericDerivedClass;';

  @jni$_.internal
  @core$_.override
  GenericDerivedClass<$T> fromReference(jni$_.JReference reference) =>
      GenericDerivedClass<$T>.fromReference(
        T,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => $BaseClass$NullableType<$T?>(T.nullableType);

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<GenericDerivedClass<$T>?> get nullableType =>
      $GenericDerivedClass$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => Object.hash($GenericDerivedClass$Type, T);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($GenericDerivedClass$Type<$T>) &&
        other is $GenericDerivedClass$Type<$T> &&
        T == other.T;
  }
}

/// from: `com.github.dart_lang.jnigen.inheritance.SpecificDerivedClass`
class SpecificDerivedClass extends BaseClass<jni$_.JString?> {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SpecificDerivedClass> $type;

  @jni$_.internal
  SpecificDerivedClass.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(const jni$_.JStringNullableType(), reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/inheritance/SpecificDerivedClass');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SpecificDerivedClass$NullableType();
  static const type = $SpecificDerivedClass$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SpecificDerivedClass() {
    return SpecificDerivedClass.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $SpecificDerivedClass$NullableType
    extends jni$_.JObjType<SpecificDerivedClass?> {
  @jni$_.internal
  const $SpecificDerivedClass$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/SpecificDerivedClass;';

  @jni$_.internal
  @core$_.override
  SpecificDerivedClass? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : SpecificDerivedClass.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $BaseClass$NullableType<jni$_.JString?>(
      jni$_.JStringNullableType());

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SpecificDerivedClass?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SpecificDerivedClass$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SpecificDerivedClass$NullableType) &&
        other is $SpecificDerivedClass$NullableType;
  }
}

final class $SpecificDerivedClass$Type
    extends jni$_.JObjType<SpecificDerivedClass> {
  @jni$_.internal
  const $SpecificDerivedClass$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/inheritance/SpecificDerivedClass;';

  @jni$_.internal
  @core$_.override
  SpecificDerivedClass fromReference(jni$_.JReference reference) =>
      SpecificDerivedClass.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $BaseClass$NullableType<jni$_.JString?>(
      jni$_.JStringNullableType());

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SpecificDerivedClass?> get nullableType =>
      const $SpecificDerivedClass$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SpecificDerivedClass$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SpecificDerivedClass$Type) &&
        other is $SpecificDerivedClass$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.Annotated$Nested`
class Annotated$Nested<$T extends jni$_.JObject?, $U extends jni$_.JObject,
    $W extends jni$_.JObject, $V extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Annotated$Nested<$T, $U, $W, $V>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$U> U;

  @jni$_.internal
  final jni$_.JObjType<$W> W;

  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  Annotated$Nested.fromReference(
    this.T,
    this.U,
    this.W,
    this.V,
    jni$_.JReference reference,
  )   : $type = type<$T, $U, $W, $V>(T, U, W, V),
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/Annotated$Nested');

  /// The type which includes information such as the signature of this class.
  static $Annotated$Nested$NullableType<$T, $U, $W, $V> nullableType<
      $T extends jni$_.JObject?,
      $U extends jni$_.JObject,
      $W extends jni$_.JObject,
      $V extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
    jni$_.JObjType<$U> U,
    jni$_.JObjType<$W> W,
    jni$_.JObjType<$V> V,
  ) {
    return $Annotated$Nested$NullableType<$T, $U, $W, $V>(
      T,
      U,
      W,
      V,
    );
  }

  static $Annotated$Nested$Type<$T, $U, $W, $V> type<
      $T extends jni$_.JObject?,
      $U extends jni$_.JObject,
      $W extends jni$_.JObject,
      $V extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
    jni$_.JObjType<$U> U,
    jni$_.JObjType<$W> W,
    jni$_.JObjType<$V> V,
  ) {
    return $Annotated$Nested$Type<$T, $U, $W, $V>(
      T,
      U,
      W,
      V,
    );
  }

  static final _id_v = _class.instanceFieldId(
    r'v',
    r'Ljava/lang/Object;',
  );

  /// from: `public V v`
  /// The returned object must be released after use, by calling the [release] method.
  $V? get v => _id_v.get(this, V.nullableType);

  /// from: `public V v`
  /// The returned object must be released after use, by calling the [release] method.
  set v($V? value) => _id_v.set(this, V.nullableType, value);

  static final _id_u = _class.instanceFieldId(
    r'u',
    r'Ljava/lang/Object;',
  );

  /// from: `public U u`
  /// The returned object must be released after use, by calling the [release] method.
  $U get u => _id_u.get(this, U);

  /// from: `public U u`
  /// The returned object must be released after use, by calling the [release] method.
  set u($U value) => _id_u.set(this, U, value);

  static final _id_new$ = _class.constructorId(
    r'(Lcom/github/dart_lang/jnigen/annotations/Annotated;Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(com.github.dart_lang.jnigen.annotations.Annotated $outerClass, V object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Annotated$Nested(
    Annotated<$T?, $U, $W> $outerClass,
    $V? object, {
    jni$_.JObjType<$T>? T,
    jni$_.JObjType<$U>? U,
    jni$_.JObjType<$W>? W,
    required jni$_.JObjType<$V> V,
  }) {
    T ??= jni$_.lowestCommonSuperType([
      ($outerClass.$type as $Annotated$Type<core$_.dynamic, core$_.dynamic,
              core$_.dynamic>)
          .T,
    ]) as jni$_.JObjType<$T>;
    U ??= jni$_.lowestCommonSuperType([
      ($outerClass.$type as $Annotated$Type<core$_.dynamic, core$_.dynamic,
              core$_.dynamic>)
          .U,
    ]) as jni$_.JObjType<$U>;
    W ??= jni$_.lowestCommonSuperType([
      ($outerClass.$type as $Annotated$Type<core$_.dynamic, core$_.dynamic,
              core$_.dynamic>)
          .W,
    ]) as jni$_.JObjType<$W>;
    final _$$outerClass = $outerClass.reference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return Annotated$Nested<$T, $U, $W, $V>.fromReference(
        T,
        U,
        W,
        V,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
                _$$outerClass.pointer, _$object.pointer)
            .reference);
  }
}

final class $Annotated$Nested$NullableType<
        $T extends jni$_.JObject?,
        $U extends jni$_.JObject,
        $W extends jni$_.JObject,
        $V extends jni$_.JObject?>
    extends jni$_.JObjType<Annotated$Nested<$T, $U, $W, $V>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$U> U;

  @jni$_.internal
  final jni$_.JObjType<$W> W;

  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  const $Annotated$Nested$NullableType(
    this.T,
    this.U,
    this.W,
    this.V,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/Annotated$Nested;';

  @jni$_.internal
  @core$_.override
  Annotated$Nested<$T, $U, $W, $V>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Annotated$Nested<$T, $U, $W, $V>.fromReference(
              T,
              U,
              W,
              V,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Annotated$Nested<$T, $U, $W, $V>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Annotated$Nested$NullableType, T, U, W, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($Annotated$Nested$NullableType<$T, $U, $W, $V>) &&
        other is $Annotated$Nested$NullableType<$T, $U, $W, $V> &&
        T == other.T &&
        U == other.U &&
        W == other.W &&
        V == other.V;
  }
}

final class $Annotated$Nested$Type<
        $T extends jni$_.JObject?,
        $U extends jni$_.JObject,
        $W extends jni$_.JObject,
        $V extends jni$_.JObject?>
    extends jni$_.JObjType<Annotated$Nested<$T, $U, $W, $V>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$U> U;

  @jni$_.internal
  final jni$_.JObjType<$W> W;

  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  const $Annotated$Nested$Type(
    this.T,
    this.U,
    this.W,
    this.V,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/Annotated$Nested;';

  @jni$_.internal
  @core$_.override
  Annotated$Nested<$T, $U, $W, $V> fromReference(jni$_.JReference reference) =>
      Annotated$Nested<$T, $U, $W, $V>.fromReference(
        T,
        U,
        W,
        V,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Annotated$Nested<$T, $U, $W, $V>?> get nullableType =>
      $Annotated$Nested$NullableType<$T, $U, $W, $V>(T, U, W, V);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Annotated$Nested$Type, T, U, W, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Annotated$Nested$Type<$T, $U, $W, $V>) &&
        other is $Annotated$Nested$Type<$T, $U, $W, $V> &&
        T == other.T &&
        U == other.U &&
        W == other.W &&
        V == other.V;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.Annotated`
class Annotated<$T extends jni$_.JObject?, $U extends jni$_.JObject,
    $W extends jni$_.JObject> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Annotated<$T, $U, $W>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$U> U;

  @jni$_.internal
  final jni$_.JObjType<$W> W;

  @jni$_.internal
  Annotated.fromReference(
    this.T,
    this.U,
    this.W,
    jni$_.JReference reference,
  )   : $type = type<$T, $U, $W>(T, U, W),
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/Annotated');

  /// The type which includes information such as the signature of this class.
  static $Annotated$NullableType<$T, $U, $W> nullableType<
      $T extends jni$_.JObject?,
      $U extends jni$_.JObject,
      $W extends jni$_.JObject>(
    jni$_.JObjType<$T> T,
    jni$_.JObjType<$U> U,
    jni$_.JObjType<$W> W,
  ) {
    return $Annotated$NullableType<$T, $U, $W>(
      T,
      U,
      W,
    );
  }

  static $Annotated$Type<$T, $U, $W> type<$T extends jni$_.JObject?,
      $U extends jni$_.JObject, $W extends jni$_.JObject>(
    jni$_.JObjType<$T> T,
    jni$_.JObjType<$U> U,
    jni$_.JObjType<$W> W,
  ) {
    return $Annotated$Type<$T, $U, $W>(
      T,
      U,
      W,
    );
  }

  static final _id_t = _class.instanceFieldId(
    r't',
    r'Ljava/lang/Object;',
  );

  /// from: `public T t`
  /// The returned object must be released after use, by calling the [release] method.
  $T? get t => _id_t.get(this, T.nullableType);

  /// from: `public T t`
  /// The returned object must be released after use, by calling the [release] method.
  set t($T? value) => _id_t.set(this, T.nullableType, value);

  static final _id_u = _class.instanceFieldId(
    r'u',
    r'Ljava/lang/Object;',
  );

  /// from: `public U u`
  /// The returned object must be released after use, by calling the [release] method.
  $U get u => _id_u.get(this, U);

  /// from: `public U u`
  /// The returned object must be released after use, by calling the [release] method.
  set u($U value) => _id_u.set(this, U, value);

  static final _id_w = _class.instanceFieldId(
    r'w',
    r'Ljava/lang/Object;',
  );

  /// from: `public W w`
  /// The returned object must be released after use, by calling the [release] method.
  $W get w => _id_w.get(this, W);

  /// from: `public W w`
  /// The returned object must be released after use, by calling the [release] method.
  set w($W value) => _id_w.set(this, W, value);

  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(T object, U object1, W object2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Annotated(
    $T? object,
    $U object1,
    $W object2, {
    required jni$_.JObjType<$T> T,
    jni$_.JObjType<$U>? U,
    jni$_.JObjType<$W>? W,
  }) {
    U ??= jni$_.lowestCommonSuperType([
      object1.$type,
    ]) as jni$_.JObjType<$U>;
    W ??= jni$_.lowestCommonSuperType([
      object2.$type,
    ]) as jni$_.JObjType<$W>;
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1.reference;
    final _$object2 = object2.reference;
    return Annotated<$T, $U, $W>.fromReference(
        T,
        U,
        W,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr,
                _$object.pointer, _$object1.pointer, _$object2.pointer)
            .reference);
  }

  static final _id_staticHello = _class.staticMethodId(
    r'staticHello',
    r'()Ljava/lang/String;',
  );

  static final _staticHello = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String staticHello()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString staticHello() {
    return _staticHello(
            _class.reference.pointer, _id_staticHello as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_hello = _class.instanceMethodId(
    r'hello',
    r'()Ljava/lang/String;',
  );

  static final _hello = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String hello()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString hello() {
    return _hello(reference.pointer, _id_hello as jni$_.JMethodIDPtr)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_nullableHello = _class.instanceMethodId(
    r'nullableHello',
    r'(Z)Ljava/lang/String;',
  );

  static final _nullableHello = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.lang.String nullableHello(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? nullableHello(
    bool z,
  ) {
    return _nullableHello(reference.pointer,
            _id_nullableHello as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_echo = _class.instanceMethodId(
    r'echo',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _echo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String echo(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString echo(
    jni$_.JString string,
  ) {
    final _$string = string.reference;
    return _echo(
            reference.pointer, _id_echo as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_nullableEcho = _class.instanceMethodId(
    r'nullableEcho',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _nullableEcho = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String nullableEcho(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? nullableEcho(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _nullableEcho(reference.pointer,
            _id_nullableEcho as jni$_.JMethodIDPtr, _$string.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_array = _class.instanceMethodId(
    r'array',
    r'()[Ljava/lang/String;',
  );

  static final _array = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String[] array()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString> array() {
    return _array(reference.pointer, _id_array as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JString>>(
            const jni$_.JArrayType<jni$_.JString>(jni$_.JStringType()));
  }

  static final _id_arrayOfNullable = _class.instanceMethodId(
    r'arrayOfNullable',
    r'()[Ljava/lang/String;',
  );

  static final _arrayOfNullable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String[] arrayOfNullable()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?> arrayOfNullable() {
    return _arrayOfNullable(
            reference.pointer, _id_arrayOfNullable as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<jni$_.JString?>>(
            const jni$_.JArrayType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_nullableArray = _class.instanceMethodId(
    r'nullableArray',
    r'(Z)[Ljava/lang/String;',
  );

  static final _nullableArray = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.lang.String[] nullableArray(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString>? nullableArray(
    bool z,
  ) {
    return _nullableArray(reference.pointer,
            _id_nullableArray as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JArray<jni$_.JString>?>(
            const jni$_.JArrayNullableType<jni$_.JString>(jni$_.JStringType()));
  }

  static final _id_nullableArrayOfNullable = _class.instanceMethodId(
    r'nullableArrayOfNullable',
    r'(Z)[Ljava/lang/String;',
  );

  static final _nullableArrayOfNullable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.lang.String[] nullableArrayOfNullable(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? nullableArrayOfNullable(
    bool z,
  ) {
    return _nullableArrayOfNullable(reference.pointer,
            _id_nullableArrayOfNullable as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JArray<jni$_.JString?>?>(
            const jni$_.JArrayNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_list = _class.instanceMethodId(
    r'list',
    r'()Ljava/util/List;',
  );

  static final _list = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List list()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString> list() {
    return _list(reference.pointer, _id_list as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString>>(
            const jni$_.JListType<jni$_.JString>(jni$_.JStringType()));
  }

  static final _id_listOfNullable = _class.instanceMethodId(
    r'listOfNullable',
    r'()Ljava/util/List;',
  );

  static final _listOfNullable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List listOfNullable()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?> listOfNullable() {
    return _listOfNullable(
            reference.pointer, _id_listOfNullable as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>>(
            const jni$_.JListType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_nullableList = _class.instanceMethodId(
    r'nullableList',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.util.List nullableList(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString>? nullableList(
    bool z,
  ) {
    return _nullableList(reference.pointer,
            _id_nullableList as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JList<jni$_.JString>?>(
            const jni$_.JListNullableType<jni$_.JString>(jni$_.JStringType()));
  }

  static final _id_nullableListOfNullable = _class.instanceMethodId(
    r'nullableListOfNullable',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableListOfNullable = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.util.List nullableListOfNullable(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? nullableListOfNullable(
    bool z,
  ) {
    return _nullableListOfNullable(reference.pointer,
            _id_nullableListOfNullable as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.JListNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_classGenericEcho = _class.instanceMethodId(
    r'classGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _classGenericEcho = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T classGenericEcho(T object)`
  /// The returned object must be released after use, by calling the [release] method.
  $T classGenericEcho(
    $T object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _classGenericEcho(reference.pointer,
            _id_classGenericEcho as jni$_.JMethodIDPtr, _$object.pointer)
        .object<$T>(T);
  }

  static final _id_nullableClassGenericEcho = _class.instanceMethodId(
    r'nullableClassGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _nullableClassGenericEcho = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T nullableClassGenericEcho(T object)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? nullableClassGenericEcho(
    $T? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _nullableClassGenericEcho(
            reference.pointer,
            _id_nullableClassGenericEcho as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_methodGenericEcho = _class.instanceMethodId(
    r'methodGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _methodGenericEcho = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V methodGenericEcho(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V methodGenericEcho<$V extends jni$_.JObject?>(
    $V object, {
    required jni$_.JObjType<$V> V,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _methodGenericEcho(reference.pointer,
            _id_methodGenericEcho as jni$_.JMethodIDPtr, _$object.pointer)
        .object<$V>(V);
  }

  static final _id_methodGenericEcho2 = _class.instanceMethodId(
    r'methodGenericEcho2',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _methodGenericEcho2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V methodGenericEcho2(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V methodGenericEcho2<$V extends jni$_.JObject>(
    $V object, {
    jni$_.JObjType<$V>? V,
  }) {
    V ??= jni$_.lowestCommonSuperType([
      object.$type,
    ]) as jni$_.JObjType<$V>;
    final _$object = object.reference;
    return _methodGenericEcho2(reference.pointer,
            _id_methodGenericEcho2 as jni$_.JMethodIDPtr, _$object.pointer)
        .object<$V>(V);
  }

  static final _id_methodGenericEcho3 = _class.instanceMethodId(
    r'methodGenericEcho3',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _methodGenericEcho3 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V methodGenericEcho3(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V methodGenericEcho3<$V extends jni$_.JObject>(
    $V object, {
    jni$_.JObjType<$V>? V,
  }) {
    V ??= jni$_.lowestCommonSuperType([
      object.$type,
    ]) as jni$_.JObjType<$V>;
    final _$object = object.reference;
    return _methodGenericEcho3(reference.pointer,
            _id_methodGenericEcho3 as jni$_.JMethodIDPtr, _$object.pointer)
        .object<$V>(V);
  }

  static final _id_nullableReturnMethodGenericEcho = _class.instanceMethodId(
    r'nullableReturnMethodGenericEcho',
    r'(Ljava/lang/Object;Z)Ljava/lang/Object;',
  );

  static final _nullableReturnMethodGenericEcho =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public V nullableReturnMethodGenericEcho(V object, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? nullableReturnMethodGenericEcho<$V extends jni$_.JObject?>(
    $V object,
    bool z, {
    required jni$_.JObjType<$V> V,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _nullableReturnMethodGenericEcho(
            reference.pointer,
            _id_nullableReturnMethodGenericEcho as jni$_.JMethodIDPtr,
            _$object.pointer,
            z ? 1 : 0)
        .object<$V?>(V.nullableType);
  }

  static final _id_nullableReturnMethodGenericEcho2 = _class.instanceMethodId(
    r'nullableReturnMethodGenericEcho2',
    r'(Ljava/lang/Object;Z)Ljava/lang/Object;',
  );

  static final _nullableReturnMethodGenericEcho2 =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public V nullableReturnMethodGenericEcho2(V object, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? nullableReturnMethodGenericEcho2<$V extends jni$_.JObject>(
    $V object,
    bool z, {
    jni$_.JObjType<$V>? V,
  }) {
    V ??= jni$_.lowestCommonSuperType([
      object.$type,
    ]) as jni$_.JObjType<$V>;
    final _$object = object.reference;
    return _nullableReturnMethodGenericEcho2(
            reference.pointer,
            _id_nullableReturnMethodGenericEcho2 as jni$_.JMethodIDPtr,
            _$object.pointer,
            z ? 1 : 0)
        .object<$V?>(V.nullableType);
  }

  static final _id_nullableMethodGenericEcho = _class.instanceMethodId(
    r'nullableMethodGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _nullableMethodGenericEcho = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V nullableMethodGenericEcho(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V nullableMethodGenericEcho<$V extends jni$_.JObject?>(
    $V object, {
    required jni$_.JObjType<$V> V,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _nullableMethodGenericEcho(
            reference.pointer,
            _id_nullableMethodGenericEcho as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<$V>(V);
  }

  static final _id_noAnnotationMethodGenericEcho = _class.instanceMethodId(
    r'noAnnotationMethodGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _noAnnotationMethodGenericEcho =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V noAnnotationMethodGenericEcho(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? noAnnotationMethodGenericEcho<$V extends jni$_.JObject?>(
    $V? object, {
    required jni$_.JObjType<$V> V,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _noAnnotationMethodGenericEcho(
            reference.pointer,
            _id_noAnnotationMethodGenericEcho as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_nullableArgMethodGenericEcho = _class.instanceMethodId(
    r'nullableArgMethodGenericEcho',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _nullableArgMethodGenericEcho =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V nullableArgMethodGenericEcho(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V nullableArgMethodGenericEcho<$V extends jni$_.JObject>(
    $V? object, {
    required jni$_.JObjType<$V> V,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _nullableArgMethodGenericEcho(
            reference.pointer,
            _id_nullableArgMethodGenericEcho as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<$V>(V);
  }

  static final _id_classGenericList = _class.instanceMethodId(
    r'classGenericList',
    r'()Ljava/util/List;',
  );

  static final _classGenericList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List classGenericList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$T> classGenericList() {
    return _classGenericList(
            reference.pointer, _id_classGenericList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<$T>>(jni$_.JListType<$T>(T));
  }

  static final _id_classGenericListOfNullable = _class.instanceMethodId(
    r'classGenericListOfNullable',
    r'()Ljava/util/List;',
  );

  static final _classGenericListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.util.List classGenericListOfNullable()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$T?> classGenericListOfNullable() {
    return _classGenericListOfNullable(reference.pointer,
            _id_classGenericListOfNullable as jni$_.JMethodIDPtr)
        .object<jni$_.JList<$T?>>(jni$_.JListType<$T?>(T.nullableType));
  }

  static final _id_nullableClassGenericList = _class.instanceMethodId(
    r'nullableClassGenericList',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableClassGenericList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.util.List nullableClassGenericList(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$T>? nullableClassGenericList(
    bool z,
  ) {
    return _nullableClassGenericList(reference.pointer,
            _id_nullableClassGenericList as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JList<$T>?>(jni$_.JListNullableType<$T>(T));
  }

  static final _id_nullableClassGenericListOfNullable = _class.instanceMethodId(
    r'nullableClassGenericListOfNullable',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableClassGenericListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.util.List nullableClassGenericListOfNullable(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$T?>? nullableClassGenericListOfNullable(
    bool z,
  ) {
    return _nullableClassGenericListOfNullable(
            reference.pointer,
            _id_nullableClassGenericListOfNullable as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .object<jni$_.JList<$T?>?>(
            jni$_.JListNullableType<$T?>(T.nullableType));
  }

  static final _id_methodGenericList = _class.instanceMethodId(
    r'methodGenericList',
    r'(Ljava/lang/Object;)Ljava/util/List;',
  );

  static final _methodGenericList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.List methodGenericList(V object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$V> methodGenericList<$V extends jni$_.JObject?>(
    $V object, {
    required jni$_.JObjType<$V> V,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _methodGenericList(reference.pointer,
            _id_methodGenericList as jni$_.JMethodIDPtr, _$object.pointer)
        .object<jni$_.JList<$V>>(jni$_.JListType<$V>(V));
  }

  static final _id_methodGenericListOfNullable = _class.instanceMethodId(
    r'methodGenericListOfNullable',
    r'()Ljava/util/List;',
  );

  static final _methodGenericListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.util.List methodGenericListOfNullable()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$V?> methodGenericListOfNullable<$V extends jni$_.JObject?>({
    required jni$_.JObjType<$V> V,
  }) {
    return _methodGenericListOfNullable(reference.pointer,
            _id_methodGenericListOfNullable as jni$_.JMethodIDPtr)
        .object<jni$_.JList<$V?>>(jni$_.JListType<$V?>(V.nullableType));
  }

  static final _id_nullableMethodGenericList = _class.instanceMethodId(
    r'nullableMethodGenericList',
    r'(Ljava/lang/Object;Z)Ljava/util/List;',
  );

  static final _nullableMethodGenericList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public java.util.List nullableMethodGenericList(V object, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$V>? nullableMethodGenericList<$V extends jni$_.JObject?>(
    $V object,
    bool z, {
    required jni$_.JObjType<$V> V,
  }) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _nullableMethodGenericList(
            reference.pointer,
            _id_nullableMethodGenericList as jni$_.JMethodIDPtr,
            _$object.pointer,
            z ? 1 : 0)
        .object<jni$_.JList<$V>?>(jni$_.JListNullableType<$V>(V));
  }

  static final _id_nullableMethodGenericListOfNullable =
      _class.instanceMethodId(
    r'nullableMethodGenericListOfNullable',
    r'(Z)Ljava/util/List;',
  );

  static final _nullableMethodGenericListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.util.List nullableMethodGenericListOfNullable(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<$V?>?
      nullableMethodGenericListOfNullable<$V extends jni$_.JObject?>(
    bool z, {
    required jni$_.JObjType<$V> V,
  }) {
    return _nullableMethodGenericListOfNullable(
            reference.pointer,
            _id_nullableMethodGenericListOfNullable as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .object<jni$_.JList<$V?>?>(
            jni$_.JListNullableType<$V?>(V.nullableType));
  }

  static final _id_firstOfClassGenericList = _class.instanceMethodId(
    r'firstOfClassGenericList',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfClassGenericList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstOfClassGenericList(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstOfClassGenericList(
    jni$_.JList<$T> list,
  ) {
    final _$list = list.reference;
    return _firstOfClassGenericList(reference.pointer,
            _id_firstOfClassGenericList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_firstOfClassGenericNullableList = _class.instanceMethodId(
    r'firstOfClassGenericNullableList',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfClassGenericNullableList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstOfClassGenericNullableList(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstOfClassGenericNullableList(
    jni$_.JList<$T>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _firstOfClassGenericNullableList(
            reference.pointer,
            _id_firstOfClassGenericNullableList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_firstOfClassGenericListOfNullable = _class.instanceMethodId(
    r'firstOfClassGenericListOfNullable',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfClassGenericListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstOfClassGenericListOfNullable(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstOfClassGenericListOfNullable(
    jni$_.JList<$T?> list,
  ) {
    final _$list = list.reference;
    return _firstOfClassGenericListOfNullable(
            reference.pointer,
            _id_firstOfClassGenericListOfNullable as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_firstOfClassGenericNullableListOfNullable =
      _class.instanceMethodId(
    r'firstOfClassGenericNullableListOfNullable',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfClassGenericNullableListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstOfClassGenericNullableListOfNullable(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstOfClassGenericNullableListOfNullable(
    jni$_.JList<$T?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _firstOfClassGenericNullableListOfNullable(
            reference.pointer,
            _id_firstOfClassGenericNullableListOfNullable as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_firstOfMethodGenericList = _class.instanceMethodId(
    r'firstOfMethodGenericList',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfMethodGenericList = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstOfMethodGenericList(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstOfMethodGenericList<$V extends jni$_.JObject?>(
    jni$_.JList<$V> list, {
    jni$_.JObjType<$V>? V,
  }) {
    V ??= jni$_.lowestCommonSuperType([
      (list.$type as jni$_.JListType<core$_.dynamic>).E,
    ]) as jni$_.JObjType<$V>;
    final _$list = list.reference;
    return _firstOfMethodGenericList(reference.pointer,
            _id_firstOfMethodGenericList as jni$_.JMethodIDPtr, _$list.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_firstOfMethodGenericNullableList = _class.instanceMethodId(
    r'firstOfMethodGenericNullableList',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfMethodGenericNullableList =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstOfMethodGenericNullableList(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstOfMethodGenericNullableList<$V extends jni$_.JObject?>(
    jni$_.JList<$V>? list, {
    required jni$_.JObjType<$V> V,
  }) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _firstOfMethodGenericNullableList(
            reference.pointer,
            _id_firstOfMethodGenericNullableList as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_firstOfMethodGenericListOfNullable = _class.instanceMethodId(
    r'firstOfMethodGenericListOfNullable',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfMethodGenericListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstOfMethodGenericListOfNullable(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstOfMethodGenericListOfNullable<$V extends jni$_.JObject?>(
    jni$_.JList<$V?> list, {
    jni$_.JObjType<$V>? V,
  }) {
    V ??= jni$_.lowestCommonSuperType([
      (list.$type as jni$_.JListType<core$_.dynamic>).E,
    ]) as jni$_.JObjType<$V>;
    final _$list = list.reference;
    return _firstOfMethodGenericListOfNullable(
            reference.pointer,
            _id_firstOfMethodGenericListOfNullable as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_firstOfMethodGenericNullableListOfNullable =
      _class.instanceMethodId(
    r'firstOfMethodGenericNullableListOfNullable',
    r'(Ljava/util/List;)Ljava/lang/Object;',
  );

  static final _firstOfMethodGenericNullableListOfNullable =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstOfMethodGenericNullableListOfNullable(java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstOfMethodGenericNullableListOfNullable<$V extends jni$_.JObject?>(
    jni$_.JList<$V?>? list, {
    required jni$_.JObjType<$V> V,
  }) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _firstOfMethodGenericNullableListOfNullable(
            reference.pointer,
            _id_firstOfMethodGenericNullableListOfNullable
                as jni$_.JMethodIDPtr,
            _$list.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_firstKeyOfComboMap = _class.instanceMethodId(
    r'firstKeyOfComboMap',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstKeyOfComboMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstKeyOfComboMap(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstKeyOfComboMap<$V extends jni$_.JObject?>(
    jni$_.JMap<$T, $V> map, {
    jni$_.JObjType<$V>? V,
  }) {
    V ??= jni$_.lowestCommonSuperType([
      (map.$type as jni$_.JMapType<core$_.dynamic, core$_.dynamic>).V,
    ]) as jni$_.JObjType<$V>;
    final _$map = map.reference;
    return _firstKeyOfComboMap(reference.pointer,
            _id_firstKeyOfComboMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_firstValueOfComboMap = _class.instanceMethodId(
    r'firstValueOfComboMap',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOfComboMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstValueOfComboMap(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstValueOfComboMap<$V extends jni$_.JObject?>(
    jni$_.JMap<$T, $V> map, {
    jni$_.JObjType<$V>? V,
  }) {
    V ??= jni$_.lowestCommonSuperType([
      (map.$type as jni$_.JMapType<core$_.dynamic, core$_.dynamic>).V,
    ]) as jni$_.JObjType<$V>;
    final _$map = map.reference;
    return _firstValueOfComboMap(reference.pointer,
            _id_firstValueOfComboMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_firstKeyOfComboMapNullableKey = _class.instanceMethodId(
    r'firstKeyOfComboMapNullableKey',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstKeyOfComboMapNullableKey =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstKeyOfComboMapNullableKey(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstKeyOfComboMapNullableKey<$V extends jni$_.JObject?>(
    jni$_.JMap<$T?, $V> map, {
    jni$_.JObjType<$V>? V,
  }) {
    V ??= jni$_.lowestCommonSuperType([
      (map.$type as jni$_.JMapType<core$_.dynamic, core$_.dynamic>).V,
    ]) as jni$_.JObjType<$V>;
    final _$map = map.reference;
    return _firstKeyOfComboMapNullableKey(
            reference.pointer,
            _id_firstKeyOfComboMapNullableKey as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_firstValueOfComboMapNullableKey = _class.instanceMethodId(
    r'firstValueOfComboMapNullableKey',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOfComboMapNullableKey =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstValueOfComboMapNullableKey(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstValueOfComboMapNullableKey<$V extends jni$_.JObject?>(
    jni$_.JMap<$T?, $V> map, {
    jni$_.JObjType<$V>? V,
  }) {
    V ??= jni$_.lowestCommonSuperType([
      (map.$type as jni$_.JMapType<core$_.dynamic, core$_.dynamic>).V,
    ]) as jni$_.JObjType<$V>;
    final _$map = map.reference;
    return _firstValueOfComboMapNullableKey(
            reference.pointer,
            _id_firstValueOfComboMapNullableKey as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_firstKeyOfComboMapNullableValue = _class.instanceMethodId(
    r'firstKeyOfComboMapNullableValue',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstKeyOfComboMapNullableValue =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstKeyOfComboMapNullableValue(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstKeyOfComboMapNullableValue<$V extends jni$_.JObject?>(
    jni$_.JMap<$T, $V?> map, {
    jni$_.JObjType<$V>? V,
  }) {
    V ??= jni$_.lowestCommonSuperType([
      (map.$type as jni$_.JMapType<core$_.dynamic, core$_.dynamic>).V,
    ]) as jni$_.JObjType<$V>;
    final _$map = map.reference;
    return _firstKeyOfComboMapNullableValue(
            reference.pointer,
            _id_firstKeyOfComboMapNullableValue as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_firstValueOfComboMapNullableValue = _class.instanceMethodId(
    r'firstValueOfComboMapNullableValue',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOfComboMapNullableValue =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstValueOfComboMapNullableValue(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstValueOfComboMapNullableValue<$V extends jni$_.JObject?>(
    jni$_.JMap<$T, $V?> map, {
    jni$_.JObjType<$V>? V,
  }) {
    V ??= jni$_.lowestCommonSuperType([
      (map.$type as jni$_.JMapType<core$_.dynamic, core$_.dynamic>).V,
    ]) as jni$_.JObjType<$V>;
    final _$map = map.reference;
    return _firstValueOfComboMapNullableValue(
            reference.pointer,
            _id_firstValueOfComboMapNullableValue as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_firstKeyOfComboMapNullableKeyAndValue =
      _class.instanceMethodId(
    r'firstKeyOfComboMapNullableKeyAndValue',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstKeyOfComboMapNullableKeyAndValue =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public T firstKeyOfComboMapNullableKeyAndValue(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? firstKeyOfComboMapNullableKeyAndValue<$V extends jni$_.JObject?>(
    jni$_.JMap<$T?, $V?> map, {
    jni$_.JObjType<$V>? V,
  }) {
    V ??= jni$_.lowestCommonSuperType([
      (map.$type as jni$_.JMapType<core$_.dynamic, core$_.dynamic>).V,
    ]) as jni$_.JObjType<$V>;
    final _$map = map.reference;
    return _firstKeyOfComboMapNullableKeyAndValue(
            reference.pointer,
            _id_firstKeyOfComboMapNullableKeyAndValue as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<$T?>(T.nullableType);
  }

  static final _id_firstValueOfComboMapNullableKeyAndValue =
      _class.instanceMethodId(
    r'firstValueOfComboMapNullableKeyAndValue',
    r'(Ljava/util/Map;)Ljava/lang/Object;',
  );

  static final _firstValueOfComboMapNullableKeyAndValue =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V firstValueOfComboMapNullableKeyAndValue(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? firstValueOfComboMapNullableKeyAndValue<$V extends jni$_.JObject?>(
    jni$_.JMap<$T?, $V?> map, {
    jni$_.JObjType<$V>? V,
  }) {
    V ??= jni$_.lowestCommonSuperType([
      (map.$type as jni$_.JMapType<core$_.dynamic, core$_.dynamic>).V,
    ]) as jni$_.JObjType<$V>;
    final _$map = map.reference;
    return _firstValueOfComboMapNullableKeyAndValue(
            reference.pointer,
            _id_firstValueOfComboMapNullableKeyAndValue as jni$_.JMethodIDPtr,
            _$map.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_firstEntryOfComboMap = _class.instanceMethodId(
    r'firstEntryOfComboMap',
    r'(Ljava/util/Map;)Ljava/util/Map$Entry;',
  );

  static final _firstEntryOfComboMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.util.Map$Entry firstEntryOfComboMap(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? firstEntryOfComboMap<$V extends jni$_.JObject?>(
    jni$_.JMap<$T, $V> map, {
    jni$_.JObjType<$V>? V,
  }) {
    V ??= jni$_.lowestCommonSuperType([
      (map.$type as jni$_.JMapType<core$_.dynamic, core$_.dynamic>).V,
    ]) as jni$_.JObjType<$V>;
    final _$map = map.reference;
    return _firstEntryOfComboMap(reference.pointer,
            _id_firstEntryOfComboMap as jni$_.JMethodIDPtr, _$map.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getW = _class.instanceMethodId(
    r'getW',
    r'()Ljava/lang/Object;',
  );

  static final _getW = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public W getW()`
  /// The returned object must be released after use, by calling the [release] method.
  $W getW() {
    return _getW(reference.pointer, _id_getW as jni$_.JMethodIDPtr)
        .object<$W>(W);
  }

  static final _id_nullableGetW = _class.instanceMethodId(
    r'nullableGetW',
    r'(Z)Ljava/lang/Object;',
  );

  static final _nullableGetW = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public W nullableGetW(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  $W? nullableGetW(
    bool z,
  ) {
    return _nullableGetW(reference.pointer,
            _id_nullableGetW as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<$W?>(W.nullableType);
  }

  static final _id_list3dOfT = _class.instanceMethodId(
    r'list3dOfT',
    r'()Ljava/util/List;',
  );

  static final _list3dOfT = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List list3dOfT()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JList<$T?>>> list3dOfT() {
    return _list3dOfT(reference.pointer, _id_list3dOfT as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JList<$T?>>>>(
            jni$_.JListType<jni$_.JList<jni$_.JList<$T?>>>(
                jni$_.JListType<jni$_.JList<$T?>>(
                    jni$_.JListType<$T?>(T.nullableType))));
  }

  static final _id_list3dOfU = _class.instanceMethodId(
    r'list3dOfU',
    r'()Ljava/util/List;',
  );

  static final _list3dOfU = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List list3dOfU()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JList<$U>>> list3dOfU() {
    return _list3dOfU(reference.pointer, _id_list3dOfU as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JList<$U>>>>(
            jni$_.JListType<jni$_.JList<jni$_.JList<$U>>>(
                jni$_.JListType<jni$_.JList<$U>>(jni$_.JListType<$U>(U))));
  }

  static final _id_list3dOfW = _class.instanceMethodId(
    r'list3dOfW',
    r'()Ljava/util/List;',
  );

  static final _list3dOfW = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List list3dOfW()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JList<$W>>> list3dOfW() {
    return _list3dOfW(reference.pointer, _id_list3dOfW as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JList<jni$_.JList<$W>>>>(
            jni$_.JListType<jni$_.JList<jni$_.JList<$W>>>(
                jni$_.JListType<jni$_.JList<$W>>(jni$_.JListType<$W>(W))));
  }

  static final _id_list3dOfNullableU = _class.instanceMethodId(
    r'list3dOfNullableU',
    r'(Z)Ljava/util/List;',
  );

  static final _list3dOfNullableU = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.util.List list3dOfNullableU(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JList<$U?>>> list3dOfNullableU(
    bool z,
  ) {
    return _list3dOfNullableU(reference.pointer,
            _id_list3dOfNullableU as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JList<jni$_.JList<jni$_.JList<$U?>>>>(
            jni$_.JListType<jni$_.JList<jni$_.JList<$U?>>>(
                jni$_.JListType<jni$_.JList<$U?>>(
                    jni$_.JListType<$U?>(U.nullableType))));
  }

  static final _id_list3dOfNullableW = _class.instanceMethodId(
    r'list3dOfNullableW',
    r'(Z)Ljava/util/List;',
  );

  static final _list3dOfNullableW = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.util.List list3dOfNullableW(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JList<jni$_.JList<$W?>>> list3dOfNullableW(
    bool z,
  ) {
    return _list3dOfNullableW(reference.pointer,
            _id_list3dOfNullableW as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<jni$_.JList<jni$_.JList<jni$_.JList<$W?>>>>(
            jni$_.JListType<jni$_.JList<jni$_.JList<$W?>>>(
                jni$_.JListType<jni$_.JList<$W?>>(
                    jni$_.JListType<$W?>(W.nullableType))));
  }

  static final _id_nested = _class.instanceMethodId(
    r'nested',
    r'()Lcom/github/dart_lang/jnigen/annotations/Annotated$Nested;',
  );

  static final _nested = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public com.github.dart_lang.jnigen.annotations.Annotated.Nested nested()`
  /// The returned object must be released after use, by calling the [release] method.
  Annotated$Nested<$T?, $U, $W, jni$_.JInteger>? nested() {
    return _nested(reference.pointer, _id_nested as jni$_.JMethodIDPtr)
        .object<Annotated$Nested<$T?, $U, $W, jni$_.JInteger>?>(
            $Annotated$Nested$NullableType<$T?, $U, $W, jni$_.JInteger>(
                T.nullableType, U, W, const jni$_.JIntegerType()));
  }

  static final _id_intList = _class.instanceMethodId(
    r'intList',
    r'()Ljava/util/List;',
  );

  static final _intList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List intList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JInteger> intList() {
    return _intList(reference.pointer, _id_intList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JInteger>>(
            const jni$_.JListType<jni$_.JInteger>(jni$_.JIntegerType()));
  }
}

final class $Annotated$NullableType<
    $T extends jni$_.JObject?,
    $U extends jni$_.JObject,
    $W extends jni$_.JObject> extends jni$_.JObjType<Annotated<$T, $U, $W>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$U> U;

  @jni$_.internal
  final jni$_.JObjType<$W> W;

  @jni$_.internal
  const $Annotated$NullableType(
    this.T,
    this.U,
    this.W,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/Annotated;';

  @jni$_.internal
  @core$_.override
  Annotated<$T, $U, $W>? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Annotated<$T, $U, $W>.fromReference(
              T,
              U,
              W,
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Annotated<$T, $U, $W>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Annotated$NullableType, T, U, W);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Annotated$NullableType<$T, $U, $W>) &&
        other is $Annotated$NullableType<$T, $U, $W> &&
        T == other.T &&
        U == other.U &&
        W == other.W;
  }
}

final class $Annotated$Type<$T extends jni$_.JObject?, $U extends jni$_.JObject,
    $W extends jni$_.JObject> extends jni$_.JObjType<Annotated<$T, $U, $W>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  final jni$_.JObjType<$U> U;

  @jni$_.internal
  final jni$_.JObjType<$W> W;

  @jni$_.internal
  const $Annotated$Type(
    this.T,
    this.U,
    this.W,
  );

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/Annotated;';

  @jni$_.internal
  @core$_.override
  Annotated<$T, $U, $W> fromReference(jni$_.JReference reference) =>
      Annotated<$T, $U, $W>.fromReference(
        T,
        U,
        W,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Annotated<$T, $U, $W>?> get nullableType =>
      $Annotated$NullableType<$T, $U, $W>(T, U, W);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($Annotated$Type, T, U, W);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Annotated$Type<$T, $U, $W>) &&
        other is $Annotated$Type<$T, $U, $W> &&
        T == other.T &&
        U == other.U &&
        W == other.W;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.JsonSerializable$Case`
class JsonSerializable$Case extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JsonSerializable$Case> $type;

  @jni$_.internal
  JsonSerializable$Case.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/JsonSerializable$Case');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JsonSerializable$Case$NullableType();
  static const type = $JsonSerializable$Case$Type();
  static final _id_SNAKE_CASE = _class.staticFieldId(
    r'SNAKE_CASE',
    r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.annotations.JsonSerializable$Case SNAKE_CASE`
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable$Case get SNAKE_CASE =>
      _id_SNAKE_CASE.get(_class, const $JsonSerializable$Case$Type());

  static final _id_KEBAB_CASE = _class.staticFieldId(
    r'KEBAB_CASE',
    r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.annotations.JsonSerializable$Case KEBAB_CASE`
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable$Case get KEBAB_CASE =>
      _id_KEBAB_CASE.get(_class, const $JsonSerializable$Case$Type());

  static final _id_CAMEL_CASE = _class.staticFieldId(
    r'CAMEL_CASE',
    r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  /// from: `static public final com.github.dart_lang.jnigen.annotations.JsonSerializable$Case CAMEL_CASE`
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable$Case get CAMEL_CASE =>
      _id_CAMEL_CASE.get(_class, const $JsonSerializable$Case$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public com.github.dart_lang.jnigen.annotations.JsonSerializable$Case[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<JsonSerializable$Case?>? values() {
    return _values(_class.reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JArray<JsonSerializable$Case?>?>(
            const jni$_.JArrayNullableType<JsonSerializable$Case?>(
                $JsonSerializable$Case$NullableType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _valueOf = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public com.github.dart_lang.jnigen.annotations.JsonSerializable$Case valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static JsonSerializable$Case? valueOf(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(_class.reference.pointer, _id_valueOf as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<JsonSerializable$Case?>(
            const $JsonSerializable$Case$NullableType());
  }
}

final class $JsonSerializable$Case$NullableType
    extends jni$_.JObjType<JsonSerializable$Case?> {
  @jni$_.internal
  const $JsonSerializable$Case$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;';

  @jni$_.internal
  @core$_.override
  JsonSerializable$Case? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JsonSerializable$Case.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JsonSerializable$Case?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JsonSerializable$Case$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JsonSerializable$Case$NullableType) &&
        other is $JsonSerializable$Case$NullableType;
  }
}

final class $JsonSerializable$Case$Type
    extends jni$_.JObjType<JsonSerializable$Case> {
  @jni$_.internal
  const $JsonSerializable$Case$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;';

  @jni$_.internal
  @core$_.override
  JsonSerializable$Case fromReference(jni$_.JReference reference) =>
      JsonSerializable$Case.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JsonSerializable$Case?> get nullableType =>
      const $JsonSerializable$Case$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JsonSerializable$Case$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JsonSerializable$Case$Type) &&
        other is $JsonSerializable$Case$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.JsonSerializable`
class JsonSerializable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JsonSerializable> $type;

  @jni$_.internal
  JsonSerializable.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/JsonSerializable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JsonSerializable$NullableType();
  static const type = $JsonSerializable$Type();
  static final _id_value = _class.instanceMethodId(
    r'value',
    r'()Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;',
  );

  static final _value = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract com.github.dart_lang.jnigen.annotations.JsonSerializable$Case value()`
  /// The returned object must be released after use, by calling the [release] method.
  JsonSerializable$Case? value() {
    return _value(reference.pointer, _id_value as jni$_.JMethodIDPtr)
        .object<JsonSerializable$Case?>(
            const $JsonSerializable$Case$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $JsonSerializable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'value()Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;') {
        final $r = _$impls[$p]!.value();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $JsonSerializable $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.annotations.JsonSerializable',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory JsonSerializable.implement(
    $JsonSerializable $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return JsonSerializable.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $JsonSerializable {
  factory $JsonSerializable({
    required JsonSerializable$Case? Function() value,
  }) = _$JsonSerializable;

  JsonSerializable$Case? value();
}

final class _$JsonSerializable with $JsonSerializable {
  _$JsonSerializable({
    required JsonSerializable$Case? Function() value,
  }) : _value = value;

  final JsonSerializable$Case? Function() _value;

  JsonSerializable$Case? value() {
    return _value();
  }
}

final class $JsonSerializable$NullableType
    extends jni$_.JObjType<JsonSerializable?> {
  @jni$_.internal
  const $JsonSerializable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable;';

  @jni$_.internal
  @core$_.override
  JsonSerializable? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : JsonSerializable.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JsonSerializable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JsonSerializable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JsonSerializable$NullableType) &&
        other is $JsonSerializable$NullableType;
  }
}

final class $JsonSerializable$Type extends jni$_.JObjType<JsonSerializable> {
  @jni$_.internal
  const $JsonSerializable$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/JsonSerializable;';

  @jni$_.internal
  @core$_.override
  JsonSerializable fromReference(jni$_.JReference reference) =>
      JsonSerializable.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JsonSerializable?> get nullableType =>
      const $JsonSerializable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($JsonSerializable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($JsonSerializable$Type) &&
        other is $JsonSerializable$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.MyDataClass`
class MyDataClass extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MyDataClass> $type;

  @jni$_.internal
  MyDataClass.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'com/github/dart_lang/jnigen/annotations/MyDataClass');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MyDataClass$NullableType();
  static const type = $MyDataClass$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MyDataClass() {
    return MyDataClass.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $MyDataClass$NullableType extends jni$_.JObjType<MyDataClass?> {
  @jni$_.internal
  const $MyDataClass$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/MyDataClass;';

  @jni$_.internal
  @core$_.override
  MyDataClass? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : MyDataClass.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyDataClass?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MyDataClass$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyDataClass$NullableType) &&
        other is $MyDataClass$NullableType;
  }
}

final class $MyDataClass$Type extends jni$_.JObjType<MyDataClass> {
  @jni$_.internal
  const $MyDataClass$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lcom/github/dart_lang/jnigen/annotations/MyDataClass;';

  @jni$_.internal
  @core$_.override
  MyDataClass fromReference(jni$_.JReference reference) =>
      MyDataClass.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MyDataClass?> get nullableType =>
      const $MyDataClass$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MyDataClass$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($MyDataClass$Type) &&
        other is $MyDataClass$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.NotNull`
class NotNull extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NotNull> $type;

  @jni$_.internal
  NotNull.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/annotations/NotNull');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NotNull$NullableType();
  static const type = $NotNull$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $NotNull> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $NotNull $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.annotations.NotNull',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory NotNull.implement(
    $NotNull $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return NotNull.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $NotNull {
  factory $NotNull() = _$NotNull;
}

final class _$NotNull with $NotNull {
  _$NotNull();
}

final class $NotNull$NullableType extends jni$_.JObjType<NotNull?> {
  @jni$_.internal
  const $NotNull$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/annotations/NotNull;';

  @jni$_.internal
  @core$_.override
  NotNull? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : NotNull.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NotNull?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NotNull$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NotNull$NullableType) &&
        other is $NotNull$NullableType;
  }
}

final class $NotNull$Type extends jni$_.JObjType<NotNull> {
  @jni$_.internal
  const $NotNull$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/annotations/NotNull;';

  @jni$_.internal
  @core$_.override
  NotNull fromReference(jni$_.JReference reference) => NotNull.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NotNull?> get nullableType => const $NotNull$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NotNull$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NotNull$Type) && other is $NotNull$Type;
  }
}

/// from: `com.github.dart_lang.jnigen.annotations.Nullable`
class Nullable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Nullable> $type;

  @jni$_.internal
  Nullable.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/github/dart_lang/jnigen/annotations/Nullable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Nullable$NullableType();
  static const type = $Nullable$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Nullable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Nullable $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'com.github.dart_lang.jnigen.annotations.Nullable',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Nullable.implement(
    $Nullable $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Nullable.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $Nullable {
  factory $Nullable() = _$Nullable;
}

final class _$Nullable with $Nullable {
  _$Nullable();
}

final class $Nullable$NullableType extends jni$_.JObjType<Nullable?> {
  @jni$_.internal
  const $Nullable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/annotations/Nullable;';

  @jni$_.internal
  @core$_.override
  Nullable? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Nullable.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Nullable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Nullable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Nullable$NullableType) &&
        other is $Nullable$NullableType;
  }
}

final class $Nullable$Type extends jni$_.JObjType<Nullable> {
  @jni$_.internal
  const $Nullable$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/github/dart_lang/jnigen/annotations/Nullable;';

  @jni$_.internal
  @core$_.override
  Nullable fromReference(jni$_.JReference reference) => Nullable.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Nullable?> get nullableType => const $Nullable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Nullable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Nullable$Type) && other is $Nullable$Type;
  }
}
