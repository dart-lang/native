// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as _$core;

import 'package:jni/_internal.dart' as _$jni;
import 'package:jni/jni.dart' as _$jni;

/// from: `com.example.in_app_java.R$drawable`
class R_drawable extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<R_drawable> $type;

  @_$jni.internal
  R_drawable.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'com/example/in_app_java/R$drawable');

  /// The type which includes information such as the signature of this class.
  static const type = $R_drawable$Type();
  static final _id_launch_background = _class.staticFieldId(
    r'launch_background',
    r'I',
  );

  /// from: `static public int launch_background`
  static int get launch_background =>
      _id_launch_background.get(_class, const _$jni.jintType());

  /// from: `static public int launch_background`
  static set launch_background(int value) =>
      _id_launch_background.set(_class, const _$jni.jintType(), value);
}

final class $R_drawable$Type extends _$jni.JObjType<R_drawable> {
  @_$jni.internal
  const $R_drawable$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/example/in_app_java/R$drawable;';

  @_$jni.internal
  @_$core.override
  R_drawable fromReference(_$jni.JReference reference) =>
      R_drawable.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($R_drawable$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($R_drawable$Type) && other is $R_drawable$Type;
  }
}

/// from: `com.example.in_app_java.R$mipmap`
class R_mipmap extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<R_mipmap> $type;

  @_$jni.internal
  R_mipmap.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'com/example/in_app_java/R$mipmap');

  /// The type which includes information such as the signature of this class.
  static const type = $R_mipmap$Type();
  static final _id_ic_launcher = _class.staticFieldId(
    r'ic_launcher',
    r'I',
  );

  /// from: `static public int ic_launcher`
  static int get ic_launcher =>
      _id_ic_launcher.get(_class, const _$jni.jintType());

  /// from: `static public int ic_launcher`
  static set ic_launcher(int value) =>
      _id_ic_launcher.set(_class, const _$jni.jintType(), value);
}

final class $R_mipmap$Type extends _$jni.JObjType<R_mipmap> {
  @_$jni.internal
  const $R_mipmap$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/example/in_app_java/R$mipmap;';

  @_$jni.internal
  @_$core.override
  R_mipmap fromReference(_$jni.JReference reference) =>
      R_mipmap.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($R_mipmap$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($R_mipmap$Type) && other is $R_mipmap$Type;
  }
}

/// from: `com.example.in_app_java.R$style`
class R_style extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<R_style> $type;

  @_$jni.internal
  R_style.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'com/example/in_app_java/R$style');

  /// The type which includes information such as the signature of this class.
  static const type = $R_style$Type();
  static final _id_LaunchTheme = _class.staticFieldId(
    r'LaunchTheme',
    r'I',
  );

  /// from: `static public int LaunchTheme`
  static int get LaunchTheme =>
      _id_LaunchTheme.get(_class, const _$jni.jintType());

  /// from: `static public int LaunchTheme`
  static set LaunchTheme(int value) =>
      _id_LaunchTheme.set(_class, const _$jni.jintType(), value);

  static final _id_NormalTheme = _class.staticFieldId(
    r'NormalTheme',
    r'I',
  );

  /// from: `static public int NormalTheme`
  static int get NormalTheme =>
      _id_NormalTheme.get(_class, const _$jni.jintType());

  /// from: `static public int NormalTheme`
  static set NormalTheme(int value) =>
      _id_NormalTheme.set(_class, const _$jni.jintType(), value);
}

final class $R_style$Type extends _$jni.JObjType<R_style> {
  @_$jni.internal
  const $R_style$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/example/in_app_java/R$style;';

  @_$jni.internal
  @_$core.override
  R_style fromReference(_$jni.JReference reference) =>
      R_style.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($R_style$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($R_style$Type) && other is $R_style$Type;
  }
}

/// from: `com.example.in_app_java.R`
class R extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<R> $type;

  @_$jni.internal
  R.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(r'com/example/in_app_java/R');

  /// The type which includes information such as the signature of this class.
  static const type = $R$Type();
}

final class $R$Type extends _$jni.JObjType<R> {
  @_$jni.internal
  const $R$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/example/in_app_java/R;';

  @_$jni.internal
  @_$core.override
  R fromReference(_$jni.JReference reference) => R.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($R$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($R$Type) && other is $R$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$CodepointSequenceMatchResult`
class EmojiCompat_CodepointSequenceMatchResult extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<EmojiCompat_CodepointSequenceMatchResult> $type;

  @_$jni.internal
  EmojiCompat_CodepointSequenceMatchResult.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$CodepointSequenceMatchResult');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_CodepointSequenceMatchResult$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $EmojiCompat_CodepointSequenceMatchResult>
      _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $EmojiCompat_CodepointSequenceMatchResult $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$CodepointSequenceMatchResult',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat_CodepointSequenceMatchResult.implement(
    $EmojiCompat_CodepointSequenceMatchResult $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return EmojiCompat_CodepointSequenceMatchResult.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $EmojiCompat_CodepointSequenceMatchResult {
  factory $EmojiCompat_CodepointSequenceMatchResult() =
      _$EmojiCompat_CodepointSequenceMatchResult;
}

final class _$EmojiCompat_CodepointSequenceMatchResult
    with $EmojiCompat_CodepointSequenceMatchResult {
  _$EmojiCompat_CodepointSequenceMatchResult();
}

final class $EmojiCompat_CodepointSequenceMatchResult$Type
    extends _$jni.JObjType<EmojiCompat_CodepointSequenceMatchResult> {
  @_$jni.internal
  const $EmojiCompat_CodepointSequenceMatchResult$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$CodepointSequenceMatchResult;';

  @_$jni.internal
  @_$core.override
  EmojiCompat_CodepointSequenceMatchResult fromReference(
          _$jni.JReference reference) =>
      EmojiCompat_CodepointSequenceMatchResult.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($EmojiCompat_CodepointSequenceMatchResult$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($EmojiCompat_CodepointSequenceMatchResult$Type) &&
        other is $EmojiCompat_CodepointSequenceMatchResult$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$Config`
class EmojiCompat_Config extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<EmojiCompat_Config> $type;

  @_$jni.internal
  EmojiCompat_Config.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'androidx/emoji2/text/EmojiCompat$Config');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_Config$Type();
  static final _id_registerInitCallback = _class.instanceMethodId(
    r'registerInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _registerInitCallback = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config registerInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config registerInitCallback(
    EmojiCompat_InitCallback initCallback,
  ) {
    return _registerInitCallback(
            reference.pointer,
            _id_registerInitCallback as _$jni.JMethodIDPtr,
            initCallback.reference.pointer)
        .object(const $EmojiCompat_Config$Type());
  }

  static final _id_unregisterInitCallback = _class.instanceMethodId(
    r'unregisterInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _unregisterInitCallback = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config unregisterInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config unregisterInitCallback(
    EmojiCompat_InitCallback initCallback,
  ) {
    return _unregisterInitCallback(
            reference.pointer,
            _id_unregisterInitCallback as _$jni.JMethodIDPtr,
            initCallback.reference.pointer)
        .object(const $EmojiCompat_Config$Type());
  }

  static final _id_setReplaceAll = _class.instanceMethodId(
    r'setReplaceAll',
    r'(Z)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setReplaceAll = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setReplaceAll(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setReplaceAll(
    bool z,
  ) {
    return _setReplaceAll(reference.pointer,
            _id_setReplaceAll as _$jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $EmojiCompat_Config$Type());
  }

  static final _id_setUseEmojiAsDefaultStyle = _class.instanceMethodId(
    r'setUseEmojiAsDefaultStyle',
    r'(Z)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setUseEmojiAsDefaultStyle = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setUseEmojiAsDefaultStyle(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setUseEmojiAsDefaultStyle(
    bool z,
  ) {
    return _setUseEmojiAsDefaultStyle(reference.pointer,
            _id_setUseEmojiAsDefaultStyle as _$jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $EmojiCompat_Config$Type());
  }

  static final _id_setUseEmojiAsDefaultStyle$1 = _class.instanceMethodId(
    r'setUseEmojiAsDefaultStyle',
    r'(ZLjava/util/List;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setUseEmojiAsDefaultStyle$1 =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<
                          (
                            _$jni.Int32,
                            _$jni.Pointer<_$jni.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, int, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setUseEmojiAsDefaultStyle(boolean z, java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setUseEmojiAsDefaultStyle$1(
    bool z,
    _$jni.JList<_$jni.JInteger> list,
  ) {
    return _setUseEmojiAsDefaultStyle$1(
            reference.pointer,
            _id_setUseEmojiAsDefaultStyle$1 as _$jni.JMethodIDPtr,
            z ? 1 : 0,
            list.reference.pointer)
        .object(const $EmojiCompat_Config$Type());
  }

  static final _id_setEmojiSpanIndicatorEnabled = _class.instanceMethodId(
    r'setEmojiSpanIndicatorEnabled',
    r'(Z)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setEmojiSpanIndicatorEnabled =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setEmojiSpanIndicatorEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setEmojiSpanIndicatorEnabled(
    bool z,
  ) {
    return _setEmojiSpanIndicatorEnabled(reference.pointer,
            _id_setEmojiSpanIndicatorEnabled as _$jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $EmojiCompat_Config$Type());
  }

  static final _id_setEmojiSpanIndicatorColor = _class.instanceMethodId(
    r'setEmojiSpanIndicatorColor',
    r'(I)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setEmojiSpanIndicatorColor =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setEmojiSpanIndicatorColor(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setEmojiSpanIndicatorColor(
    int i,
  ) {
    return _setEmojiSpanIndicatorColor(reference.pointer,
            _id_setEmojiSpanIndicatorColor as _$jni.JMethodIDPtr, i)
        .object(const $EmojiCompat_Config$Type());
  }

  static final _id_setMetadataLoadStrategy = _class.instanceMethodId(
    r'setMetadataLoadStrategy',
    r'(I)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setMetadataLoadStrategy = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setMetadataLoadStrategy(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setMetadataLoadStrategy(
    int i,
  ) {
    return _setMetadataLoadStrategy(reference.pointer,
            _id_setMetadataLoadStrategy as _$jni.JMethodIDPtr, i)
        .object(const $EmojiCompat_Config$Type());
  }

  static final _id_setSpanFactory = _class.instanceMethodId(
    r'setSpanFactory',
    r'(Landroidx/emoji2/text/EmojiCompat$SpanFactory;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setSpanFactory = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setSpanFactory(androidx.emoji2.text.EmojiCompat$SpanFactory spanFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setSpanFactory(
    EmojiCompat_SpanFactory spanFactory,
  ) {
    return _setSpanFactory(
            reference.pointer,
            _id_setSpanFactory as _$jni.JMethodIDPtr,
            spanFactory.reference.pointer)
        .object(const $EmojiCompat_Config$Type());
  }

  static final _id_setGlyphChecker = _class.instanceMethodId(
    r'setGlyphChecker',
    r'(Landroidx/emoji2/text/EmojiCompat$GlyphChecker;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setGlyphChecker = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setGlyphChecker(androidx.emoji2.text.EmojiCompat$GlyphChecker glyphChecker)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setGlyphChecker(
    EmojiCompat_GlyphChecker glyphChecker,
  ) {
    return _setGlyphChecker(
            reference.pointer,
            _id_setGlyphChecker as _$jni.JMethodIDPtr,
            glyphChecker.reference.pointer)
        .object(const $EmojiCompat_Config$Type());
  }
}

final class $EmojiCompat_Config$Type
    extends _$jni.JObjType<EmojiCompat_Config> {
  @_$jni.internal
  const $EmojiCompat_Config$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$Config;';

  @_$jni.internal
  @_$core.override
  EmojiCompat_Config fromReference(_$jni.JReference reference) =>
      EmojiCompat_Config.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($EmojiCompat_Config$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_Config$Type) &&
        other is $EmojiCompat_Config$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$DefaultSpanFactory`
class EmojiCompat_DefaultSpanFactory extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<EmojiCompat_DefaultSpanFactory> $type;

  @_$jni.internal
  EmojiCompat_DefaultSpanFactory.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$DefaultSpanFactory');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_DefaultSpanFactory$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory EmojiCompat_DefaultSpanFactory() {
    return EmojiCompat_DefaultSpanFactory.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }

  static final _id_createSpan = _class.instanceMethodId(
    r'createSpan',
    r'(Landroidx/emoji2/text/TypefaceEmojiRasterizer;)Landroidx/emoji2/text/EmojiSpan;',
  );

  static final _createSpan = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiSpan createSpan(androidx.emoji2.text.TypefaceEmojiRasterizer typefaceEmojiRasterizer)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject createSpan(
    _$jni.JObject typefaceEmojiRasterizer,
  ) {
    return _createSpan(reference.pointer, _id_createSpan as _$jni.JMethodIDPtr,
            typefaceEmojiRasterizer.reference.pointer)
        .object(const _$jni.JObjectType());
  }
}

final class $EmojiCompat_DefaultSpanFactory$Type
    extends _$jni.JObjType<EmojiCompat_DefaultSpanFactory> {
  @_$jni.internal
  const $EmojiCompat_DefaultSpanFactory$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$DefaultSpanFactory;';

  @_$jni.internal
  @_$core.override
  EmojiCompat_DefaultSpanFactory fromReference(_$jni.JReference reference) =>
      EmojiCompat_DefaultSpanFactory.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($EmojiCompat_DefaultSpanFactory$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_DefaultSpanFactory$Type) &&
        other is $EmojiCompat_DefaultSpanFactory$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$GlyphChecker`
class EmojiCompat_GlyphChecker extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<EmojiCompat_GlyphChecker> $type;

  @_$jni.internal
  EmojiCompat_GlyphChecker.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'androidx/emoji2/text/EmojiCompat$GlyphChecker');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_GlyphChecker$Type();
  static final _id_hasGlyph = _class.instanceMethodId(
    r'hasGlyph',
    r'(Ljava/lang/CharSequence;III)Z',
  );

  static final _hasGlyph = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int, int, int)>();

  /// from: `public abstract boolean hasGlyph(java.lang.CharSequence charSequence, int i, int i1, int i2)`
  bool hasGlyph(
    _$jni.JObject charSequence,
    int i,
    int i1,
    int i2,
  ) {
    return _hasGlyph(reference.pointer, _id_hasGlyph as _$jni.JMethodIDPtr,
            charSequence.reference.pointer, i, i1, i2)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $EmojiCompat_GlyphChecker> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'hasGlyph(Ljava/lang/CharSequence;III)Z') {
        final $r = _$impls[$p]!.hasGlyph(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
          $a[1]
              .as(const _$jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2]
              .as(const _$jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[3]
              .as(const _$jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return _$jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $EmojiCompat_GlyphChecker $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$GlyphChecker',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat_GlyphChecker.implement(
    $EmojiCompat_GlyphChecker $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return EmojiCompat_GlyphChecker.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $EmojiCompat_GlyphChecker {
  factory $EmojiCompat_GlyphChecker({
    required bool Function(_$jni.JObject charSequence, int i, int i1, int i2)
        hasGlyph,
  }) = _$EmojiCompat_GlyphChecker;

  bool hasGlyph(_$jni.JObject charSequence, int i, int i1, int i2);
}

final class _$EmojiCompat_GlyphChecker with $EmojiCompat_GlyphChecker {
  _$EmojiCompat_GlyphChecker({
    required bool Function(_$jni.JObject charSequence, int i, int i1, int i2)
        hasGlyph,
  }) : _hasGlyph = hasGlyph;

  final bool Function(_$jni.JObject charSequence, int i, int i1, int i2)
      _hasGlyph;

  bool hasGlyph(_$jni.JObject charSequence, int i, int i1, int i2) {
    return _hasGlyph(charSequence, i, i1, i2);
  }
}

final class $EmojiCompat_GlyphChecker$Type
    extends _$jni.JObjType<EmojiCompat_GlyphChecker> {
  @_$jni.internal
  const $EmojiCompat_GlyphChecker$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$GlyphChecker;';

  @_$jni.internal
  @_$core.override
  EmojiCompat_GlyphChecker fromReference(_$jni.JReference reference) =>
      EmojiCompat_GlyphChecker.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($EmojiCompat_GlyphChecker$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_GlyphChecker$Type) &&
        other is $EmojiCompat_GlyphChecker$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$InitCallback`
class EmojiCompat_InitCallback extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<EmojiCompat_InitCallback> $type;

  @_$jni.internal
  EmojiCompat_InitCallback.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'androidx/emoji2/text/EmojiCompat$InitCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_InitCallback$Type();
  static final _id_onInitialized = _class.instanceMethodId(
    r'onInitialized',
    r'()V',
  );

  static final _onInitialized = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void onInitialized()`
  void onInitialized() {
    _onInitialized(reference.pointer, _id_onInitialized as _$jni.JMethodIDPtr)
        .check();
  }

  static final _id_onFailed = _class.instanceMethodId(
    r'onFailed',
    r'(Ljava/lang/Throwable;)V',
  );

  static final _onFailed = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void onFailed(java.lang.Throwable throwable)`
  void onFailed(
    _$jni.JObject throwable,
  ) {
    _onFailed(reference.pointer, _id_onFailed as _$jni.JMethodIDPtr,
            throwable.reference.pointer)
        .check();
  }
}

final class $EmojiCompat_InitCallback$Type
    extends _$jni.JObjType<EmojiCompat_InitCallback> {
  @_$jni.internal
  const $EmojiCompat_InitCallback$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$InitCallback;';

  @_$jni.internal
  @_$core.override
  EmojiCompat_InitCallback fromReference(_$jni.JReference reference) =>
      EmojiCompat_InitCallback.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($EmojiCompat_InitCallback$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_InitCallback$Type) &&
        other is $EmojiCompat_InitCallback$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$LoadStrategy`
class EmojiCompat_LoadStrategy extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<EmojiCompat_LoadStrategy> $type;

  @_$jni.internal
  EmojiCompat_LoadStrategy.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'androidx/emoji2/text/EmojiCompat$LoadStrategy');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_LoadStrategy$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $EmojiCompat_LoadStrategy> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $EmojiCompat_LoadStrategy $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$LoadStrategy',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat_LoadStrategy.implement(
    $EmojiCompat_LoadStrategy $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return EmojiCompat_LoadStrategy.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $EmojiCompat_LoadStrategy {
  factory $EmojiCompat_LoadStrategy() = _$EmojiCompat_LoadStrategy;
}

final class _$EmojiCompat_LoadStrategy with $EmojiCompat_LoadStrategy {
  _$EmojiCompat_LoadStrategy();
}

final class $EmojiCompat_LoadStrategy$Type
    extends _$jni.JObjType<EmojiCompat_LoadStrategy> {
  @_$jni.internal
  const $EmojiCompat_LoadStrategy$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$LoadStrategy;';

  @_$jni.internal
  @_$core.override
  EmojiCompat_LoadStrategy fromReference(_$jni.JReference reference) =>
      EmojiCompat_LoadStrategy.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($EmojiCompat_LoadStrategy$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_LoadStrategy$Type) &&
        other is $EmojiCompat_LoadStrategy$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$MetadataRepoLoader`
class EmojiCompat_MetadataRepoLoader extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<EmojiCompat_MetadataRepoLoader> $type;

  @_$jni.internal
  EmojiCompat_MetadataRepoLoader.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$MetadataRepoLoader');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_MetadataRepoLoader$Type();
  static final _id_load = _class.instanceMethodId(
    r'load',
    r'(Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;)V',
  );

  static final _load = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void load(androidx.emoji2.text.EmojiCompat$MetadataRepoLoaderCallback metadataRepoLoaderCallback)`
  void load(
    EmojiCompat_MetadataRepoLoaderCallback metadataRepoLoaderCallback,
  ) {
    _load(reference.pointer, _id_load as _$jni.JMethodIDPtr,
            metadataRepoLoaderCallback.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $EmojiCompat_MetadataRepoLoader> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'load(Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;)V') {
        _$impls[$p]!.load(
          $a[0].as(const $EmojiCompat_MetadataRepoLoaderCallback$Type(),
              releaseOriginal: true),
        );
        return _$jni.nullptr;
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $EmojiCompat_MetadataRepoLoader $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$MetadataRepoLoader',
      $p,
      _$invokePointer,
      [
        if ($impl.load$async)
          r'load(Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat_MetadataRepoLoader.implement(
    $EmojiCompat_MetadataRepoLoader $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return EmojiCompat_MetadataRepoLoader.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $EmojiCompat_MetadataRepoLoader {
  factory $EmojiCompat_MetadataRepoLoader({
    required void Function(
            EmojiCompat_MetadataRepoLoaderCallback metadataRepoLoaderCallback)
        load,
    bool load$async,
  }) = _$EmojiCompat_MetadataRepoLoader;

  void load(EmojiCompat_MetadataRepoLoaderCallback metadataRepoLoaderCallback);
  bool get load$async => false;
}

final class _$EmojiCompat_MetadataRepoLoader
    with $EmojiCompat_MetadataRepoLoader {
  _$EmojiCompat_MetadataRepoLoader({
    required void Function(
            EmojiCompat_MetadataRepoLoaderCallback metadataRepoLoaderCallback)
        load,
    this.load$async = false,
  }) : _load = load;

  final void Function(
      EmojiCompat_MetadataRepoLoaderCallback metadataRepoLoaderCallback) _load;
  final bool load$async;

  void load(EmojiCompat_MetadataRepoLoaderCallback metadataRepoLoaderCallback) {
    return _load(metadataRepoLoaderCallback);
  }
}

final class $EmojiCompat_MetadataRepoLoader$Type
    extends _$jni.JObjType<EmojiCompat_MetadataRepoLoader> {
  @_$jni.internal
  const $EmojiCompat_MetadataRepoLoader$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoader;';

  @_$jni.internal
  @_$core.override
  EmojiCompat_MetadataRepoLoader fromReference(_$jni.JReference reference) =>
      EmojiCompat_MetadataRepoLoader.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($EmojiCompat_MetadataRepoLoader$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_MetadataRepoLoader$Type) &&
        other is $EmojiCompat_MetadataRepoLoader$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$MetadataRepoLoaderCallback`
class EmojiCompat_MetadataRepoLoaderCallback extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<EmojiCompat_MetadataRepoLoaderCallback> $type;

  @_$jni.internal
  EmojiCompat_MetadataRepoLoaderCallback.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_MetadataRepoLoaderCallback$Type();
  static final _id_onLoaded = _class.instanceMethodId(
    r'onLoaded',
    r'(Landroidx/emoji2/text/MetadataRepo;)V',
  );

  static final _onLoaded = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onLoaded(androidx.emoji2.text.MetadataRepo metadataRepo)`
  void onLoaded(
    _$jni.JObject metadataRepo,
  ) {
    _onLoaded(reference.pointer, _id_onLoaded as _$jni.JMethodIDPtr,
            metadataRepo.reference.pointer)
        .check();
  }

  static final _id_onFailed = _class.instanceMethodId(
    r'onFailed',
    r'(Ljava/lang/Throwable;)V',
  );

  static final _onFailed = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract void onFailed(java.lang.Throwable throwable)`
  void onFailed(
    _$jni.JObject throwable,
  ) {
    _onFailed(reference.pointer, _id_onFailed as _$jni.JMethodIDPtr,
            throwable.reference.pointer)
        .check();
  }
}

final class $EmojiCompat_MetadataRepoLoaderCallback$Type
    extends _$jni.JObjType<EmojiCompat_MetadataRepoLoaderCallback> {
  @_$jni.internal
  const $EmojiCompat_MetadataRepoLoaderCallback$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;';

  @_$jni.internal
  @_$core.override
  EmojiCompat_MetadataRepoLoaderCallback fromReference(
          _$jni.JReference reference) =>
      EmojiCompat_MetadataRepoLoaderCallback.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($EmojiCompat_MetadataRepoLoaderCallback$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($EmojiCompat_MetadataRepoLoaderCallback$Type) &&
        other is $EmojiCompat_MetadataRepoLoaderCallback$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$ReplaceStrategy`
class EmojiCompat_ReplaceStrategy extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<EmojiCompat_ReplaceStrategy> $type;

  @_$jni.internal
  EmojiCompat_ReplaceStrategy.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'androidx/emoji2/text/EmojiCompat$ReplaceStrategy');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_ReplaceStrategy$Type();

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $EmojiCompat_ReplaceStrategy> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $EmojiCompat_ReplaceStrategy $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$ReplaceStrategy',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat_ReplaceStrategy.implement(
    $EmojiCompat_ReplaceStrategy $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return EmojiCompat_ReplaceStrategy.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $EmojiCompat_ReplaceStrategy {
  factory $EmojiCompat_ReplaceStrategy() = _$EmojiCompat_ReplaceStrategy;
}

final class _$EmojiCompat_ReplaceStrategy with $EmojiCompat_ReplaceStrategy {
  _$EmojiCompat_ReplaceStrategy();
}

final class $EmojiCompat_ReplaceStrategy$Type
    extends _$jni.JObjType<EmojiCompat_ReplaceStrategy> {
  @_$jni.internal
  const $EmojiCompat_ReplaceStrategy$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$ReplaceStrategy;';

  @_$jni.internal
  @_$core.override
  EmojiCompat_ReplaceStrategy fromReference(_$jni.JReference reference) =>
      EmojiCompat_ReplaceStrategy.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($EmojiCompat_ReplaceStrategy$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_ReplaceStrategy$Type) &&
        other is $EmojiCompat_ReplaceStrategy$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$SpanFactory`
class EmojiCompat_SpanFactory extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<EmojiCompat_SpanFactory> $type;

  @_$jni.internal
  EmojiCompat_SpanFactory.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'androidx/emoji2/text/EmojiCompat$SpanFactory');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_SpanFactory$Type();
  static final _id_createSpan = _class.instanceMethodId(
    r'createSpan',
    r'(Landroidx/emoji2/text/TypefaceEmojiRasterizer;)Landroidx/emoji2/text/EmojiSpan;',
  );

  static final _createSpan = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public abstract androidx.emoji2.text.EmojiSpan createSpan(androidx.emoji2.text.TypefaceEmojiRasterizer typefaceEmojiRasterizer)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject createSpan(
    _$jni.JObject typefaceEmojiRasterizer,
  ) {
    return _createSpan(reference.pointer, _id_createSpan as _$jni.JMethodIDPtr,
            typefaceEmojiRasterizer.reference.pointer)
        .object(const _$jni.JObjectType());
  }

  /// Maps a specific port to the implemented interface.
  static final _$core.Map<int, $EmojiCompat_SpanFactory> _$impls = {};
  static _$jni.JObjectPtr _$invoke(
    int port,
    _$jni.JObjectPtr descriptor,
    _$jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      _$jni.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final _$jni.Pointer<
          _$jni.NativeFunction<
              _$jni.JObjectPtr Function(
                  _$jni.Int64, _$jni.JObjectPtr, _$jni.JObjectPtr)>>
      _$invokePointer = _$jni.Pointer.fromFunction(_$invoke);

  static _$jni.Pointer<_$jni.Void> _$invokeMethod(
    int $p,
    _$jni.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'createSpan(Landroidx/emoji2/text/TypefaceEmojiRasterizer;)Landroidx/emoji2/text/EmojiSpan;') {
        final $r = _$impls[$p]!.createSpan(
          $a[0].as(const _$jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as _$jni.JObject)
            .as(const _$jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return _$jni.ProtectedJniExtensions.newDartException(e);
    }
    return _$jni.nullptr;
  }

  static void implementIn(
    _$jni.JImplementer implementer,
    $EmojiCompat_SpanFactory $impl,
  ) {
    late final _$jni.RawReceivePort $p;
    $p = _$jni.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = _$jni.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      _$jni.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$SpanFactory',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat_SpanFactory.implement(
    $EmojiCompat_SpanFactory $impl,
  ) {
    final $i = _$jni.JImplementer();
    implementIn($i, $impl);
    return EmojiCompat_SpanFactory.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $EmojiCompat_SpanFactory {
  factory $EmojiCompat_SpanFactory({
    required _$jni.JObject Function(_$jni.JObject typefaceEmojiRasterizer)
        createSpan,
  }) = _$EmojiCompat_SpanFactory;

  _$jni.JObject createSpan(_$jni.JObject typefaceEmojiRasterizer);
}

final class _$EmojiCompat_SpanFactory with $EmojiCompat_SpanFactory {
  _$EmojiCompat_SpanFactory({
    required _$jni.JObject Function(_$jni.JObject typefaceEmojiRasterizer)
        createSpan,
  }) : _createSpan = createSpan;

  final _$jni.JObject Function(_$jni.JObject typefaceEmojiRasterizer)
      _createSpan;

  _$jni.JObject createSpan(_$jni.JObject typefaceEmojiRasterizer) {
    return _createSpan(typefaceEmojiRasterizer);
  }
}

final class $EmojiCompat_SpanFactory$Type
    extends _$jni.JObjType<EmojiCompat_SpanFactory> {
  @_$jni.internal
  const $EmojiCompat_SpanFactory$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$SpanFactory;';

  @_$jni.internal
  @_$core.override
  EmojiCompat_SpanFactory fromReference(_$jni.JReference reference) =>
      EmojiCompat_SpanFactory.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($EmojiCompat_SpanFactory$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_SpanFactory$Type) &&
        other is $EmojiCompat_SpanFactory$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat`
class EmojiCompat extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<EmojiCompat> $type;

  @_$jni.internal
  EmojiCompat.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'androidx/emoji2/text/EmojiCompat');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat$Type();
  static final _id_EDITOR_INFO_METAVERSION_KEY = _class.staticFieldId(
    r'EDITOR_INFO_METAVERSION_KEY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EDITOR_INFO_METAVERSION_KEY`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get EDITOR_INFO_METAVERSION_KEY =>
      _id_EDITOR_INFO_METAVERSION_KEY.get(_class, const _$jni.JStringType());

  static final _id_EDITOR_INFO_REPLACE_ALL_KEY = _class.staticFieldId(
    r'EDITOR_INFO_REPLACE_ALL_KEY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EDITOR_INFO_REPLACE_ALL_KEY`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get EDITOR_INFO_REPLACE_ALL_KEY =>
      _id_EDITOR_INFO_REPLACE_ALL_KEY.get(_class, const _$jni.JStringType());

  /// from: `static public final int LOAD_STATE_DEFAULT`
  static const LOAD_STATE_DEFAULT = 3;

  /// from: `static public final int LOAD_STATE_LOADING`
  static const LOAD_STATE_LOADING = 0;

  /// from: `static public final int LOAD_STATE_SUCCEEDED`
  static const LOAD_STATE_SUCCEEDED = 1;

  /// from: `static public final int LOAD_STATE_FAILED`
  static const LOAD_STATE_FAILED = 2;

  /// from: `static public final int REPLACE_STRATEGY_DEFAULT`
  static const REPLACE_STRATEGY_DEFAULT = 0;

  /// from: `static public final int REPLACE_STRATEGY_ALL`
  static const REPLACE_STRATEGY_ALL = 1;

  /// from: `static public final int REPLACE_STRATEGY_NON_EXISTENT`
  static const REPLACE_STRATEGY_NON_EXISTENT = 2;

  /// from: `static public final int LOAD_STRATEGY_DEFAULT`
  static const LOAD_STRATEGY_DEFAULT = 0;

  /// from: `static public final int LOAD_STRATEGY_MANUAL`
  static const LOAD_STRATEGY_MANUAL = 1;

  /// from: `static public final int EMOJI_UNSUPPORTED`
  static const EMOJI_UNSUPPORTED = 0;

  /// from: `static public final int EMOJI_SUPPORTED`
  static const EMOJI_SUPPORTED = 1;

  /// from: `static public final int EMOJI_FALLBACK`
  static const EMOJI_FALLBACK = 2;
  static final _id_init = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _init = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat init(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat init(
    _$jni.JObject context,
  ) {
    return _init(_class.reference.pointer, _id_init as _$jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const $EmojiCompat$Type());
  }

  static final _id_init$1 = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _init$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat init(android.content.Context context, androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory defaultEmojiCompatConfigFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat init$1(
    _$jni.JObject context,
    DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory
        defaultEmojiCompatConfigFactory,
  ) {
    return _init$1(
            _class.reference.pointer,
            _id_init$1 as _$jni.JMethodIDPtr,
            context.reference.pointer,
            defaultEmojiCompatConfigFactory.reference.pointer)
        .object(const $EmojiCompat$Type());
  }

  static final _id_init$2 = _class.staticMethodId(
    r'init',
    r'(Landroidx/emoji2/text/EmojiCompat$Config;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _init$2 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat init(androidx.emoji2.text.EmojiCompat$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat init$2(
    EmojiCompat_Config config,
  ) {
    return _init$2(_class.reference.pointer, _id_init$2 as _$jni.JMethodIDPtr,
            config.reference.pointer)
        .object(const $EmojiCompat$Type());
  }

  static final _id_isConfigured = _class.staticMethodId(
    r'isConfigured',
    r'()Z',
  );

  static final _isConfigured = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public boolean isConfigured()`
  static bool isConfigured() {
    return _isConfigured(
            _class.reference.pointer, _id_isConfigured as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_reset = _class.staticMethodId(
    r'reset',
    r'(Landroidx/emoji2/text/EmojiCompat$Config;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _reset = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat reset(androidx.emoji2.text.EmojiCompat$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat reset(
    EmojiCompat_Config config,
  ) {
    return _reset(_class.reference.pointer, _id_reset as _$jni.JMethodIDPtr,
            config.reference.pointer)
        .object(const $EmojiCompat$Type());
  }

  static final _id_reset$1 = _class.staticMethodId(
    r'reset',
    r'(Landroidx/emoji2/text/EmojiCompat;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _reset$1 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat reset(androidx.emoji2.text.EmojiCompat emojiCompat)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat reset$1(
    EmojiCompat emojiCompat,
  ) {
    return _reset$1(_class.reference.pointer, _id_reset$1 as _$jni.JMethodIDPtr,
            emojiCompat.reference.pointer)
        .object(const $EmojiCompat$Type());
  }

  static final _id_skipDefaultConfigurationLookup = _class.staticMethodId(
    r'skipDefaultConfigurationLookup',
    r'(Z)V',
  );

  static final _skipDefaultConfigurationLookup =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Int32,)>)>>(
              'globalEnv_CallStaticVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `static public void skipDefaultConfigurationLookup(boolean z)`
  static void skipDefaultConfigurationLookup(
    bool z,
  ) {
    _skipDefaultConfigurationLookup(_class.reference.pointer,
            _id_skipDefaultConfigurationLookup as _$jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_get = _class.staticMethodId(
    r'get',
    r'()Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _get = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public androidx.emoji2.text.EmojiCompat get()`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat get() {
    return _get(_class.reference.pointer, _id_get as _$jni.JMethodIDPtr)
        .object(const $EmojiCompat$Type());
  }

  static final _id_load = _class.instanceMethodId(
    r'load',
    r'()V',
  );

  static final _load = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void load()`
  void load() {
    _load(reference.pointer, _id_load as _$jni.JMethodIDPtr).check();
  }

  static final _id_registerInitCallback = _class.instanceMethodId(
    r'registerInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)V',
  );

  static final _registerInitCallback = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void registerInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  void registerInitCallback(
    EmojiCompat_InitCallback initCallback,
  ) {
    _registerInitCallback(
            reference.pointer,
            _id_registerInitCallback as _$jni.JMethodIDPtr,
            initCallback.reference.pointer)
        .check();
  }

  static final _id_unregisterInitCallback = _class.instanceMethodId(
    r'unregisterInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)V',
  );

  static final _unregisterInitCallback = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void unregisterInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  void unregisterInitCallback(
    EmojiCompat_InitCallback initCallback,
  ) {
    _unregisterInitCallback(
            reference.pointer,
            _id_unregisterInitCallback as _$jni.JMethodIDPtr,
            initCallback.reference.pointer)
        .check();
  }

  static final _id_getLoadState = _class.instanceMethodId(
    r'getLoadState',
    r'()I',
  );

  static final _getLoadState = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int getLoadState()`
  int getLoadState() {
    return _getLoadState(
            reference.pointer, _id_getLoadState as _$jni.JMethodIDPtr)
        .integer;
  }

  static final _id_isEmojiSpanIndicatorEnabled = _class.instanceMethodId(
    r'isEmojiSpanIndicatorEnabled',
    r'()Z',
  );

  static final _isEmojiSpanIndicatorEnabled =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public boolean isEmojiSpanIndicatorEnabled()`
  bool isEmojiSpanIndicatorEnabled() {
    return _isEmojiSpanIndicatorEnabled(reference.pointer,
            _id_isEmojiSpanIndicatorEnabled as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getEmojiSpanIndicatorColor = _class.instanceMethodId(
    r'getEmojiSpanIndicatorColor',
    r'()I',
  );

  static final _getEmojiSpanIndicatorColor =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallIntMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public int getEmojiSpanIndicatorColor()`
  int getEmojiSpanIndicatorColor() {
    return _getEmojiSpanIndicatorColor(reference.pointer,
            _id_getEmojiSpanIndicatorColor as _$jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getEmojiStart = _class.instanceMethodId(
    r'getEmojiStart',
    r'(Ljava/lang/CharSequence;I)I',
  );

  static final _getEmojiStart = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni
                          .VarArgs<(_$jni.Pointer<_$jni.Void>, _$jni.Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int)>();

  /// from: `public int getEmojiStart(java.lang.CharSequence charSequence, int i)`
  int getEmojiStart(
    _$jni.JObject charSequence,
    int i,
  ) {
    return _getEmojiStart(
            reference.pointer,
            _id_getEmojiStart as _$jni.JMethodIDPtr,
            charSequence.reference.pointer,
            i)
        .integer;
  }

  static final _id_getEmojiEnd = _class.instanceMethodId(
    r'getEmojiEnd',
    r'(Ljava/lang/CharSequence;I)I',
  );

  static final _getEmojiEnd = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni
                          .VarArgs<(_$jni.Pointer<_$jni.Void>, _$jni.Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int)>();

  /// from: `public int getEmojiEnd(java.lang.CharSequence charSequence, int i)`
  int getEmojiEnd(
    _$jni.JObject charSequence,
    int i,
  ) {
    return _getEmojiEnd(
            reference.pointer,
            _id_getEmojiEnd as _$jni.JMethodIDPtr,
            charSequence.reference.pointer,
            i)
        .integer;
  }

  static final _id_handleOnKeyDown = _class.staticMethodId(
    r'handleOnKeyDown',
    r'(Landroid/text/Editable;ILandroid/view/KeyEvent;)Z',
  );

  static final _handleOnKeyDown = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              int,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public boolean handleOnKeyDown(android.text.Editable editable, int i, android.view.KeyEvent keyEvent)`
  static bool handleOnKeyDown(
    _$jni.JObject editable,
    int i,
    _$jni.JObject keyEvent,
  ) {
    return _handleOnKeyDown(
            _class.reference.pointer,
            _id_handleOnKeyDown as _$jni.JMethodIDPtr,
            editable.reference.pointer,
            i,
            keyEvent.reference.pointer)
        .boolean;
  }

  static final _id_handleDeleteSurroundingText = _class.staticMethodId(
    r'handleDeleteSurroundingText',
    r'(Landroid/view/inputmethod/InputConnection;Landroid/text/Editable;IIZ)Z',
  );

  static final _handleDeleteSurroundingText =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<
                          (
                            _$jni.Pointer<_$jni.Void>,
                            _$jni.Pointer<_$jni.Void>,
                            _$jni.Int32,
                            _$jni.Int32,
                            _$jni.Int32
                          )>)>>('globalEnv_CallStaticBooleanMethod')
          .asFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.Pointer<_$jni.Void>,
                  int,
                  int,
                  int)>();

  /// from: `static public boolean handleDeleteSurroundingText(android.view.inputmethod.InputConnection inputConnection, android.text.Editable editable, int i, int i1, boolean z)`
  static bool handleDeleteSurroundingText(
    _$jni.JObject inputConnection,
    _$jni.JObject editable,
    int i,
    int i1,
    bool z,
  ) {
    return _handleDeleteSurroundingText(
            _class.reference.pointer,
            _id_handleDeleteSurroundingText as _$jni.JMethodIDPtr,
            inputConnection.reference.pointer,
            editable.reference.pointer,
            i,
            i1,
            z ? 1 : 0)
        .boolean;
  }

  static final _id_hasEmojiGlyph = _class.instanceMethodId(
    r'hasEmojiGlyph',
    r'(Ljava/lang/CharSequence;)Z',
  );

  static final _hasEmojiGlyph = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public boolean hasEmojiGlyph(java.lang.CharSequence charSequence)`
  bool hasEmojiGlyph(
    _$jni.JObject charSequence,
  ) {
    return _hasEmojiGlyph(
            reference.pointer,
            _id_hasEmojiGlyph as _$jni.JMethodIDPtr,
            charSequence.reference.pointer)
        .boolean;
  }

  static final _id_hasEmojiGlyph$1 = _class.instanceMethodId(
    r'hasEmojiGlyph',
    r'(Ljava/lang/CharSequence;I)Z',
  );

  static final _hasEmojiGlyph$1 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni
                          .VarArgs<(_$jni.Pointer<_$jni.Void>, _$jni.Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int)>();

  /// from: `public boolean hasEmojiGlyph(java.lang.CharSequence charSequence, int i)`
  bool hasEmojiGlyph$1(
    _$jni.JObject charSequence,
    int i,
  ) {
    return _hasEmojiGlyph$1(
            reference.pointer,
            _id_hasEmojiGlyph$1 as _$jni.JMethodIDPtr,
            charSequence.reference.pointer,
            i)
        .boolean;
  }

  static final _id_getEmojiMatch = _class.instanceMethodId(
    r'getEmojiMatch',
    r'(Ljava/lang/CharSequence;I)I',
  );

  static final _getEmojiMatch = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni
                          .VarArgs<(_$jni.Pointer<_$jni.Void>, _$jni.Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int)>();

  /// from: `public int getEmojiMatch(java.lang.CharSequence charSequence, int i)`
  int getEmojiMatch(
    _$jni.JObject charSequence,
    int i,
  ) {
    return _getEmojiMatch(
            reference.pointer,
            _id_getEmojiMatch as _$jni.JMethodIDPtr,
            charSequence.reference.pointer,
            i)
        .integer;
  }

  static final _id_process = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;)Ljava/lang/CharSequence;',
  );

  static final _process = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject process(
    _$jni.JObject charSequence,
  ) {
    return _process(reference.pointer, _id_process as _$jni.JMethodIDPtr,
            charSequence.reference.pointer)
        .object(const _$jni.JObjectType());
  }

  static final _id_process$1 = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;II)Ljava/lang/CharSequence;',
  );

  static final _process$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32,
                        _$jni.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int, int)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject process$1(
    _$jni.JObject charSequence,
    int i,
    int i1,
  ) {
    return _process$1(reference.pointer, _id_process$1 as _$jni.JMethodIDPtr,
            charSequence.reference.pointer, i, i1)
        .object(const _$jni.JObjectType());
  }

  static final _id_process$2 = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;III)Ljava/lang/CharSequence;',
  );

  static final _process$2 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>, int, int, int)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence, int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject process$2(
    _$jni.JObject charSequence,
    int i,
    int i1,
    int i2,
  ) {
    return _process$2(reference.pointer, _id_process$2 as _$jni.JMethodIDPtr,
            charSequence.reference.pointer, i, i1, i2)
        .object(const _$jni.JObjectType());
  }

  static final _id_process$3 = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;IIII)Ljava/lang/CharSequence;',
  );

  static final _process$3 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32,
                        _$jni.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              int,
              int,
              int,
              int)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence, int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject process$3(
    _$jni.JObject charSequence,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _process$3(reference.pointer, _id_process$3 as _$jni.JMethodIDPtr,
            charSequence.reference.pointer, i, i1, i2, i3)
        .object(const _$jni.JObjectType());
  }

  static final _id_getAssetSignature = _class.instanceMethodId(
    r'getAssetSignature',
    r'()Ljava/lang/String;',
  );

  static final _getAssetSignature = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getAssetSignature()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JString getAssetSignature() {
    return _getAssetSignature(
            reference.pointer, _id_getAssetSignature as _$jni.JMethodIDPtr)
        .object(const _$jni.JStringType());
  }

  static final _id_updateEditorInfo = _class.instanceMethodId(
    r'updateEditorInfo',
    r'(Landroid/view/inputmethod/EditorInfo;)V',
  );

  static final _updateEditorInfo = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void updateEditorInfo(android.view.inputmethod.EditorInfo editorInfo)`
  void updateEditorInfo(
    _$jni.JObject editorInfo,
  ) {
    _updateEditorInfo(
            reference.pointer,
            _id_updateEditorInfo as _$jni.JMethodIDPtr,
            editorInfo.reference.pointer)
        .check();
  }
}

final class $EmojiCompat$Type extends _$jni.JObjType<EmojiCompat> {
  @_$jni.internal
  const $EmojiCompat$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat;';

  @_$jni.internal
  @_$core.override
  EmojiCompat fromReference(_$jni.JReference reference) =>
      EmojiCompat.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($EmojiCompat$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat$Type) &&
        other is $EmojiCompat$Type;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory`
class DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory
    extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory>
      $type;

  @_$jni.internal
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory');

  /// The type which includes information such as the signature of this class.
  static const type =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper;)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper defaultEmojiCompatConfigHelper)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory(
    DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper
        defaultEmojiCompatConfigHelper,
  ) {
    return DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory
        .fromReference(_new$(
                _class.reference.pointer,
                _id_new$ as _$jni.JMethodIDPtr,
                defaultEmojiCompatConfigHelper.reference.pointer)
            .reference);
  }

  static final _id_create = _class.instanceMethodId(
    r'create',
    r'(Landroid/content/Context;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _create = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config create(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config create(
    _$jni.JObject context,
  ) {
    return _create(reference.pointer, _id_create as _$jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const $EmojiCompat_Config$Type());
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$Type
    extends _$jni
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory> {
  @_$jni.internal
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory;';

  @_$jni.internal
  @_$core.override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory fromReference(
          _$jni.JReference reference) =>
      DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory.fromReference(
          reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$Type) &&
        other is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$Type;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper`
class DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper
    extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper>
      $type;

  @_$jni.internal
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper');

  /// The type which includes information such as the signature of this class.
  static const type =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper() {
    return DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper
        .fromReference(
            _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
                .reference);
  }

  static final _id_getSigningSignatures = _class.instanceMethodId(
    r'getSigningSignatures',
    r'(Landroid/content/pm/PackageManager;Ljava/lang/String;)[Landroid/content/pm/Signature;',
  );

  static final _getSigningSignatures = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public android.content.pm.Signature[] getSigningSignatures(android.content.pm.PackageManager packageManager, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JArray<_$jni.JObject> getSigningSignatures(
    _$jni.JObject packageManager,
    _$jni.JString string,
  ) {
    return _getSigningSignatures(
            reference.pointer,
            _id_getSigningSignatures as _$jni.JMethodIDPtr,
            packageManager.reference.pointer,
            string.reference.pointer)
        .object(const _$jni.JArrayType(_$jni.JObjectType()));
  }

  static final _id_queryIntentContentProviders = _class.instanceMethodId(
    r'queryIntentContentProviders',
    r'(Landroid/content/pm/PackageManager;Landroid/content/Intent;I)Ljava/util/List;',
  );

  static final _queryIntentContentProviders =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<
                          (
                            _$jni.Pointer<_$jni.Void>,
                            _$jni.Pointer<_$jni.Void>,
                            _$jni.Int32
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.Pointer<_$jni.Void>,
                  int)>();

  /// from: `public java.util.List queryIntentContentProviders(android.content.pm.PackageManager packageManager, android.content.Intent intent, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> queryIntentContentProviders(
    _$jni.JObject packageManager,
    _$jni.JObject intent,
    int i,
  ) {
    return _queryIntentContentProviders(
            reference.pointer,
            _id_queryIntentContentProviders as _$jni.JMethodIDPtr,
            packageManager.reference.pointer,
            intent.reference.pointer,
            i)
        .object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_getProviderInfo = _class.instanceMethodId(
    r'getProviderInfo',
    r'(Landroid/content/pm/ResolveInfo;)Landroid/content/pm/ProviderInfo;',
  );

  static final _getProviderInfo = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public android.content.pm.ProviderInfo getProviderInfo(android.content.pm.ResolveInfo resolveInfo)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject getProviderInfo(
    _$jni.JObject resolveInfo,
  ) {
    return _getProviderInfo(
            reference.pointer,
            _id_getProviderInfo as _$jni.JMethodIDPtr,
            resolveInfo.reference.pointer)
        .object(const _$jni.JObjectType());
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$Type
    extends _$jni
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper> {
  @_$jni.internal
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper;';

  @_$jni.internal
  @_$core.override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper fromReference(
          _$jni.JReference reference) =>
      DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper.fromReference(
          reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$Type) &&
        other is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$Type;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19`
class DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19
    extends DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper {
  @_$jni.internal
  @_$core.override
  final _$jni
      .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19>
      $type;

  @_$jni.internal
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19');

  /// The type which includes information such as the signature of this class.
  static const type =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19() {
    return DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19
        .fromReference(
            _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
                .reference);
  }

  static final _id_queryIntentContentProviders = _class.instanceMethodId(
    r'queryIntentContentProviders',
    r'(Landroid/content/pm/PackageManager;Landroid/content/Intent;I)Ljava/util/List;',
  );

  static final _queryIntentContentProviders =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<
                          (
                            _$jni.Pointer<_$jni.Void>,
                            _$jni.Pointer<_$jni.Void>,
                            _$jni.Int32
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.Pointer<_$jni.Void>,
                  int)>();

  /// from: `public java.util.List queryIntentContentProviders(android.content.pm.PackageManager packageManager, android.content.Intent intent, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JList<_$jni.JObject> queryIntentContentProviders(
    _$jni.JObject packageManager,
    _$jni.JObject intent,
    int i,
  ) {
    return _queryIntentContentProviders(
            reference.pointer,
            _id_queryIntentContentProviders as _$jni.JMethodIDPtr,
            packageManager.reference.pointer,
            intent.reference.pointer,
            i)
        .object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_getProviderInfo = _class.instanceMethodId(
    r'getProviderInfo',
    r'(Landroid/content/pm/ResolveInfo;)Landroid/content/pm/ProviderInfo;',
  );

  static final _getProviderInfo = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public android.content.pm.ProviderInfo getProviderInfo(android.content.pm.ResolveInfo resolveInfo)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject getProviderInfo(
    _$jni.JObject resolveInfo,
  ) {
    return _getProviderInfo(
            reference.pointer,
            _id_getProviderInfo as _$jni.JMethodIDPtr,
            resolveInfo.reference.pointer)
        .object(const _$jni.JObjectType());
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$Type
    extends _$jni
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19> {
  @_$jni.internal
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19;';

  @_$jni.internal
  @_$core.override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19 fromReference(
          _$jni.JReference reference) =>
      DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19
          .fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType =>
      const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$Type();

  @_$jni.internal
  @_$core.override
  final superCount = 2;

  @_$core.override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$Type)
          .hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$Type) &&
        other
            is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$Type;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28`
class DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28
    extends DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19 {
  @_$jni.internal
  @_$core.override
  final _$jni
      .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28>
      $type;

  @_$jni.internal
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28');

  /// The type which includes information such as the signature of this class.
  static const type =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28() {
    return DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28
        .fromReference(
            _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
                .reference);
  }

  static final _id_getSigningSignatures$1 = _class.instanceMethodId(
    r'getSigningSignatures',
    r'(Landroid/content/pm/PackageManager;Ljava/lang/String;)[Landroid/content/pm/Signature;',
  );

  static final _getSigningSignatures$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public android.content.pm.Signature[] getSigningSignatures(android.content.pm.PackageManager packageManager, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JArray<_$jni.JObject> getSigningSignatures$1(
    _$jni.JObject packageManager,
    _$jni.JString string,
  ) {
    return _getSigningSignatures$1(
            reference.pointer,
            _id_getSigningSignatures$1 as _$jni.JMethodIDPtr,
            packageManager.reference.pointer,
            string.reference.pointer)
        .object(const _$jni.JArrayType(_$jni.JObjectType()));
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$Type
    extends _$jni
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28> {
  @_$jni.internal
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$Type();

  @_$jni.internal
  @_$core.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28;';

  @_$jni.internal
  @_$core.override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28 fromReference(
          _$jni.JReference reference) =>
      DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28
          .fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType =>
      const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$Type();

  @_$jni.internal
  @_$core.override
  final superCount = 3;

  @_$core.override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$Type)
          .hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$Type) &&
        other
            is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$Type;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig`
class DefaultEmojiCompatConfig extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<DefaultEmojiCompatConfig> $type;

  @_$jni.internal
  DefaultEmojiCompatConfig.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'androidx/emoji2/text/DefaultEmojiCompatConfig');

  /// The type which includes information such as the signature of this class.
  static const type = $DefaultEmojiCompatConfig$Type();
  static final _id_create = _class.staticMethodId(
    r'create',
    r'(Landroid/content/Context;)Landroidx/emoji2/text/FontRequestEmojiCompatConfig;',
  );

  static final _create = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public androidx.emoji2.text.FontRequestEmojiCompatConfig create(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JObject create(
    _$jni.JObject context,
  ) {
    return _create(_class.reference.pointer, _id_create as _$jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const _$jni.JObjectType());
  }
}

final class $DefaultEmojiCompatConfig$Type
    extends _$jni.JObjType<DefaultEmojiCompatConfig> {
  @_$jni.internal
  const $DefaultEmojiCompatConfig$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Landroidx/emoji2/text/DefaultEmojiCompatConfig;';

  @_$jni.internal
  @_$core.override
  DefaultEmojiCompatConfig fromReference(_$jni.JReference reference) =>
      DefaultEmojiCompatConfig.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($DefaultEmojiCompatConfig$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DefaultEmojiCompatConfig$Type) &&
        other is $DefaultEmojiCompatConfig$Type;
  }
}

/// from: `android.os.Build$Partition`
class Build_Partition extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Build_Partition> $type;

  @_$jni.internal
  Build_Partition.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(r'android/os/Build$Partition');

  /// The type which includes information such as the signature of this class.
  static const type = $Build_Partition$Type();
  static final _id_PARTITION_NAME_SYSTEM = _class.staticFieldId(
    r'PARTITION_NAME_SYSTEM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PARTITION_NAME_SYSTEM`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get PARTITION_NAME_SYSTEM =>
      _id_PARTITION_NAME_SYSTEM.get(_class, const _$jni.JStringType());

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JString getName() {
    return _getName(reference.pointer, _id_getName as _$jni.JMethodIDPtr)
        .object(const _$jni.JStringType());
  }

  static final _id_getFingerprint = _class.instanceMethodId(
    r'getFingerprint',
    r'()Ljava/lang/String;',
  );

  static final _getFingerprint = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getFingerprint()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JString getFingerprint() {
    return _getFingerprint(
            reference.pointer, _id_getFingerprint as _$jni.JMethodIDPtr)
        .object(const _$jni.JStringType());
  }

  static final _id_getBuildTimeMillis = _class.instanceMethodId(
    r'getBuildTimeMillis',
    r'()J',
  );

  static final _getBuildTimeMillis = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public long getBuildTimeMillis()`
  int getBuildTimeMillis() {
    return _getBuildTimeMillis(
            reference.pointer, _id_getBuildTimeMillis as _$jni.JMethodIDPtr)
        .long;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    _$jni.JObject object,
  ) {
    return _equals(reference.pointer, _id_equals as _$jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as _$jni.JMethodIDPtr)
        .integer;
  }
}

final class $Build_Partition$Type extends _$jni.JObjType<Build_Partition> {
  @_$jni.internal
  const $Build_Partition$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Landroid/os/Build$Partition;';

  @_$jni.internal
  @_$core.override
  Build_Partition fromReference(_$jni.JReference reference) =>
      Build_Partition.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Build_Partition$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_Partition$Type) &&
        other is $Build_Partition$Type;
  }
}

/// from: `android.os.Build$VERSION`
class Build_VERSION extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Build_VERSION> $type;

  @_$jni.internal
  Build_VERSION.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(r'android/os/Build$VERSION');

  /// The type which includes information such as the signature of this class.
  static const type = $Build_VERSION$Type();
  static final _id_BASE_OS = _class.staticFieldId(
    r'BASE_OS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BASE_OS`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get BASE_OS =>
      _id_BASE_OS.get(_class, const _$jni.JStringType());

  static final _id_CODENAME = _class.staticFieldId(
    r'CODENAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CODENAME`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get CODENAME =>
      _id_CODENAME.get(_class, const _$jni.JStringType());

  static final _id_INCREMENTAL = _class.staticFieldId(
    r'INCREMENTAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String INCREMENTAL`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get INCREMENTAL =>
      _id_INCREMENTAL.get(_class, const _$jni.JStringType());

  static final _id_MEDIA_PERFORMANCE_CLASS = _class.staticFieldId(
    r'MEDIA_PERFORMANCE_CLASS',
    r'I',
  );

  /// from: `static public final int MEDIA_PERFORMANCE_CLASS`
  static int get MEDIA_PERFORMANCE_CLASS =>
      _id_MEDIA_PERFORMANCE_CLASS.get(_class, const _$jni.jintType());

  static final _id_PREVIEW_SDK_INT = _class.staticFieldId(
    r'PREVIEW_SDK_INT',
    r'I',
  );

  /// from: `static public final int PREVIEW_SDK_INT`
  static int get PREVIEW_SDK_INT =>
      _id_PREVIEW_SDK_INT.get(_class, const _$jni.jintType());

  static final _id_RELEASE = _class.staticFieldId(
    r'RELEASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get RELEASE =>
      _id_RELEASE.get(_class, const _$jni.JStringType());

  static final _id_RELEASE_OR_CODENAME = _class.staticFieldId(
    r'RELEASE_OR_CODENAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE_OR_CODENAME`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get RELEASE_OR_CODENAME =>
      _id_RELEASE_OR_CODENAME.get(_class, const _$jni.JStringType());

  static final _id_RELEASE_OR_PREVIEW_DISPLAY = _class.staticFieldId(
    r'RELEASE_OR_PREVIEW_DISPLAY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE_OR_PREVIEW_DISPLAY`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get RELEASE_OR_PREVIEW_DISPLAY =>
      _id_RELEASE_OR_PREVIEW_DISPLAY.get(_class, const _$jni.JStringType());

  static final _id_SDK = _class.staticFieldId(
    r'SDK',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SDK`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get SDK =>
      _id_SDK.get(_class, const _$jni.JStringType());

  static final _id_SDK_INT = _class.staticFieldId(
    r'SDK_INT',
    r'I',
  );

  /// from: `static public final int SDK_INT`
  static int get SDK_INT => _id_SDK_INT.get(_class, const _$jni.jintType());

  static final _id_SECURITY_PATCH = _class.staticFieldId(
    r'SECURITY_PATCH',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SECURITY_PATCH`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get SECURITY_PATCH =>
      _id_SECURITY_PATCH.get(_class, const _$jni.JStringType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build_VERSION() {
    return Build_VERSION.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $Build_VERSION$Type extends _$jni.JObjType<Build_VERSION> {
  @_$jni.internal
  const $Build_VERSION$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Landroid/os/Build$VERSION;';

  @_$jni.internal
  @_$core.override
  Build_VERSION fromReference(_$jni.JReference reference) =>
      Build_VERSION.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Build_VERSION$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_VERSION$Type) &&
        other is $Build_VERSION$Type;
  }
}

/// from: `android.os.Build$VERSION_CODES`
class Build_VERSION_CODES extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Build_VERSION_CODES> $type;

  @_$jni.internal
  Build_VERSION_CODES.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(r'android/os/Build$VERSION_CODES');

  /// The type which includes information such as the signature of this class.
  static const type = $Build_VERSION_CODES$Type();

  /// from: `static public final int BASE`
  static const BASE = 1;

  /// from: `static public final int BASE_1_1`
  static const BASE_1_1 = 2;

  /// from: `static public final int CUPCAKE`
  static const CUPCAKE = 3;

  /// from: `static public final int CUR_DEVELOPMENT`
  static const CUR_DEVELOPMENT = 10000;

  /// from: `static public final int DONUT`
  static const DONUT = 4;

  /// from: `static public final int ECLAIR`
  static const ECLAIR = 5;

  /// from: `static public final int ECLAIR_0_1`
  static const ECLAIR_0_1 = 6;

  /// from: `static public final int ECLAIR_MR1`
  static const ECLAIR_MR1 = 7;

  /// from: `static public final int FROYO`
  static const FROYO = 8;

  /// from: `static public final int GINGERBREAD`
  static const GINGERBREAD = 9;

  /// from: `static public final int GINGERBREAD_MR1`
  static const GINGERBREAD_MR1 = 10;

  /// from: `static public final int HONEYCOMB`
  static const HONEYCOMB = 11;

  /// from: `static public final int HONEYCOMB_MR1`
  static const HONEYCOMB_MR1 = 12;

  /// from: `static public final int HONEYCOMB_MR2`
  static const HONEYCOMB_MR2 = 13;

  /// from: `static public final int ICE_CREAM_SANDWICH`
  static const ICE_CREAM_SANDWICH = 14;

  /// from: `static public final int ICE_CREAM_SANDWICH_MR1`
  static const ICE_CREAM_SANDWICH_MR1 = 15;

  /// from: `static public final int JELLY_BEAN`
  static const JELLY_BEAN = 16;

  /// from: `static public final int JELLY_BEAN_MR1`
  static const JELLY_BEAN_MR1 = 17;

  /// from: `static public final int JELLY_BEAN_MR2`
  static const JELLY_BEAN_MR2 = 18;

  /// from: `static public final int KITKAT`
  static const KITKAT = 19;

  /// from: `static public final int KITKAT_WATCH`
  static const KITKAT_WATCH = 20;

  /// from: `static public final int LOLLIPOP`
  static const LOLLIPOP = 21;

  /// from: `static public final int LOLLIPOP_MR1`
  static const LOLLIPOP_MR1 = 22;

  /// from: `static public final int M`
  static const M = 23;

  /// from: `static public final int N`
  static const N = 24;

  /// from: `static public final int N_MR1`
  static const N_MR1 = 25;

  /// from: `static public final int O`
  static const O = 26;

  /// from: `static public final int O_MR1`
  static const O_MR1 = 27;

  /// from: `static public final int P`
  static const P = 28;

  /// from: `static public final int Q`
  static const Q = 29;

  /// from: `static public final int R`
  static const R = 30;

  /// from: `static public final int S`
  static const S = 31;

  /// from: `static public final int S_V2`
  static const S_V2 = 32;

  /// from: `static public final int TIRAMISU`
  static const TIRAMISU = 33;

  /// from: `static public final int UPSIDE_DOWN_CAKE`
  static const UPSIDE_DOWN_CAKE = 34;

  /// from: `static public final int VANILLA_ICE_CREAM`
  static const VANILLA_ICE_CREAM = 35;
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build_VERSION_CODES() {
    return Build_VERSION_CODES.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }
}

final class $Build_VERSION_CODES$Type
    extends _$jni.JObjType<Build_VERSION_CODES> {
  @_$jni.internal
  const $Build_VERSION_CODES$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Landroid/os/Build$VERSION_CODES;';

  @_$jni.internal
  @_$core.override
  Build_VERSION_CODES fromReference(_$jni.JReference reference) =>
      Build_VERSION_CODES.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Build_VERSION_CODES$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_VERSION_CODES$Type) &&
        other is $Build_VERSION_CODES$Type;
  }
}

/// from: `android.os.Build`
class Build extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<Build> $type;

  @_$jni.internal
  Build.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(r'android/os/Build');

  /// The type which includes information such as the signature of this class.
  static const type = $Build$Type();
  static final _id_BOARD = _class.staticFieldId(
    r'BOARD',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BOARD`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get BOARD =>
      _id_BOARD.get(_class, const _$jni.JStringType());

  static final _id_BOOTLOADER = _class.staticFieldId(
    r'BOOTLOADER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BOOTLOADER`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get BOOTLOADER =>
      _id_BOOTLOADER.get(_class, const _$jni.JStringType());

  static final _id_BRAND = _class.staticFieldId(
    r'BRAND',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BRAND`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get BRAND =>
      _id_BRAND.get(_class, const _$jni.JStringType());

  static final _id_CPU_ABI = _class.staticFieldId(
    r'CPU_ABI',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CPU_ABI`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get CPU_ABI =>
      _id_CPU_ABI.get(_class, const _$jni.JStringType());

  static final _id_CPU_ABI2 = _class.staticFieldId(
    r'CPU_ABI2',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CPU_ABI2`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get CPU_ABI2 =>
      _id_CPU_ABI2.get(_class, const _$jni.JStringType());

  static final _id_DEVICE = _class.staticFieldId(
    r'DEVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DEVICE =>
      _id_DEVICE.get(_class, const _$jni.JStringType());

  static final _id_DISPLAY = _class.staticFieldId(
    r'DISPLAY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DISPLAY`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get DISPLAY =>
      _id_DISPLAY.get(_class, const _$jni.JStringType());

  static final _id_FINGERPRINT = _class.staticFieldId(
    r'FINGERPRINT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FINGERPRINT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get FINGERPRINT =>
      _id_FINGERPRINT.get(_class, const _$jni.JStringType());

  static final _id_HARDWARE = _class.staticFieldId(
    r'HARDWARE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HARDWARE`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get HARDWARE =>
      _id_HARDWARE.get(_class, const _$jni.JStringType());

  static final _id_HOST = _class.staticFieldId(
    r'HOST',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HOST`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get HOST =>
      _id_HOST.get(_class, const _$jni.JStringType());

  static final _id_ID = _class.staticFieldId(
    r'ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ID`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ID => _id_ID.get(_class, const _$jni.JStringType());

  static final _id_MANUFACTURER = _class.staticFieldId(
    r'MANUFACTURER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MANUFACTURER`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get MANUFACTURER =>
      _id_MANUFACTURER.get(_class, const _$jni.JStringType());

  static final _id_MODEL = _class.staticFieldId(
    r'MODEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MODEL`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get MODEL =>
      _id_MODEL.get(_class, const _$jni.JStringType());

  static final _id_ODM_SKU = _class.staticFieldId(
    r'ODM_SKU',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ODM_SKU`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get ODM_SKU =>
      _id_ODM_SKU.get(_class, const _$jni.JStringType());

  static final _id_PRODUCT = _class.staticFieldId(
    r'PRODUCT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PRODUCT`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get PRODUCT =>
      _id_PRODUCT.get(_class, const _$jni.JStringType());

  static final _id_RADIO = _class.staticFieldId(
    r'RADIO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RADIO`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get RADIO =>
      _id_RADIO.get(_class, const _$jni.JStringType());

  static final _id_SERIAL = _class.staticFieldId(
    r'SERIAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SERIAL`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get SERIAL =>
      _id_SERIAL.get(_class, const _$jni.JStringType());

  static final _id_SKU = _class.staticFieldId(
    r'SKU',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SKU`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get SKU =>
      _id_SKU.get(_class, const _$jni.JStringType());

  static final _id_SOC_MANUFACTURER = _class.staticFieldId(
    r'SOC_MANUFACTURER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SOC_MANUFACTURER`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get SOC_MANUFACTURER =>
      _id_SOC_MANUFACTURER.get(_class, const _$jni.JStringType());

  static final _id_SOC_MODEL = _class.staticFieldId(
    r'SOC_MODEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SOC_MODEL`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get SOC_MODEL =>
      _id_SOC_MODEL.get(_class, const _$jni.JStringType());

  static final _id_SUPPORTED_32_BIT_ABIS = _class.staticFieldId(
    r'SUPPORTED_32_BIT_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_32_BIT_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JArray<_$jni.JString> get SUPPORTED_32_BIT_ABIS =>
      _id_SUPPORTED_32_BIT_ABIS.get(
          _class, const _$jni.JArrayType(_$jni.JStringType()));

  static final _id_SUPPORTED_64_BIT_ABIS = _class.staticFieldId(
    r'SUPPORTED_64_BIT_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_64_BIT_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JArray<_$jni.JString> get SUPPORTED_64_BIT_ABIS =>
      _id_SUPPORTED_64_BIT_ABIS.get(
          _class, const _$jni.JArrayType(_$jni.JStringType()));

  static final _id_SUPPORTED_ABIS = _class.staticFieldId(
    r'SUPPORTED_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JArray<_$jni.JString> get SUPPORTED_ABIS => _id_SUPPORTED_ABIS
      .get(_class, const _$jni.JArrayType(_$jni.JStringType()));

  static final _id_TAGS = _class.staticFieldId(
    r'TAGS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TAGS`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TAGS =>
      _id_TAGS.get(_class, const _$jni.JStringType());

  static final _id_TIME = _class.staticFieldId(
    r'TIME',
    r'J',
  );

  /// from: `static public final long TIME`
  static int get TIME => _id_TIME.get(_class, const _$jni.jlongType());

  static final _id_TYPE = _class.staticFieldId(
    r'TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get TYPE =>
      _id_TYPE.get(_class, const _$jni.JStringType());

  static final _id_UNKNOWN = _class.staticFieldId(
    r'UNKNOWN',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String UNKNOWN`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get UNKNOWN =>
      _id_UNKNOWN.get(_class, const _$jni.JStringType());

  static final _id_USER = _class.staticFieldId(
    r'USER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USER`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString get USER =>
      _id_USER.get(_class, const _$jni.JStringType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build() {
    return Build.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getSerial = _class.staticMethodId(
    r'getSerial',
    r'()Ljava/lang/String;',
  );

  static final _getSerial = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String getSerial()`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString getSerial() {
    return _getSerial(
            _class.reference.pointer, _id_getSerial as _$jni.JMethodIDPtr)
        .object(const _$jni.JStringType());
  }

  static final _id_getFingerprintedPartitions = _class.staticMethodId(
    r'getFingerprintedPartitions',
    r'()Ljava/util/List;',
  );

  static final _getFingerprintedPartitions =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `static public java.util.List getFingerprintedPartitions()`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JList<Build_Partition> getFingerprintedPartitions() {
    return _getFingerprintedPartitions(_class.reference.pointer,
            _id_getFingerprintedPartitions as _$jni.JMethodIDPtr)
        .object(const _$jni.JListType($Build_Partition$Type()));
  }

  static final _id_getRadioVersion = _class.staticMethodId(
    r'getRadioVersion',
    r'()Ljava/lang/String;',
  );

  static final _getRadioVersion = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String getRadioVersion()`
  /// The returned object must be released after use, by calling the [release] method.
  static _$jni.JString getRadioVersion() {
    return _getRadioVersion(
            _class.reference.pointer, _id_getRadioVersion as _$jni.JMethodIDPtr)
        .object(const _$jni.JStringType());
  }
}

final class $Build$Type extends _$jni.JObjType<Build> {
  @_$jni.internal
  const $Build$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Landroid/os/Build;';

  @_$jni.internal
  @_$core.override
  Build fromReference(_$jni.JReference reference) =>
      Build.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($Build$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build$Type) && other is $Build$Type;
  }
}

/// from: `java.util.HashMap`
class HashMap<$K extends _$jni.JObject, $V extends _$jni.JObject>
    extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<HashMap<$K, $V>> $type;

  @_$jni.internal
  final _$jni.JObjType<$K> K;

  @_$jni.internal
  final _$jni.JObjType<$V> V;

  @_$jni.internal
  HashMap.fromReference(
    this.K,
    this.V,
    _$jni.JReference reference,
  )   : $type = type(K, V),
        super.fromReference(reference);

  static final _class = _$jni.JClass.forName(r'java/util/HashMap');

  /// The type which includes information such as the signature of this class.
  static $HashMap$Type<$K, $V>
      type<$K extends _$jni.JObject, $V extends _$jni.JObject>(
    _$jni.JObjType<$K> K,
    _$jni.JObjType<$V> V,
  ) {
    return $HashMap$Type(
      K,
      V,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'(IF)V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Int32, _$jni.Double)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int, double)>();

  /// from: `public void <init>(int i, float f)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap(
    int i,
    double f, {
    required _$jni.JObjType<$K> K,
    required _$jni.JObjType<$V> V,
  }) {
    return HashMap.fromReference(
        K,
        V,
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr, i, f)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(I)V',
  );

  static final _new$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$1(
    int i, {
    required _$jni.JObjType<$K> K,
    required _$jni.JObjType<$V> V,
  }) {
    return HashMap.fromReference(
        K,
        V,
        _new$1(_class.reference.pointer, _id_new$1 as _$jni.JMethodIDPtr, i)
            .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'()V',
  );

  static final _new$2 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$2({
    required _$jni.JObjType<$K> K,
    required _$jni.JObjType<$V> V,
  }) {
    return HashMap.fromReference(
        K,
        V,
        _new$2(_class.reference.pointer, _id_new$2 as _$jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/util/Map;)V',
  );

  static final _new$3 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$3(
    _$jni.JMap<$K, $V> map, {
    _$jni.JObjType<$K>? K,
    _$jni.JObjType<$V>? V,
  }) {
    K ??= _$jni.lowestCommonSuperType([
      (map.$type as _$jni.JMapType<_$core.dynamic, _$core.dynamic>).K,
    ]) as _$jni.JObjType<$K>;
    V ??= _$jni.lowestCommonSuperType([
      (map.$type as _$jni.JMapType<_$core.dynamic, _$core.dynamic>).V,
    ]) as _$jni.JObjType<$V>;
    return HashMap.fromReference(
        K,
        V,
        _new$3(_class.reference.pointer, _id_new$3 as _$jni.JMethodIDPtr,
                map.reference.pointer)
            .reference);
  }

  static final _id_size = _class.instanceMethodId(
    r'size',
    r'()I',
  );

  static final _size = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int size()`
  int size() {
    return _size(reference.pointer, _id_size as _$jni.JMethodIDPtr).integer;
  }

  static final _id_isEmpty = _class.instanceMethodId(
    r'isEmpty',
    r'()Z',
  );

  static final _isEmpty = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public boolean isEmpty()`
  bool isEmpty() {
    return _isEmpty(reference.pointer, _id_isEmpty as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _get = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V get(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V get(
    _$jni.JObject object,
  ) {
    return _get(reference.pointer, _id_get as _$jni.JMethodIDPtr,
            object.reference.pointer)
        .object(V);
  }

  static final _id_containsKey = _class.instanceMethodId(
    r'containsKey',
    r'(Ljava/lang/Object;)Z',
  );

  static final _containsKey = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public boolean containsKey(java.lang.Object object)`
  bool containsKey(
    _$jni.JObject object,
  ) {
    return _containsKey(reference.pointer,
            _id_containsKey as _$jni.JMethodIDPtr, object.reference.pointer)
        .boolean;
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _put = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V put(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V put(
    $K object,
    $V object1,
  ) {
    return _put(reference.pointer, _id_put as _$jni.JMethodIDPtr,
            object.reference.pointer, object1.reference.pointer)
        .object(V);
  }

  static final _id_putAll = _class.instanceMethodId(
    r'putAll',
    r'(Ljava/util/Map;)V',
  );

  static final _putAll = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void putAll(java.util.Map map)`
  void putAll(
    _$jni.JMap<$K, $V> map,
  ) {
    _putAll(reference.pointer, _id_putAll as _$jni.JMethodIDPtr,
            map.reference.pointer)
        .check();
  }

  static final _id_remove = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _remove = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V remove(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V remove(
    _$jni.JObject object,
  ) {
    return _remove(reference.pointer, _id_remove as _$jni.JMethodIDPtr,
            object.reference.pointer)
        .object(V);
  }

  static final _id_clear = _class.instanceMethodId(
    r'clear',
    r'()V',
  );

  static final _clear = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void clear()`
  void clear() {
    _clear(reference.pointer, _id_clear as _$jni.JMethodIDPtr).check();
  }

  static final _id_containsValue = _class.instanceMethodId(
    r'containsValue',
    r'(Ljava/lang/Object;)Z',
  );

  static final _containsValue = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public boolean containsValue(java.lang.Object object)`
  bool containsValue(
    _$jni.JObject object,
  ) {
    return _containsValue(reference.pointer,
            _id_containsValue as _$jni.JMethodIDPtr, object.reference.pointer)
        .boolean;
  }

  static final _id_keySet = _class.instanceMethodId(
    r'keySet',
    r'()Ljava/util/Set;',
  );

  static final _keySet = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.Set keySet()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JSet<$K> keySet() {
    return _keySet(reference.pointer, _id_keySet as _$jni.JMethodIDPtr)
        .object(_$jni.JSetType(K));
  }

  static final _id_values = _class.instanceMethodId(
    r'values',
    r'()Ljava/util/Collection;',
  );

  static final _values = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.Collection values()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject values() {
    return _values(reference.pointer, _id_values as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_entrySet = _class.instanceMethodId(
    r'entrySet',
    r'()Ljava/util/Set;',
  );

  static final _entrySet = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.Set entrySet()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JSet<_$jni.JObject> entrySet() {
    return _entrySet(reference.pointer, _id_entrySet as _$jni.JMethodIDPtr)
        .object(const _$jni.JSetType(_$jni.JObjectType()));
  }

  static final _id_getOrDefault = _class.instanceMethodId(
    r'getOrDefault',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _getOrDefault = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V getOrDefault(java.lang.Object object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V getOrDefault(
    _$jni.JObject object,
    $V object1,
  ) {
    return _getOrDefault(
            reference.pointer,
            _id_getOrDefault as _$jni.JMethodIDPtr,
            object.reference.pointer,
            object1.reference.pointer)
        .object(V);
  }

  static final _id_putIfAbsent = _class.instanceMethodId(
    r'putIfAbsent',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _putIfAbsent = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V putIfAbsent(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V putIfAbsent(
    $K object,
    $V object1,
  ) {
    return _putIfAbsent(
            reference.pointer,
            _id_putIfAbsent as _$jni.JMethodIDPtr,
            object.reference.pointer,
            object1.reference.pointer)
        .object(V);
  }

  static final _id_remove$1 = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Z',
  );

  static final _remove$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public boolean remove(java.lang.Object object, java.lang.Object object1)`
  bool remove$1(
    _$jni.JObject object,
    _$jni.JObject object1,
  ) {
    return _remove$1(reference.pointer, _id_remove$1 as _$jni.JMethodIDPtr,
            object.reference.pointer, object1.reference.pointer)
        .boolean;
  }

  static final _id_replace = _class.instanceMethodId(
    r'replace',
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Z',
  );

  static final _replace = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public boolean replace(K object, V object1, V object2)`
  bool replace(
    $K object,
    $V object1,
    $V object2,
  ) {
    return _replace(
            reference.pointer,
            _id_replace as _$jni.JMethodIDPtr,
            object.reference.pointer,
            object1.reference.pointer,
            object2.reference.pointer)
        .boolean;
  }

  static final _id_replace$1 = _class.instanceMethodId(
    r'replace',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _replace$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V replace(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V replace$1(
    $K object,
    $V object1,
  ) {
    return _replace$1(reference.pointer, _id_replace$1 as _$jni.JMethodIDPtr,
            object.reference.pointer, object1.reference.pointer)
        .object(V);
  }

  static final _id_computeIfAbsent = _class.instanceMethodId(
    r'computeIfAbsent',
    r'(Ljava/lang/Object;Ljava/util/function/Function;)Ljava/lang/Object;',
  );

  static final _computeIfAbsent = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V computeIfAbsent(K object, java.util.function.Function function)`
  /// The returned object must be released after use, by calling the [release] method.
  $V computeIfAbsent(
    $K object,
    _$jni.JObject function,
  ) {
    return _computeIfAbsent(
            reference.pointer,
            _id_computeIfAbsent as _$jni.JMethodIDPtr,
            object.reference.pointer,
            function.reference.pointer)
        .object(V);
  }

  static final _id_computeIfPresent = _class.instanceMethodId(
    r'computeIfPresent',
    r'(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _computeIfPresent = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V computeIfPresent(K object, java.util.function.BiFunction biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V computeIfPresent(
    $K object,
    _$jni.JObject biFunction,
  ) {
    return _computeIfPresent(
            reference.pointer,
            _id_computeIfPresent as _$jni.JMethodIDPtr,
            object.reference.pointer,
            biFunction.reference.pointer)
        .object(V);
  }

  static final _id_compute = _class.instanceMethodId(
    r'compute',
    r'(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _compute = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V compute(K object, java.util.function.BiFunction biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V compute(
    $K object,
    _$jni.JObject biFunction,
  ) {
    return _compute(reference.pointer, _id_compute as _$jni.JMethodIDPtr,
            object.reference.pointer, biFunction.reference.pointer)
        .object(V);
  }

  static final _id_merge = _class.instanceMethodId(
    r'merge',
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _merge = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public V merge(K object, V object1, java.util.function.BiFunction biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V merge(
    $K object,
    $V object1,
    _$jni.JObject biFunction,
  ) {
    return _merge(
            reference.pointer,
            _id_merge as _$jni.JMethodIDPtr,
            object.reference.pointer,
            object1.reference.pointer,
            biFunction.reference.pointer)
        .object(V);
  }

  static final _id_forEach = _class.instanceMethodId(
    r'forEach',
    r'(Ljava/util/function/BiConsumer;)V',
  );

  static final _forEach = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void forEach(java.util.function.BiConsumer biConsumer)`
  void forEach(
    _$jni.JObject biConsumer,
  ) {
    _forEach(reference.pointer, _id_forEach as _$jni.JMethodIDPtr,
            biConsumer.reference.pointer)
        .check();
  }

  static final _id_replaceAll = _class.instanceMethodId(
    r'replaceAll',
    r'(Ljava/util/function/BiFunction;)V',
  );

  static final _replaceAll = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void replaceAll(java.util.function.BiFunction biFunction)`
  void replaceAll(
    _$jni.JObject biFunction,
  ) {
    _replaceAll(reference.pointer, _id_replaceAll as _$jni.JMethodIDPtr,
            biFunction.reference.pointer)
        .check();
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  _$jni.JObject clone() {
    return _clone(reference.pointer, _id_clone as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_newHashMap = _class.staticMethodId(
    r'newHashMap',
    r'(I)Ljava/util/HashMap;',
  );

  static final _newHashMap = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr, _$jni.VarArgs<(_$jni.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `static public java.util.HashMap newHashMap(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static HashMap<$K, $V>
      newHashMap<$K extends _$jni.JObject, $V extends _$jni.JObject>(
    int i, {
    required _$jni.JObjType<$K> K,
    required _$jni.JObjType<$V> V,
  }) {
    return _newHashMap(
            _class.reference.pointer, _id_newHashMap as _$jni.JMethodIDPtr, i)
        .object($HashMap$Type(K, V));
  }
}

final class $HashMap$Type<$K extends _$jni.JObject, $V extends _$jni.JObject>
    extends _$jni.JObjType<HashMap<$K, $V>> {
  @_$jni.internal
  final _$jni.JObjType<$K> K;

  @_$jni.internal
  final _$jni.JObjType<$V> V;

  @_$jni.internal
  const $HashMap$Type(
    this.K,
    this.V,
  );

  @_$jni.internal
  @_$core.override
  String get signature => r'Ljava/util/HashMap;';

  @_$jni.internal
  @_$core.override
  HashMap<$K, $V> fromReference(_$jni.JReference reference) =>
      HashMap.fromReference(K, V, reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => Object.hash($HashMap$Type, K, V);

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($HashMap$Type<$K, $V>) &&
        other is $HashMap$Type<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

/// from: `com.example.in_app_java.AndroidUtils`
class AndroidUtils extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<AndroidUtils> $type;

  @_$jni.internal
  AndroidUtils.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'com/example/in_app_java/AndroidUtils');

  /// The type which includes information such as the signature of this class.
  static const type = $AndroidUtils$Type();
  static final _id_showToast = _class.staticMethodId(
    r'showToast',
    r'(Landroid/app/Activity;Ljava/lang/CharSequence;I)V',
  );

  static final _showToast = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Int32
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              int)>();

  /// from: `static public void showToast(android.app.Activity mainActivity, java.lang.CharSequence text, int duration)`
  static void showToast(
    _$jni.JObject mainActivity,
    _$jni.JObject text,
    int duration,
  ) {
    _showToast(_class.reference.pointer, _id_showToast as _$jni.JMethodIDPtr,
            mainActivity.reference.pointer, text.reference.pointer, duration)
        .check();
  }
}

final class $AndroidUtils$Type extends _$jni.JObjType<AndroidUtils> {
  @_$jni.internal
  const $AndroidUtils$Type();

  @_$jni.internal
  @_$core.override
  String get signature => r'Lcom/example/in_app_java/AndroidUtils;';

  @_$jni.internal
  @_$core.override
  AndroidUtils fromReference(_$jni.JReference reference) =>
      AndroidUtils.fromReference(reference);

  @_$jni.internal
  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$jni.internal
  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($AndroidUtils$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AndroidUtils$Type) &&
        other is $AndroidUtils$Type;
  }
}
