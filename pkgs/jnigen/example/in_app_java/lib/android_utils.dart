// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

/// from: `androidx.emoji2.text.EmojiCompat$CodepointSequenceMatchResult`
class EmojiCompat_CodepointSequenceMatchResult extends jni.JObject {
  @override
  late final jni.JObjType<EmojiCompat_CodepointSequenceMatchResult> $type =
      type;

  EmojiCompat_CodepointSequenceMatchResult.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$CodepointSequenceMatchResult');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_CodepointSequenceMatchResultType();
}

final class $EmojiCompat_CodepointSequenceMatchResultType
    extends jni.JObjType<EmojiCompat_CodepointSequenceMatchResult> {
  const $EmojiCompat_CodepointSequenceMatchResultType();

  @override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$CodepointSequenceMatchResult;';

  @override
  EmojiCompat_CodepointSequenceMatchResult fromReference(
          jni.JReference reference) =>
      EmojiCompat_CodepointSequenceMatchResult.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($EmojiCompat_CodepointSequenceMatchResultType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($EmojiCompat_CodepointSequenceMatchResultType) &&
        other is $EmojiCompat_CodepointSequenceMatchResultType;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$Config`
class EmojiCompat_Config extends jni.JObject {
  @override
  late final jni.JObjType<EmojiCompat_Config> $type = type;

  EmojiCompat_Config.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/emoji2/text/EmojiCompat$Config');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_ConfigType();
  static final _id_registerInitCallback = _class.instanceMethodId(
    r'registerInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _registerInitCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config registerInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config registerInitCallback(
    EmojiCompat_InitCallback initCallback,
  ) {
    return _registerInitCallback(
            reference.pointer,
            _id_registerInitCallback as jni.JMethodIDPtr,
            initCallback.reference.pointer)
        .object(const $EmojiCompat_ConfigType());
  }

  static final _id_unregisterInitCallback = _class.instanceMethodId(
    r'unregisterInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _unregisterInitCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config unregisterInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config unregisterInitCallback(
    EmojiCompat_InitCallback initCallback,
  ) {
    return _unregisterInitCallback(
            reference.pointer,
            _id_unregisterInitCallback as jni.JMethodIDPtr,
            initCallback.reference.pointer)
        .object(const $EmojiCompat_ConfigType());
  }

  static final _id_setReplaceAll = _class.instanceMethodId(
    r'setReplaceAll',
    r'(Z)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setReplaceAll = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setReplaceAll(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setReplaceAll(
    bool z,
  ) {
    return _setReplaceAll(
            reference.pointer, _id_setReplaceAll as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $EmojiCompat_ConfigType());
  }

  static final _id_setUseEmojiAsDefaultStyle = _class.instanceMethodId(
    r'setUseEmojiAsDefaultStyle',
    r'(Z)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setUseEmojiAsDefaultStyle = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setUseEmojiAsDefaultStyle(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setUseEmojiAsDefaultStyle(
    bool z,
  ) {
    return _setUseEmojiAsDefaultStyle(reference.pointer,
            _id_setUseEmojiAsDefaultStyle as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $EmojiCompat_ConfigType());
  }

  static final _id_setUseEmojiAsDefaultStyle$1 = _class.instanceMethodId(
    r'setUseEmojiAsDefaultStyle',
    r'(ZLjava/util/List;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setUseEmojiAsDefaultStyle$1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setUseEmojiAsDefaultStyle(boolean z, java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setUseEmojiAsDefaultStyle$1(
    bool z,
    jni.JList<jni.JInteger> list,
  ) {
    return _setUseEmojiAsDefaultStyle$1(
            reference.pointer,
            _id_setUseEmojiAsDefaultStyle$1 as jni.JMethodIDPtr,
            z ? 1 : 0,
            list.reference.pointer)
        .object(const $EmojiCompat_ConfigType());
  }

  static final _id_setEmojiSpanIndicatorEnabled = _class.instanceMethodId(
    r'setEmojiSpanIndicatorEnabled',
    r'(Z)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setEmojiSpanIndicatorEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setEmojiSpanIndicatorEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setEmojiSpanIndicatorEnabled(
    bool z,
  ) {
    return _setEmojiSpanIndicatorEnabled(reference.pointer,
            _id_setEmojiSpanIndicatorEnabled as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $EmojiCompat_ConfigType());
  }

  static final _id_setEmojiSpanIndicatorColor = _class.instanceMethodId(
    r'setEmojiSpanIndicatorColor',
    r'(I)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setEmojiSpanIndicatorColor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setEmojiSpanIndicatorColor(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setEmojiSpanIndicatorColor(
    int i,
  ) {
    return _setEmojiSpanIndicatorColor(reference.pointer,
            _id_setEmojiSpanIndicatorColor as jni.JMethodIDPtr, i)
        .object(const $EmojiCompat_ConfigType());
  }

  static final _id_setMetadataLoadStrategy = _class.instanceMethodId(
    r'setMetadataLoadStrategy',
    r'(I)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setMetadataLoadStrategy = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setMetadataLoadStrategy(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setMetadataLoadStrategy(
    int i,
  ) {
    return _setMetadataLoadStrategy(reference.pointer,
            _id_setMetadataLoadStrategy as jni.JMethodIDPtr, i)
        .object(const $EmojiCompat_ConfigType());
  }

  static final _id_setSpanFactory = _class.instanceMethodId(
    r'setSpanFactory',
    r'(Landroidx/emoji2/text/EmojiCompat$SpanFactory;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setSpanFactory = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setSpanFactory(androidx.emoji2.text.EmojiCompat$SpanFactory spanFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setSpanFactory(
    EmojiCompat_SpanFactory spanFactory,
  ) {
    return _setSpanFactory(
            reference.pointer,
            _id_setSpanFactory as jni.JMethodIDPtr,
            spanFactory.reference.pointer)
        .object(const $EmojiCompat_ConfigType());
  }

  static final _id_setGlyphChecker = _class.instanceMethodId(
    r'setGlyphChecker',
    r'(Landroidx/emoji2/text/EmojiCompat$GlyphChecker;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setGlyphChecker = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setGlyphChecker(androidx.emoji2.text.EmojiCompat$GlyphChecker glyphChecker)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config setGlyphChecker(
    EmojiCompat_GlyphChecker glyphChecker,
  ) {
    return _setGlyphChecker(
            reference.pointer,
            _id_setGlyphChecker as jni.JMethodIDPtr,
            glyphChecker.reference.pointer)
        .object(const $EmojiCompat_ConfigType());
  }
}

final class $EmojiCompat_ConfigType extends jni.JObjType<EmojiCompat_Config> {
  const $EmojiCompat_ConfigType();

  @override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$Config;';

  @override
  EmojiCompat_Config fromReference(jni.JReference reference) =>
      EmojiCompat_Config.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($EmojiCompat_ConfigType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_ConfigType) &&
        other is $EmojiCompat_ConfigType;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$DefaultSpanFactory`
class EmojiCompat_DefaultSpanFactory extends jni.JObject {
  @override
  late final jni.JObjType<EmojiCompat_DefaultSpanFactory> $type = type;

  EmojiCompat_DefaultSpanFactory.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$DefaultSpanFactory');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_DefaultSpanFactoryType();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory EmojiCompat_DefaultSpanFactory() {
    return EmojiCompat_DefaultSpanFactory.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_createSpan = _class.instanceMethodId(
    r'createSpan',
    r'(Landroidx/emoji2/text/TypefaceEmojiRasterizer;)Landroidx/emoji2/text/EmojiSpan;',
  );

  static final _createSpan = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiSpan createSpan(androidx.emoji2.text.TypefaceEmojiRasterizer typefaceEmojiRasterizer)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject createSpan(
    jni.JObject typefaceEmojiRasterizer,
  ) {
    return _createSpan(reference.pointer, _id_createSpan as jni.JMethodIDPtr,
            typefaceEmojiRasterizer.reference.pointer)
        .object(const jni.JObjectType());
  }
}

final class $EmojiCompat_DefaultSpanFactoryType
    extends jni.JObjType<EmojiCompat_DefaultSpanFactory> {
  const $EmojiCompat_DefaultSpanFactoryType();

  @override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$DefaultSpanFactory;';

  @override
  EmojiCompat_DefaultSpanFactory fromReference(jni.JReference reference) =>
      EmojiCompat_DefaultSpanFactory.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($EmojiCompat_DefaultSpanFactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_DefaultSpanFactoryType) &&
        other is $EmojiCompat_DefaultSpanFactoryType;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$GlyphChecker`
class EmojiCompat_GlyphChecker extends jni.JObject {
  @override
  late final jni.JObjType<EmojiCompat_GlyphChecker> $type = type;

  EmojiCompat_GlyphChecker.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/emoji2/text/EmojiCompat$GlyphChecker');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_GlyphCheckerType();
  static final _id_hasGlyph = _class.instanceMethodId(
    r'hasGlyph',
    r'(Ljava/lang/CharSequence;III)Z',
  );

  static final _hasGlyph = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: `public abstract boolean hasGlyph(java.lang.CharSequence charSequence, int i, int i1, int i2)`
  bool hasGlyph(
    jni.JObject charSequence,
    int i,
    int i1,
    int i2,
  ) {
    return _hasGlyph(reference.pointer, _id_hasGlyph as jni.JMethodIDPtr,
            charSequence.reference.pointer, i, i1, i2)
        .boolean;
  }
}

final class $EmojiCompat_GlyphCheckerType
    extends jni.JObjType<EmojiCompat_GlyphChecker> {
  const $EmojiCompat_GlyphCheckerType();

  @override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$GlyphChecker;';

  @override
  EmojiCompat_GlyphChecker fromReference(jni.JReference reference) =>
      EmojiCompat_GlyphChecker.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($EmojiCompat_GlyphCheckerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_GlyphCheckerType) &&
        other is $EmojiCompat_GlyphCheckerType;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$InitCallback`
class EmojiCompat_InitCallback extends jni.JObject {
  @override
  late final jni.JObjType<EmojiCompat_InitCallback> $type = type;

  EmojiCompat_InitCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/emoji2/text/EmojiCompat$InitCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_InitCallbackType();
  static final _id_onInitialized = _class.instanceMethodId(
    r'onInitialized',
    r'()V',
  );

  static final _onInitialized = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void onInitialized()`
  void onInitialized() {
    _onInitialized(reference.pointer, _id_onInitialized as jni.JMethodIDPtr)
        .check();
  }

  static final _id_onFailed = _class.instanceMethodId(
    r'onFailed',
    r'(Ljava/lang/Throwable;)V',
  );

  static final _onFailed = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void onFailed(java.lang.Throwable throwable)`
  void onFailed(
    jni.JObject throwable,
  ) {
    _onFailed(reference.pointer, _id_onFailed as jni.JMethodIDPtr,
            throwable.reference.pointer)
        .check();
  }
}

final class $EmojiCompat_InitCallbackType
    extends jni.JObjType<EmojiCompat_InitCallback> {
  const $EmojiCompat_InitCallbackType();

  @override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$InitCallback;';

  @override
  EmojiCompat_InitCallback fromReference(jni.JReference reference) =>
      EmojiCompat_InitCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($EmojiCompat_InitCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_InitCallbackType) &&
        other is $EmojiCompat_InitCallbackType;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$LoadStrategy`
class EmojiCompat_LoadStrategy extends jni.JObject {
  @override
  late final jni.JObjType<EmojiCompat_LoadStrategy> $type = type;

  EmojiCompat_LoadStrategy.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/emoji2/text/EmojiCompat$LoadStrategy');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_LoadStrategyType();
}

final class $EmojiCompat_LoadStrategyType
    extends jni.JObjType<EmojiCompat_LoadStrategy> {
  const $EmojiCompat_LoadStrategyType();

  @override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$LoadStrategy;';

  @override
  EmojiCompat_LoadStrategy fromReference(jni.JReference reference) =>
      EmojiCompat_LoadStrategy.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($EmojiCompat_LoadStrategyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_LoadStrategyType) &&
        other is $EmojiCompat_LoadStrategyType;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$MetadataRepoLoader`
class EmojiCompat_MetadataRepoLoader extends jni.JObject {
  @override
  late final jni.JObjType<EmojiCompat_MetadataRepoLoader> $type = type;

  EmojiCompat_MetadataRepoLoader.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$MetadataRepoLoader');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_MetadataRepoLoaderType();
  static final _id_load = _class.instanceMethodId(
    r'load',
    r'(Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;)V',
  );

  static final _load = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void load(androidx.emoji2.text.EmojiCompat$MetadataRepoLoaderCallback metadataRepoLoaderCallback)`
  void load(
    EmojiCompat_MetadataRepoLoaderCallback metadataRepoLoaderCallback,
  ) {
    _load(reference.pointer, _id_load as jni.JMethodIDPtr,
            metadataRepoLoaderCallback.reference.pointer)
        .check();
  }
}

final class $EmojiCompat_MetadataRepoLoaderType
    extends jni.JObjType<EmojiCompat_MetadataRepoLoader> {
  const $EmojiCompat_MetadataRepoLoaderType();

  @override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoader;';

  @override
  EmojiCompat_MetadataRepoLoader fromReference(jni.JReference reference) =>
      EmojiCompat_MetadataRepoLoader.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($EmojiCompat_MetadataRepoLoaderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_MetadataRepoLoaderType) &&
        other is $EmojiCompat_MetadataRepoLoaderType;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$MetadataRepoLoaderCallback`
class EmojiCompat_MetadataRepoLoaderCallback extends jni.JObject {
  @override
  late final jni.JObjType<EmojiCompat_MetadataRepoLoaderCallback> $type = type;

  EmojiCompat_MetadataRepoLoaderCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_MetadataRepoLoaderCallbackType();
  static final _id_onLoaded = _class.instanceMethodId(
    r'onLoaded',
    r'(Landroidx/emoji2/text/MetadataRepo;)V',
  );

  static final _onLoaded = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onLoaded(androidx.emoji2.text.MetadataRepo metadataRepo)`
  void onLoaded(
    jni.JObject metadataRepo,
  ) {
    _onLoaded(reference.pointer, _id_onLoaded as jni.JMethodIDPtr,
            metadataRepo.reference.pointer)
        .check();
  }

  static final _id_onFailed = _class.instanceMethodId(
    r'onFailed',
    r'(Ljava/lang/Throwable;)V',
  );

  static final _onFailed = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract void onFailed(java.lang.Throwable throwable)`
  void onFailed(
    jni.JObject throwable,
  ) {
    _onFailed(reference.pointer, _id_onFailed as jni.JMethodIDPtr,
            throwable.reference.pointer)
        .check();
  }
}

final class $EmojiCompat_MetadataRepoLoaderCallbackType
    extends jni.JObjType<EmojiCompat_MetadataRepoLoaderCallback> {
  const $EmojiCompat_MetadataRepoLoaderCallbackType();

  @override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;';

  @override
  EmojiCompat_MetadataRepoLoaderCallback fromReference(
          jni.JReference reference) =>
      EmojiCompat_MetadataRepoLoaderCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($EmojiCompat_MetadataRepoLoaderCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_MetadataRepoLoaderCallbackType) &&
        other is $EmojiCompat_MetadataRepoLoaderCallbackType;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$ReplaceStrategy`
class EmojiCompat_ReplaceStrategy extends jni.JObject {
  @override
  late final jni.JObjType<EmojiCompat_ReplaceStrategy> $type = type;

  EmojiCompat_ReplaceStrategy.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/emoji2/text/EmojiCompat$ReplaceStrategy');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_ReplaceStrategyType();
}

final class $EmojiCompat_ReplaceStrategyType
    extends jni.JObjType<EmojiCompat_ReplaceStrategy> {
  const $EmojiCompat_ReplaceStrategyType();

  @override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$ReplaceStrategy;';

  @override
  EmojiCompat_ReplaceStrategy fromReference(jni.JReference reference) =>
      EmojiCompat_ReplaceStrategy.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($EmojiCompat_ReplaceStrategyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_ReplaceStrategyType) &&
        other is $EmojiCompat_ReplaceStrategyType;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$SpanFactory`
class EmojiCompat_SpanFactory extends jni.JObject {
  @override
  late final jni.JObjType<EmojiCompat_SpanFactory> $type = type;

  EmojiCompat_SpanFactory.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/emoji2/text/EmojiCompat$SpanFactory');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompat_SpanFactoryType();
  static final _id_createSpan = _class.instanceMethodId(
    r'createSpan',
    r'(Landroidx/emoji2/text/TypefaceEmojiRasterizer;)Landroidx/emoji2/text/EmojiSpan;',
  );

  static final _createSpan = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public abstract androidx.emoji2.text.EmojiSpan createSpan(androidx.emoji2.text.TypefaceEmojiRasterizer typefaceEmojiRasterizer)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject createSpan(
    jni.JObject typefaceEmojiRasterizer,
  ) {
    return _createSpan(reference.pointer, _id_createSpan as jni.JMethodIDPtr,
            typefaceEmojiRasterizer.reference.pointer)
        .object(const jni.JObjectType());
  }
}

final class $EmojiCompat_SpanFactoryType
    extends jni.JObjType<EmojiCompat_SpanFactory> {
  const $EmojiCompat_SpanFactoryType();

  @override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$SpanFactory;';

  @override
  EmojiCompat_SpanFactory fromReference(jni.JReference reference) =>
      EmojiCompat_SpanFactory.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($EmojiCompat_SpanFactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_SpanFactoryType) &&
        other is $EmojiCompat_SpanFactoryType;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat`
class EmojiCompat extends jni.JObject {
  @override
  late final jni.JObjType<EmojiCompat> $type = type;

  EmojiCompat.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'androidx/emoji2/text/EmojiCompat');

  /// The type which includes information such as the signature of this class.
  static const type = $EmojiCompatType();
  static final _id_EDITOR_INFO_METAVERSION_KEY = _class.staticFieldId(
    r'EDITOR_INFO_METAVERSION_KEY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EDITOR_INFO_METAVERSION_KEY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EDITOR_INFO_METAVERSION_KEY =>
      _id_EDITOR_INFO_METAVERSION_KEY.get(_class, const jni.JStringType());

  static final _id_EDITOR_INFO_REPLACE_ALL_KEY = _class.staticFieldId(
    r'EDITOR_INFO_REPLACE_ALL_KEY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EDITOR_INFO_REPLACE_ALL_KEY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get EDITOR_INFO_REPLACE_ALL_KEY =>
      _id_EDITOR_INFO_REPLACE_ALL_KEY.get(_class, const jni.JStringType());

  /// from: `static public final int LOAD_STATE_DEFAULT`
  static const LOAD_STATE_DEFAULT = 3;

  /// from: `static public final int LOAD_STATE_LOADING`
  static const LOAD_STATE_LOADING = 0;

  /// from: `static public final int LOAD_STATE_SUCCEEDED`
  static const LOAD_STATE_SUCCEEDED = 1;

  /// from: `static public final int LOAD_STATE_FAILED`
  static const LOAD_STATE_FAILED = 2;

  /// from: `static public final int REPLACE_STRATEGY_DEFAULT`
  static const REPLACE_STRATEGY_DEFAULT = 0;

  /// from: `static public final int REPLACE_STRATEGY_ALL`
  static const REPLACE_STRATEGY_ALL = 1;

  /// from: `static public final int REPLACE_STRATEGY_NON_EXISTENT`
  static const REPLACE_STRATEGY_NON_EXISTENT = 2;

  /// from: `static public final int LOAD_STRATEGY_DEFAULT`
  static const LOAD_STRATEGY_DEFAULT = 0;

  /// from: `static public final int LOAD_STRATEGY_MANUAL`
  static const LOAD_STRATEGY_MANUAL = 1;

  /// from: `static public final int EMOJI_UNSUPPORTED`
  static const EMOJI_UNSUPPORTED = 0;

  /// from: `static public final int EMOJI_SUPPORTED`
  static const EMOJI_SUPPORTED = 1;

  /// from: `static public final int EMOJI_FALLBACK`
  static const EMOJI_FALLBACK = 2;
  static final _id_init = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _init = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat init(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat init(
    jni.JObject context,
  ) {
    return _init(_class.reference.pointer, _id_init as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const $EmojiCompatType());
  }

  static final _id_init$1 = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _init$1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat init(android.content.Context context, androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory defaultEmojiCompatConfigFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat init$1(
    jni.JObject context,
    DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory
        defaultEmojiCompatConfigFactory,
  ) {
    return _init$1(
            _class.reference.pointer,
            _id_init$1 as jni.JMethodIDPtr,
            context.reference.pointer,
            defaultEmojiCompatConfigFactory.reference.pointer)
        .object(const $EmojiCompatType());
  }

  static final _id_init$2 = _class.staticMethodId(
    r'init',
    r'(Landroidx/emoji2/text/EmojiCompat$Config;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _init$2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat init(androidx.emoji2.text.EmojiCompat$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat init$2(
    EmojiCompat_Config config,
  ) {
    return _init$2(_class.reference.pointer, _id_init$2 as jni.JMethodIDPtr,
            config.reference.pointer)
        .object(const $EmojiCompatType());
  }

  static final _id_isConfigured = _class.staticMethodId(
    r'isConfigured',
    r'()Z',
  );

  static final _isConfigured = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public boolean isConfigured()`
  static bool isConfigured() {
    return _isConfigured(
            _class.reference.pointer, _id_isConfigured as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_reset = _class.staticMethodId(
    r'reset',
    r'(Landroidx/emoji2/text/EmojiCompat$Config;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _reset = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat reset(androidx.emoji2.text.EmojiCompat$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat reset(
    EmojiCompat_Config config,
  ) {
    return _reset(_class.reference.pointer, _id_reset as jni.JMethodIDPtr,
            config.reference.pointer)
        .object(const $EmojiCompatType());
  }

  static final _id_reset$1 = _class.staticMethodId(
    r'reset',
    r'(Landroidx/emoji2/text/EmojiCompat;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _reset$1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat reset(androidx.emoji2.text.EmojiCompat emojiCompat)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat reset$1(
    EmojiCompat emojiCompat,
  ) {
    return _reset$1(_class.reference.pointer, _id_reset$1 as jni.JMethodIDPtr,
            emojiCompat.reference.pointer)
        .object(const $EmojiCompatType());
  }

  static final _id_skipDefaultConfigurationLookup = _class.staticMethodId(
    r'skipDefaultConfigurationLookup',
    r'(Z)V',
  );

  static final _skipDefaultConfigurationLookup = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `static public void skipDefaultConfigurationLookup(boolean z)`
  static void skipDefaultConfigurationLookup(
    bool z,
  ) {
    _skipDefaultConfigurationLookup(_class.reference.pointer,
            _id_skipDefaultConfigurationLookup as jni.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_get$ = _class.staticMethodId(
    r'get',
    r'()Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _get$ = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public androidx.emoji2.text.EmojiCompat get()`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat get$() {
    return _get$(_class.reference.pointer, _id_get$ as jni.JMethodIDPtr)
        .object(const $EmojiCompatType());
  }

  static final _id_load = _class.instanceMethodId(
    r'load',
    r'()V',
  );

  static final _load = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void load()`
  void load() {
    _load(reference.pointer, _id_load as jni.JMethodIDPtr).check();
  }

  static final _id_registerInitCallback = _class.instanceMethodId(
    r'registerInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)V',
  );

  static final _registerInitCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void registerInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  void registerInitCallback(
    EmojiCompat_InitCallback initCallback,
  ) {
    _registerInitCallback(
            reference.pointer,
            _id_registerInitCallback as jni.JMethodIDPtr,
            initCallback.reference.pointer)
        .check();
  }

  static final _id_unregisterInitCallback = _class.instanceMethodId(
    r'unregisterInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)V',
  );

  static final _unregisterInitCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void unregisterInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  void unregisterInitCallback(
    EmojiCompat_InitCallback initCallback,
  ) {
    _unregisterInitCallback(
            reference.pointer,
            _id_unregisterInitCallback as jni.JMethodIDPtr,
            initCallback.reference.pointer)
        .check();
  }

  static final _id_getLoadState = _class.instanceMethodId(
    r'getLoadState',
    r'()I',
  );

  static final _getLoadState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getLoadState()`
  int getLoadState() {
    return _getLoadState(
            reference.pointer, _id_getLoadState as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_isEmojiSpanIndicatorEnabled = _class.instanceMethodId(
    r'isEmojiSpanIndicatorEnabled',
    r'()Z',
  );

  static final _isEmojiSpanIndicatorEnabled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean isEmojiSpanIndicatorEnabled()`
  bool isEmojiSpanIndicatorEnabled() {
    return _isEmojiSpanIndicatorEnabled(reference.pointer,
            _id_isEmojiSpanIndicatorEnabled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getEmojiSpanIndicatorColor = _class.instanceMethodId(
    r'getEmojiSpanIndicatorColor',
    r'()I',
  );

  static final _getEmojiSpanIndicatorColor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getEmojiSpanIndicatorColor()`
  int getEmojiSpanIndicatorColor() {
    return _getEmojiSpanIndicatorColor(reference.pointer,
            _id_getEmojiSpanIndicatorColor as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getEmojiStart = _class.instanceMethodId(
    r'getEmojiStart',
    r'(Ljava/lang/CharSequence;I)I',
  );

  static final _getEmojiStart = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: `public int getEmojiStart(java.lang.CharSequence charSequence, int i)`
  int getEmojiStart(
    jni.JObject charSequence,
    int i,
  ) {
    return _getEmojiStart(
            reference.pointer,
            _id_getEmojiStart as jni.JMethodIDPtr,
            charSequence.reference.pointer,
            i)
        .integer;
  }

  static final _id_getEmojiEnd = _class.instanceMethodId(
    r'getEmojiEnd',
    r'(Ljava/lang/CharSequence;I)I',
  );

  static final _getEmojiEnd = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: `public int getEmojiEnd(java.lang.CharSequence charSequence, int i)`
  int getEmojiEnd(
    jni.JObject charSequence,
    int i,
  ) {
    return _getEmojiEnd(reference.pointer, _id_getEmojiEnd as jni.JMethodIDPtr,
            charSequence.reference.pointer, i)
        .integer;
  }

  static final _id_handleOnKeyDown = _class.staticMethodId(
    r'handleOnKeyDown',
    r'(Landroid/text/Editable;ILandroid/view/KeyEvent;)Z',
  );

  static final _handleOnKeyDown = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: `static public boolean handleOnKeyDown(android.text.Editable editable, int i, android.view.KeyEvent keyEvent)`
  static bool handleOnKeyDown(
    jni.JObject editable,
    int i,
    jni.JObject keyEvent,
  ) {
    return _handleOnKeyDown(
            _class.reference.pointer,
            _id_handleOnKeyDown as jni.JMethodIDPtr,
            editable.reference.pointer,
            i,
            keyEvent.reference.pointer)
        .boolean;
  }

  static final _id_handleDeleteSurroundingText = _class.staticMethodId(
    r'handleDeleteSurroundingText',
    r'(Landroid/view/inputmethod/InputConnection;Landroid/text/Editable;IIZ)Z',
  );

  static final _handleDeleteSurroundingText = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: `static public boolean handleDeleteSurroundingText(android.view.inputmethod.InputConnection inputConnection, android.text.Editable editable, int i, int i1, boolean z)`
  static bool handleDeleteSurroundingText(
    jni.JObject inputConnection,
    jni.JObject editable,
    int i,
    int i1,
    bool z,
  ) {
    return _handleDeleteSurroundingText(
            _class.reference.pointer,
            _id_handleDeleteSurroundingText as jni.JMethodIDPtr,
            inputConnection.reference.pointer,
            editable.reference.pointer,
            i,
            i1,
            z ? 1 : 0)
        .boolean;
  }

  static final _id_hasEmojiGlyph = _class.instanceMethodId(
    r'hasEmojiGlyph',
    r'(Ljava/lang/CharSequence;)Z',
  );

  static final _hasEmojiGlyph = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public boolean hasEmojiGlyph(java.lang.CharSequence charSequence)`
  bool hasEmojiGlyph(
    jni.JObject charSequence,
  ) {
    return _hasEmojiGlyph(
            reference.pointer,
            _id_hasEmojiGlyph as jni.JMethodIDPtr,
            charSequence.reference.pointer)
        .boolean;
  }

  static final _id_hasEmojiGlyph$1 = _class.instanceMethodId(
    r'hasEmojiGlyph',
    r'(Ljava/lang/CharSequence;I)Z',
  );

  static final _hasEmojiGlyph$1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: `public boolean hasEmojiGlyph(java.lang.CharSequence charSequence, int i)`
  bool hasEmojiGlyph$1(
    jni.JObject charSequence,
    int i,
  ) {
    return _hasEmojiGlyph$1(
            reference.pointer,
            _id_hasEmojiGlyph$1 as jni.JMethodIDPtr,
            charSequence.reference.pointer,
            i)
        .boolean;
  }

  static final _id_getEmojiMatch = _class.instanceMethodId(
    r'getEmojiMatch',
    r'(Ljava/lang/CharSequence;I)I',
  );

  static final _getEmojiMatch = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: `public int getEmojiMatch(java.lang.CharSequence charSequence, int i)`
  int getEmojiMatch(
    jni.JObject charSequence,
    int i,
  ) {
    return _getEmojiMatch(
            reference.pointer,
            _id_getEmojiMatch as jni.JMethodIDPtr,
            charSequence.reference.pointer,
            i)
        .integer;
  }

  static final _id_process = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;)Ljava/lang/CharSequence;',
  );

  static final _process = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject process(
    jni.JObject charSequence,
  ) {
    return _process(reference.pointer, _id_process as jni.JMethodIDPtr,
            charSequence.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_process$1 = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;II)Ljava/lang/CharSequence;',
  );

  static final _process$1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32, $Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject process$1(
    jni.JObject charSequence,
    int i,
    int i1,
  ) {
    return _process$1(reference.pointer, _id_process$1 as jni.JMethodIDPtr,
            charSequence.reference.pointer, i, i1)
        .object(const jni.JObjectType());
  }

  static final _id_process$2 = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;III)Ljava/lang/CharSequence;',
  );

  static final _process$2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence, int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject process$2(
    jni.JObject charSequence,
    int i,
    int i1,
    int i2,
  ) {
    return _process$2(reference.pointer, _id_process$2 as jni.JMethodIDPtr,
            charSequence.reference.pointer, i, i1, i2)
        .object(const jni.JObjectType());
  }

  static final _id_process$3 = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;IIII)Ljava/lang/CharSequence;',
  );

  static final _process$3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence, int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject process$3(
    jni.JObject charSequence,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _process$3(reference.pointer, _id_process$3 as jni.JMethodIDPtr,
            charSequence.reference.pointer, i, i1, i2, i3)
        .object(const jni.JObjectType());
  }

  static final _id_getAssetSignature = _class.instanceMethodId(
    r'getAssetSignature',
    r'()Ljava/lang/String;',
  );

  static final _getAssetSignature = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getAssetSignature()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAssetSignature() {
    return _getAssetSignature(
            reference.pointer, _id_getAssetSignature as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_updateEditorInfo = _class.instanceMethodId(
    r'updateEditorInfo',
    r'(Landroid/view/inputmethod/EditorInfo;)V',
  );

  static final _updateEditorInfo = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void updateEditorInfo(android.view.inputmethod.EditorInfo editorInfo)`
  void updateEditorInfo(
    jni.JObject editorInfo,
  ) {
    _updateEditorInfo(
            reference.pointer,
            _id_updateEditorInfo as jni.JMethodIDPtr,
            editorInfo.reference.pointer)
        .check();
  }
}

final class $EmojiCompatType extends jni.JObjType<EmojiCompat> {
  const $EmojiCompatType();

  @override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat;';

  @override
  EmojiCompat fromReference(jni.JReference reference) =>
      EmojiCompat.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($EmojiCompatType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompatType) && other is $EmojiCompatType;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory`
class DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory
    extends jni.JObject {
  @override
  late final jni
      .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory>
      $type = type;

  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory');

  /// The type which includes information such as the signature of this class.
  static const type =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactoryType();
  static final _id_new$ = _class.constructorId(
    r'(Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper;)V',
  );

  static final _new$ = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper defaultEmojiCompatConfigHelper)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory(
    DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper
        defaultEmojiCompatConfigHelper,
  ) {
    return DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory
        .fromReference(_new$(
                _class.reference.pointer,
                _id_new$ as jni.JMethodIDPtr,
                defaultEmojiCompatConfigHelper.reference.pointer)
            .reference);
  }

  static final _id_create = _class.instanceMethodId(
    r'create',
    r'(Landroid/content/Context;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _create = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config create(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config create(
    jni.JObject context,
  ) {
    return _create(reference.pointer, _id_create as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const $EmojiCompat_ConfigType());
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactoryType
    extends jni
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory> {
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactoryType();

  @override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory;';

  @override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory fromReference(
          jni.JReference reference) =>
      DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory.fromReference(
          reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactoryType) &&
        other is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactoryType;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper`
class DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper
    extends jni.JObject {
  @override
  late final jni
      .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper> $type =
      type;

  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper');

  /// The type which includes information such as the signature of this class.
  static const type =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelperType();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper() {
    return DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper
        .fromReference(
            _new$(_class.reference.pointer, _id_new$ as jni.JMethodIDPtr)
                .reference);
  }

  static final _id_getSigningSignatures = _class.instanceMethodId(
    r'getSigningSignatures',
    r'(Landroid/content/pm/PackageManager;Ljava/lang/String;)[Landroid/content/pm/Signature;',
  );

  static final _getSigningSignatures = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public android.content.pm.Signature[] getSigningSignatures(android.content.pm.PackageManager packageManager, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JObject> getSigningSignatures(
    jni.JObject packageManager,
    jni.JString string,
  ) {
    return _getSigningSignatures(
            reference.pointer,
            _id_getSigningSignatures as jni.JMethodIDPtr,
            packageManager.reference.pointer,
            string.reference.pointer)
        .object(const jni.JArrayType(jni.JObjectType()));
  }

  static final _id_queryIntentContentProviders = _class.instanceMethodId(
    r'queryIntentContentProviders',
    r'(Landroid/content/pm/PackageManager;Landroid/content/Intent;I)Ljava/util/List;',
  );

  static final _queryIntentContentProviders = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: `public java.util.List queryIntentContentProviders(android.content.pm.PackageManager packageManager, android.content.Intent intent, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> queryIntentContentProviders(
    jni.JObject packageManager,
    jni.JObject intent,
    int i,
  ) {
    return _queryIntentContentProviders(
            reference.pointer,
            _id_queryIntentContentProviders as jni.JMethodIDPtr,
            packageManager.reference.pointer,
            intent.reference.pointer,
            i)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_getProviderInfo = _class.instanceMethodId(
    r'getProviderInfo',
    r'(Landroid/content/pm/ResolveInfo;)Landroid/content/pm/ProviderInfo;',
  );

  static final _getProviderInfo = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public android.content.pm.ProviderInfo getProviderInfo(android.content.pm.ResolveInfo resolveInfo)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getProviderInfo(
    jni.JObject resolveInfo,
  ) {
    return _getProviderInfo(
            reference.pointer,
            _id_getProviderInfo as jni.JMethodIDPtr,
            resolveInfo.reference.pointer)
        .object(const jni.JObjectType());
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelperType
    extends jni
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper> {
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelperType();

  @override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper;';

  @override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper fromReference(
          jni.JReference reference) =>
      DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper.fromReference(
          reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelperType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelperType) &&
        other is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelperType;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19`
class DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19
    extends DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper {
  @override
  late final jni
      .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19>
      $type = type;

  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19');

  /// The type which includes information such as the signature of this class.
  static const type =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19() {
    return DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19
        .fromReference(
            _new$(_class.reference.pointer, _id_new$ as jni.JMethodIDPtr)
                .reference);
  }

  static final _id_queryIntentContentProviders = _class.instanceMethodId(
    r'queryIntentContentProviders',
    r'(Landroid/content/pm/PackageManager;Landroid/content/Intent;I)Ljava/util/List;',
  );

  static final _queryIntentContentProviders = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: `public java.util.List queryIntentContentProviders(android.content.pm.PackageManager packageManager, android.content.Intent intent, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> queryIntentContentProviders(
    jni.JObject packageManager,
    jni.JObject intent,
    int i,
  ) {
    return _queryIntentContentProviders(
            reference.pointer,
            _id_queryIntentContentProviders as jni.JMethodIDPtr,
            packageManager.reference.pointer,
            intent.reference.pointer,
            i)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_getProviderInfo = _class.instanceMethodId(
    r'getProviderInfo',
    r'(Landroid/content/pm/ResolveInfo;)Landroid/content/pm/ProviderInfo;',
  );

  static final _getProviderInfo = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public android.content.pm.ProviderInfo getProviderInfo(android.content.pm.ResolveInfo resolveInfo)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getProviderInfo(
    jni.JObject resolveInfo,
  ) {
    return _getProviderInfo(
            reference.pointer,
            _id_getProviderInfo as jni.JMethodIDPtr,
            resolveInfo.reference.pointer)
        .object(const jni.JObjectType());
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19Type
    extends jni
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19> {
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19Type();

  @override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19;';

  @override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19 fromReference(
          jni.JReference reference) =>
      DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19
          .fromReference(reference);

  @override
  jni.JObjType get superType =>
      const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelperType();

  @override
  final superCount = 2;

  @override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19Type)
          .hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19Type) &&
        other
            is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19Type;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28`
class DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28
    extends DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19 {
  @override
  late final jni
      .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28>
      $type = type;

  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28');

  /// The type which includes information such as the signature of this class.
  static const type =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28() {
    return DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28
        .fromReference(
            _new$(_class.reference.pointer, _id_new$ as jni.JMethodIDPtr)
                .reference);
  }

  static final _id_getSigningSignatures$1 = _class.instanceMethodId(
    r'getSigningSignatures',
    r'(Landroid/content/pm/PackageManager;Ljava/lang/String;)[Landroid/content/pm/Signature;',
  );

  static final _getSigningSignatures$1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public android.content.pm.Signature[] getSigningSignatures(android.content.pm.PackageManager packageManager, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JObject> getSigningSignatures$1(
    jni.JObject packageManager,
    jni.JString string,
  ) {
    return _getSigningSignatures$1(
            reference.pointer,
            _id_getSigningSignatures$1 as jni.JMethodIDPtr,
            packageManager.reference.pointer,
            string.reference.pointer)
        .object(const jni.JArrayType(jni.JObjectType()));
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28Type
    extends jni
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28> {
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28Type();

  @override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28;';

  @override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28 fromReference(
          jni.JReference reference) =>
      DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28
          .fromReference(reference);

  @override
  jni.JObjType get superType =>
      const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19Type();

  @override
  final superCount = 3;

  @override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28Type)
          .hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28Type) &&
        other
            is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28Type;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig`
class DefaultEmojiCompatConfig extends jni.JObject {
  @override
  late final jni.JObjType<DefaultEmojiCompatConfig> $type = type;

  DefaultEmojiCompatConfig.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'androidx/emoji2/text/DefaultEmojiCompatConfig');

  /// The type which includes information such as the signature of this class.
  static const type = $DefaultEmojiCompatConfigType();
  static final _id_create = _class.staticMethodId(
    r'create',
    r'(Landroid/content/Context;)Landroidx/emoji2/text/FontRequestEmojiCompatConfig;',
  );

  static final _create = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `static public androidx.emoji2.text.FontRequestEmojiCompatConfig create(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject create(
    jni.JObject context,
  ) {
    return _create(_class.reference.pointer, _id_create as jni.JMethodIDPtr,
            context.reference.pointer)
        .object(const jni.JObjectType());
  }
}

final class $DefaultEmojiCompatConfigType
    extends jni.JObjType<DefaultEmojiCompatConfig> {
  const $DefaultEmojiCompatConfigType();

  @override
  String get signature => r'Landroidx/emoji2/text/DefaultEmojiCompatConfig;';

  @override
  DefaultEmojiCompatConfig fromReference(jni.JReference reference) =>
      DefaultEmojiCompatConfig.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($DefaultEmojiCompatConfigType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($DefaultEmojiCompatConfigType) &&
        other is $DefaultEmojiCompatConfigType;
  }
}

/// from: `android.os.Build$Partition`
class Build_Partition extends jni.JObject {
  @override
  late final jni.JObjType<Build_Partition> $type = type;

  Build_Partition.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/os/Build$Partition');

  /// The type which includes information such as the signature of this class.
  static const type = $Build_PartitionType();
  static final _id_PARTITION_NAME_SYSTEM = _class.staticFieldId(
    r'PARTITION_NAME_SYSTEM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PARTITION_NAME_SYSTEM`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PARTITION_NAME_SYSTEM =>
      _id_PARTITION_NAME_SYSTEM.get(_class, const jni.JStringType());

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getName() {
    return _getName(reference.pointer, _id_getName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getFingerprint = _class.instanceMethodId(
    r'getFingerprint',
    r'()Ljava/lang/String;',
  );

  static final _getFingerprint = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getFingerprint()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFingerprint() {
    return _getFingerprint(
            reference.pointer, _id_getFingerprint as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getBuildTimeMillis = _class.instanceMethodId(
    r'getBuildTimeMillis',
    r'()J',
  );

  static final _getBuildTimeMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public long getBuildTimeMillis()`
  int getBuildTimeMillis() {
    return _getBuildTimeMillis(
            reference.pointer, _id_getBuildTimeMillis as jni.JMethodIDPtr)
        .long;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, _id_equals as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni.JMethodIDPtr)
        .integer;
  }
}

final class $Build_PartitionType extends jni.JObjType<Build_Partition> {
  const $Build_PartitionType();

  @override
  String get signature => r'Landroid/os/Build$Partition;';

  @override
  Build_Partition fromReference(jni.JReference reference) =>
      Build_Partition.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Build_PartitionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_PartitionType) &&
        other is $Build_PartitionType;
  }
}

/// from: `android.os.Build$VERSION`
class Build_VERSION extends jni.JObject {
  @override
  late final jni.JObjType<Build_VERSION> $type = type;

  Build_VERSION.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/os/Build$VERSION');

  /// The type which includes information such as the signature of this class.
  static const type = $Build_VERSIONType();
  static final _id_BASE_OS = _class.staticFieldId(
    r'BASE_OS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BASE_OS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BASE_OS =>
      _id_BASE_OS.get(_class, const jni.JStringType());

  static final _id_CODENAME = _class.staticFieldId(
    r'CODENAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CODENAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CODENAME =>
      _id_CODENAME.get(_class, const jni.JStringType());

  static final _id_INCREMENTAL = _class.staticFieldId(
    r'INCREMENTAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String INCREMENTAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INCREMENTAL =>
      _id_INCREMENTAL.get(_class, const jni.JStringType());

  static final _id_MEDIA_PERFORMANCE_CLASS = _class.staticFieldId(
    r'MEDIA_PERFORMANCE_CLASS',
    r'I',
  );

  /// from: `static public final int MEDIA_PERFORMANCE_CLASS`
  static int get MEDIA_PERFORMANCE_CLASS =>
      _id_MEDIA_PERFORMANCE_CLASS.get(_class, const jni.jintType());

  static final _id_PREVIEW_SDK_INT = _class.staticFieldId(
    r'PREVIEW_SDK_INT',
    r'I',
  );

  /// from: `static public final int PREVIEW_SDK_INT`
  static int get PREVIEW_SDK_INT =>
      _id_PREVIEW_SDK_INT.get(_class, const jni.jintType());

  static final _id_RELEASE = _class.staticFieldId(
    r'RELEASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RELEASE =>
      _id_RELEASE.get(_class, const jni.JStringType());

  static final _id_RELEASE_OR_CODENAME = _class.staticFieldId(
    r'RELEASE_OR_CODENAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE_OR_CODENAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RELEASE_OR_CODENAME =>
      _id_RELEASE_OR_CODENAME.get(_class, const jni.JStringType());

  static final _id_RELEASE_OR_PREVIEW_DISPLAY = _class.staticFieldId(
    r'RELEASE_OR_PREVIEW_DISPLAY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE_OR_PREVIEW_DISPLAY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RELEASE_OR_PREVIEW_DISPLAY =>
      _id_RELEASE_OR_PREVIEW_DISPLAY.get(_class, const jni.JStringType());

  static final _id_SDK = _class.staticFieldId(
    r'SDK',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SDK`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SDK => _id_SDK.get(_class, const jni.JStringType());

  static final _id_SDK_INT = _class.staticFieldId(
    r'SDK_INT',
    r'I',
  );

  /// from: `static public final int SDK_INT`
  static int get SDK_INT => _id_SDK_INT.get(_class, const jni.jintType());

  static final _id_SECURITY_PATCH = _class.staticFieldId(
    r'SECURITY_PATCH',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SECURITY_PATCH`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SECURITY_PATCH =>
      _id_SECURITY_PATCH.get(_class, const jni.JStringType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build_VERSION() {
    return Build_VERSION.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni.JMethodIDPtr)
            .reference);
  }
}

final class $Build_VERSIONType extends jni.JObjType<Build_VERSION> {
  const $Build_VERSIONType();

  @override
  String get signature => r'Landroid/os/Build$VERSION;';

  @override
  Build_VERSION fromReference(jni.JReference reference) =>
      Build_VERSION.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Build_VERSIONType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_VERSIONType) &&
        other is $Build_VERSIONType;
  }
}

/// from: `android.os.Build$VERSION_CODES`
class Build_VERSION_CODES extends jni.JObject {
  @override
  late final jni.JObjType<Build_VERSION_CODES> $type = type;

  Build_VERSION_CODES.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/os/Build$VERSION_CODES');

  /// The type which includes information such as the signature of this class.
  static const type = $Build_VERSION_CODESType();

  /// from: `static public final int BASE`
  static const BASE = 1;

  /// from: `static public final int BASE_1_1`
  static const BASE_1_1 = 2;

  /// from: `static public final int CUPCAKE`
  static const CUPCAKE = 3;

  /// from: `static public final int CUR_DEVELOPMENT`
  static const CUR_DEVELOPMENT = 10000;

  /// from: `static public final int DONUT`
  static const DONUT = 4;

  /// from: `static public final int ECLAIR`
  static const ECLAIR = 5;

  /// from: `static public final int ECLAIR_0_1`
  static const ECLAIR_0_1 = 6;

  /// from: `static public final int ECLAIR_MR1`
  static const ECLAIR_MR1 = 7;

  /// from: `static public final int FROYO`
  static const FROYO = 8;

  /// from: `static public final int GINGERBREAD`
  static const GINGERBREAD = 9;

  /// from: `static public final int GINGERBREAD_MR1`
  static const GINGERBREAD_MR1 = 10;

  /// from: `static public final int HONEYCOMB`
  static const HONEYCOMB = 11;

  /// from: `static public final int HONEYCOMB_MR1`
  static const HONEYCOMB_MR1 = 12;

  /// from: `static public final int HONEYCOMB_MR2`
  static const HONEYCOMB_MR2 = 13;

  /// from: `static public final int ICE_CREAM_SANDWICH`
  static const ICE_CREAM_SANDWICH = 14;

  /// from: `static public final int ICE_CREAM_SANDWICH_MR1`
  static const ICE_CREAM_SANDWICH_MR1 = 15;

  /// from: `static public final int JELLY_BEAN`
  static const JELLY_BEAN = 16;

  /// from: `static public final int JELLY_BEAN_MR1`
  static const JELLY_BEAN_MR1 = 17;

  /// from: `static public final int JELLY_BEAN_MR2`
  static const JELLY_BEAN_MR2 = 18;

  /// from: `static public final int KITKAT`
  static const KITKAT = 19;

  /// from: `static public final int KITKAT_WATCH`
  static const KITKAT_WATCH = 20;

  /// from: `static public final int LOLLIPOP`
  static const LOLLIPOP = 21;

  /// from: `static public final int LOLLIPOP_MR1`
  static const LOLLIPOP_MR1 = 22;

  /// from: `static public final int M`
  static const M = 23;

  /// from: `static public final int N`
  static const N = 24;

  /// from: `static public final int N_MR1`
  static const N_MR1 = 25;

  /// from: `static public final int O`
  static const O = 26;

  /// from: `static public final int O_MR1`
  static const O_MR1 = 27;

  /// from: `static public final int P`
  static const P = 28;

  /// from: `static public final int Q`
  static const Q = 29;

  /// from: `static public final int R`
  static const R = 30;

  /// from: `static public final int S`
  static const S = 31;

  /// from: `static public final int S_V2`
  static const S_V2 = 32;

  /// from: `static public final int TIRAMISU`
  static const TIRAMISU = 33;

  /// from: `static public final int UPSIDE_DOWN_CAKE`
  static const UPSIDE_DOWN_CAKE = 34;
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build_VERSION_CODES() {
    return Build_VERSION_CODES.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni.JMethodIDPtr)
            .reference);
  }
}

final class $Build_VERSION_CODESType extends jni.JObjType<Build_VERSION_CODES> {
  const $Build_VERSION_CODESType();

  @override
  String get signature => r'Landroid/os/Build$VERSION_CODES;';

  @override
  Build_VERSION_CODES fromReference(jni.JReference reference) =>
      Build_VERSION_CODES.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Build_VERSION_CODESType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_VERSION_CODESType) &&
        other is $Build_VERSION_CODESType;
  }
}

/// from: `android.os.Build`
class Build extends jni.JObject {
  @override
  late final jni.JObjType<Build> $type = type;

  Build.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/os/Build');

  /// The type which includes information such as the signature of this class.
  static const type = $BuildType();
  static final _id_BOARD = _class.staticFieldId(
    r'BOARD',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BOARD`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BOARD =>
      _id_BOARD.get(_class, const jni.JStringType());

  static final _id_BOOTLOADER = _class.staticFieldId(
    r'BOOTLOADER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BOOTLOADER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BOOTLOADER =>
      _id_BOOTLOADER.get(_class, const jni.JStringType());

  static final _id_BRAND = _class.staticFieldId(
    r'BRAND',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BRAND`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BRAND =>
      _id_BRAND.get(_class, const jni.JStringType());

  static final _id_CPU_ABI = _class.staticFieldId(
    r'CPU_ABI',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CPU_ABI`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CPU_ABI =>
      _id_CPU_ABI.get(_class, const jni.JStringType());

  static final _id_CPU_ABI2 = _class.staticFieldId(
    r'CPU_ABI2',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CPU_ABI2`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CPU_ABI2 =>
      _id_CPU_ABI2.get(_class, const jni.JStringType());

  static final _id_DEVICE = _class.staticFieldId(
    r'DEVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEVICE =>
      _id_DEVICE.get(_class, const jni.JStringType());

  static final _id_DISPLAY = _class.staticFieldId(
    r'DISPLAY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DISPLAY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DISPLAY =>
      _id_DISPLAY.get(_class, const jni.JStringType());

  static final _id_FINGERPRINT = _class.staticFieldId(
    r'FINGERPRINT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FINGERPRINT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FINGERPRINT =>
      _id_FINGERPRINT.get(_class, const jni.JStringType());

  static final _id_HARDWARE = _class.staticFieldId(
    r'HARDWARE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HARDWARE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HARDWARE =>
      _id_HARDWARE.get(_class, const jni.JStringType());

  static final _id_HOST = _class.staticFieldId(
    r'HOST',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HOST`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HOST => _id_HOST.get(_class, const jni.JStringType());

  static final _id_ID = _class.staticFieldId(
    r'ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ID => _id_ID.get(_class, const jni.JStringType());

  static final _id_MANUFACTURER = _class.staticFieldId(
    r'MANUFACTURER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MANUFACTURER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANUFACTURER =>
      _id_MANUFACTURER.get(_class, const jni.JStringType());

  static final _id_MODEL = _class.staticFieldId(
    r'MODEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MODEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MODEL =>
      _id_MODEL.get(_class, const jni.JStringType());

  static final _id_ODM_SKU = _class.staticFieldId(
    r'ODM_SKU',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ODM_SKU`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ODM_SKU =>
      _id_ODM_SKU.get(_class, const jni.JStringType());

  static final _id_PRODUCT = _class.staticFieldId(
    r'PRODUCT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PRODUCT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PRODUCT =>
      _id_PRODUCT.get(_class, const jni.JStringType());

  static final _id_RADIO = _class.staticFieldId(
    r'RADIO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RADIO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RADIO =>
      _id_RADIO.get(_class, const jni.JStringType());

  static final _id_SERIAL = _class.staticFieldId(
    r'SERIAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SERIAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SERIAL =>
      _id_SERIAL.get(_class, const jni.JStringType());

  static final _id_SKU = _class.staticFieldId(
    r'SKU',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SKU`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SKU => _id_SKU.get(_class, const jni.JStringType());

  static final _id_SOC_MANUFACTURER = _class.staticFieldId(
    r'SOC_MANUFACTURER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SOC_MANUFACTURER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SOC_MANUFACTURER =>
      _id_SOC_MANUFACTURER.get(_class, const jni.JStringType());

  static final _id_SOC_MODEL = _class.staticFieldId(
    r'SOC_MODEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SOC_MODEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SOC_MODEL =>
      _id_SOC_MODEL.get(_class, const jni.JStringType());

  static final _id_SUPPORTED_32_BIT_ABIS = _class.staticFieldId(
    r'SUPPORTED_32_BIT_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_32_BIT_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JString> get SUPPORTED_32_BIT_ABIS =>
      _id_SUPPORTED_32_BIT_ABIS.get(
          _class, const jni.JArrayType(jni.JStringType()));

  static final _id_SUPPORTED_64_BIT_ABIS = _class.staticFieldId(
    r'SUPPORTED_64_BIT_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_64_BIT_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JString> get SUPPORTED_64_BIT_ABIS =>
      _id_SUPPORTED_64_BIT_ABIS.get(
          _class, const jni.JArrayType(jni.JStringType()));

  static final _id_SUPPORTED_ABIS = _class.staticFieldId(
    r'SUPPORTED_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JString> get SUPPORTED_ABIS =>
      _id_SUPPORTED_ABIS.get(_class, const jni.JArrayType(jni.JStringType()));

  static final _id_TAGS = _class.staticFieldId(
    r'TAGS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TAGS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TAGS => _id_TAGS.get(_class, const jni.JStringType());

  static final _id_TIME = _class.staticFieldId(
    r'TIME',
    r'J',
  );

  /// from: `static public final long TIME`
  static int get TIME => _id_TIME.get(_class, const jni.jlongType());

  static final _id_TYPE = _class.staticFieldId(
    r'TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TYPE => _id_TYPE.get(_class, const jni.JStringType());

  static final _id_UNKNOWN = _class.staticFieldId(
    r'UNKNOWN',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String UNKNOWN`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get UNKNOWN =>
      _id_UNKNOWN.get(_class, const jni.JStringType());

  static final _id_USER = _class.staticFieldId(
    r'USER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get USER => _id_USER.get(_class, const jni.JStringType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build() {
    return Build.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getSerial = _class.staticMethodId(
    r'getSerial',
    r'()Ljava/lang/String;',
  );

  static final _getSerial = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String getSerial()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getSerial() {
    return _getSerial(
            _class.reference.pointer, _id_getSerial as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getFingerprintedPartitions = _class.staticMethodId(
    r'getFingerprintedPartitions',
    r'()Ljava/util/List;',
  );

  static final _getFingerprintedPartitions = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public java.util.List getFingerprintedPartitions()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JList<Build_Partition> getFingerprintedPartitions() {
    return _getFingerprintedPartitions(_class.reference.pointer,
            _id_getFingerprintedPartitions as jni.JMethodIDPtr)
        .object(const jni.JListType($Build_PartitionType()));
  }

  static final _id_getRadioVersion = _class.staticMethodId(
    r'getRadioVersion',
    r'()Ljava/lang/String;',
  );

  static final _getRadioVersion = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String getRadioVersion()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getRadioVersion() {
    return _getRadioVersion(
            _class.reference.pointer, _id_getRadioVersion as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }
}

final class $BuildType extends jni.JObjType<Build> {
  const $BuildType();

  @override
  String get signature => r'Landroid/os/Build;';

  @override
  Build fromReference(jni.JReference reference) =>
      Build.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BuildType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BuildType) && other is $BuildType;
  }
}

/// from: `java.util.HashMap`
class HashMap<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObject {
  @override
  late final jni.JObjType<HashMap<$K, $V>> $type = type(K, V);

  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  HashMap.fromReference(
    this.K,
    this.V,
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'java/util/HashMap');

  /// The type which includes information such as the signature of this class.
  static $HashMapType<$K, $V>
      type<$K extends jni.JObject, $V extends jni.JObject>(
    jni.JObjType<$K> K,
    jni.JObjType<$V> V,
  ) {
    return $HashMapType(
      K,
      V,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'(IF)V',
  );

  static final _new$ = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, ffi.Double)>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, double)>();

  /// from: `public void <init>(int i, float f)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap(
    int i,
    double f, {
    required jni.JObjType<$K> K,
    required jni.JObjType<$V> V,
  }) {
    return HashMap.fromReference(
        K,
        V,
        _new$(_class.reference.pointer, _id_new$ as jni.JMethodIDPtr, i, f)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(I)V',
  );

  static final _new$1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$1(
    int i, {
    required jni.JObjType<$K> K,
    required jni.JObjType<$V> V,
  }) {
    return HashMap.fromReference(
        K,
        V,
        _new$1(_class.reference.pointer, _id_new$1 as jni.JMethodIDPtr, i)
            .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'()V',
  );

  static final _new$2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$2({
    required jni.JObjType<$K> K,
    required jni.JObjType<$V> V,
  }) {
    return HashMap.fromReference(
        K,
        V,
        _new$2(_class.reference.pointer, _id_new$2 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/util/Map;)V',
  );

  static final _new$3 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void <init>(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$3(
    jni.JMap<$K, $V> map, {
    jni.JObjType<$K>? K,
    jni.JObjType<$V>? V,
  }) {
    K ??= jni.lowestCommonSuperType([
      (map.$type as jni.JMapType).K,
    ]) as jni.JObjType<$K>;
    V ??= jni.lowestCommonSuperType([
      (map.$type as jni.JMapType).V,
    ]) as jni.JObjType<$V>;
    return HashMap.fromReference(
        K,
        V,
        _new$3(_class.reference.pointer, _id_new$3 as jni.JMethodIDPtr,
                map.reference.pointer)
            .reference);
  }

  static final _id_size = _class.instanceMethodId(
    r'size',
    r'()I',
  );

  static final _size = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int size()`
  int size() {
    return _size(reference.pointer, _id_size as jni.JMethodIDPtr).integer;
  }

  static final _id_isEmpty = _class.instanceMethodId(
    r'isEmpty',
    r'()Z',
  );

  static final _isEmpty = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean isEmpty()`
  bool isEmpty() {
    return _isEmpty(reference.pointer, _id_isEmpty as jni.JMethodIDPtr).boolean;
  }

  static final _id_get$ = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _get$ = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public V get(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V get$(
    jni.JObject object,
  ) {
    return _get$(reference.pointer, _id_get$ as jni.JMethodIDPtr,
            object.reference.pointer)
        .object(V);
  }

  static final _id_containsKey = _class.instanceMethodId(
    r'containsKey',
    r'(Ljava/lang/Object;)Z',
  );

  static final _containsKey = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public boolean containsKey(java.lang.Object object)`
  bool containsKey(
    jni.JObject object,
  ) {
    return _containsKey(reference.pointer, _id_containsKey as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _put = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public V put(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V put(
    $K object,
    $V object1,
  ) {
    return _put(reference.pointer, _id_put as jni.JMethodIDPtr,
            object.reference.pointer, object1.reference.pointer)
        .object(V);
  }

  static final _id_putAll = _class.instanceMethodId(
    r'putAll',
    r'(Ljava/util/Map;)V',
  );

  static final _putAll = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void putAll(java.util.Map map)`
  void putAll(
    jni.JMap<$K, $V> map,
  ) {
    _putAll(reference.pointer, _id_putAll as jni.JMethodIDPtr,
            map.reference.pointer)
        .check();
  }

  static final _id_remove = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _remove = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public V remove(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V remove(
    jni.JObject object,
  ) {
    return _remove(reference.pointer, _id_remove as jni.JMethodIDPtr,
            object.reference.pointer)
        .object(V);
  }

  static final _id_clear = _class.instanceMethodId(
    r'clear',
    r'()V',
  );

  static final _clear = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void clear()`
  void clear() {
    _clear(reference.pointer, _id_clear as jni.JMethodIDPtr).check();
  }

  static final _id_containsValue = _class.instanceMethodId(
    r'containsValue',
    r'(Ljava/lang/Object;)Z',
  );

  static final _containsValue = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public boolean containsValue(java.lang.Object object)`
  bool containsValue(
    jni.JObject object,
  ) {
    return _containsValue(reference.pointer,
            _id_containsValue as jni.JMethodIDPtr, object.reference.pointer)
        .boolean;
  }

  static final _id_keySet = _class.instanceMethodId(
    r'keySet',
    r'()Ljava/util/Set;',
  );

  static final _keySet = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.Set keySet()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JSet<$K> keySet() {
    return _keySet(reference.pointer, _id_keySet as jni.JMethodIDPtr)
        .object(jni.JSetType(K));
  }

  static final _id_values = _class.instanceMethodId(
    r'values',
    r'()Ljava/util/Collection;',
  );

  static final _values = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.Collection values()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject values() {
    return _values(reference.pointer, _id_values as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_entrySet = _class.instanceMethodId(
    r'entrySet',
    r'()Ljava/util/Set;',
  );

  static final _entrySet = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.Set entrySet()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JSet<jni.JObject> entrySet() {
    return _entrySet(reference.pointer, _id_entrySet as jni.JMethodIDPtr)
        .object(const jni.JSetType(jni.JObjectType()));
  }

  static final _id_getOrDefault = _class.instanceMethodId(
    r'getOrDefault',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _getOrDefault = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public V getOrDefault(java.lang.Object object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V getOrDefault(
    jni.JObject object,
    $V object1,
  ) {
    return _getOrDefault(
            reference.pointer,
            _id_getOrDefault as jni.JMethodIDPtr,
            object.reference.pointer,
            object1.reference.pointer)
        .object(V);
  }

  static final _id_putIfAbsent = _class.instanceMethodId(
    r'putIfAbsent',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _putIfAbsent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public V putIfAbsent(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V putIfAbsent(
    $K object,
    $V object1,
  ) {
    return _putIfAbsent(reference.pointer, _id_putIfAbsent as jni.JMethodIDPtr,
            object.reference.pointer, object1.reference.pointer)
        .object(V);
  }

  static final _id_remove$1 = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Z',
  );

  static final _remove$1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public boolean remove(java.lang.Object object, java.lang.Object object1)`
  bool remove$1(
    jni.JObject object,
    jni.JObject object1,
  ) {
    return _remove$1(reference.pointer, _id_remove$1 as jni.JMethodIDPtr,
            object.reference.pointer, object1.reference.pointer)
        .boolean;
  }

  static final _id_replace = _class.instanceMethodId(
    r'replace',
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Z',
  );

  static final _replace = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public boolean replace(K object, V object1, V object2)`
  bool replace(
    $K object,
    $V object1,
    $V object2,
  ) {
    return _replace(
            reference.pointer,
            _id_replace as jni.JMethodIDPtr,
            object.reference.pointer,
            object1.reference.pointer,
            object2.reference.pointer)
        .boolean;
  }

  static final _id_replace$1 = _class.instanceMethodId(
    r'replace',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _replace$1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public V replace(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V replace$1(
    $K object,
    $V object1,
  ) {
    return _replace$1(reference.pointer, _id_replace$1 as jni.JMethodIDPtr,
            object.reference.pointer, object1.reference.pointer)
        .object(V);
  }

  static final _id_computeIfAbsent = _class.instanceMethodId(
    r'computeIfAbsent',
    r'(Ljava/lang/Object;Ljava/util/function/Function;)Ljava/lang/Object;',
  );

  static final _computeIfAbsent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public V computeIfAbsent(K object, java.util.function.Function function)`
  /// The returned object must be released after use, by calling the [release] method.
  $V computeIfAbsent(
    $K object,
    jni.JObject function,
  ) {
    return _computeIfAbsent(
            reference.pointer,
            _id_computeIfAbsent as jni.JMethodIDPtr,
            object.reference.pointer,
            function.reference.pointer)
        .object(V);
  }

  static final _id_computeIfPresent = _class.instanceMethodId(
    r'computeIfPresent',
    r'(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _computeIfPresent = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public V computeIfPresent(K object, java.util.function.BiFunction biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V computeIfPresent(
    $K object,
    jni.JObject biFunction,
  ) {
    return _computeIfPresent(
            reference.pointer,
            _id_computeIfPresent as jni.JMethodIDPtr,
            object.reference.pointer,
            biFunction.reference.pointer)
        .object(V);
  }

  static final _id_compute = _class.instanceMethodId(
    r'compute',
    r'(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _compute = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public V compute(K object, java.util.function.BiFunction biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V compute(
    $K object,
    jni.JObject biFunction,
  ) {
    return _compute(reference.pointer, _id_compute as jni.JMethodIDPtr,
            object.reference.pointer, biFunction.reference.pointer)
        .object(V);
  }

  static final _id_merge = _class.instanceMethodId(
    r'merge',
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _merge = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public V merge(K object, V object1, java.util.function.BiFunction biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V merge(
    $K object,
    $V object1,
    jni.JObject biFunction,
  ) {
    return _merge(
            reference.pointer,
            _id_merge as jni.JMethodIDPtr,
            object.reference.pointer,
            object1.reference.pointer,
            biFunction.reference.pointer)
        .object(V);
  }

  static final _id_forEach = _class.instanceMethodId(
    r'forEach',
    r'(Ljava/util/function/BiConsumer;)V',
  );

  static final _forEach = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void forEach(java.util.function.BiConsumer biConsumer)`
  void forEach(
    jni.JObject biConsumer,
  ) {
    _forEach(reference.pointer, _id_forEach as jni.JMethodIDPtr,
            biConsumer.reference.pointer)
        .check();
  }

  static final _id_replaceAll = _class.instanceMethodId(
    r'replaceAll',
    r'(Ljava/util/function/BiFunction;)V',
  );

  static final _replaceAll = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void replaceAll(java.util.function.BiFunction biFunction)`
  void replaceAll(
    jni.JObject biFunction,
  ) {
    _replaceAll(reference.pointer, _id_replaceAll as jni.JMethodIDPtr,
            biFunction.reference.pointer)
        .check();
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject clone() {
    return _clone(reference.pointer, _id_clone as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }
}

final class $HashMapType<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObjType<HashMap<$K, $V>> {
  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  const $HashMapType(
    this.K,
    this.V,
  );

  @override
  String get signature => r'Ljava/util/HashMap;';

  @override
  HashMap<$K, $V> fromReference(jni.JReference reference) =>
      HashMap.fromReference(K, V, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($HashMapType, K, V);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($HashMapType<$K, $V>) &&
        other is $HashMapType<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

/// from: `com.example.in_app_java.AndroidUtils`
class AndroidUtils extends jni.JObject {
  @override
  late final jni.JObjType<AndroidUtils> $type = type;

  AndroidUtils.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/example/in_app_java/AndroidUtils');

  /// The type which includes information such as the signature of this class.
  static const type = $AndroidUtilsType();
  static final _id_showToast = _class.staticMethodId(
    r'showToast',
    r'(Landroid/app/Activity;Ljava/lang/CharSequence;I)V',
  );

  static final _showToast = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: `static public void showToast(android.app.Activity mainActivity, java.lang.CharSequence text, int duration)`
  static void showToast(
    jni.JObject mainActivity,
    jni.JObject text,
    int duration,
  ) {
    _showToast(_class.reference.pointer, _id_showToast as jni.JMethodIDPtr,
            mainActivity.reference.pointer, text.reference.pointer, duration)
        .check();
  }
}

final class $AndroidUtilsType extends jni.JObjType<AndroidUtils> {
  const $AndroidUtilsType();

  @override
  String get signature => r'Lcom/example/in_app_java/AndroidUtils;';

  @override
  AndroidUtils fromReference(jni.JReference reference) =>
      AndroidUtils.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($AndroidUtilsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($AndroidUtilsType) &&
        other is $AndroidUtilsType;
  }
}
