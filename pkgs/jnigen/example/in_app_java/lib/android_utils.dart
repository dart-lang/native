// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `com.example.in_app_java.R$drawable`
class R_drawable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<R_drawable> $type;

  @jni$_.internal
  R_drawable.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/example/in_app_java/R$drawable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $R_drawable$NullableType();
  static const type = $R_drawable$Type();
  static final _id_launch_background = _class.staticFieldId(
    r'launch_background',
    r'I',
  );

  /// from: `static public int launch_background`
  static int get launch_background =>
      _id_launch_background.get(_class, const jni$_.jintType());

  /// from: `static public int launch_background`
  static set launch_background(int value) =>
      _id_launch_background.set(_class, const jni$_.jintType(), value);
}

final class $R_drawable$NullableType extends jni$_.JObjType<R_drawable?> {
  @jni$_.internal
  const $R_drawable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/R$drawable;';

  @jni$_.internal
  @core$_.override
  R_drawable? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : R_drawable.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<R_drawable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($R_drawable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($R_drawable$NullableType) &&
        other is $R_drawable$NullableType;
  }
}

final class $R_drawable$Type extends jni$_.JObjType<R_drawable> {
  @jni$_.internal
  const $R_drawable$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/R$drawable;';

  @jni$_.internal
  @core$_.override
  R_drawable fromReference(jni$_.JReference reference) =>
      R_drawable.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<R_drawable?> get nullableType =>
      const $R_drawable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($R_drawable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($R_drawable$Type) && other is $R_drawable$Type;
  }
}

/// from: `com.example.in_app_java.R$mipmap`
class R_mipmap extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<R_mipmap> $type;

  @jni$_.internal
  R_mipmap.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/example/in_app_java/R$mipmap');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $R_mipmap$NullableType();
  static const type = $R_mipmap$Type();
  static final _id_ic_launcher = _class.staticFieldId(
    r'ic_launcher',
    r'I',
  );

  /// from: `static public int ic_launcher`
  static int get ic_launcher =>
      _id_ic_launcher.get(_class, const jni$_.jintType());

  /// from: `static public int ic_launcher`
  static set ic_launcher(int value) =>
      _id_ic_launcher.set(_class, const jni$_.jintType(), value);
}

final class $R_mipmap$NullableType extends jni$_.JObjType<R_mipmap?> {
  @jni$_.internal
  const $R_mipmap$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/R$mipmap;';

  @jni$_.internal
  @core$_.override
  R_mipmap? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : R_mipmap.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<R_mipmap?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($R_mipmap$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($R_mipmap$NullableType) &&
        other is $R_mipmap$NullableType;
  }
}

final class $R_mipmap$Type extends jni$_.JObjType<R_mipmap> {
  @jni$_.internal
  const $R_mipmap$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/R$mipmap;';

  @jni$_.internal
  @core$_.override
  R_mipmap fromReference(jni$_.JReference reference) => R_mipmap.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<R_mipmap?> get nullableType => const $R_mipmap$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($R_mipmap$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($R_mipmap$Type) && other is $R_mipmap$Type;
  }
}

/// from: `com.example.in_app_java.R$style`
class R_style extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<R_style> $type;

  @jni$_.internal
  R_style.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/example/in_app_java/R$style');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $R_style$NullableType();
  static const type = $R_style$Type();
  static final _id_LaunchTheme = _class.staticFieldId(
    r'LaunchTheme',
    r'I',
  );

  /// from: `static public int LaunchTheme`
  static int get LaunchTheme =>
      _id_LaunchTheme.get(_class, const jni$_.jintType());

  /// from: `static public int LaunchTheme`
  static set LaunchTheme(int value) =>
      _id_LaunchTheme.set(_class, const jni$_.jintType(), value);

  static final _id_NormalTheme = _class.staticFieldId(
    r'NormalTheme',
    r'I',
  );

  /// from: `static public int NormalTheme`
  static int get NormalTheme =>
      _id_NormalTheme.get(_class, const jni$_.jintType());

  /// from: `static public int NormalTheme`
  static set NormalTheme(int value) =>
      _id_NormalTheme.set(_class, const jni$_.jintType(), value);
}

final class $R_style$NullableType extends jni$_.JObjType<R_style?> {
  @jni$_.internal
  const $R_style$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/R$style;';

  @jni$_.internal
  @core$_.override
  R_style? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : R_style.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<R_style?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($R_style$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($R_style$NullableType) &&
        other is $R_style$NullableType;
  }
}

final class $R_style$Type extends jni$_.JObjType<R_style> {
  @jni$_.internal
  const $R_style$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/R$style;';

  @jni$_.internal
  @core$_.override
  R_style fromReference(jni$_.JReference reference) => R_style.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<R_style?> get nullableType => const $R_style$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($R_style$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($R_style$Type) && other is $R_style$Type;
  }
}

/// from: `com.example.in_app_java.R`
class R extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<R> $type;

  @jni$_.internal
  R.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/example/in_app_java/R');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $R$NullableType();
  static const type = $R$Type();
}

final class $R$NullableType extends jni$_.JObjType<R?> {
  @jni$_.internal
  const $R$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/R;';

  @jni$_.internal
  @core$_.override
  R? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : R.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<R?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($R$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($R$NullableType) && other is $R$NullableType;
  }
}

final class $R$Type extends jni$_.JObjType<R> {
  @jni$_.internal
  const $R$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/R;';

  @jni$_.internal
  @core$_.override
  R fromReference(jni$_.JReference reference) => R.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<R?> get nullableType => const $R$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($R$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($R$Type) && other is $R$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$CodepointSequenceMatchResult`
class EmojiCompat_CodepointSequenceMatchResult extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<EmojiCompat_CodepointSequenceMatchResult> $type;

  @jni$_.internal
  EmojiCompat_CodepointSequenceMatchResult.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$CodepointSequenceMatchResult');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $EmojiCompat_CodepointSequenceMatchResult$NullableType();
  static const type = $EmojiCompat_CodepointSequenceMatchResult$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $EmojiCompat_CodepointSequenceMatchResult>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $EmojiCompat_CodepointSequenceMatchResult $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$CodepointSequenceMatchResult',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat_CodepointSequenceMatchResult.implement(
    $EmojiCompat_CodepointSequenceMatchResult $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return EmojiCompat_CodepointSequenceMatchResult.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $EmojiCompat_CodepointSequenceMatchResult {
  factory $EmojiCompat_CodepointSequenceMatchResult() =
      _$EmojiCompat_CodepointSequenceMatchResult;
}

final class _$EmojiCompat_CodepointSequenceMatchResult
    with $EmojiCompat_CodepointSequenceMatchResult {
  _$EmojiCompat_CodepointSequenceMatchResult();
}

final class $EmojiCompat_CodepointSequenceMatchResult$NullableType
    extends jni$_.JObjType<EmojiCompat_CodepointSequenceMatchResult?> {
  @jni$_.internal
  const $EmojiCompat_CodepointSequenceMatchResult$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$CodepointSequenceMatchResult;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_CodepointSequenceMatchResult? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : EmojiCompat_CodepointSequenceMatchResult.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_CodepointSequenceMatchResult?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($EmojiCompat_CodepointSequenceMatchResult$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($EmojiCompat_CodepointSequenceMatchResult$NullableType) &&
        other is $EmojiCompat_CodepointSequenceMatchResult$NullableType;
  }
}

final class $EmojiCompat_CodepointSequenceMatchResult$Type
    extends jni$_.JObjType<EmojiCompat_CodepointSequenceMatchResult> {
  @jni$_.internal
  const $EmojiCompat_CodepointSequenceMatchResult$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$CodepointSequenceMatchResult;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_CodepointSequenceMatchResult fromReference(
          jni$_.JReference reference) =>
      EmojiCompat_CodepointSequenceMatchResult.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_CodepointSequenceMatchResult?> get nullableType =>
      const $EmojiCompat_CodepointSequenceMatchResult$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_CodepointSequenceMatchResult$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($EmojiCompat_CodepointSequenceMatchResult$Type) &&
        other is $EmojiCompat_CodepointSequenceMatchResult$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$Config`
class EmojiCompat_Config extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<EmojiCompat_Config> $type;

  @jni$_.internal
  EmojiCompat_Config.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/EmojiCompat$Config');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $EmojiCompat_Config$NullableType();
  static const type = $EmojiCompat_Config$Type();
  static final _id_registerInitCallback = _class.instanceMethodId(
    r'registerInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _registerInitCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config registerInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config? registerInitCallback(
    EmojiCompat_InitCallback? initCallback,
  ) {
    final _$initCallback = initCallback?.reference ?? jni$_.jNullReference;
    return _registerInitCallback(
            reference.pointer,
            _id_registerInitCallback as jni$_.JMethodIDPtr,
            _$initCallback.pointer)
        .object<EmojiCompat_Config?>(const $EmojiCompat_Config$NullableType());
  }

  static final _id_unregisterInitCallback = _class.instanceMethodId(
    r'unregisterInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _unregisterInitCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config unregisterInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config? unregisterInitCallback(
    EmojiCompat_InitCallback? initCallback,
  ) {
    final _$initCallback = initCallback?.reference ?? jni$_.jNullReference;
    return _unregisterInitCallback(
            reference.pointer,
            _id_unregisterInitCallback as jni$_.JMethodIDPtr,
            _$initCallback.pointer)
        .object<EmojiCompat_Config?>(const $EmojiCompat_Config$NullableType());
  }

  static final _id_setReplaceAll = _class.instanceMethodId(
    r'setReplaceAll',
    r'(Z)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setReplaceAll = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setReplaceAll(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config? setReplaceAll(
    bool z,
  ) {
    return _setReplaceAll(reference.pointer,
            _id_setReplaceAll as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<EmojiCompat_Config?>(const $EmojiCompat_Config$NullableType());
  }

  static final _id_setUseEmojiAsDefaultStyle = _class.instanceMethodId(
    r'setUseEmojiAsDefaultStyle',
    r'(Z)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setUseEmojiAsDefaultStyle = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setUseEmojiAsDefaultStyle(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config? setUseEmojiAsDefaultStyle(
    bool z,
  ) {
    return _setUseEmojiAsDefaultStyle(reference.pointer,
            _id_setUseEmojiAsDefaultStyle as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<EmojiCompat_Config?>(const $EmojiCompat_Config$NullableType());
  }

  static final _id_setUseEmojiAsDefaultStyle$1 = _class.instanceMethodId(
    r'setUseEmojiAsDefaultStyle',
    r'(ZLjava/util/List;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setUseEmojiAsDefaultStyle$1 =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Int32,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setUseEmojiAsDefaultStyle(boolean z, java.util.List list)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config? setUseEmojiAsDefaultStyle$1(
    bool z,
    jni$_.JList<jni$_.JInteger?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _setUseEmojiAsDefaultStyle$1(
            reference.pointer,
            _id_setUseEmojiAsDefaultStyle$1 as jni$_.JMethodIDPtr,
            z ? 1 : 0,
            _$list.pointer)
        .object<EmojiCompat_Config?>(const $EmojiCompat_Config$NullableType());
  }

  static final _id_setEmojiSpanIndicatorEnabled = _class.instanceMethodId(
    r'setEmojiSpanIndicatorEnabled',
    r'(Z)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setEmojiSpanIndicatorEnabled =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setEmojiSpanIndicatorEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config? setEmojiSpanIndicatorEnabled(
    bool z,
  ) {
    return _setEmojiSpanIndicatorEnabled(reference.pointer,
            _id_setEmojiSpanIndicatorEnabled as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<EmojiCompat_Config?>(const $EmojiCompat_Config$NullableType());
  }

  static final _id_setEmojiSpanIndicatorColor = _class.instanceMethodId(
    r'setEmojiSpanIndicatorColor',
    r'(I)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setEmojiSpanIndicatorColor =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setEmojiSpanIndicatorColor(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config? setEmojiSpanIndicatorColor(
    int i,
  ) {
    return _setEmojiSpanIndicatorColor(reference.pointer,
            _id_setEmojiSpanIndicatorColor as jni$_.JMethodIDPtr, i)
        .object<EmojiCompat_Config?>(const $EmojiCompat_Config$NullableType());
  }

  static final _id_setMetadataLoadStrategy = _class.instanceMethodId(
    r'setMetadataLoadStrategy',
    r'(I)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setMetadataLoadStrategy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setMetadataLoadStrategy(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config? setMetadataLoadStrategy(
    int i,
  ) {
    return _setMetadataLoadStrategy(reference.pointer,
            _id_setMetadataLoadStrategy as jni$_.JMethodIDPtr, i)
        .object<EmojiCompat_Config?>(const $EmojiCompat_Config$NullableType());
  }

  static final _id_setSpanFactory = _class.instanceMethodId(
    r'setSpanFactory',
    r'(Landroidx/emoji2/text/EmojiCompat$SpanFactory;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setSpanFactory = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setSpanFactory(androidx.emoji2.text.EmojiCompat$SpanFactory spanFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config? setSpanFactory(
    EmojiCompat_SpanFactory? spanFactory,
  ) {
    final _$spanFactory = spanFactory?.reference ?? jni$_.jNullReference;
    return _setSpanFactory(reference.pointer,
            _id_setSpanFactory as jni$_.JMethodIDPtr, _$spanFactory.pointer)
        .object<EmojiCompat_Config?>(const $EmojiCompat_Config$NullableType());
  }

  static final _id_setGlyphChecker = _class.instanceMethodId(
    r'setGlyphChecker',
    r'(Landroidx/emoji2/text/EmojiCompat$GlyphChecker;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setGlyphChecker = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setGlyphChecker(androidx.emoji2.text.EmojiCompat$GlyphChecker glyphChecker)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config? setGlyphChecker(
    EmojiCompat_GlyphChecker? glyphChecker,
  ) {
    final _$glyphChecker = glyphChecker?.reference ?? jni$_.jNullReference;
    return _setGlyphChecker(reference.pointer,
            _id_setGlyphChecker as jni$_.JMethodIDPtr, _$glyphChecker.pointer)
        .object<EmojiCompat_Config?>(const $EmojiCompat_Config$NullableType());
  }
}

final class $EmojiCompat_Config$NullableType
    extends jni$_.JObjType<EmojiCompat_Config?> {
  @jni$_.internal
  const $EmojiCompat_Config$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$Config;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_Config? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : EmojiCompat_Config.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_Config?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_Config$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_Config$NullableType) &&
        other is $EmojiCompat_Config$NullableType;
  }
}

final class $EmojiCompat_Config$Type
    extends jni$_.JObjType<EmojiCompat_Config> {
  @jni$_.internal
  const $EmojiCompat_Config$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$Config;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_Config fromReference(jni$_.JReference reference) =>
      EmojiCompat_Config.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_Config?> get nullableType =>
      const $EmojiCompat_Config$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_Config$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_Config$Type) &&
        other is $EmojiCompat_Config$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$DefaultSpanFactory`
class EmojiCompat_DefaultSpanFactory extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<EmojiCompat_DefaultSpanFactory> $type;

  @jni$_.internal
  EmojiCompat_DefaultSpanFactory.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$DefaultSpanFactory');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $EmojiCompat_DefaultSpanFactory$NullableType();
  static const type = $EmojiCompat_DefaultSpanFactory$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory EmojiCompat_DefaultSpanFactory() {
    return EmojiCompat_DefaultSpanFactory.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_createSpan = _class.instanceMethodId(
    r'createSpan',
    r'(Landroidx/emoji2/text/TypefaceEmojiRasterizer;)Landroidx/emoji2/text/EmojiSpan;',
  );

  static final _createSpan = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiSpan createSpan(androidx.emoji2.text.TypefaceEmojiRasterizer typefaceEmojiRasterizer)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? createSpan(
    jni$_.JObject? typefaceEmojiRasterizer,
  ) {
    final _$typefaceEmojiRasterizer =
        typefaceEmojiRasterizer?.reference ?? jni$_.jNullReference;
    return _createSpan(reference.pointer, _id_createSpan as jni$_.JMethodIDPtr,
            _$typefaceEmojiRasterizer.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $EmojiCompat_DefaultSpanFactory$NullableType
    extends jni$_.JObjType<EmojiCompat_DefaultSpanFactory?> {
  @jni$_.internal
  const $EmojiCompat_DefaultSpanFactory$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$DefaultSpanFactory;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_DefaultSpanFactory? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : EmojiCompat_DefaultSpanFactory.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_DefaultSpanFactory?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_DefaultSpanFactory$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($EmojiCompat_DefaultSpanFactory$NullableType) &&
        other is $EmojiCompat_DefaultSpanFactory$NullableType;
  }
}

final class $EmojiCompat_DefaultSpanFactory$Type
    extends jni$_.JObjType<EmojiCompat_DefaultSpanFactory> {
  @jni$_.internal
  const $EmojiCompat_DefaultSpanFactory$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$DefaultSpanFactory;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_DefaultSpanFactory fromReference(jni$_.JReference reference) =>
      EmojiCompat_DefaultSpanFactory.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_DefaultSpanFactory?> get nullableType =>
      const $EmojiCompat_DefaultSpanFactory$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_DefaultSpanFactory$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_DefaultSpanFactory$Type) &&
        other is $EmojiCompat_DefaultSpanFactory$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$GlyphChecker`
class EmojiCompat_GlyphChecker extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<EmojiCompat_GlyphChecker> $type;

  @jni$_.internal
  EmojiCompat_GlyphChecker.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/EmojiCompat$GlyphChecker');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $EmojiCompat_GlyphChecker$NullableType();
  static const type = $EmojiCompat_GlyphChecker$Type();
  static final _id_hasGlyph = _class.instanceMethodId(
    r'hasGlyph',
    r'(Ljava/lang/CharSequence;III)Z',
  );

  static final _hasGlyph = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int, int)>();

  /// from: `public abstract boolean hasGlyph(java.lang.CharSequence charSequence, int i, int i1, int i2)`
  bool hasGlyph(
    jni$_.JObject? charSequence,
    int i,
    int i1,
    int i2,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _hasGlyph(reference.pointer, _id_hasGlyph as jni$_.JMethodIDPtr,
            _$charSequence.pointer, i, i1, i2)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $EmojiCompat_GlyphChecker> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'hasGlyph(Ljava/lang/CharSequence;III)Z') {
        final $r = _$impls[$p]!.hasGlyph(
          $a![0]?.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![3]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $EmojiCompat_GlyphChecker $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$GlyphChecker',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat_GlyphChecker.implement(
    $EmojiCompat_GlyphChecker $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return EmojiCompat_GlyphChecker.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $EmojiCompat_GlyphChecker {
  factory $EmojiCompat_GlyphChecker({
    required bool Function(jni$_.JObject? charSequence, int i, int i1, int i2)
        hasGlyph,
  }) = _$EmojiCompat_GlyphChecker;

  bool hasGlyph(jni$_.JObject? charSequence, int i, int i1, int i2);
}

final class _$EmojiCompat_GlyphChecker with $EmojiCompat_GlyphChecker {
  _$EmojiCompat_GlyphChecker({
    required bool Function(jni$_.JObject? charSequence, int i, int i1, int i2)
        hasGlyph,
  }) : _hasGlyph = hasGlyph;

  final bool Function(jni$_.JObject? charSequence, int i, int i1, int i2)
      _hasGlyph;

  bool hasGlyph(jni$_.JObject? charSequence, int i, int i1, int i2) {
    return _hasGlyph(charSequence, i, i1, i2);
  }
}

final class $EmojiCompat_GlyphChecker$NullableType
    extends jni$_.JObjType<EmojiCompat_GlyphChecker?> {
  @jni$_.internal
  const $EmojiCompat_GlyphChecker$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$GlyphChecker;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_GlyphChecker? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : EmojiCompat_GlyphChecker.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_GlyphChecker?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_GlyphChecker$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_GlyphChecker$NullableType) &&
        other is $EmojiCompat_GlyphChecker$NullableType;
  }
}

final class $EmojiCompat_GlyphChecker$Type
    extends jni$_.JObjType<EmojiCompat_GlyphChecker> {
  @jni$_.internal
  const $EmojiCompat_GlyphChecker$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$GlyphChecker;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_GlyphChecker fromReference(jni$_.JReference reference) =>
      EmojiCompat_GlyphChecker.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_GlyphChecker?> get nullableType =>
      const $EmojiCompat_GlyphChecker$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_GlyphChecker$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_GlyphChecker$Type) &&
        other is $EmojiCompat_GlyphChecker$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$InitCallback`
class EmojiCompat_InitCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<EmojiCompat_InitCallback> $type;

  @jni$_.internal
  EmojiCompat_InitCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/EmojiCompat$InitCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $EmojiCompat_InitCallback$NullableType();
  static const type = $EmojiCompat_InitCallback$Type();
  static final _id_onInitialized = _class.instanceMethodId(
    r'onInitialized',
    r'()V',
  );

  static final _onInitialized = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void onInitialized()`
  void onInitialized() {
    _onInitialized(reference.pointer, _id_onInitialized as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_onFailed = _class.instanceMethodId(
    r'onFailed',
    r'(Ljava/lang/Throwable;)V',
  );

  static final _onFailed = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onFailed(java.lang.Throwable throwable)`
  void onFailed(
    jni$_.JObject? throwable,
  ) {
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    _onFailed(reference.pointer, _id_onFailed as jni$_.JMethodIDPtr,
            _$throwable.pointer)
        .check();
  }
}

final class $EmojiCompat_InitCallback$NullableType
    extends jni$_.JObjType<EmojiCompat_InitCallback?> {
  @jni$_.internal
  const $EmojiCompat_InitCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$InitCallback;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_InitCallback? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : EmojiCompat_InitCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_InitCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_InitCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_InitCallback$NullableType) &&
        other is $EmojiCompat_InitCallback$NullableType;
  }
}

final class $EmojiCompat_InitCallback$Type
    extends jni$_.JObjType<EmojiCompat_InitCallback> {
  @jni$_.internal
  const $EmojiCompat_InitCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$InitCallback;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_InitCallback fromReference(jni$_.JReference reference) =>
      EmojiCompat_InitCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_InitCallback?> get nullableType =>
      const $EmojiCompat_InitCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_InitCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_InitCallback$Type) &&
        other is $EmojiCompat_InitCallback$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$LoadStrategy`
class EmojiCompat_LoadStrategy extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<EmojiCompat_LoadStrategy> $type;

  @jni$_.internal
  EmojiCompat_LoadStrategy.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/EmojiCompat$LoadStrategy');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $EmojiCompat_LoadStrategy$NullableType();
  static const type = $EmojiCompat_LoadStrategy$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $EmojiCompat_LoadStrategy> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $EmojiCompat_LoadStrategy $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$LoadStrategy',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat_LoadStrategy.implement(
    $EmojiCompat_LoadStrategy $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return EmojiCompat_LoadStrategy.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $EmojiCompat_LoadStrategy {
  factory $EmojiCompat_LoadStrategy() = _$EmojiCompat_LoadStrategy;
}

final class _$EmojiCompat_LoadStrategy with $EmojiCompat_LoadStrategy {
  _$EmojiCompat_LoadStrategy();
}

final class $EmojiCompat_LoadStrategy$NullableType
    extends jni$_.JObjType<EmojiCompat_LoadStrategy?> {
  @jni$_.internal
  const $EmojiCompat_LoadStrategy$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$LoadStrategy;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_LoadStrategy? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : EmojiCompat_LoadStrategy.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_LoadStrategy?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_LoadStrategy$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_LoadStrategy$NullableType) &&
        other is $EmojiCompat_LoadStrategy$NullableType;
  }
}

final class $EmojiCompat_LoadStrategy$Type
    extends jni$_.JObjType<EmojiCompat_LoadStrategy> {
  @jni$_.internal
  const $EmojiCompat_LoadStrategy$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$LoadStrategy;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_LoadStrategy fromReference(jni$_.JReference reference) =>
      EmojiCompat_LoadStrategy.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_LoadStrategy?> get nullableType =>
      const $EmojiCompat_LoadStrategy$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_LoadStrategy$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_LoadStrategy$Type) &&
        other is $EmojiCompat_LoadStrategy$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$MetadataRepoLoader`
class EmojiCompat_MetadataRepoLoader extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<EmojiCompat_MetadataRepoLoader> $type;

  @jni$_.internal
  EmojiCompat_MetadataRepoLoader.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$MetadataRepoLoader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $EmojiCompat_MetadataRepoLoader$NullableType();
  static const type = $EmojiCompat_MetadataRepoLoader$Type();
  static final _id_load = _class.instanceMethodId(
    r'load',
    r'(Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;)V',
  );

  static final _load = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void load(androidx.emoji2.text.EmojiCompat$MetadataRepoLoaderCallback metadataRepoLoaderCallback)`
  void load(
    EmojiCompat_MetadataRepoLoaderCallback? metadataRepoLoaderCallback,
  ) {
    final _$metadataRepoLoaderCallback =
        metadataRepoLoaderCallback?.reference ?? jni$_.jNullReference;
    _load(reference.pointer, _id_load as jni$_.JMethodIDPtr,
            _$metadataRepoLoaderCallback.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $EmojiCompat_MetadataRepoLoader> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'load(Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;)V') {
        _$impls[$p]!.load(
          $a![0]?.as(const $EmojiCompat_MetadataRepoLoaderCallback$Type(),
              releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $EmojiCompat_MetadataRepoLoader $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$MetadataRepoLoader',
      $p,
      _$invokePointer,
      [
        if ($impl.load$async)
          r'load(Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat_MetadataRepoLoader.implement(
    $EmojiCompat_MetadataRepoLoader $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return EmojiCompat_MetadataRepoLoader.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $EmojiCompat_MetadataRepoLoader {
  factory $EmojiCompat_MetadataRepoLoader({
    required void Function(
            EmojiCompat_MetadataRepoLoaderCallback? metadataRepoLoaderCallback)
        load,
    bool load$async,
  }) = _$EmojiCompat_MetadataRepoLoader;

  void load(EmojiCompat_MetadataRepoLoaderCallback? metadataRepoLoaderCallback);
  bool get load$async => false;
}

final class _$EmojiCompat_MetadataRepoLoader
    with $EmojiCompat_MetadataRepoLoader {
  _$EmojiCompat_MetadataRepoLoader({
    required void Function(
            EmojiCompat_MetadataRepoLoaderCallback? metadataRepoLoaderCallback)
        load,
    this.load$async = false,
  }) : _load = load;

  final void Function(
      EmojiCompat_MetadataRepoLoaderCallback? metadataRepoLoaderCallback) _load;
  final bool load$async;

  void load(
      EmojiCompat_MetadataRepoLoaderCallback? metadataRepoLoaderCallback) {
    return _load(metadataRepoLoaderCallback);
  }
}

final class $EmojiCompat_MetadataRepoLoader$NullableType
    extends jni$_.JObjType<EmojiCompat_MetadataRepoLoader?> {
  @jni$_.internal
  const $EmojiCompat_MetadataRepoLoader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoader;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_MetadataRepoLoader? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : EmojiCompat_MetadataRepoLoader.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_MetadataRepoLoader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_MetadataRepoLoader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($EmojiCompat_MetadataRepoLoader$NullableType) &&
        other is $EmojiCompat_MetadataRepoLoader$NullableType;
  }
}

final class $EmojiCompat_MetadataRepoLoader$Type
    extends jni$_.JObjType<EmojiCompat_MetadataRepoLoader> {
  @jni$_.internal
  const $EmojiCompat_MetadataRepoLoader$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoader;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_MetadataRepoLoader fromReference(jni$_.JReference reference) =>
      EmojiCompat_MetadataRepoLoader.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_MetadataRepoLoader?> get nullableType =>
      const $EmojiCompat_MetadataRepoLoader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_MetadataRepoLoader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_MetadataRepoLoader$Type) &&
        other is $EmojiCompat_MetadataRepoLoader$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$MetadataRepoLoaderCallback`
class EmojiCompat_MetadataRepoLoaderCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<EmojiCompat_MetadataRepoLoaderCallback> $type;

  @jni$_.internal
  EmojiCompat_MetadataRepoLoaderCallback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $EmojiCompat_MetadataRepoLoaderCallback$NullableType();
  static const type = $EmojiCompat_MetadataRepoLoaderCallback$Type();
  static final _id_onLoaded = _class.instanceMethodId(
    r'onLoaded',
    r'(Landroidx/emoji2/text/MetadataRepo;)V',
  );

  static final _onLoaded = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onLoaded(androidx.emoji2.text.MetadataRepo metadataRepo)`
  void onLoaded(
    jni$_.JObject? metadataRepo,
  ) {
    final _$metadataRepo = metadataRepo?.reference ?? jni$_.jNullReference;
    _onLoaded(reference.pointer, _id_onLoaded as jni$_.JMethodIDPtr,
            _$metadataRepo.pointer)
        .check();
  }

  static final _id_onFailed = _class.instanceMethodId(
    r'onFailed',
    r'(Ljava/lang/Throwable;)V',
  );

  static final _onFailed = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onFailed(java.lang.Throwable throwable)`
  void onFailed(
    jni$_.JObject? throwable,
  ) {
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    _onFailed(reference.pointer, _id_onFailed as jni$_.JMethodIDPtr,
            _$throwable.pointer)
        .check();
  }
}

final class $EmojiCompat_MetadataRepoLoaderCallback$NullableType
    extends jni$_.JObjType<EmojiCompat_MetadataRepoLoaderCallback?> {
  @jni$_.internal
  const $EmojiCompat_MetadataRepoLoaderCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_MetadataRepoLoaderCallback? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : EmojiCompat_MetadataRepoLoaderCallback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_MetadataRepoLoaderCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($EmojiCompat_MetadataRepoLoaderCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($EmojiCompat_MetadataRepoLoaderCallback$NullableType) &&
        other is $EmojiCompat_MetadataRepoLoaderCallback$NullableType;
  }
}

final class $EmojiCompat_MetadataRepoLoaderCallback$Type
    extends jni$_.JObjType<EmojiCompat_MetadataRepoLoaderCallback> {
  @jni$_.internal
  const $EmojiCompat_MetadataRepoLoaderCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_MetadataRepoLoaderCallback fromReference(
          jni$_.JReference reference) =>
      EmojiCompat_MetadataRepoLoaderCallback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_MetadataRepoLoaderCallback?> get nullableType =>
      const $EmojiCompat_MetadataRepoLoaderCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_MetadataRepoLoaderCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($EmojiCompat_MetadataRepoLoaderCallback$Type) &&
        other is $EmojiCompat_MetadataRepoLoaderCallback$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$ReplaceStrategy`
class EmojiCompat_ReplaceStrategy extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<EmojiCompat_ReplaceStrategy> $type;

  @jni$_.internal
  EmojiCompat_ReplaceStrategy.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/EmojiCompat$ReplaceStrategy');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $EmojiCompat_ReplaceStrategy$NullableType();
  static const type = $EmojiCompat_ReplaceStrategy$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $EmojiCompat_ReplaceStrategy> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $EmojiCompat_ReplaceStrategy $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$ReplaceStrategy',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat_ReplaceStrategy.implement(
    $EmojiCompat_ReplaceStrategy $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return EmojiCompat_ReplaceStrategy.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $EmojiCompat_ReplaceStrategy {
  factory $EmojiCompat_ReplaceStrategy() = _$EmojiCompat_ReplaceStrategy;
}

final class _$EmojiCompat_ReplaceStrategy with $EmojiCompat_ReplaceStrategy {
  _$EmojiCompat_ReplaceStrategy();
}

final class $EmojiCompat_ReplaceStrategy$NullableType
    extends jni$_.JObjType<EmojiCompat_ReplaceStrategy?> {
  @jni$_.internal
  const $EmojiCompat_ReplaceStrategy$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$ReplaceStrategy;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_ReplaceStrategy? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : EmojiCompat_ReplaceStrategy.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_ReplaceStrategy?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_ReplaceStrategy$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_ReplaceStrategy$NullableType) &&
        other is $EmojiCompat_ReplaceStrategy$NullableType;
  }
}

final class $EmojiCompat_ReplaceStrategy$Type
    extends jni$_.JObjType<EmojiCompat_ReplaceStrategy> {
  @jni$_.internal
  const $EmojiCompat_ReplaceStrategy$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$ReplaceStrategy;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_ReplaceStrategy fromReference(jni$_.JReference reference) =>
      EmojiCompat_ReplaceStrategy.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_ReplaceStrategy?> get nullableType =>
      const $EmojiCompat_ReplaceStrategy$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_ReplaceStrategy$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_ReplaceStrategy$Type) &&
        other is $EmojiCompat_ReplaceStrategy$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat$SpanFactory`
class EmojiCompat_SpanFactory extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<EmojiCompat_SpanFactory> $type;

  @jni$_.internal
  EmojiCompat_SpanFactory.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/EmojiCompat$SpanFactory');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $EmojiCompat_SpanFactory$NullableType();
  static const type = $EmojiCompat_SpanFactory$Type();
  static final _id_createSpan = _class.instanceMethodId(
    r'createSpan',
    r'(Landroidx/emoji2/text/TypefaceEmojiRasterizer;)Landroidx/emoji2/text/EmojiSpan;',
  );

  static final _createSpan = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract androidx.emoji2.text.EmojiSpan createSpan(androidx.emoji2.text.TypefaceEmojiRasterizer typefaceEmojiRasterizer)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? createSpan(
    jni$_.JObject? typefaceEmojiRasterizer,
  ) {
    final _$typefaceEmojiRasterizer =
        typefaceEmojiRasterizer?.reference ?? jni$_.jNullReference;
    return _createSpan(reference.pointer, _id_createSpan as jni$_.JMethodIDPtr,
            _$typefaceEmojiRasterizer.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $EmojiCompat_SpanFactory> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'createSpan(Landroidx/emoji2/text/TypefaceEmojiRasterizer;)Landroidx/emoji2/text/EmojiSpan;') {
        final $r = _$impls[$p]!.createSpan(
          $a![0]?.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $EmojiCompat_SpanFactory $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$SpanFactory',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat_SpanFactory.implement(
    $EmojiCompat_SpanFactory $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return EmojiCompat_SpanFactory.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $EmojiCompat_SpanFactory {
  factory $EmojiCompat_SpanFactory({
    required jni$_.JObject? Function(jni$_.JObject? typefaceEmojiRasterizer)
        createSpan,
  }) = _$EmojiCompat_SpanFactory;

  jni$_.JObject? createSpan(jni$_.JObject? typefaceEmojiRasterizer);
}

final class _$EmojiCompat_SpanFactory with $EmojiCompat_SpanFactory {
  _$EmojiCompat_SpanFactory({
    required jni$_.JObject? Function(jni$_.JObject? typefaceEmojiRasterizer)
        createSpan,
  }) : _createSpan = createSpan;

  final jni$_.JObject? Function(jni$_.JObject? typefaceEmojiRasterizer)
      _createSpan;

  jni$_.JObject? createSpan(jni$_.JObject? typefaceEmojiRasterizer) {
    return _createSpan(typefaceEmojiRasterizer);
  }
}

final class $EmojiCompat_SpanFactory$NullableType
    extends jni$_.JObjType<EmojiCompat_SpanFactory?> {
  @jni$_.internal
  const $EmojiCompat_SpanFactory$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$SpanFactory;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_SpanFactory? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : EmojiCompat_SpanFactory.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_SpanFactory?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_SpanFactory$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_SpanFactory$NullableType) &&
        other is $EmojiCompat_SpanFactory$NullableType;
  }
}

final class $EmojiCompat_SpanFactory$Type
    extends jni$_.JObjType<EmojiCompat_SpanFactory> {
  @jni$_.internal
  const $EmojiCompat_SpanFactory$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$SpanFactory;';

  @jni$_.internal
  @core$_.override
  EmojiCompat_SpanFactory fromReference(jni$_.JReference reference) =>
      EmojiCompat_SpanFactory.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat_SpanFactory?> get nullableType =>
      const $EmojiCompat_SpanFactory$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat_SpanFactory$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat_SpanFactory$Type) &&
        other is $EmojiCompat_SpanFactory$Type;
  }
}

/// from: `androidx.emoji2.text.EmojiCompat`
class EmojiCompat extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<EmojiCompat> $type;

  @jni$_.internal
  EmojiCompat.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/EmojiCompat');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $EmojiCompat$NullableType();
  static const type = $EmojiCompat$Type();
  static final _id_EDITOR_INFO_METAVERSION_KEY = _class.staticFieldId(
    r'EDITOR_INFO_METAVERSION_KEY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EDITOR_INFO_METAVERSION_KEY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EDITOR_INFO_METAVERSION_KEY =>
      _id_EDITOR_INFO_METAVERSION_KEY.get(
          _class, const jni$_.JStringNullableType());

  static final _id_EDITOR_INFO_REPLACE_ALL_KEY = _class.staticFieldId(
    r'EDITOR_INFO_REPLACE_ALL_KEY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EDITOR_INFO_REPLACE_ALL_KEY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EDITOR_INFO_REPLACE_ALL_KEY =>
      _id_EDITOR_INFO_REPLACE_ALL_KEY.get(
          _class, const jni$_.JStringNullableType());

  /// from: `static public final int LOAD_STATE_DEFAULT`
  static const LOAD_STATE_DEFAULT = 3;

  /// from: `static public final int LOAD_STATE_LOADING`
  static const LOAD_STATE_LOADING = 0;

  /// from: `static public final int LOAD_STATE_SUCCEEDED`
  static const LOAD_STATE_SUCCEEDED = 1;

  /// from: `static public final int LOAD_STATE_FAILED`
  static const LOAD_STATE_FAILED = 2;

  /// from: `static public final int REPLACE_STRATEGY_DEFAULT`
  static const REPLACE_STRATEGY_DEFAULT = 0;

  /// from: `static public final int REPLACE_STRATEGY_ALL`
  static const REPLACE_STRATEGY_ALL = 1;

  /// from: `static public final int REPLACE_STRATEGY_NON_EXISTENT`
  static const REPLACE_STRATEGY_NON_EXISTENT = 2;

  /// from: `static public final int LOAD_STRATEGY_DEFAULT`
  static const LOAD_STRATEGY_DEFAULT = 0;

  /// from: `static public final int LOAD_STRATEGY_MANUAL`
  static const LOAD_STRATEGY_MANUAL = 1;

  /// from: `static public final int EMOJI_UNSUPPORTED`
  static const EMOJI_UNSUPPORTED = 0;

  /// from: `static public final int EMOJI_SUPPORTED`
  static const EMOJI_SUPPORTED = 1;

  /// from: `static public final int EMOJI_FALLBACK`
  static const EMOJI_FALLBACK = 2;
  static final _id_init = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _init = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat init(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat? init(
    jni$_.JObject? context,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    return _init(_class.reference.pointer, _id_init as jni$_.JMethodIDPtr,
            _$context.pointer)
        .object<EmojiCompat?>(const $EmojiCompat$NullableType());
  }

  static final _id_init$1 = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _init$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat init(android.content.Context context, androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory defaultEmojiCompatConfigFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat? init$1(
    jni$_.JObject? context,
    DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory?
        defaultEmojiCompatConfigFactory,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    final _$defaultEmojiCompatConfigFactory =
        defaultEmojiCompatConfigFactory?.reference ?? jni$_.jNullReference;
    return _init$1(_class.reference.pointer, _id_init$1 as jni$_.JMethodIDPtr,
            _$context.pointer, _$defaultEmojiCompatConfigFactory.pointer)
        .object<EmojiCompat?>(const $EmojiCompat$NullableType());
  }

  static final _id_init$2 = _class.staticMethodId(
    r'init',
    r'(Landroidx/emoji2/text/EmojiCompat$Config;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _init$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat init(androidx.emoji2.text.EmojiCompat$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat? init$2(
    EmojiCompat_Config? config,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _init$2(_class.reference.pointer, _id_init$2 as jni$_.JMethodIDPtr,
            _$config.pointer)
        .object<EmojiCompat?>(const $EmojiCompat$NullableType());
  }

  static final _id_isConfigured = _class.staticMethodId(
    r'isConfigured',
    r'()Z',
  );

  static final _isConfigured = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public boolean isConfigured()`
  static bool isConfigured() {
    return _isConfigured(
            _class.reference.pointer, _id_isConfigured as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_reset = _class.staticMethodId(
    r'reset',
    r'(Landroidx/emoji2/text/EmojiCompat$Config;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _reset = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat reset(androidx.emoji2.text.EmojiCompat$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat? reset(
    EmojiCompat_Config? config,
  ) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _reset(_class.reference.pointer, _id_reset as jni$_.JMethodIDPtr,
            _$config.pointer)
        .object<EmojiCompat?>(const $EmojiCompat$NullableType());
  }

  static final _id_reset$1 = _class.staticMethodId(
    r'reset',
    r'(Landroidx/emoji2/text/EmojiCompat;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _reset$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat reset(androidx.emoji2.text.EmojiCompat emojiCompat)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat? reset$1(
    EmojiCompat? emojiCompat,
  ) {
    final _$emojiCompat = emojiCompat?.reference ?? jni$_.jNullReference;
    return _reset$1(_class.reference.pointer, _id_reset$1 as jni$_.JMethodIDPtr,
            _$emojiCompat.pointer)
        .object<EmojiCompat?>(const $EmojiCompat$NullableType());
  }

  static final _id_skipDefaultConfigurationLookup = _class.staticMethodId(
    r'skipDefaultConfigurationLookup',
    r'(Z)V',
  );

  static final _skipDefaultConfigurationLookup =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallStaticVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public void skipDefaultConfigurationLookup(boolean z)`
  static void skipDefaultConfigurationLookup(
    bool z,
  ) {
    _skipDefaultConfigurationLookup(_class.reference.pointer,
            _id_skipDefaultConfigurationLookup as jni$_.JMethodIDPtr, z ? 1 : 0)
        .check();
  }

  static final _id_get = _class.staticMethodId(
    r'get',
    r'()Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _get = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public androidx.emoji2.text.EmojiCompat get()`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat? get() {
    return _get(_class.reference.pointer, _id_get as jni$_.JMethodIDPtr)
        .object<EmojiCompat?>(const $EmojiCompat$NullableType());
  }

  static final _id_load = _class.instanceMethodId(
    r'load',
    r'()V',
  );

  static final _load = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void load()`
  void load() {
    _load(reference.pointer, _id_load as jni$_.JMethodIDPtr).check();
  }

  static final _id_registerInitCallback = _class.instanceMethodId(
    r'registerInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)V',
  );

  static final _registerInitCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void registerInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  void registerInitCallback(
    EmojiCompat_InitCallback? initCallback,
  ) {
    final _$initCallback = initCallback?.reference ?? jni$_.jNullReference;
    _registerInitCallback(
            reference.pointer,
            _id_registerInitCallback as jni$_.JMethodIDPtr,
            _$initCallback.pointer)
        .check();
  }

  static final _id_unregisterInitCallback = _class.instanceMethodId(
    r'unregisterInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)V',
  );

  static final _unregisterInitCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void unregisterInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  void unregisterInitCallback(
    EmojiCompat_InitCallback? initCallback,
  ) {
    final _$initCallback = initCallback?.reference ?? jni$_.jNullReference;
    _unregisterInitCallback(
            reference.pointer,
            _id_unregisterInitCallback as jni$_.JMethodIDPtr,
            _$initCallback.pointer)
        .check();
  }

  static final _id_getLoadState = _class.instanceMethodId(
    r'getLoadState',
    r'()I',
  );

  static final _getLoadState = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getLoadState()`
  int getLoadState() {
    return _getLoadState(
            reference.pointer, _id_getLoadState as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_isEmojiSpanIndicatorEnabled = _class.instanceMethodId(
    r'isEmojiSpanIndicatorEnabled',
    r'()Z',
  );

  static final _isEmojiSpanIndicatorEnabled =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEmojiSpanIndicatorEnabled()`
  bool isEmojiSpanIndicatorEnabled() {
    return _isEmojiSpanIndicatorEnabled(reference.pointer,
            _id_isEmojiSpanIndicatorEnabled as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getEmojiSpanIndicatorColor = _class.instanceMethodId(
    r'getEmojiSpanIndicatorColor',
    r'()I',
  );

  static final _getEmojiSpanIndicatorColor =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallIntMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public int getEmojiSpanIndicatorColor()`
  int getEmojiSpanIndicatorColor() {
    return _getEmojiSpanIndicatorColor(reference.pointer,
            _id_getEmojiSpanIndicatorColor as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getEmojiStart = _class.instanceMethodId(
    r'getEmojiStart',
    r'(Ljava/lang/CharSequence;I)I',
  );

  static final _getEmojiStart = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public int getEmojiStart(java.lang.CharSequence charSequence, int i)`
  int getEmojiStart(
    jni$_.JObject? charSequence,
    int i,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _getEmojiStart(reference.pointer,
            _id_getEmojiStart as jni$_.JMethodIDPtr, _$charSequence.pointer, i)
        .integer;
  }

  static final _id_getEmojiEnd = _class.instanceMethodId(
    r'getEmojiEnd',
    r'(Ljava/lang/CharSequence;I)I',
  );

  static final _getEmojiEnd = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public int getEmojiEnd(java.lang.CharSequence charSequence, int i)`
  int getEmojiEnd(
    jni$_.JObject? charSequence,
    int i,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _getEmojiEnd(reference.pointer,
            _id_getEmojiEnd as jni$_.JMethodIDPtr, _$charSequence.pointer, i)
        .integer;
  }

  static final _id_handleOnKeyDown = _class.staticMethodId(
    r'handleOnKeyDown',
    r'(Landroid/text/Editable;ILandroid/view/KeyEvent;)Z',
  );

  static final _handleOnKeyDown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public boolean handleOnKeyDown(android.text.Editable editable, int i, android.view.KeyEvent keyEvent)`
  static bool handleOnKeyDown(
    jni$_.JObject? editable,
    int i,
    jni$_.JObject? keyEvent,
  ) {
    final _$editable = editable?.reference ?? jni$_.jNullReference;
    final _$keyEvent = keyEvent?.reference ?? jni$_.jNullReference;
    return _handleOnKeyDown(
            _class.reference.pointer,
            _id_handleOnKeyDown as jni$_.JMethodIDPtr,
            _$editable.pointer,
            i,
            _$keyEvent.pointer)
        .boolean;
  }

  static final _id_handleDeleteSurroundingText = _class.staticMethodId(
    r'handleDeleteSurroundingText',
    r'(Landroid/view/inputmethod/InputConnection;Landroid/text/Editable;IIZ)Z',
  );

  static final _handleDeleteSurroundingText =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32,
                            jni$_.Int32,
                            jni$_.Int32
                          )>)>>('globalEnv_CallStaticBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  int,
                  int,
                  int)>();

  /// from: `static public boolean handleDeleteSurroundingText(android.view.inputmethod.InputConnection inputConnection, android.text.Editable editable, int i, int i1, boolean z)`
  static bool handleDeleteSurroundingText(
    jni$_.JObject? inputConnection,
    jni$_.JObject? editable,
    int i,
    int i1,
    bool z,
  ) {
    final _$inputConnection =
        inputConnection?.reference ?? jni$_.jNullReference;
    final _$editable = editable?.reference ?? jni$_.jNullReference;
    return _handleDeleteSurroundingText(
            _class.reference.pointer,
            _id_handleDeleteSurroundingText as jni$_.JMethodIDPtr,
            _$inputConnection.pointer,
            _$editable.pointer,
            i,
            i1,
            z ? 1 : 0)
        .boolean;
  }

  static final _id_hasEmojiGlyph = _class.instanceMethodId(
    r'hasEmojiGlyph',
    r'(Ljava/lang/CharSequence;)Z',
  );

  static final _hasEmojiGlyph = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean hasEmojiGlyph(java.lang.CharSequence charSequence)`
  bool hasEmojiGlyph(
    jni$_.JObject? charSequence,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _hasEmojiGlyph(reference.pointer,
            _id_hasEmojiGlyph as jni$_.JMethodIDPtr, _$charSequence.pointer)
        .boolean;
  }

  static final _id_hasEmojiGlyph$1 = _class.instanceMethodId(
    r'hasEmojiGlyph',
    r'(Ljava/lang/CharSequence;I)Z',
  );

  static final _hasEmojiGlyph$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public boolean hasEmojiGlyph(java.lang.CharSequence charSequence, int i)`
  bool hasEmojiGlyph$1(
    jni$_.JObject? charSequence,
    int i,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _hasEmojiGlyph$1(
            reference.pointer,
            _id_hasEmojiGlyph$1 as jni$_.JMethodIDPtr,
            _$charSequence.pointer,
            i)
        .boolean;
  }

  static final _id_getEmojiMatch = _class.instanceMethodId(
    r'getEmojiMatch',
    r'(Ljava/lang/CharSequence;I)I',
  );

  static final _getEmojiMatch = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public int getEmojiMatch(java.lang.CharSequence charSequence, int i)`
  int getEmojiMatch(
    jni$_.JObject? charSequence,
    int i,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _getEmojiMatch(reference.pointer,
            _id_getEmojiMatch as jni$_.JMethodIDPtr, _$charSequence.pointer, i)
        .integer;
  }

  static final _id_process = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;)Ljava/lang/CharSequence;',
  );

  static final _process = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? process(
    jni$_.JObject? charSequence,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _process(reference.pointer, _id_process as jni$_.JMethodIDPtr,
            _$charSequence.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_process$1 = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;II)Ljava/lang/CharSequence;',
  );

  static final _process$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? process$1(
    jni$_.JObject? charSequence,
    int i,
    int i1,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _process$1(reference.pointer, _id_process$1 as jni$_.JMethodIDPtr,
            _$charSequence.pointer, i, i1)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_process$2 = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;III)Ljava/lang/CharSequence;',
  );

  static final _process$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int, int)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence, int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? process$2(
    jni$_.JObject? charSequence,
    int i,
    int i1,
    int i2,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _process$2(reference.pointer, _id_process$2 as jni$_.JMethodIDPtr,
            _$charSequence.pointer, i, i1, i2)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_process$3 = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;IIII)Ljava/lang/CharSequence;',
  );

  static final _process$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence, int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? process$3(
    jni$_.JObject? charSequence,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _process$3(reference.pointer, _id_process$3 as jni$_.JMethodIDPtr,
            _$charSequence.pointer, i, i1, i2, i3)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getAssetSignature = _class.instanceMethodId(
    r'getAssetSignature',
    r'()Ljava/lang/String;',
  );

  static final _getAssetSignature = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getAssetSignature()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAssetSignature() {
    return _getAssetSignature(
            reference.pointer, _id_getAssetSignature as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_updateEditorInfo = _class.instanceMethodId(
    r'updateEditorInfo',
    r'(Landroid/view/inputmethod/EditorInfo;)V',
  );

  static final _updateEditorInfo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void updateEditorInfo(android.view.inputmethod.EditorInfo editorInfo)`
  void updateEditorInfo(
    jni$_.JObject? editorInfo,
  ) {
    final _$editorInfo = editorInfo?.reference ?? jni$_.jNullReference;
    _updateEditorInfo(reference.pointer,
            _id_updateEditorInfo as jni$_.JMethodIDPtr, _$editorInfo.pointer)
        .check();
  }
}

final class $EmojiCompat$NullableType extends jni$_.JObjType<EmojiCompat?> {
  @jni$_.internal
  const $EmojiCompat$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat;';

  @jni$_.internal
  @core$_.override
  EmojiCompat? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : EmojiCompat.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat$NullableType) &&
        other is $EmojiCompat$NullableType;
  }
}

final class $EmojiCompat$Type extends jni$_.JObjType<EmojiCompat> {
  @jni$_.internal
  const $EmojiCompat$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat;';

  @jni$_.internal
  @core$_.override
  EmojiCompat fromReference(jni$_.JReference reference) =>
      EmojiCompat.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EmojiCompat?> get nullableType =>
      const $EmojiCompat$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($EmojiCompat$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EmojiCompat$Type) &&
        other is $EmojiCompat$Type;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory`
class DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory>
      $type;

  @jni$_.internal
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$NullableType();
  static const type =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$Type();
  static final _id_new$ = _class.constructorId(
    r'(Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper defaultEmojiCompatConfigHelper)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory(
    DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper?
        defaultEmojiCompatConfigHelper,
  ) {
    final _$defaultEmojiCompatConfigHelper =
        defaultEmojiCompatConfigHelper?.reference ?? jni$_.jNullReference;
    return DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory
        .fromReference(_new$(
                _class.reference.pointer,
                _id_new$ as jni$_.JMethodIDPtr,
                _$defaultEmojiCompatConfigHelper.pointer)
            .reference);
  }

  static final _id_create = _class.instanceMethodId(
    r'create',
    r'(Landroid/content/Context;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _create = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config create(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat_Config? create(
    jni$_.JObject? context,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    return _create(reference.pointer, _id_create as jni$_.JMethodIDPtr,
            _$context.pointer)
        .object<EmojiCompat_Config?>(const $EmojiCompat_Config$NullableType());
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$NullableType
    extends jni$_
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory?> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory;';

  @jni$_.internal
  @core$_.override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory
              .fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$NullableType)
          .hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$NullableType) &&
        other
            is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$NullableType;
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$Type
    extends jni$_
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory;';

  @jni$_.internal
  @core$_.override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory fromReference(
          jni$_.JReference reference) =>
      DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory?>
      get nullableType =>
          const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$Type) &&
        other is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigFactory$Type;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper`
class DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper>
      $type;

  @jni$_.internal
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$NullableType();
  static const type =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper() {
    return DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper
        .fromReference(
            _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
                .reference);
  }

  static final _id_getSigningSignatures = _class.instanceMethodId(
    r'getSigningSignatures',
    r'(Landroid/content/pm/PackageManager;Ljava/lang/String;)[Landroid/content/pm/Signature;',
  );

  static final _getSigningSignatures = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.content.pm.Signature[] getSigningSignatures(android.content.pm.PackageManager packageManager, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? getSigningSignatures(
    jni$_.JObject? packageManager,
    jni$_.JString? string,
  ) {
    final _$packageManager = packageManager?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getSigningSignatures(
            reference.pointer,
            _id_getSigningSignatures as jni$_.JMethodIDPtr,
            _$packageManager.pointer,
            _$string.pointer)
        .object<jni$_.JArray<jni$_.JObject?>?>(
            const jni$_.JArrayNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_queryIntentContentProviders = _class.instanceMethodId(
    r'queryIntentContentProviders',
    r'(Landroid/content/pm/PackageManager;Landroid/content/Intent;I)Ljava/util/List;',
  );

  static final _queryIntentContentProviders =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  int)>();

  /// from: `public java.util.List queryIntentContentProviders(android.content.pm.PackageManager packageManager, android.content.Intent intent, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? queryIntentContentProviders(
    jni$_.JObject? packageManager,
    jni$_.JObject? intent,
    int i,
  ) {
    final _$packageManager = packageManager?.reference ?? jni$_.jNullReference;
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    return _queryIntentContentProviders(
            reference.pointer,
            _id_queryIntentContentProviders as jni$_.JMethodIDPtr,
            _$packageManager.pointer,
            _$intent.pointer,
            i)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getProviderInfo = _class.instanceMethodId(
    r'getProviderInfo',
    r'(Landroid/content/pm/ResolveInfo;)Landroid/content/pm/ProviderInfo;',
  );

  static final _getProviderInfo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.content.pm.ProviderInfo getProviderInfo(android.content.pm.ResolveInfo resolveInfo)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getProviderInfo(
    jni$_.JObject? resolveInfo,
  ) {
    final _$resolveInfo = resolveInfo?.reference ?? jni$_.jNullReference;
    return _getProviderInfo(reference.pointer,
            _id_getProviderInfo as jni$_.JMethodIDPtr, _$resolveInfo.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$NullableType
    extends jni$_
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper?> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper;';

  @jni$_.internal
  @core$_.override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper
              .fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$NullableType)
          .hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$NullableType) &&
        other
            is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$NullableType;
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$Type
    extends jni$_
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper;';

  @jni$_.internal
  @core$_.override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper fromReference(
          jni$_.JReference reference) =>
      DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper?>
      get nullableType =>
          const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$Type) &&
        other is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$Type;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19`
class DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19
    extends DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper {
  @jni$_.internal
  @core$_.override
  final jni$_
      .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19>
      $type;

  @jni$_.internal
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$NullableType();
  static const type =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19() {
    return DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19
        .fromReference(
            _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
                .reference);
  }

  static final _id_queryIntentContentProviders = _class.instanceMethodId(
    r'queryIntentContentProviders',
    r'(Landroid/content/pm/PackageManager;Landroid/content/Intent;I)Ljava/util/List;',
  );

  static final _queryIntentContentProviders =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  int)>();

  /// from: `public java.util.List queryIntentContentProviders(android.content.pm.PackageManager packageManager, android.content.Intent intent, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? queryIntentContentProviders(
    jni$_.JObject? packageManager,
    jni$_.JObject? intent,
    int i,
  ) {
    final _$packageManager = packageManager?.reference ?? jni$_.jNullReference;
    final _$intent = intent?.reference ?? jni$_.jNullReference;
    return _queryIntentContentProviders(
            reference.pointer,
            _id_queryIntentContentProviders as jni$_.JMethodIDPtr,
            _$packageManager.pointer,
            _$intent.pointer,
            i)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getProviderInfo = _class.instanceMethodId(
    r'getProviderInfo',
    r'(Landroid/content/pm/ResolveInfo;)Landroid/content/pm/ProviderInfo;',
  );

  static final _getProviderInfo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.content.pm.ProviderInfo getProviderInfo(android.content.pm.ResolveInfo resolveInfo)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getProviderInfo(
    jni$_.JObject? resolveInfo,
  ) {
    final _$resolveInfo = resolveInfo?.reference ?? jni$_.jNullReference;
    return _getProviderInfo(reference.pointer,
            _id_getProviderInfo as jni$_.JMethodIDPtr, _$resolveInfo.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$NullableType
    extends jni$_
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19?> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19;';

  @jni$_.internal
  @core$_.override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19
              .fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$NullableType)
          .hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$NullableType) &&
        other
            is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$NullableType;
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$Type
    extends jni$_
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19;';

  @jni$_.internal
  @core$_.override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19 fromReference(
          jni$_.JReference reference) =>
      DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19
          .fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19?>
      get nullableType =>
          const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$Type)
          .hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$Type) &&
        other
            is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$Type;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28`
class DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28
    extends DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19 {
  @jni$_.internal
  @core$_.override
  final jni$_
      .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28>
      $type;

  @jni$_.internal
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28');

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$NullableType();
  static const type =
      $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28() {
    return DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28
        .fromReference(
            _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
                .reference);
  }

  static final _id_getSigningSignatures$1 = _class.instanceMethodId(
    r'getSigningSignatures',
    r'(Landroid/content/pm/PackageManager;Ljava/lang/String;)[Landroid/content/pm/Signature;',
  );

  static final _getSigningSignatures$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.content.pm.Signature[] getSigningSignatures(android.content.pm.PackageManager packageManager, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? getSigningSignatures$1(
    jni$_.JObject? packageManager,
    jni$_.JString? string,
  ) {
    final _$packageManager = packageManager?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getSigningSignatures$1(
            reference.pointer,
            _id_getSigningSignatures$1 as jni$_.JMethodIDPtr,
            _$packageManager.pointer,
            _$string.pointer)
        .object<jni$_.JArray<jni$_.JObject?>?>(
            const jni$_.JArrayNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$NullableType
    extends jni$_
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28?> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28;';

  @jni$_.internal
  @core$_.override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28
              .fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$NullableType)
          .hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$NullableType) &&
        other
            is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$NullableType;
  }
}

final class $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$Type
    extends jni$_
    .JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28;';

  @jni$_.internal
  @core$_.override
  DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28 fromReference(
          jni$_.JReference reference) =>
      DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28
          .fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API19$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28?>
      get nullableType =>
          const $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode =>
      ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$Type)
          .hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$Type) &&
        other
            is $DefaultEmojiCompatConfig_DefaultEmojiCompatConfigHelper_API28$Type;
  }
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig`
class DefaultEmojiCompatConfig extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DefaultEmojiCompatConfig> $type;

  @jni$_.internal
  DefaultEmojiCompatConfig.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/DefaultEmojiCompatConfig');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DefaultEmojiCompatConfig$NullableType();
  static const type = $DefaultEmojiCompatConfig$Type();
  static final _id_create = _class.staticMethodId(
    r'create',
    r'(Landroid/content/Context;)Landroidx/emoji2/text/FontRequestEmojiCompatConfig;',
  );

  static final _create = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public androidx.emoji2.text.FontRequestEmojiCompatConfig create(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? create(
    jni$_.JObject? context,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    return _create(_class.reference.pointer, _id_create as jni$_.JMethodIDPtr,
            _$context.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $DefaultEmojiCompatConfig$NullableType
    extends jni$_.JObjType<DefaultEmojiCompatConfig?> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/DefaultEmojiCompatConfig;';

  @jni$_.internal
  @core$_.override
  DefaultEmojiCompatConfig? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : DefaultEmojiCompatConfig.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DefaultEmojiCompatConfig?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DefaultEmojiCompatConfig$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DefaultEmojiCompatConfig$NullableType) &&
        other is $DefaultEmojiCompatConfig$NullableType;
  }
}

final class $DefaultEmojiCompatConfig$Type
    extends jni$_.JObjType<DefaultEmojiCompatConfig> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/DefaultEmojiCompatConfig;';

  @jni$_.internal
  @core$_.override
  DefaultEmojiCompatConfig fromReference(jni$_.JReference reference) =>
      DefaultEmojiCompatConfig.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DefaultEmojiCompatConfig?> get nullableType =>
      const $DefaultEmojiCompatConfig$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DefaultEmojiCompatConfig$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DefaultEmojiCompatConfig$Type) &&
        other is $DefaultEmojiCompatConfig$Type;
  }
}

/// from: `android.os.Build$Partition`
class Build_Partition extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Build_Partition> $type;

  @jni$_.internal
  Build_Partition.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/os/Build$Partition');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Build_Partition$NullableType();
  static const type = $Build_Partition$Type();
  static final _id_PARTITION_NAME_SYSTEM = _class.staticFieldId(
    r'PARTITION_NAME_SYSTEM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PARTITION_NAME_SYSTEM`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PARTITION_NAME_SYSTEM =>
      _id_PARTITION_NAME_SYSTEM.get(_class, const jni$_.JStringNullableType());

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() {
    return _getName(reference.pointer, _id_getName as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getFingerprint = _class.instanceMethodId(
    r'getFingerprint',
    r'()Ljava/lang/String;',
  );

  static final _getFingerprint = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getFingerprint()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getFingerprint() {
    return _getFingerprint(
            reference.pointer, _id_getFingerprint as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getBuildTimeMillis = _class.instanceMethodId(
    r'getBuildTimeMillis',
    r'()J',
  );

  static final _getBuildTimeMillis = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getBuildTimeMillis()`
  int getBuildTimeMillis() {
    return _getBuildTimeMillis(
            reference.pointer, _id_getBuildTimeMillis as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }
}

final class $Build_Partition$NullableType
    extends jni$_.JObjType<Build_Partition?> {
  @jni$_.internal
  const $Build_Partition$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$Partition;';

  @jni$_.internal
  @core$_.override
  Build_Partition? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Build_Partition.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build_Partition?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build_Partition$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_Partition$NullableType) &&
        other is $Build_Partition$NullableType;
  }
}

final class $Build_Partition$Type extends jni$_.JObjType<Build_Partition> {
  @jni$_.internal
  const $Build_Partition$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$Partition;';

  @jni$_.internal
  @core$_.override
  Build_Partition fromReference(jni$_.JReference reference) =>
      Build_Partition.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build_Partition?> get nullableType =>
      const $Build_Partition$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build_Partition$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_Partition$Type) &&
        other is $Build_Partition$Type;
  }
}

/// from: `android.os.Build$VERSION`
class Build_VERSION extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Build_VERSION> $type;

  @jni$_.internal
  Build_VERSION.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/os/Build$VERSION');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Build_VERSION$NullableType();
  static const type = $Build_VERSION$Type();
  static final _id_BASE_OS = _class.staticFieldId(
    r'BASE_OS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BASE_OS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BASE_OS =>
      _id_BASE_OS.get(_class, const jni$_.JStringNullableType());

  static final _id_CODENAME = _class.staticFieldId(
    r'CODENAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CODENAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CODENAME =>
      _id_CODENAME.get(_class, const jni$_.JStringNullableType());

  static final _id_INCREMENTAL = _class.staticFieldId(
    r'INCREMENTAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String INCREMENTAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get INCREMENTAL =>
      _id_INCREMENTAL.get(_class, const jni$_.JStringNullableType());

  static final _id_MEDIA_PERFORMANCE_CLASS = _class.staticFieldId(
    r'MEDIA_PERFORMANCE_CLASS',
    r'I',
  );

  /// from: `static public final int MEDIA_PERFORMANCE_CLASS`
  static int get MEDIA_PERFORMANCE_CLASS =>
      _id_MEDIA_PERFORMANCE_CLASS.get(_class, const jni$_.jintType());

  static final _id_PREVIEW_SDK_INT = _class.staticFieldId(
    r'PREVIEW_SDK_INT',
    r'I',
  );

  /// from: `static public final int PREVIEW_SDK_INT`
  static int get PREVIEW_SDK_INT =>
      _id_PREVIEW_SDK_INT.get(_class, const jni$_.jintType());

  static final _id_RELEASE = _class.staticFieldId(
    r'RELEASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RELEASE =>
      _id_RELEASE.get(_class, const jni$_.JStringNullableType());

  static final _id_RELEASE_OR_CODENAME = _class.staticFieldId(
    r'RELEASE_OR_CODENAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE_OR_CODENAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RELEASE_OR_CODENAME =>
      _id_RELEASE_OR_CODENAME.get(_class, const jni$_.JStringNullableType());

  static final _id_RELEASE_OR_PREVIEW_DISPLAY = _class.staticFieldId(
    r'RELEASE_OR_PREVIEW_DISPLAY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE_OR_PREVIEW_DISPLAY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RELEASE_OR_PREVIEW_DISPLAY =>
      _id_RELEASE_OR_PREVIEW_DISPLAY.get(
          _class, const jni$_.JStringNullableType());

  static final _id_SDK = _class.staticFieldId(
    r'SDK',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SDK`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SDK =>
      _id_SDK.get(_class, const jni$_.JStringNullableType());

  static final _id_SDK_INT = _class.staticFieldId(
    r'SDK_INT',
    r'I',
  );

  /// from: `static public final int SDK_INT`
  static int get SDK_INT => _id_SDK_INT.get(_class, const jni$_.jintType());

  static final _id_SECURITY_PATCH = _class.staticFieldId(
    r'SECURITY_PATCH',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SECURITY_PATCH`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SECURITY_PATCH =>
      _id_SECURITY_PATCH.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build_VERSION() {
    return Build_VERSION.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $Build_VERSION$NullableType extends jni$_.JObjType<Build_VERSION?> {
  @jni$_.internal
  const $Build_VERSION$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$VERSION;';

  @jni$_.internal
  @core$_.override
  Build_VERSION? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Build_VERSION.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build_VERSION?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build_VERSION$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_VERSION$NullableType) &&
        other is $Build_VERSION$NullableType;
  }
}

final class $Build_VERSION$Type extends jni$_.JObjType<Build_VERSION> {
  @jni$_.internal
  const $Build_VERSION$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$VERSION;';

  @jni$_.internal
  @core$_.override
  Build_VERSION fromReference(jni$_.JReference reference) =>
      Build_VERSION.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build_VERSION?> get nullableType =>
      const $Build_VERSION$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build_VERSION$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_VERSION$Type) &&
        other is $Build_VERSION$Type;
  }
}

/// from: `android.os.Build$VERSION_CODES`
class Build_VERSION_CODES extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Build_VERSION_CODES> $type;

  @jni$_.internal
  Build_VERSION_CODES.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/os/Build$VERSION_CODES');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Build_VERSION_CODES$NullableType();
  static const type = $Build_VERSION_CODES$Type();

  /// from: `static public final int BASE`
  static const BASE = 1;

  /// from: `static public final int BASE_1_1`
  static const BASE_1_1 = 2;

  /// from: `static public final int CUPCAKE`
  static const CUPCAKE = 3;

  /// from: `static public final int CUR_DEVELOPMENT`
  static const CUR_DEVELOPMENT = 10000;

  /// from: `static public final int DONUT`
  static const DONUT = 4;

  /// from: `static public final int ECLAIR`
  static const ECLAIR = 5;

  /// from: `static public final int ECLAIR_0_1`
  static const ECLAIR_0_1 = 6;

  /// from: `static public final int ECLAIR_MR1`
  static const ECLAIR_MR1 = 7;

  /// from: `static public final int FROYO`
  static const FROYO = 8;

  /// from: `static public final int GINGERBREAD`
  static const GINGERBREAD = 9;

  /// from: `static public final int GINGERBREAD_MR1`
  static const GINGERBREAD_MR1 = 10;

  /// from: `static public final int HONEYCOMB`
  static const HONEYCOMB = 11;

  /// from: `static public final int HONEYCOMB_MR1`
  static const HONEYCOMB_MR1 = 12;

  /// from: `static public final int HONEYCOMB_MR2`
  static const HONEYCOMB_MR2 = 13;

  /// from: `static public final int ICE_CREAM_SANDWICH`
  static const ICE_CREAM_SANDWICH = 14;

  /// from: `static public final int ICE_CREAM_SANDWICH_MR1`
  static const ICE_CREAM_SANDWICH_MR1 = 15;

  /// from: `static public final int JELLY_BEAN`
  static const JELLY_BEAN = 16;

  /// from: `static public final int JELLY_BEAN_MR1`
  static const JELLY_BEAN_MR1 = 17;

  /// from: `static public final int JELLY_BEAN_MR2`
  static const JELLY_BEAN_MR2 = 18;

  /// from: `static public final int KITKAT`
  static const KITKAT = 19;

  /// from: `static public final int KITKAT_WATCH`
  static const KITKAT_WATCH = 20;

  /// from: `static public final int LOLLIPOP`
  static const LOLLIPOP = 21;

  /// from: `static public final int LOLLIPOP_MR1`
  static const LOLLIPOP_MR1 = 22;

  /// from: `static public final int M`
  static const M = 23;

  /// from: `static public final int N`
  static const N = 24;

  /// from: `static public final int N_MR1`
  static const N_MR1 = 25;

  /// from: `static public final int O`
  static const O = 26;

  /// from: `static public final int O_MR1`
  static const O_MR1 = 27;

  /// from: `static public final int P`
  static const P = 28;

  /// from: `static public final int Q`
  static const Q = 29;

  /// from: `static public final int R`
  static const R = 30;

  /// from: `static public final int S`
  static const S = 31;

  /// from: `static public final int S_V2`
  static const S_V2 = 32;

  /// from: `static public final int TIRAMISU`
  static const TIRAMISU = 33;

  /// from: `static public final int UPSIDE_DOWN_CAKE`
  static const UPSIDE_DOWN_CAKE = 34;

  /// from: `static public final int VANILLA_ICE_CREAM`
  static const VANILLA_ICE_CREAM = 35;
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build_VERSION_CODES() {
    return Build_VERSION_CODES.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }
}

final class $Build_VERSION_CODES$NullableType
    extends jni$_.JObjType<Build_VERSION_CODES?> {
  @jni$_.internal
  const $Build_VERSION_CODES$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$VERSION_CODES;';

  @jni$_.internal
  @core$_.override
  Build_VERSION_CODES? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Build_VERSION_CODES.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build_VERSION_CODES?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build_VERSION_CODES$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_VERSION_CODES$NullableType) &&
        other is $Build_VERSION_CODES$NullableType;
  }
}

final class $Build_VERSION_CODES$Type
    extends jni$_.JObjType<Build_VERSION_CODES> {
  @jni$_.internal
  const $Build_VERSION_CODES$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$VERSION_CODES;';

  @jni$_.internal
  @core$_.override
  Build_VERSION_CODES fromReference(jni$_.JReference reference) =>
      Build_VERSION_CODES.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build_VERSION_CODES?> get nullableType =>
      const $Build_VERSION_CODES$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build_VERSION_CODES$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_VERSION_CODES$Type) &&
        other is $Build_VERSION_CODES$Type;
  }
}

/// from: `android.os.Build`
class Build extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Build> $type;

  @jni$_.internal
  Build.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/os/Build');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Build$NullableType();
  static const type = $Build$Type();
  static final _id_BOARD = _class.staticFieldId(
    r'BOARD',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BOARD`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BOARD =>
      _id_BOARD.get(_class, const jni$_.JStringNullableType());

  static final _id_BOOTLOADER = _class.staticFieldId(
    r'BOOTLOADER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BOOTLOADER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BOOTLOADER =>
      _id_BOOTLOADER.get(_class, const jni$_.JStringNullableType());

  static final _id_BRAND = _class.staticFieldId(
    r'BRAND',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BRAND`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BRAND =>
      _id_BRAND.get(_class, const jni$_.JStringNullableType());

  static final _id_CPU_ABI = _class.staticFieldId(
    r'CPU_ABI',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CPU_ABI`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CPU_ABI =>
      _id_CPU_ABI.get(_class, const jni$_.JStringNullableType());

  static final _id_CPU_ABI2 = _class.staticFieldId(
    r'CPU_ABI2',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CPU_ABI2`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CPU_ABI2 =>
      _id_CPU_ABI2.get(_class, const jni$_.JStringNullableType());

  static final _id_DEVICE = _class.staticFieldId(
    r'DEVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DEVICE =>
      _id_DEVICE.get(_class, const jni$_.JStringNullableType());

  static final _id_DISPLAY = _class.staticFieldId(
    r'DISPLAY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DISPLAY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DISPLAY =>
      _id_DISPLAY.get(_class, const jni$_.JStringNullableType());

  static final _id_FINGERPRINT = _class.staticFieldId(
    r'FINGERPRINT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FINGERPRINT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get FINGERPRINT =>
      _id_FINGERPRINT.get(_class, const jni$_.JStringNullableType());

  static final _id_HARDWARE = _class.staticFieldId(
    r'HARDWARE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HARDWARE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get HARDWARE =>
      _id_HARDWARE.get(_class, const jni$_.JStringNullableType());

  static final _id_HOST = _class.staticFieldId(
    r'HOST',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HOST`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get HOST =>
      _id_HOST.get(_class, const jni$_.JStringNullableType());

  static final _id_ID = _class.staticFieldId(
    r'ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ID =>
      _id_ID.get(_class, const jni$_.JStringNullableType());

  static final _id_MANUFACTURER = _class.staticFieldId(
    r'MANUFACTURER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MANUFACTURER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MANUFACTURER =>
      _id_MANUFACTURER.get(_class, const jni$_.JStringNullableType());

  static final _id_MODEL = _class.staticFieldId(
    r'MODEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MODEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MODEL =>
      _id_MODEL.get(_class, const jni$_.JStringNullableType());

  static final _id_ODM_SKU = _class.staticFieldId(
    r'ODM_SKU',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ODM_SKU`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ODM_SKU =>
      _id_ODM_SKU.get(_class, const jni$_.JStringNullableType());

  static final _id_PRODUCT = _class.staticFieldId(
    r'PRODUCT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PRODUCT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PRODUCT =>
      _id_PRODUCT.get(_class, const jni$_.JStringNullableType());

  static final _id_RADIO = _class.staticFieldId(
    r'RADIO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RADIO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RADIO =>
      _id_RADIO.get(_class, const jni$_.JStringNullableType());

  static final _id_SERIAL = _class.staticFieldId(
    r'SERIAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SERIAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SERIAL =>
      _id_SERIAL.get(_class, const jni$_.JStringNullableType());

  static final _id_SKU = _class.staticFieldId(
    r'SKU',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SKU`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SKU =>
      _id_SKU.get(_class, const jni$_.JStringNullableType());

  static final _id_SOC_MANUFACTURER = _class.staticFieldId(
    r'SOC_MANUFACTURER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SOC_MANUFACTURER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SOC_MANUFACTURER =>
      _id_SOC_MANUFACTURER.get(_class, const jni$_.JStringNullableType());

  static final _id_SOC_MODEL = _class.staticFieldId(
    r'SOC_MODEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SOC_MODEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SOC_MODEL =>
      _id_SOC_MODEL.get(_class, const jni$_.JStringNullableType());

  static final _id_SUPPORTED_32_BIT_ABIS = _class.staticFieldId(
    r'SUPPORTED_32_BIT_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_32_BIT_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get SUPPORTED_32_BIT_ABIS =>
      _id_SUPPORTED_32_BIT_ABIS.get(
          _class,
          const jni$_.JArrayNullableType<jni$_.JString?>(
              jni$_.JStringNullableType()));

  static final _id_SUPPORTED_64_BIT_ABIS = _class.staticFieldId(
    r'SUPPORTED_64_BIT_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_64_BIT_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get SUPPORTED_64_BIT_ABIS =>
      _id_SUPPORTED_64_BIT_ABIS.get(
          _class,
          const jni$_.JArrayNullableType<jni$_.JString?>(
              jni$_.JStringNullableType()));

  static final _id_SUPPORTED_ABIS = _class.staticFieldId(
    r'SUPPORTED_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get SUPPORTED_ABIS => _id_SUPPORTED_ABIS
      .get(
          _class,
          const jni$_.JArrayNullableType<jni$_.JString?>(
              jni$_.JStringNullableType()));

  static final _id_TAGS = _class.staticFieldId(
    r'TAGS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TAGS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TAGS =>
      _id_TAGS.get(_class, const jni$_.JStringNullableType());

  static final _id_TIME = _class.staticFieldId(
    r'TIME',
    r'J',
  );

  /// from: `static public final long TIME`
  static int get TIME => _id_TIME.get(_class, const jni$_.jlongType());

  static final _id_TYPE = _class.staticFieldId(
    r'TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TYPE =>
      _id_TYPE.get(_class, const jni$_.JStringNullableType());

  static final _id_UNKNOWN = _class.staticFieldId(
    r'UNKNOWN',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String UNKNOWN`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get UNKNOWN =>
      _id_UNKNOWN.get(_class, const jni$_.JStringNullableType());

  static final _id_USER = _class.staticFieldId(
    r'USER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get USER =>
      _id_USER.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build() {
    return Build.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getSerial = _class.staticMethodId(
    r'getSerial',
    r'()Ljava/lang/String;',
  );

  static final _getSerial = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String getSerial()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? getSerial() {
    return _getSerial(
            _class.reference.pointer, _id_getSerial as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getFingerprintedPartitions = _class.staticMethodId(
    r'getFingerprintedPartitions',
    r'()Ljava/util/List;',
  );

  static final _getFingerprintedPartitions =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `static public java.util.List getFingerprintedPartitions()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JList<Build_Partition?>? getFingerprintedPartitions() {
    return _getFingerprintedPartitions(_class.reference.pointer,
            _id_getFingerprintedPartitions as jni$_.JMethodIDPtr)
        .object<jni$_.JList<Build_Partition?>?>(
            const jni$_.JListNullableType<Build_Partition?>(
                $Build_Partition$NullableType()));
  }

  static final _id_getRadioVersion = _class.staticMethodId(
    r'getRadioVersion',
    r'()Ljava/lang/String;',
  );

  static final _getRadioVersion = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String getRadioVersion()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? getRadioVersion() {
    return _getRadioVersion(
            _class.reference.pointer, _id_getRadioVersion as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $Build$NullableType extends jni$_.JObjType<Build?> {
  @jni$_.internal
  const $Build$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build;';

  @jni$_.internal
  @core$_.override
  Build? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Build.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build$NullableType) &&
        other is $Build$NullableType;
  }
}

final class $Build$Type extends jni$_.JObjType<Build> {
  @jni$_.internal
  const $Build$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build;';

  @jni$_.internal
  @core$_.override
  Build fromReference(jni$_.JReference reference) => Build.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Build?> get nullableType => const $Build$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Build$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build$Type) && other is $Build$Type;
  }
}

/// from: `java.util.HashMap`
class HashMap<$K extends jni$_.JObject?, $V extends jni$_.JObject?>
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<HashMap<$K, $V>> $type;

  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  HashMap.fromReference(
    this.K,
    this.V,
    jni$_.JReference reference,
  )   : $type = type<$K, $V>(K, V),
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/util/HashMap');

  /// The type which includes information such as the signature of this class.
  static $HashMap$NullableType<$K, $V>
      nullableType<$K extends jni$_.JObject?, $V extends jni$_.JObject?>(
    jni$_.JObjType<$K> K,
    jni$_.JObjType<$V> V,
  ) {
    return $HashMap$NullableType<$K, $V>(
      K,
      V,
    );
  }

  static $HashMap$Type<$K, $V>
      type<$K extends jni$_.JObject?, $V extends jni$_.JObject?>(
    jni$_.JObjType<$K> K,
    jni$_.JObjType<$V> V,
  ) {
    return $HashMap$Type<$K, $V>(
      K,
      V,
    );
  }

  static final _id_new$ = _class.constructorId(
    r'(IF)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Double)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, double)>();

  /// from: `public void <init>(int i, float f)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap(
    int i,
    double f, {
    required jni$_.JObjType<$K> K,
    required jni$_.JObjType<$V> V,
  }) {
    return HashMap<$K, $V>.fromReference(
        K,
        V,
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr, i, f)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(I)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$1(
    int i, {
    required jni$_.JObjType<$K> K,
    required jni$_.JObjType<$V> V,
  }) {
    return HashMap<$K, $V>.fromReference(
        K,
        V,
        _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr, i)
            .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'()V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$2({
    required jni$_.JObjType<$K> K,
    required jni$_.JObjType<$V> V,
  }) {
    return HashMap<$K, $V>.fromReference(
        K,
        V,
        _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/util/Map;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.util.Map map)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$3(
    jni$_.JMap<$K?, $V?>? map, {
    required jni$_.JObjType<$K> K,
    required jni$_.JObjType<$V> V,
  }) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return HashMap<$K, $V>.fromReference(
        K,
        V,
        _new$3(_class.reference.pointer, _id_new$3 as jni$_.JMethodIDPtr,
                _$map.pointer)
            .reference);
  }

  static final _id_size = _class.instanceMethodId(
    r'size',
    r'()I',
  );

  static final _size = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int size()`
  int size() {
    return _size(reference.pointer, _id_size as jni$_.JMethodIDPtr).integer;
  }

  static final _id_isEmpty = _class.instanceMethodId(
    r'isEmpty',
    r'()Z',
  );

  static final _isEmpty = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEmpty()`
  bool isEmpty() {
    return _isEmpty(reference.pointer, _id_isEmpty as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _get = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V get(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? get(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _get(
            reference.pointer, _id_get as jni$_.JMethodIDPtr, _$object.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_containsKey = _class.instanceMethodId(
    r'containsKey',
    r'(Ljava/lang/Object;)Z',
  );

  static final _containsKey = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean containsKey(java.lang.Object object)`
  bool containsKey(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _containsKey(reference.pointer,
            _id_containsKey as jni$_.JMethodIDPtr, _$object.pointer)
        .boolean;
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _put = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V put(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? put(
    $K? object,
    $V? object1,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _put(reference.pointer, _id_put as jni$_.JMethodIDPtr,
            _$object.pointer, _$object1.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_putAll = _class.instanceMethodId(
    r'putAll',
    r'(Ljava/util/Map;)V',
  );

  static final _putAll = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void putAll(java.util.Map map)`
  void putAll(
    jni$_.JMap<$K?, $V?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _putAll(reference.pointer, _id_putAll as jni$_.JMethodIDPtr, _$map.pointer)
        .check();
  }

  static final _id_remove = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _remove = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V remove(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? remove(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _remove(reference.pointer, _id_remove as jni$_.JMethodIDPtr,
            _$object.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_clear = _class.instanceMethodId(
    r'clear',
    r'()V',
  );

  static final _clear = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clear()`
  void clear() {
    _clear(reference.pointer, _id_clear as jni$_.JMethodIDPtr).check();
  }

  static final _id_containsValue = _class.instanceMethodId(
    r'containsValue',
    r'(Ljava/lang/Object;)Z',
  );

  static final _containsValue = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean containsValue(java.lang.Object object)`
  bool containsValue(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _containsValue(reference.pointer,
            _id_containsValue as jni$_.JMethodIDPtr, _$object.pointer)
        .boolean;
  }

  static final _id_keySet = _class.instanceMethodId(
    r'keySet',
    r'()Ljava/util/Set;',
  );

  static final _keySet = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Set keySet()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<$K?>? keySet() {
    return _keySet(reference.pointer, _id_keySet as jni$_.JMethodIDPtr)
        .object<jni$_.JSet<$K?>?>(jni$_.JSetNullableType<$K?>(K.nullableType));
  }

  static final _id_values = _class.instanceMethodId(
    r'values',
    r'()Ljava/util/Collection;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Collection values()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? values() {
    return _values(reference.pointer, _id_values as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_entrySet = _class.instanceMethodId(
    r'entrySet',
    r'()Ljava/util/Set;',
  );

  static final _entrySet = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Set entrySet()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JObject?>? entrySet() {
    return _entrySet(reference.pointer, _id_entrySet as jni$_.JMethodIDPtr)
        .object<jni$_.JSet<jni$_.JObject?>?>(
            const jni$_.JSetNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getOrDefault = _class.instanceMethodId(
    r'getOrDefault',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _getOrDefault = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V getOrDefault(java.lang.Object object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? getOrDefault(
    jni$_.JObject? object,
    $V? object1,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _getOrDefault(
            reference.pointer,
            _id_getOrDefault as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$object1.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_putIfAbsent = _class.instanceMethodId(
    r'putIfAbsent',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _putIfAbsent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V putIfAbsent(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? putIfAbsent(
    $K? object,
    $V? object1,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _putIfAbsent(
            reference.pointer,
            _id_putIfAbsent as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$object1.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_remove$1 = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Z',
  );

  static final _remove$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean remove(java.lang.Object object, java.lang.Object object1)`
  bool remove$1(
    jni$_.JObject? object,
    jni$_.JObject? object1,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _remove$1(reference.pointer, _id_remove$1 as jni$_.JMethodIDPtr,
            _$object.pointer, _$object1.pointer)
        .boolean;
  }

  static final _id_replace = _class.instanceMethodId(
    r'replace',
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Z',
  );

  static final _replace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean replace(K object, V object1, V object2)`
  bool replace(
    $K? object,
    $V? object1,
    $V? object2,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    final _$object2 = object2?.reference ?? jni$_.jNullReference;
    return _replace(reference.pointer, _id_replace as jni$_.JMethodIDPtr,
            _$object.pointer, _$object1.pointer, _$object2.pointer)
        .boolean;
  }

  static final _id_replace$1 = _class.instanceMethodId(
    r'replace',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _replace$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V replace(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? replace$1(
    $K? object,
    $V? object1,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _replace$1(reference.pointer, _id_replace$1 as jni$_.JMethodIDPtr,
            _$object.pointer, _$object1.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_computeIfAbsent = _class.instanceMethodId(
    r'computeIfAbsent',
    r'(Ljava/lang/Object;Ljava/util/function/Function;)Ljava/lang/Object;',
  );

  static final _computeIfAbsent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V computeIfAbsent(K object, java.util.function.Function function)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? computeIfAbsent(
    $K? object,
    jni$_.JObject? function,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$function = function?.reference ?? jni$_.jNullReference;
    return _computeIfAbsent(
            reference.pointer,
            _id_computeIfAbsent as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$function.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_computeIfPresent = _class.instanceMethodId(
    r'computeIfPresent',
    r'(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _computeIfPresent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V computeIfPresent(K object, java.util.function.BiFunction biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? computeIfPresent(
    $K? object,
    jni$_.JObject? biFunction,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$biFunction = biFunction?.reference ?? jni$_.jNullReference;
    return _computeIfPresent(
            reference.pointer,
            _id_computeIfPresent as jni$_.JMethodIDPtr,
            _$object.pointer,
            _$biFunction.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_compute = _class.instanceMethodId(
    r'compute',
    r'(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _compute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V compute(K object, java.util.function.BiFunction biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? compute(
    $K? object,
    jni$_.JObject? biFunction,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$biFunction = biFunction?.reference ?? jni$_.jNullReference;
    return _compute(reference.pointer, _id_compute as jni$_.JMethodIDPtr,
            _$object.pointer, _$biFunction.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_merge = _class.instanceMethodId(
    r'merge',
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _merge = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V merge(K object, V object1, java.util.function.BiFunction biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? merge(
    $K? object,
    $V? object1,
    jni$_.JObject? biFunction,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    final _$biFunction = biFunction?.reference ?? jni$_.jNullReference;
    return _merge(reference.pointer, _id_merge as jni$_.JMethodIDPtr,
            _$object.pointer, _$object1.pointer, _$biFunction.pointer)
        .object<$V?>(V.nullableType);
  }

  static final _id_forEach = _class.instanceMethodId(
    r'forEach',
    r'(Ljava/util/function/BiConsumer;)V',
  );

  static final _forEach = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void forEach(java.util.function.BiConsumer biConsumer)`
  void forEach(
    jni$_.JObject? biConsumer,
  ) {
    final _$biConsumer = biConsumer?.reference ?? jni$_.jNullReference;
    _forEach(reference.pointer, _id_forEach as jni$_.JMethodIDPtr,
            _$biConsumer.pointer)
        .check();
  }

  static final _id_replaceAll = _class.instanceMethodId(
    r'replaceAll',
    r'(Ljava/util/function/BiFunction;)V',
  );

  static final _replaceAll = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void replaceAll(java.util.function.BiFunction biFunction)`
  void replaceAll(
    jni$_.JObject? biFunction,
  ) {
    final _$biFunction = biFunction?.reference ?? jni$_.jNullReference;
    _replaceAll(reference.pointer, _id_replaceAll as jni$_.JMethodIDPtr,
            _$biFunction.pointer)
        .check();
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() {
    return _clone(reference.pointer, _id_clone as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_newHashMap = _class.staticMethodId(
    r'newHashMap',
    r'(I)Ljava/util/HashMap;',
  );

  static final _newHashMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.util.HashMap newHashMap(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static HashMap<$K?, $V?>?
      newHashMap<$K extends jni$_.JObject?, $V extends jni$_.JObject?>(
    int i, {
    required jni$_.JObjType<$K> K,
    required jni$_.JObjType<$V> V,
  }) {
    return _newHashMap(
            _class.reference.pointer, _id_newHashMap as jni$_.JMethodIDPtr, i)
        .object<HashMap<$K?, $V?>?>(
            $HashMap$NullableType<$K?, $V?>(K.nullableType, V.nullableType));
  }
}

final class $HashMap$NullableType<$K extends jni$_.JObject?,
    $V extends jni$_.JObject?> extends jni$_.JObjType<HashMap<$K, $V>?> {
  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  const $HashMap$NullableType(
    this.K,
    this.V,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/HashMap;';

  @jni$_.internal
  @core$_.override
  HashMap<$K, $V>? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : HashMap<$K, $V>.fromReference(
          K,
          V,
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HashMap<$K, $V>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($HashMap$NullableType, K, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($HashMap$NullableType<$K, $V>) &&
        other is $HashMap$NullableType<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

final class $HashMap$Type<$K extends jni$_.JObject?, $V extends jni$_.JObject?>
    extends jni$_.JObjType<HashMap<$K, $V>> {
  @jni$_.internal
  final jni$_.JObjType<$K> K;

  @jni$_.internal
  final jni$_.JObjType<$V> V;

  @jni$_.internal
  const $HashMap$Type(
    this.K,
    this.V,
  );

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/HashMap;';

  @jni$_.internal
  @core$_.override
  HashMap<$K, $V> fromReference(jni$_.JReference reference) =>
      HashMap<$K, $V>.fromReference(
        K,
        V,
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HashMap<$K, $V>?> get nullableType =>
      $HashMap$NullableType<$K, $V>(K, V);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($HashMap$Type, K, V);

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($HashMap$Type<$K, $V>) &&
        other is $HashMap$Type<$K, $V> &&
        K == other.K &&
        V == other.V;
  }
}

/// from: `com.example.in_app_java.AndroidUtils`
class AndroidUtils extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AndroidUtils> $type;

  @jni$_.internal
  AndroidUtils.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'com/example/in_app_java/AndroidUtils');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AndroidUtils$NullableType();
  static const type = $AndroidUtils$Type();
  static final _id_showToast = _class.staticMethodId(
    r'showToast',
    r'(Landroid/app/Activity;Ljava/lang/CharSequence;I)V',
  );

  static final _showToast = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public void showToast(android.app.Activity mainActivity, java.lang.CharSequence text, int duration)`
  static void showToast(
    jni$_.JObject? mainActivity,
    jni$_.JObject? text,
    int duration,
  ) {
    final _$mainActivity = mainActivity?.reference ?? jni$_.jNullReference;
    final _$text = text?.reference ?? jni$_.jNullReference;
    _showToast(_class.reference.pointer, _id_showToast as jni$_.JMethodIDPtr,
            _$mainActivity.pointer, _$text.pointer, duration)
        .check();
  }
}

final class $AndroidUtils$NullableType extends jni$_.JObjType<AndroidUtils?> {
  @jni$_.internal
  const $AndroidUtils$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/AndroidUtils;';

  @jni$_.internal
  @core$_.override
  AndroidUtils? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : AndroidUtils.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AndroidUtils?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AndroidUtils$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AndroidUtils$NullableType) &&
        other is $AndroidUtils$NullableType;
  }
}

final class $AndroidUtils$Type extends jni$_.JObjType<AndroidUtils> {
  @jni$_.internal
  const $AndroidUtils$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/AndroidUtils;';

  @jni$_.internal
  @core$_.override
  AndroidUtils fromReference(jni$_.JReference reference) =>
      AndroidUtils.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AndroidUtils?> get nullableType =>
      const $AndroidUtils$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AndroidUtils$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($AndroidUtils$Type) &&
        other is $AndroidUtils$Type;
  }
}
