// AUTO GENERATED BY JNIGEN 0.15.1. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `com.example.in_app_java.R$drawable`
extension type R$drawable._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/example/in_app_java/R$drawable');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<R$drawable> type = $R$drawable$Type$();
  static final _id_launch_background = _class.staticFieldId(
    r'launch_background',
    r'I',
  );

  /// from: `static public int launch_background`
  static int get launch_background =>
      _id_launch_background.get(_class, jni$_.jint.type) as int;

  /// from: `static public int launch_background`
  static set launch_background(int value) =>
      _id_launch_background.set(_class, jni$_.jint.type, value);
}

final class $R$drawable$Type$ extends jni$_.JType<R$drawable> {
  @jni$_.internal
  const $R$drawable$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/R$drawable;';
}

/// from: `com.example.in_app_java.R$mipmap`
extension type R$mipmap._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/example/in_app_java/R$mipmap');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<R$mipmap> type = $R$mipmap$Type$();
  static final _id_ic_launcher = _class.staticFieldId(
    r'ic_launcher',
    r'I',
  );

  /// from: `static public int ic_launcher`
  static int get ic_launcher =>
      _id_ic_launcher.get(_class, jni$_.jint.type) as int;

  /// from: `static public int ic_launcher`
  static set ic_launcher(int value) =>
      _id_ic_launcher.set(_class, jni$_.jint.type, value);
}

final class $R$mipmap$Type$ extends jni$_.JType<R$mipmap> {
  @jni$_.internal
  const $R$mipmap$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/R$mipmap;';
}

/// from: `com.example.in_app_java.R$style`
extension type R$style._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/example/in_app_java/R$style');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<R$style> type = $R$style$Type$();
  static final _id_LaunchTheme = _class.staticFieldId(
    r'LaunchTheme',
    r'I',
  );

  /// from: `static public int LaunchTheme`
  static int get LaunchTheme =>
      _id_LaunchTheme.get(_class, jni$_.jint.type) as int;

  /// from: `static public int LaunchTheme`
  static set LaunchTheme(int value) =>
      _id_LaunchTheme.set(_class, jni$_.jint.type, value);

  static final _id_NormalTheme = _class.staticFieldId(
    r'NormalTheme',
    r'I',
  );

  /// from: `static public int NormalTheme`
  static int get NormalTheme =>
      _id_NormalTheme.get(_class, jni$_.jint.type) as int;

  /// from: `static public int NormalTheme`
  static set NormalTheme(int value) =>
      _id_NormalTheme.set(_class, jni$_.jint.type, value);
}

final class $R$style$Type$ extends jni$_.JType<R$style> {
  @jni$_.internal
  const $R$style$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/R$style;';
}

/// from: `com.example.in_app_java.R`
extension type R._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(r'com/example/in_app_java/R');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<R> type = $R$Type$();
}

final class $R$Type$ extends jni$_.JType<R> {
  @jni$_.internal
  const $R$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/R;';
}

/// from: `androidx.emoji2.text.EmojiCompat$CodepointSequenceMatchResult`
extension type EmojiCompat$CodepointSequenceMatchResult._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$CodepointSequenceMatchResult');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<EmojiCompat$CodepointSequenceMatchResult> type =
      $EmojiCompat$CodepointSequenceMatchResult$Type$();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $EmojiCompat$CodepointSequenceMatchResult>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $EmojiCompat$CodepointSequenceMatchResult $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$CodepointSequenceMatchResult',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat$CodepointSequenceMatchResult.implement(
    $EmojiCompat$CodepointSequenceMatchResult $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<EmojiCompat$CodepointSequenceMatchResult>();
  }
}

abstract base mixin class $EmojiCompat$CodepointSequenceMatchResult {
  factory $EmojiCompat$CodepointSequenceMatchResult() =
      _$EmojiCompat$CodepointSequenceMatchResult;
}

final class _$EmojiCompat$CodepointSequenceMatchResult
    with $EmojiCompat$CodepointSequenceMatchResult {
  _$EmojiCompat$CodepointSequenceMatchResult();
}

final class $EmojiCompat$CodepointSequenceMatchResult$Type$
    extends jni$_.JType<EmojiCompat$CodepointSequenceMatchResult> {
  @jni$_.internal
  const $EmojiCompat$CodepointSequenceMatchResult$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$CodepointSequenceMatchResult;';
}

/// from: `androidx.emoji2.text.EmojiCompat$Config`
extension type EmojiCompat$Config._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/EmojiCompat$Config');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<EmojiCompat$Config> type =
      $EmojiCompat$Config$Type$();
  static final _id_registerInitCallback = _class.instanceMethodId(
    r'registerInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _registerInitCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config registerInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat$Config registerInitCallback(
    EmojiCompat$InitCallback initCallback,
  ) {
    final _$initCallback = initCallback.reference;
    return _registerInitCallback(reference.pointer,
            _id_registerInitCallback.pointer, _$initCallback.pointer)
        .object<EmojiCompat$Config>();
  }

  static final _id_unregisterInitCallback = _class.instanceMethodId(
    r'unregisterInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _unregisterInitCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config unregisterInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat$Config unregisterInitCallback(
    EmojiCompat$InitCallback initCallback,
  ) {
    final _$initCallback = initCallback.reference;
    return _unregisterInitCallback(reference.pointer,
            _id_unregisterInitCallback.pointer, _$initCallback.pointer)
        .object<EmojiCompat$Config>();
  }

  static final _id_setReplaceAll = _class.instanceMethodId(
    r'setReplaceAll',
    r'(Z)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setReplaceAll = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setReplaceAll(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat$Config setReplaceAll(
    core$_.bool z,
  ) {
    return _setReplaceAll(
            reference.pointer, _id_setReplaceAll.pointer, z ? 1 : 0)
        .object<EmojiCompat$Config>();
  }

  static final _id_setUseEmojiAsDefaultStyle = _class.instanceMethodId(
    r'setUseEmojiAsDefaultStyle',
    r'(Z)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setUseEmojiAsDefaultStyle = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setUseEmojiAsDefaultStyle(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat$Config setUseEmojiAsDefaultStyle(
    core$_.bool z,
  ) {
    return _setUseEmojiAsDefaultStyle(
            reference.pointer, _id_setUseEmojiAsDefaultStyle.pointer, z ? 1 : 0)
        .object<EmojiCompat$Config>();
  }

  static final _id_setUseEmojiAsDefaultStyle$1 = _class.instanceMethodId(
    r'setUseEmojiAsDefaultStyle',
    r'(ZLjava/util/List;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setUseEmojiAsDefaultStyle$1 =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Int32,
                            jni$_.Pointer<jni$_.Void>
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setUseEmojiAsDefaultStyle(boolean z, java.util.List<java.lang.Integer> list)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat$Config setUseEmojiAsDefaultStyle$1(
    core$_.bool z,
    jni$_.JList<jni$_.JInteger?>? list,
  ) {
    final _$list = list?.reference ?? jni$_.jNullReference;
    return _setUseEmojiAsDefaultStyle$1(reference.pointer,
            _id_setUseEmojiAsDefaultStyle$1.pointer, z ? 1 : 0, _$list.pointer)
        .object<EmojiCompat$Config>();
  }

  static final _id_setEmojiSpanIndicatorEnabled = _class.instanceMethodId(
    r'setEmojiSpanIndicatorEnabled',
    r'(Z)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setEmojiSpanIndicatorEnabled =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setEmojiSpanIndicatorEnabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat$Config setEmojiSpanIndicatorEnabled(
    core$_.bool z,
  ) {
    return _setEmojiSpanIndicatorEnabled(reference.pointer,
            _id_setEmojiSpanIndicatorEnabled.pointer, z ? 1 : 0)
        .object<EmojiCompat$Config>();
  }

  static final _id_setEmojiSpanIndicatorColor = _class.instanceMethodId(
    r'setEmojiSpanIndicatorColor',
    r'(I)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setEmojiSpanIndicatorColor =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setEmojiSpanIndicatorColor(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat$Config setEmojiSpanIndicatorColor(
    int i,
  ) {
    return _setEmojiSpanIndicatorColor(
            reference.pointer, _id_setEmojiSpanIndicatorColor.pointer, i)
        .object<EmojiCompat$Config>();
  }

  static final _id_setMetadataLoadStrategy = _class.instanceMethodId(
    r'setMetadataLoadStrategy',
    r'(I)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setMetadataLoadStrategy = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setMetadataLoadStrategy(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat$Config setMetadataLoadStrategy(
    int i,
  ) {
    return _setMetadataLoadStrategy(
            reference.pointer, _id_setMetadataLoadStrategy.pointer, i)
        .object<EmojiCompat$Config>();
  }

  static final _id_setSpanFactory = _class.instanceMethodId(
    r'setSpanFactory',
    r'(Landroidx/emoji2/text/EmojiCompat$SpanFactory;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setSpanFactory = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setSpanFactory(androidx.emoji2.text.EmojiCompat$SpanFactory spanFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat$Config setSpanFactory(
    EmojiCompat$SpanFactory spanFactory,
  ) {
    final _$spanFactory = spanFactory.reference;
    return _setSpanFactory(reference.pointer, _id_setSpanFactory.pointer,
            _$spanFactory.pointer)
        .object<EmojiCompat$Config>();
  }

  static final _id_setGlyphChecker = _class.instanceMethodId(
    r'setGlyphChecker',
    r'(Landroidx/emoji2/text/EmojiCompat$GlyphChecker;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _setGlyphChecker = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config setGlyphChecker(androidx.emoji2.text.EmojiCompat$GlyphChecker glyphChecker)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat$Config setGlyphChecker(
    EmojiCompat$GlyphChecker glyphChecker,
  ) {
    final _$glyphChecker = glyphChecker.reference;
    return _setGlyphChecker(reference.pointer, _id_setGlyphChecker.pointer,
            _$glyphChecker.pointer)
        .object<EmojiCompat$Config>();
  }
}

final class $EmojiCompat$Config$Type$ extends jni$_.JType<EmojiCompat$Config> {
  @jni$_.internal
  const $EmojiCompat$Config$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$Config;';
}

/// from: `androidx.emoji2.text.EmojiCompat$DefaultSpanFactory`
extension type EmojiCompat$DefaultSpanFactory._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$DefaultSpanFactory');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<EmojiCompat$DefaultSpanFactory> type =
      $EmojiCompat$DefaultSpanFactory$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory EmojiCompat$DefaultSpanFactory() {
    return _new$(_class.reference.pointer, _id_new$.pointer)
        .object<EmojiCompat$DefaultSpanFactory>();
  }

  static final _id_createSpan = _class.instanceMethodId(
    r'createSpan',
    r'(Landroidx/emoji2/text/TypefaceEmojiRasterizer;)Landroidx/emoji2/text/EmojiSpan;',
  );

  static final _createSpan = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiSpan createSpan(androidx.emoji2.text.TypefaceEmojiRasterizer typefaceEmojiRasterizer)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject createSpan(
    jni$_.JObject typefaceEmojiRasterizer,
  ) {
    final _$typefaceEmojiRasterizer = typefaceEmojiRasterizer.reference;
    return _createSpan(reference.pointer, _id_createSpan.pointer,
            _$typefaceEmojiRasterizer.pointer)
        .object<jni$_.JObject>();
  }
}

final class $EmojiCompat$DefaultSpanFactory$Type$
    extends jni$_.JType<EmojiCompat$DefaultSpanFactory> {
  @jni$_.internal
  const $EmojiCompat$DefaultSpanFactory$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$DefaultSpanFactory;';
}

/// from: `androidx.emoji2.text.EmojiCompat$GlyphChecker`
extension type EmojiCompat$GlyphChecker._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/EmojiCompat$GlyphChecker');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<EmojiCompat$GlyphChecker> type =
      $EmojiCompat$GlyphChecker$Type$();
  static final _id_hasGlyph = _class.instanceMethodId(
    r'hasGlyph',
    r'(Ljava/lang/CharSequence;III)Z',
  );

  static final _hasGlyph = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int, int)>();

  /// from: `public abstract boolean hasGlyph(java.lang.CharSequence charSequence, int i, int i1, int i2)`
  core$_.bool hasGlyph(
    jni$_.JObject charSequence,
    int i,
    int i1,
    int i2,
  ) {
    final _$charSequence = charSequence.reference;
    return _hasGlyph(reference.pointer, _id_hasGlyph.pointer,
            _$charSequence.pointer, i, i1, i2)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $EmojiCompat$GlyphChecker> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'hasGlyph(Ljava/lang/CharSequence;III)Z') {
        final $r = _$impls[$p]!.hasGlyph(
          ($a![0] as jni$_.JObject),
          ($a![1] as jni$_.JInteger).intValue(releaseOriginal: true),
          ($a![2] as jni$_.JInteger).intValue(releaseOriginal: true),
          ($a![3] as jni$_.JInteger).intValue(releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $EmojiCompat$GlyphChecker $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$GlyphChecker',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat$GlyphChecker.implement(
    $EmojiCompat$GlyphChecker $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<EmojiCompat$GlyphChecker>();
  }
}

abstract base mixin class $EmojiCompat$GlyphChecker {
  factory $EmojiCompat$GlyphChecker({
    required core$_.bool Function(
            jni$_.JObject charSequence, int i, int i1, int i2)
        hasGlyph,
  }) = _$EmojiCompat$GlyphChecker;

  core$_.bool hasGlyph(jni$_.JObject charSequence, int i, int i1, int i2);
}

final class _$EmojiCompat$GlyphChecker with $EmojiCompat$GlyphChecker {
  _$EmojiCompat$GlyphChecker({
    required core$_.bool Function(
            jni$_.JObject charSequence, int i, int i1, int i2)
        hasGlyph,
  }) : _hasGlyph = hasGlyph;

  final core$_.bool Function(jni$_.JObject charSequence, int i, int i1, int i2)
      _hasGlyph;

  core$_.bool hasGlyph(jni$_.JObject charSequence, int i, int i1, int i2) {
    return _hasGlyph(charSequence, i, i1, i2);
  }
}

final class $EmojiCompat$GlyphChecker$Type$
    extends jni$_.JType<EmojiCompat$GlyphChecker> {
  @jni$_.internal
  const $EmojiCompat$GlyphChecker$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$GlyphChecker;';
}

/// from: `androidx.emoji2.text.EmojiCompat$InitCallback`
extension type EmojiCompat$InitCallback._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/EmojiCompat$InitCallback');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<EmojiCompat$InitCallback> type =
      $EmojiCompat$InitCallback$Type$();
  static final _id_onInitialized = _class.instanceMethodId(
    r'onInitialized',
    r'()V',
  );

  static final _onInitialized = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void onInitialized()`
  void onInitialized() {
    _onInitialized(reference.pointer, _id_onInitialized.pointer).check();
  }

  static final _id_onFailed = _class.instanceMethodId(
    r'onFailed',
    r'(Ljava/lang/Throwable;)V',
  );

  static final _onFailed = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onFailed(java.lang.Throwable throwable)`
  void onFailed(
    jni$_.JObject? throwable,
  ) {
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    _onFailed(reference.pointer, _id_onFailed.pointer, _$throwable.pointer)
        .check();
  }
}

final class $EmojiCompat$InitCallback$Type$
    extends jni$_.JType<EmojiCompat$InitCallback> {
  @jni$_.internal
  const $EmojiCompat$InitCallback$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$InitCallback;';
}

/// from: `androidx.emoji2.text.EmojiCompat$LoadStrategy`
extension type EmojiCompat$LoadStrategy._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/EmojiCompat$LoadStrategy');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<EmojiCompat$LoadStrategy> type =
      $EmojiCompat$LoadStrategy$Type$();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $EmojiCompat$LoadStrategy> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $EmojiCompat$LoadStrategy $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$LoadStrategy',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat$LoadStrategy.implement(
    $EmojiCompat$LoadStrategy $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<EmojiCompat$LoadStrategy>();
  }
}

abstract base mixin class $EmojiCompat$LoadStrategy {
  factory $EmojiCompat$LoadStrategy() = _$EmojiCompat$LoadStrategy;
}

final class _$EmojiCompat$LoadStrategy with $EmojiCompat$LoadStrategy {
  _$EmojiCompat$LoadStrategy();
}

final class $EmojiCompat$LoadStrategy$Type$
    extends jni$_.JType<EmojiCompat$LoadStrategy> {
  @jni$_.internal
  const $EmojiCompat$LoadStrategy$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$LoadStrategy;';
}

/// from: `androidx.emoji2.text.EmojiCompat$MetadataRepoLoader`
extension type EmojiCompat$MetadataRepoLoader._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$MetadataRepoLoader');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<EmojiCompat$MetadataRepoLoader> type =
      $EmojiCompat$MetadataRepoLoader$Type$();
  static final _id_load = _class.instanceMethodId(
    r'load',
    r'(Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;)V',
  );

  static final _load = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void load(androidx.emoji2.text.EmojiCompat$MetadataRepoLoaderCallback metadataRepoLoaderCallback)`
  void load(
    EmojiCompat$MetadataRepoLoaderCallback metadataRepoLoaderCallback,
  ) {
    final _$metadataRepoLoaderCallback = metadataRepoLoaderCallback.reference;
    _load(reference.pointer, _id_load.pointer,
            _$metadataRepoLoaderCallback.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $EmojiCompat$MetadataRepoLoader> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'load(Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;)V') {
        _$impls[$p]!.load(
          ($a![0] as EmojiCompat$MetadataRepoLoaderCallback),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $EmojiCompat$MetadataRepoLoader $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$MetadataRepoLoader',
      $p,
      _$invokePointer,
      [
        if ($impl.load$async)
          r'load(Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat$MetadataRepoLoader.implement(
    $EmojiCompat$MetadataRepoLoader $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<EmojiCompat$MetadataRepoLoader>();
  }
}

abstract base mixin class $EmojiCompat$MetadataRepoLoader {
  factory $EmojiCompat$MetadataRepoLoader({
    required void Function(
            EmojiCompat$MetadataRepoLoaderCallback metadataRepoLoaderCallback)
        load,
    core$_.bool load$async,
  }) = _$EmojiCompat$MetadataRepoLoader;

  void load(EmojiCompat$MetadataRepoLoaderCallback metadataRepoLoaderCallback);
  core$_.bool get load$async => false;
}

final class _$EmojiCompat$MetadataRepoLoader
    with $EmojiCompat$MetadataRepoLoader {
  _$EmojiCompat$MetadataRepoLoader({
    required void Function(
            EmojiCompat$MetadataRepoLoaderCallback metadataRepoLoaderCallback)
        load,
    this.load$async = false,
  }) : _load = load;

  final void Function(
      EmojiCompat$MetadataRepoLoaderCallback metadataRepoLoaderCallback) _load;
  final core$_.bool load$async;

  void load(EmojiCompat$MetadataRepoLoaderCallback metadataRepoLoaderCallback) {
    return _load(metadataRepoLoaderCallback);
  }
}

final class $EmojiCompat$MetadataRepoLoader$Type$
    extends jni$_.JType<EmojiCompat$MetadataRepoLoader> {
  @jni$_.internal
  const $EmojiCompat$MetadataRepoLoader$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoader;';
}

/// from: `androidx.emoji2.text.EmojiCompat$MetadataRepoLoaderCallback`
extension type EmojiCompat$MetadataRepoLoaderCallback._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<EmojiCompat$MetadataRepoLoaderCallback> type =
      $EmojiCompat$MetadataRepoLoaderCallback$Type$();
  static final _id_onLoaded = _class.instanceMethodId(
    r'onLoaded',
    r'(Landroidx/emoji2/text/MetadataRepo;)V',
  );

  static final _onLoaded = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onLoaded(androidx.emoji2.text.MetadataRepo metadataRepo)`
  void onLoaded(
    jni$_.JObject metadataRepo,
  ) {
    final _$metadataRepo = metadataRepo.reference;
    _onLoaded(reference.pointer, _id_onLoaded.pointer, _$metadataRepo.pointer)
        .check();
  }

  static final _id_onFailed = _class.instanceMethodId(
    r'onFailed',
    r'(Ljava/lang/Throwable;)V',
  );

  static final _onFailed = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onFailed(java.lang.Throwable throwable)`
  void onFailed(
    jni$_.JObject? throwable,
  ) {
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    _onFailed(reference.pointer, _id_onFailed.pointer, _$throwable.pointer)
        .check();
  }
}

final class $EmojiCompat$MetadataRepoLoaderCallback$Type$
    extends jni$_.JType<EmojiCompat$MetadataRepoLoaderCallback> {
  @jni$_.internal
  const $EmojiCompat$MetadataRepoLoaderCallback$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/EmojiCompat$MetadataRepoLoaderCallback;';
}

/// from: `androidx.emoji2.text.EmojiCompat$ReplaceStrategy`
extension type EmojiCompat$ReplaceStrategy._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/EmojiCompat$ReplaceStrategy');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<EmojiCompat$ReplaceStrategy> type =
      $EmojiCompat$ReplaceStrategy$Type$();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $EmojiCompat$ReplaceStrategy> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $EmojiCompat$ReplaceStrategy $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$ReplaceStrategy',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat$ReplaceStrategy.implement(
    $EmojiCompat$ReplaceStrategy $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<EmojiCompat$ReplaceStrategy>();
  }
}

abstract base mixin class $EmojiCompat$ReplaceStrategy {
  factory $EmojiCompat$ReplaceStrategy() = _$EmojiCompat$ReplaceStrategy;
}

final class _$EmojiCompat$ReplaceStrategy with $EmojiCompat$ReplaceStrategy {
  _$EmojiCompat$ReplaceStrategy();
}

final class $EmojiCompat$ReplaceStrategy$Type$
    extends jni$_.JType<EmojiCompat$ReplaceStrategy> {
  @jni$_.internal
  const $EmojiCompat$ReplaceStrategy$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$ReplaceStrategy;';
}

/// from: `androidx.emoji2.text.EmojiCompat$SpanFactory`
extension type EmojiCompat$SpanFactory._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/EmojiCompat$SpanFactory');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<EmojiCompat$SpanFactory> type =
      $EmojiCompat$SpanFactory$Type$();
  static final _id_createSpan = _class.instanceMethodId(
    r'createSpan',
    r'(Landroidx/emoji2/text/TypefaceEmojiRasterizer;)Landroidx/emoji2/text/EmojiSpan;',
  );

  static final _createSpan = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract androidx.emoji2.text.EmojiSpan createSpan(androidx.emoji2.text.TypefaceEmojiRasterizer typefaceEmojiRasterizer)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject createSpan(
    jni$_.JObject typefaceEmojiRasterizer,
  ) {
    final _$typefaceEmojiRasterizer = typefaceEmojiRasterizer.reference;
    return _createSpan(reference.pointer, _id_createSpan.pointer,
            _$typefaceEmojiRasterizer.pointer)
        .object<jni$_.JObject>();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $EmojiCompat$SpanFactory> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'createSpan(Landroidx/emoji2/text/TypefaceEmojiRasterizer;)Landroidx/emoji2/text/EmojiSpan;') {
        final $r = _$impls[$p]!.createSpan(
          ($a![0] as jni$_.JObject),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.$JObject$Type$())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $EmojiCompat$SpanFactory $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.emoji2.text.EmojiCompat$SpanFactory',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory EmojiCompat$SpanFactory.implement(
    $EmojiCompat$SpanFactory $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return $i.implement<EmojiCompat$SpanFactory>();
  }
}

abstract base mixin class $EmojiCompat$SpanFactory {
  factory $EmojiCompat$SpanFactory({
    required jni$_.JObject Function(jni$_.JObject typefaceEmojiRasterizer)
        createSpan,
  }) = _$EmojiCompat$SpanFactory;

  jni$_.JObject createSpan(jni$_.JObject typefaceEmojiRasterizer);
}

final class _$EmojiCompat$SpanFactory with $EmojiCompat$SpanFactory {
  _$EmojiCompat$SpanFactory({
    required jni$_.JObject Function(jni$_.JObject typefaceEmojiRasterizer)
        createSpan,
  }) : _createSpan = createSpan;

  final jni$_.JObject Function(jni$_.JObject typefaceEmojiRasterizer)
      _createSpan;

  jni$_.JObject createSpan(jni$_.JObject typefaceEmojiRasterizer) {
    return _createSpan(typefaceEmojiRasterizer);
  }
}

final class $EmojiCompat$SpanFactory$Type$
    extends jni$_.JType<EmojiCompat$SpanFactory> {
  @jni$_.internal
  const $EmojiCompat$SpanFactory$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat$SpanFactory;';
}

/// from: `androidx.emoji2.text.EmojiCompat`
extension type EmojiCompat._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/EmojiCompat');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<EmojiCompat> type = $EmojiCompat$Type$();
  static final _id_EDITOR_INFO_METAVERSION_KEY = _class.staticFieldId(
    r'EDITOR_INFO_METAVERSION_KEY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EDITOR_INFO_METAVERSION_KEY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EDITOR_INFO_METAVERSION_KEY =>
      _id_EDITOR_INFO_METAVERSION_KEY.get(_class, jni$_.JString.type)
          as jni$_.JString?;

  static final _id_EDITOR_INFO_REPLACE_ALL_KEY = _class.staticFieldId(
    r'EDITOR_INFO_REPLACE_ALL_KEY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String EDITOR_INFO_REPLACE_ALL_KEY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get EDITOR_INFO_REPLACE_ALL_KEY =>
      _id_EDITOR_INFO_REPLACE_ALL_KEY.get(_class, jni$_.JString.type)
          as jni$_.JString?;

  /// from: `static public final int LOAD_STATE_DEFAULT`
  static const LOAD_STATE_DEFAULT = 3;

  /// from: `static public final int LOAD_STATE_LOADING`
  static const LOAD_STATE_LOADING = 0;

  /// from: `static public final int LOAD_STATE_SUCCEEDED`
  static const LOAD_STATE_SUCCEEDED = 1;

  /// from: `static public final int LOAD_STATE_FAILED`
  static const LOAD_STATE_FAILED = 2;

  /// from: `static public final int REPLACE_STRATEGY_DEFAULT`
  static const REPLACE_STRATEGY_DEFAULT = 0;

  /// from: `static public final int REPLACE_STRATEGY_ALL`
  static const REPLACE_STRATEGY_ALL = 1;

  /// from: `static public final int REPLACE_STRATEGY_NON_EXISTENT`
  static const REPLACE_STRATEGY_NON_EXISTENT = 2;

  /// from: `static public final int LOAD_STRATEGY_DEFAULT`
  static const LOAD_STRATEGY_DEFAULT = 0;

  /// from: `static public final int LOAD_STRATEGY_MANUAL`
  static const LOAD_STRATEGY_MANUAL = 1;

  /// from: `static public final int EMOJI_UNSUPPORTED`
  static const EMOJI_UNSUPPORTED = 0;

  /// from: `static public final int EMOJI_SUPPORTED`
  static const EMOJI_SUPPORTED = 1;

  /// from: `static public final int EMOJI_FALLBACK`
  static const EMOJI_FALLBACK = 2;
  static final _id_init = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _init = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat init(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat? init(
    jni$_.JObject context,
  ) {
    final _$context = context.reference;
    return _init(_class.reference.pointer, _id_init.pointer, _$context.pointer)
        .object<EmojiCompat?>();
  }

  static final _id_init$1 = _class.staticMethodId(
    r'init',
    r'(Landroid/content/Context;Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _init$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat init(android.content.Context context, androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory defaultEmojiCompatConfigFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat? init$1(
    jni$_.JObject context,
    DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory?
        defaultEmojiCompatConfigFactory,
  ) {
    final _$context = context.reference;
    final _$defaultEmojiCompatConfigFactory =
        defaultEmojiCompatConfigFactory?.reference ?? jni$_.jNullReference;
    return _init$1(_class.reference.pointer, _id_init$1.pointer,
            _$context.pointer, _$defaultEmojiCompatConfigFactory.pointer)
        .object<EmojiCompat?>();
  }

  static final _id_init$2 = _class.staticMethodId(
    r'init',
    r'(Landroidx/emoji2/text/EmojiCompat$Config;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _init$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat init(androidx.emoji2.text.EmojiCompat$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat init$2(
    EmojiCompat$Config config,
  ) {
    final _$config = config.reference;
    return _init$2(
            _class.reference.pointer, _id_init$2.pointer, _$config.pointer)
        .object<EmojiCompat>();
  }

  static final _id_isConfigured = _class.staticMethodId(
    r'isConfigured',
    r'()Z',
  );

  static final _isConfigured = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public boolean isConfigured()`
  static core$_.bool isConfigured() {
    return _isConfigured(_class.reference.pointer, _id_isConfigured.pointer)
        .boolean;
  }

  static final _id_reset = _class.staticMethodId(
    r'reset',
    r'(Landroidx/emoji2/text/EmojiCompat$Config;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _reset = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat reset(androidx.emoji2.text.EmojiCompat$Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat reset(
    EmojiCompat$Config config,
  ) {
    final _$config = config.reference;
    return _reset(_class.reference.pointer, _id_reset.pointer, _$config.pointer)
        .object<EmojiCompat>();
  }

  static final _id_reset$1 = _class.staticMethodId(
    r'reset',
    r'(Landroidx/emoji2/text/EmojiCompat;)Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _reset$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public androidx.emoji2.text.EmojiCompat reset(androidx.emoji2.text.EmojiCompat emojiCompat)`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat? reset$1(
    EmojiCompat? emojiCompat,
  ) {
    final _$emojiCompat = emojiCompat?.reference ?? jni$_.jNullReference;
    return _reset$1(_class.reference.pointer, _id_reset$1.pointer,
            _$emojiCompat.pointer)
        .object<EmojiCompat?>();
  }

  static final _id_skipDefaultConfigurationLookup = _class.staticMethodId(
    r'skipDefaultConfigurationLookup',
    r'(Z)V',
  );

  static final _skipDefaultConfigurationLookup =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallStaticVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public void skipDefaultConfigurationLookup(boolean z)`
  static void skipDefaultConfigurationLookup(
    core$_.bool z,
  ) {
    _skipDefaultConfigurationLookup(_class.reference.pointer,
            _id_skipDefaultConfigurationLookup.pointer, z ? 1 : 0)
        .check();
  }

  static final _id_get = _class.staticMethodId(
    r'get',
    r'()Landroidx/emoji2/text/EmojiCompat;',
  );

  static final _get = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public androidx.emoji2.text.EmojiCompat get()`
  /// The returned object must be released after use, by calling the [release] method.
  static EmojiCompat get() {
    return _get(_class.reference.pointer, _id_get.pointer)
        .object<EmojiCompat>();
  }

  static final _id_load = _class.instanceMethodId(
    r'load',
    r'()V',
  );

  static final _load = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void load()`
  void load() {
    _load(reference.pointer, _id_load.pointer).check();
  }

  static final _id_registerInitCallback = _class.instanceMethodId(
    r'registerInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)V',
  );

  static final _registerInitCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void registerInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  void registerInitCallback(
    EmojiCompat$InitCallback initCallback,
  ) {
    final _$initCallback = initCallback.reference;
    _registerInitCallback(reference.pointer, _id_registerInitCallback.pointer,
            _$initCallback.pointer)
        .check();
  }

  static final _id_unregisterInitCallback = _class.instanceMethodId(
    r'unregisterInitCallback',
    r'(Landroidx/emoji2/text/EmojiCompat$InitCallback;)V',
  );

  static final _unregisterInitCallback = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void unregisterInitCallback(androidx.emoji2.text.EmojiCompat$InitCallback initCallback)`
  void unregisterInitCallback(
    EmojiCompat$InitCallback initCallback,
  ) {
    final _$initCallback = initCallback.reference;
    _unregisterInitCallback(reference.pointer,
            _id_unregisterInitCallback.pointer, _$initCallback.pointer)
        .check();
  }

  static final _id_getLoadState = _class.instanceMethodId(
    r'getLoadState',
    r'()I',
  );

  static final _getLoadState = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getLoadState()`
  int getLoadState() {
    return _getLoadState(reference.pointer, _id_getLoadState.pointer).integer;
  }

  static final _id_isEmojiSpanIndicatorEnabled = _class.instanceMethodId(
    r'isEmojiSpanIndicatorEnabled',
    r'()Z',
  );

  static final _isEmojiSpanIndicatorEnabled =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean isEmojiSpanIndicatorEnabled()`
  core$_.bool isEmojiSpanIndicatorEnabled() {
    return _isEmojiSpanIndicatorEnabled(
            reference.pointer, _id_isEmojiSpanIndicatorEnabled.pointer)
        .boolean;
  }

  static final _id_getEmojiSpanIndicatorColor = _class.instanceMethodId(
    r'getEmojiSpanIndicatorColor',
    r'()I',
  );

  static final _getEmojiSpanIndicatorColor =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallIntMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public int getEmojiSpanIndicatorColor()`
  int getEmojiSpanIndicatorColor() {
    return _getEmojiSpanIndicatorColor(
            reference.pointer, _id_getEmojiSpanIndicatorColor.pointer)
        .integer;
  }

  static final _id_getEmojiStart = _class.instanceMethodId(
    r'getEmojiStart',
    r'(Ljava/lang/CharSequence;I)I',
  );

  static final _getEmojiStart = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public int getEmojiStart(java.lang.CharSequence charSequence, int i)`
  int getEmojiStart(
    jni$_.JObject charSequence,
    int i,
  ) {
    final _$charSequence = charSequence.reference;
    return _getEmojiStart(reference.pointer, _id_getEmojiStart.pointer,
            _$charSequence.pointer, i)
        .integer;
  }

  static final _id_getEmojiEnd = _class.instanceMethodId(
    r'getEmojiEnd',
    r'(Ljava/lang/CharSequence;I)I',
  );

  static final _getEmojiEnd = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public int getEmojiEnd(java.lang.CharSequence charSequence, int i)`
  int getEmojiEnd(
    jni$_.JObject charSequence,
    int i,
  ) {
    final _$charSequence = charSequence.reference;
    return _getEmojiEnd(reference.pointer, _id_getEmojiEnd.pointer,
            _$charSequence.pointer, i)
        .integer;
  }

  static final _id_handleOnKeyDown = _class.staticMethodId(
    r'handleOnKeyDown',
    r'(Landroid/text/Editable;ILandroid/view/KeyEvent;)Z',
  );

  static final _handleOnKeyDown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public boolean handleOnKeyDown(android.text.Editable editable, int i, android.view.KeyEvent keyEvent)`
  static core$_.bool handleOnKeyDown(
    jni$_.JObject editable,
    int i,
    jni$_.JObject keyEvent,
  ) {
    final _$editable = editable.reference;
    final _$keyEvent = keyEvent.reference;
    return _handleOnKeyDown(
            _class.reference.pointer,
            _id_handleOnKeyDown.pointer,
            _$editable.pointer,
            i,
            _$keyEvent.pointer)
        .boolean;
  }

  static final _id_handleDeleteSurroundingText = _class.staticMethodId(
    r'handleDeleteSurroundingText',
    r'(Landroid/view/inputmethod/InputConnection;Landroid/text/Editable;IIZ)Z',
  );

  static final _handleDeleteSurroundingText =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32,
                            jni$_.Int32,
                            jni$_.Int32
                          )>)>>('globalEnv_CallStaticBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  int,
                  int,
                  int)>();

  /// from: `static public boolean handleDeleteSurroundingText(android.view.inputmethod.InputConnection inputConnection, android.text.Editable editable, int i, int i1, boolean z)`
  static core$_.bool handleDeleteSurroundingText(
    jni$_.JObject inputConnection,
    jni$_.JObject editable,
    int i,
    int i1,
    core$_.bool z,
  ) {
    final _$inputConnection = inputConnection.reference;
    final _$editable = editable.reference;
    return _handleDeleteSurroundingText(
            _class.reference.pointer,
            _id_handleDeleteSurroundingText.pointer,
            _$inputConnection.pointer,
            _$editable.pointer,
            i,
            i1,
            z ? 1 : 0)
        .boolean;
  }

  static final _id_hasEmojiGlyph = _class.instanceMethodId(
    r'hasEmojiGlyph',
    r'(Ljava/lang/CharSequence;)Z',
  );

  static final _hasEmojiGlyph = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean hasEmojiGlyph(java.lang.CharSequence charSequence)`
  core$_.bool hasEmojiGlyph(
    jni$_.JObject charSequence,
  ) {
    final _$charSequence = charSequence.reference;
    return _hasEmojiGlyph(reference.pointer, _id_hasEmojiGlyph.pointer,
            _$charSequence.pointer)
        .boolean;
  }

  static final _id_hasEmojiGlyph$1 = _class.instanceMethodId(
    r'hasEmojiGlyph',
    r'(Ljava/lang/CharSequence;I)Z',
  );

  static final _hasEmojiGlyph$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public boolean hasEmojiGlyph(java.lang.CharSequence charSequence, int i)`
  core$_.bool hasEmojiGlyph$1(
    jni$_.JObject charSequence,
    int i,
  ) {
    final _$charSequence = charSequence.reference;
    return _hasEmojiGlyph$1(reference.pointer, _id_hasEmojiGlyph$1.pointer,
            _$charSequence.pointer, i)
        .boolean;
  }

  static final _id_getEmojiMatch = _class.instanceMethodId(
    r'getEmojiMatch',
    r'(Ljava/lang/CharSequence;I)I',
  );

  static final _getEmojiMatch = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public int getEmojiMatch(java.lang.CharSequence charSequence, int i)`
  int getEmojiMatch(
    jni$_.JObject charSequence,
    int i,
  ) {
    final _$charSequence = charSequence.reference;
    return _getEmojiMatch(reference.pointer, _id_getEmojiMatch.pointer,
            _$charSequence.pointer, i)
        .integer;
  }

  static final _id_process = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;)Ljava/lang/CharSequence;',
  );

  static final _process = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? process(
    jni$_.JObject? charSequence,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _process(
            reference.pointer, _id_process.pointer, _$charSequence.pointer)
        .object<jni$_.JObject?>();
  }

  static final _id_process$1 = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;II)Ljava/lang/CharSequence;',
  );

  static final _process$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? process$1(
    jni$_.JObject? charSequence,
    int i,
    int i1,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _process$1(reference.pointer, _id_process$1.pointer,
            _$charSequence.pointer, i, i1)
        .object<jni$_.JObject?>();
  }

  static final _id_process$2 = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;III)Ljava/lang/CharSequence;',
  );

  static final _process$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int, int)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence, int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? process$2(
    jni$_.JObject? charSequence,
    int i,
    int i1,
    int i2,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _process$2(reference.pointer, _id_process$2.pointer,
            _$charSequence.pointer, i, i1, i2)
        .object<jni$_.JObject?>();
  }

  static final _id_process$3 = _class.instanceMethodId(
    r'process',
    r'(Ljava/lang/CharSequence;IIII)Ljava/lang/CharSequence;',
  );

  static final _process$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int)>();

  /// from: `public java.lang.CharSequence process(java.lang.CharSequence charSequence, int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? process$3(
    jni$_.JObject? charSequence,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _process$3(reference.pointer, _id_process$3.pointer,
            _$charSequence.pointer, i, i1, i2, i3)
        .object<jni$_.JObject?>();
  }

  static final _id_getAssetSignature = _class.instanceMethodId(
    r'getAssetSignature',
    r'()Ljava/lang/String;',
  );

  static final _getAssetSignature = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getAssetSignature()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString getAssetSignature() {
    return _getAssetSignature(reference.pointer, _id_getAssetSignature.pointer)
        .object<jni$_.JString>();
  }

  static final _id_updateEditorInfo = _class.instanceMethodId(
    r'updateEditorInfo',
    r'(Landroid/view/inputmethod/EditorInfo;)V',
  );

  static final _updateEditorInfo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void updateEditorInfo(android.view.inputmethod.EditorInfo editorInfo)`
  void updateEditorInfo(
    jni$_.JObject editorInfo,
  ) {
    final _$editorInfo = editorInfo.reference;
    _updateEditorInfo(reference.pointer, _id_updateEditorInfo.pointer,
            _$editorInfo.pointer)
        .check();
  }
}

final class $EmojiCompat$Type$ extends jni$_.JType<EmojiCompat> {
  @jni$_.internal
  const $EmojiCompat$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/EmojiCompat;';
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory`
extension type DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory._(
    jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory');

  /// The type which includes information such as the signature of this class.
  static const jni$_
      .JType<DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory> type =
      $DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory$Type$();
  static final _id_new$ = _class.constructorId(
    r'(Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper defaultEmojiCompatConfigHelper)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory(
    DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper?
        defaultEmojiCompatConfigHelper,
  ) {
    final _$defaultEmojiCompatConfigHelper =
        defaultEmojiCompatConfigHelper?.reference ?? jni$_.jNullReference;
    return _new$(_class.reference.pointer, _id_new$.pointer,
            _$defaultEmojiCompatConfigHelper.pointer)
        .object<DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory>();
  }

  static final _id_create = _class.instanceMethodId(
    r'create',
    r'(Landroid/content/Context;)Landroidx/emoji2/text/EmojiCompat$Config;',
  );

  static final _create = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public androidx.emoji2.text.EmojiCompat$Config create(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  EmojiCompat$Config? create(
    jni$_.JObject context,
  ) {
    final _$context = context.reference;
    return _create(reference.pointer, _id_create.pointer, _$context.pointer)
        .object<EmojiCompat$Config?>();
  }
}

final class $DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory$Type$
    extends jni$_
    .JType<DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigFactory;';
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper`
extension type DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper._(
    jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper');

  /// The type which includes information such as the signature of this class.
  static const jni$_
      .JType<DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper> type =
      $DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper() {
    return _new$(_class.reference.pointer, _id_new$.pointer)
        .object<DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper>();
  }

  static final _id_getSigningSignatures = _class.instanceMethodId(
    r'getSigningSignatures',
    r'(Landroid/content/pm/PackageManager;Ljava/lang/String;)[Landroid/content/pm/Signature;',
  );

  static final _getSigningSignatures = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.content.pm.Signature[] getSigningSignatures(android.content.pm.PackageManager packageManager, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?> getSigningSignatures(
    jni$_.JObject packageManager,
    jni$_.JString string,
  ) {
    final _$packageManager = packageManager.reference;
    final _$string = string.reference;
    return _getSigningSignatures(
            reference.pointer,
            _id_getSigningSignatures.pointer,
            _$packageManager.pointer,
            _$string.pointer)
        .object<jni$_.JArray<jni$_.JObject?>>();
  }

  static final _id_queryIntentContentProviders = _class.instanceMethodId(
    r'queryIntentContentProviders',
    r'(Landroid/content/pm/PackageManager;Landroid/content/Intent;I)Ljava/util/List;',
  );

  static final _queryIntentContentProviders =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  int)>();

  /// from: `public java.util.List<android.content.pm.ResolveInfo> queryIntentContentProviders(android.content.pm.PackageManager packageManager, android.content.Intent intent, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> queryIntentContentProviders(
    jni$_.JObject packageManager,
    jni$_.JObject intent,
    int i,
  ) {
    final _$packageManager = packageManager.reference;
    final _$intent = intent.reference;
    return _queryIntentContentProviders(
            reference.pointer,
            _id_queryIntentContentProviders.pointer,
            _$packageManager.pointer,
            _$intent.pointer,
            i)
        .object<jni$_.JList<jni$_.JObject?>>();
  }

  static final _id_getProviderInfo = _class.instanceMethodId(
    r'getProviderInfo',
    r'(Landroid/content/pm/ResolveInfo;)Landroid/content/pm/ProviderInfo;',
  );

  static final _getProviderInfo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.content.pm.ProviderInfo getProviderInfo(android.content.pm.ResolveInfo resolveInfo)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getProviderInfo(
    jni$_.JObject resolveInfo,
  ) {
    final _$resolveInfo = resolveInfo.reference;
    return _getProviderInfo(reference.pointer, _id_getProviderInfo.pointer,
            _$resolveInfo.pointer)
        .object<jni$_.JObject?>();
  }
}

final class $DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper$Type$
    extends jni$_
    .JType<DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper;';
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19`
extension type DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19._(
        jni$_.JObject _$this)
    implements DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper {
  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19');

  /// The type which includes information such as the signature of this class.
  static const jni$_
      .JType<DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19>
      type =
      $DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19() {
    return _new$(_class.reference.pointer, _id_new$.pointer).object<
        DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19>();
  }

  static final _id_queryIntentContentProviders = _class.instanceMethodId(
    r'queryIntentContentProviders',
    r'(Landroid/content/pm/PackageManager;Landroid/content/Intent;I)Ljava/util/List;',
  );

  static final _queryIntentContentProviders =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<
                          (
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Pointer<jni$_.Void>,
                            jni$_.Int32
                          )>)>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.Pointer<jni$_.Void>,
                  int)>();

  /// from: `public java.util.List<android.content.pm.ResolveInfo> queryIntentContentProviders(android.content.pm.PackageManager packageManager, android.content.Intent intent, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?> queryIntentContentProviders(
    jni$_.JObject packageManager,
    jni$_.JObject intent,
    int i,
  ) {
    final _$packageManager = packageManager.reference;
    final _$intent = intent.reference;
    return _queryIntentContentProviders(
            reference.pointer,
            _id_queryIntentContentProviders.pointer,
            _$packageManager.pointer,
            _$intent.pointer,
            i)
        .object<jni$_.JList<jni$_.JObject?>>();
  }

  static final _id_getProviderInfo = _class.instanceMethodId(
    r'getProviderInfo',
    r'(Landroid/content/pm/ResolveInfo;)Landroid/content/pm/ProviderInfo;',
  );

  static final _getProviderInfo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.content.pm.ProviderInfo getProviderInfo(android.content.pm.ResolveInfo resolveInfo)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getProviderInfo(
    jni$_.JObject resolveInfo,
  ) {
    final _$resolveInfo = resolveInfo.reference;
    return _getProviderInfo(reference.pointer, _id_getProviderInfo.pointer,
            _$resolveInfo.pointer)
        .object<jni$_.JObject?>();
  }
}

final class $DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19$Type$
    extends jni$_
    .JType<DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19;';
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28`
extension type DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28._(
        jni$_.JObject _$this)
    implements DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API19 {
  static final _class = jni$_.JClass.forName(
      r'androidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28');

  /// The type which includes information such as the signature of this class.
  static const jni$_
      .JType<DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28>
      type =
      $DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28() {
    return _new$(_class.reference.pointer, _id_new$.pointer).object<
        DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28>();
  }

  static final _id_getSigningSignatures$1 = _class.instanceMethodId(
    r'getSigningSignatures',
    r'(Landroid/content/pm/PackageManager;Ljava/lang/String;)[Landroid/content/pm/Signature;',
  );

  static final _getSigningSignatures$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public android.content.pm.Signature[] getSigningSignatures(android.content.pm.PackageManager packageManager, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?> getSigningSignatures$1(
    jni$_.JObject packageManager,
    jni$_.JString string,
  ) {
    final _$packageManager = packageManager.reference;
    final _$string = string.reference;
    return _getSigningSignatures$1(
            reference.pointer,
            _id_getSigningSignatures$1.pointer,
            _$packageManager.pointer,
            _$string.pointer)
        .object<jni$_.JArray<jni$_.JObject?>>();
  }
}

final class $DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28$Type$
    extends jni$_
    .JType<DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/emoji2/text/DefaultEmojiCompatConfig$DefaultEmojiCompatConfigHelper_API28;';
}

/// from: `androidx.emoji2.text.DefaultEmojiCompatConfig`
extension type DefaultEmojiCompatConfig._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'androidx/emoji2/text/DefaultEmojiCompatConfig');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<DefaultEmojiCompatConfig> type =
      $DefaultEmojiCompatConfig$Type$();
  static final _id_create = _class.staticMethodId(
    r'create',
    r'(Landroid/content/Context;)Landroidx/emoji2/text/FontRequestEmojiCompatConfig;',
  );

  static final _create = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public androidx.emoji2.text.FontRequestEmojiCompatConfig create(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? create(
    jni$_.JObject context,
  ) {
    final _$context = context.reference;
    return _create(
            _class.reference.pointer, _id_create.pointer, _$context.pointer)
        .object<jni$_.JObject?>();
  }
}

final class $DefaultEmojiCompatConfig$Type$
    extends jni$_.JType<DefaultEmojiCompatConfig> {
  @jni$_.internal
  const $DefaultEmojiCompatConfig$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/emoji2/text/DefaultEmojiCompatConfig;';
}

/// from: `android.os.Build$Partition`
extension type Build$Partition._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(r'android/os/Build$Partition');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Build$Partition> type = $Build$Partition$Type$();
  static final _id_PARTITION_NAME_SYSTEM = _class.staticFieldId(
    r'PARTITION_NAME_SYSTEM',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PARTITION_NAME_SYSTEM`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PARTITION_NAME_SYSTEM =>
      _id_PARTITION_NAME_SYSTEM.get(_class, jni$_.JString.type)
          as jni$_.JString?;

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  core$_.bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals.pointer, _$object.pointer)
        .boolean;
  }

  static final _id_getBuildTimeMillis = _class.instanceMethodId(
    r'getBuildTimeMillis',
    r'()J',
  );

  static final _getBuildTimeMillis = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getBuildTimeMillis()`
  int getBuildTimeMillis() {
    return _getBuildTimeMillis(
            reference.pointer, _id_getBuildTimeMillis.pointer)
        .long;
  }

  static final _id_getFingerprint = _class.instanceMethodId(
    r'getFingerprint',
    r'()Ljava/lang/String;',
  );

  static final _getFingerprint = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getFingerprint()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getFingerprint() {
    return _getFingerprint(reference.pointer, _id_getFingerprint.pointer)
        .object<jni$_.JString?>();
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() {
    return _getName(reference.pointer, _id_getName.pointer)
        .object<jni$_.JString?>();
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1.pointer).integer;
  }
}

final class $Build$Partition$Type$ extends jni$_.JType<Build$Partition> {
  @jni$_.internal
  const $Build$Partition$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$Partition;';
}

/// from: `android.os.Build$VERSION`
extension type Build$VERSION._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(r'android/os/Build$VERSION');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Build$VERSION> type = $Build$VERSION$Type$();
  static final _id_BASE_OS = _class.staticFieldId(
    r'BASE_OS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BASE_OS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BASE_OS =>
      _id_BASE_OS.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_CODENAME = _class.staticFieldId(
    r'CODENAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CODENAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CODENAME =>
      _id_CODENAME.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_INCREMENTAL = _class.staticFieldId(
    r'INCREMENTAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String INCREMENTAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get INCREMENTAL =>
      _id_INCREMENTAL.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_MEDIA_PERFORMANCE_CLASS = _class.staticFieldId(
    r'MEDIA_PERFORMANCE_CLASS',
    r'I',
  );

  /// from: `static public final int MEDIA_PERFORMANCE_CLASS`
  static int get MEDIA_PERFORMANCE_CLASS =>
      _id_MEDIA_PERFORMANCE_CLASS.get(_class, jni$_.jint.type) as int;

  static final _id_PREVIEW_SDK_INT = _class.staticFieldId(
    r'PREVIEW_SDK_INT',
    r'I',
  );

  /// from: `static public final int PREVIEW_SDK_INT`
  static int get PREVIEW_SDK_INT =>
      _id_PREVIEW_SDK_INT.get(_class, jni$_.jint.type) as int;

  static final _id_RELEASE = _class.staticFieldId(
    r'RELEASE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RELEASE =>
      _id_RELEASE.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_RELEASE_OR_CODENAME = _class.staticFieldId(
    r'RELEASE_OR_CODENAME',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE_OR_CODENAME`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RELEASE_OR_CODENAME =>
      _id_RELEASE_OR_CODENAME.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_RELEASE_OR_PREVIEW_DISPLAY = _class.staticFieldId(
    r'RELEASE_OR_PREVIEW_DISPLAY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RELEASE_OR_PREVIEW_DISPLAY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RELEASE_OR_PREVIEW_DISPLAY =>
      _id_RELEASE_OR_PREVIEW_DISPLAY.get(_class, jni$_.JString.type)
          as jni$_.JString?;

  static final _id_SDK = _class.staticFieldId(
    r'SDK',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SDK`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SDK =>
      _id_SDK.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_SDK_INT = _class.staticFieldId(
    r'SDK_INT',
    r'I',
  );

  /// from: `static public final int SDK_INT`
  static int get SDK_INT => _id_SDK_INT.get(_class, jni$_.jint.type) as int;

  static final _id_SDK_INT_FULL = _class.staticFieldId(
    r'SDK_INT_FULL',
    r'I',
  );

  /// from: `static public final int SDK_INT_FULL`
  static int get SDK_INT_FULL =>
      _id_SDK_INT_FULL.get(_class, jni$_.jint.type) as int;

  static final _id_SECURITY_PATCH = _class.staticFieldId(
    r'SECURITY_PATCH',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SECURITY_PATCH`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SECURITY_PATCH =>
      _id_SECURITY_PATCH.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build$VERSION() {
    return _new$(_class.reference.pointer, _id_new$.pointer)
        .object<Build$VERSION>();
  }
}

final class $Build$VERSION$Type$ extends jni$_.JType<Build$VERSION> {
  @jni$_.internal
  const $Build$VERSION$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$VERSION;';
}

/// from: `android.os.Build$VERSION_CODES`
extension type Build$VERSION_CODES._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(r'android/os/Build$VERSION_CODES');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Build$VERSION_CODES> type =
      $Build$VERSION_CODES$Type$();

  /// from: `static public final int BAKLAVA`
  static const BAKLAVA = 36;

  /// from: `static public final int BASE`
  static const BASE = 1;

  /// from: `static public final int BASE_1_1`
  static const BASE_1_1 = 2;

  /// from: `static public final int CUPCAKE`
  static const CUPCAKE = 3;

  /// from: `static public final int CUR_DEVELOPMENT`
  static const CUR_DEVELOPMENT = 10000;

  /// from: `static public final int DONUT`
  static const DONUT = 4;

  /// from: `static public final int ECLAIR`
  static const ECLAIR = 5;

  /// from: `static public final int ECLAIR_0_1`
  static const ECLAIR_0_1 = 6;

  /// from: `static public final int ECLAIR_MR1`
  static const ECLAIR_MR1 = 7;

  /// from: `static public final int FROYO`
  static const FROYO = 8;

  /// from: `static public final int GINGERBREAD`
  static const GINGERBREAD = 9;

  /// from: `static public final int GINGERBREAD_MR1`
  static const GINGERBREAD_MR1 = 10;

  /// from: `static public final int HONEYCOMB`
  static const HONEYCOMB = 11;

  /// from: `static public final int HONEYCOMB_MR1`
  static const HONEYCOMB_MR1 = 12;

  /// from: `static public final int HONEYCOMB_MR2`
  static const HONEYCOMB_MR2 = 13;

  /// from: `static public final int ICE_CREAM_SANDWICH`
  static const ICE_CREAM_SANDWICH = 14;

  /// from: `static public final int ICE_CREAM_SANDWICH_MR1`
  static const ICE_CREAM_SANDWICH_MR1 = 15;

  /// from: `static public final int JELLY_BEAN`
  static const JELLY_BEAN = 16;

  /// from: `static public final int JELLY_BEAN_MR1`
  static const JELLY_BEAN_MR1 = 17;

  /// from: `static public final int JELLY_BEAN_MR2`
  static const JELLY_BEAN_MR2 = 18;

  /// from: `static public final int KITKAT`
  static const KITKAT = 19;

  /// from: `static public final int KITKAT_WATCH`
  static const KITKAT_WATCH = 20;

  /// from: `static public final int LOLLIPOP`
  static const LOLLIPOP = 21;

  /// from: `static public final int LOLLIPOP_MR1`
  static const LOLLIPOP_MR1 = 22;

  /// from: `static public final int M`
  static const M = 23;

  /// from: `static public final int N`
  static const N = 24;

  /// from: `static public final int N_MR1`
  static const N_MR1 = 25;

  /// from: `static public final int O`
  static const O = 26;

  /// from: `static public final int O_MR1`
  static const O_MR1 = 27;

  /// from: `static public final int P`
  static const P = 28;

  /// from: `static public final int Q`
  static const Q = 29;

  /// from: `static public final int R`
  static const R = 30;

  /// from: `static public final int S`
  static const S = 31;

  /// from: `static public final int S_V2`
  static const S_V2 = 32;

  /// from: `static public final int TIRAMISU`
  static const TIRAMISU = 33;

  /// from: `static public final int UPSIDE_DOWN_CAKE`
  static const UPSIDE_DOWN_CAKE = 34;

  /// from: `static public final int VANILLA_ICE_CREAM`
  static const VANILLA_ICE_CREAM = 35;
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build$VERSION_CODES() {
    return _new$(_class.reference.pointer, _id_new$.pointer)
        .object<Build$VERSION_CODES>();
  }
}

final class $Build$VERSION_CODES$Type$
    extends jni$_.JType<Build$VERSION_CODES> {
  @jni$_.internal
  const $Build$VERSION_CODES$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$VERSION_CODES;';
}

/// from: `android.os.Build$VERSION_CODES_FULL`
extension type Build$VERSION_CODES_FULL._(jni$_.JObject _$this)
    implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'android/os/Build$VERSION_CODES_FULL');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Build$VERSION_CODES_FULL> type =
      $Build$VERSION_CODES_FULL$Type$();

  /// from: `static public final int BAKLAVA`
  static const BAKLAVA = 3600000;

  /// from: `static public final int BASE`
  static const BASE = 100000;

  /// from: `static public final int BASE_1_1`
  static const BASE_1_1 = 200000;

  /// from: `static public final int CUPCAKE`
  static const CUPCAKE = 300000;

  /// from: `static public final int DONUT`
  static const DONUT = 400000;

  /// from: `static public final int ECLAIR`
  static const ECLAIR = 500000;

  /// from: `static public final int ECLAIR_0_1`
  static const ECLAIR_0_1 = 600000;

  /// from: `static public final int ECLAIR_MR1`
  static const ECLAIR_MR1 = 700000;

  /// from: `static public final int FROYO`
  static const FROYO = 800000;

  /// from: `static public final int GINGERBREAD`
  static const GINGERBREAD = 900000;

  /// from: `static public final int GINGERBREAD_MR1`
  static const GINGERBREAD_MR1 = 1000000;

  /// from: `static public final int HONEYCOMB`
  static const HONEYCOMB = 1100000;

  /// from: `static public final int HONEYCOMB_MR1`
  static const HONEYCOMB_MR1 = 1200000;

  /// from: `static public final int HONEYCOMB_MR2`
  static const HONEYCOMB_MR2 = 1300000;

  /// from: `static public final int ICE_CREAM_SANDWICH`
  static const ICE_CREAM_SANDWICH = 1400000;

  /// from: `static public final int ICE_CREAM_SANDWICH_MR1`
  static const ICE_CREAM_SANDWICH_MR1 = 1500000;

  /// from: `static public final int JELLY_BEAN`
  static const JELLY_BEAN = 1600000;

  /// from: `static public final int JELLY_BEAN_MR1`
  static const JELLY_BEAN_MR1 = 1700000;

  /// from: `static public final int JELLY_BEAN_MR2`
  static const JELLY_BEAN_MR2 = 1800000;

  /// from: `static public final int KITKAT`
  static const KITKAT = 1900000;

  /// from: `static public final int KITKAT_WATCH`
  static const KITKAT_WATCH = 2000000;

  /// from: `static public final int LOLLIPOP`
  static const LOLLIPOP = 2100000;

  /// from: `static public final int LOLLIPOP_MR1`
  static const LOLLIPOP_MR1 = 2200000;

  /// from: `static public final int M`
  static const M = 2300000;

  /// from: `static public final int N`
  static const N = 2400000;

  /// from: `static public final int N_MR1`
  static const N_MR1 = 2500000;

  /// from: `static public final int O`
  static const O = 2600000;

  /// from: `static public final int O_MR1`
  static const O_MR1 = 2700000;

  /// from: `static public final int P`
  static const P = 2800000;

  /// from: `static public final int Q`
  static const Q = 2900000;

  /// from: `static public final int R`
  static const R = 3000000;

  /// from: `static public final int S`
  static const S = 3100000;

  /// from: `static public final int S_V2`
  static const S_V2 = 3200000;

  /// from: `static public final int TIRAMISU`
  static const TIRAMISU = 3300000;

  /// from: `static public final int UPSIDE_DOWN_CAKE`
  static const UPSIDE_DOWN_CAKE = 3400000;

  /// from: `static public final int VANILLA_ICE_CREAM`
  static const VANILLA_ICE_CREAM = 3500000;
}

final class $Build$VERSION_CODES_FULL$Type$
    extends jni$_.JType<Build$VERSION_CODES_FULL> {
  @jni$_.internal
  const $Build$VERSION_CODES_FULL$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build$VERSION_CODES_FULL;';
}

/// from: `android.os.Build`
extension type Build._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(r'android/os/Build');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Build> type = $Build$Type$();
  static final _id_BOARD = _class.staticFieldId(
    r'BOARD',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BOARD`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BOARD =>
      _id_BOARD.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_BOOTLOADER = _class.staticFieldId(
    r'BOOTLOADER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BOOTLOADER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BOOTLOADER =>
      _id_BOOTLOADER.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_BRAND = _class.staticFieldId(
    r'BRAND',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String BRAND`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get BRAND =>
      _id_BRAND.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_CPU_ABI = _class.staticFieldId(
    r'CPU_ABI',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CPU_ABI`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CPU_ABI =>
      _id_CPU_ABI.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_CPU_ABI2 = _class.staticFieldId(
    r'CPU_ABI2',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String CPU_ABI2`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get CPU_ABI2 =>
      _id_CPU_ABI2.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_DEVICE = _class.staticFieldId(
    r'DEVICE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DEVICE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DEVICE =>
      _id_DEVICE.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_DISPLAY = _class.staticFieldId(
    r'DISPLAY',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String DISPLAY`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get DISPLAY =>
      _id_DISPLAY.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_FINGERPRINT = _class.staticFieldId(
    r'FINGERPRINT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String FINGERPRINT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get FINGERPRINT =>
      _id_FINGERPRINT.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_HARDWARE = _class.staticFieldId(
    r'HARDWARE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HARDWARE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get HARDWARE =>
      _id_HARDWARE.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_HOST = _class.staticFieldId(
    r'HOST',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String HOST`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get HOST =>
      _id_HOST.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_ID = _class.staticFieldId(
    r'ID',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ID`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ID =>
      _id_ID.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_MANUFACTURER = _class.staticFieldId(
    r'MANUFACTURER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MANUFACTURER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MANUFACTURER =>
      _id_MANUFACTURER.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_MODEL = _class.staticFieldId(
    r'MODEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String MODEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get MODEL =>
      _id_MODEL.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_ODM_SKU = _class.staticFieldId(
    r'ODM_SKU',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String ODM_SKU`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get ODM_SKU =>
      _id_ODM_SKU.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_PRODUCT = _class.staticFieldId(
    r'PRODUCT',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String PRODUCT`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get PRODUCT =>
      _id_PRODUCT.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_RADIO = _class.staticFieldId(
    r'RADIO',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String RADIO`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get RADIO =>
      _id_RADIO.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_SERIAL = _class.staticFieldId(
    r'SERIAL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SERIAL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SERIAL =>
      _id_SERIAL.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_SKU = _class.staticFieldId(
    r'SKU',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SKU`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SKU =>
      _id_SKU.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_SOC_MANUFACTURER = _class.staticFieldId(
    r'SOC_MANUFACTURER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SOC_MANUFACTURER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SOC_MANUFACTURER =>
      _id_SOC_MANUFACTURER.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_SOC_MODEL = _class.staticFieldId(
    r'SOC_MODEL',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String SOC_MODEL`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get SOC_MODEL =>
      _id_SOC_MODEL.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_SUPPORTED_32_BIT_ABIS = _class.staticFieldId(
    r'SUPPORTED_32_BIT_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_32_BIT_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get SUPPORTED_32_BIT_ABIS =>
      _id_SUPPORTED_32_BIT_ABIS.get(
              _class, jni$_.$JArray$.type<jni$_.JString?>(jni$_.JString.type))
          as jni$_.JArray<jni$_.JString?>?;

  static final _id_SUPPORTED_64_BIT_ABIS = _class.staticFieldId(
    r'SUPPORTED_64_BIT_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_64_BIT_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get SUPPORTED_64_BIT_ABIS =>
      _id_SUPPORTED_64_BIT_ABIS.get(
              _class, jni$_.$JArray$.type<jni$_.JString?>(jni$_.JString.type))
          as jni$_.JArray<jni$_.JString?>?;

  static final _id_SUPPORTED_ABIS = _class.staticFieldId(
    r'SUPPORTED_ABIS',
    r'[Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String[] SUPPORTED_ABIS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JString?>? get SUPPORTED_ABIS => _id_SUPPORTED_ABIS
          .get(_class, jni$_.$JArray$.type<jni$_.JString?>(jni$_.JString.type))
      as jni$_.JArray<jni$_.JString?>?;

  static final _id_TAGS = _class.staticFieldId(
    r'TAGS',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TAGS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TAGS =>
      _id_TAGS.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_TIME = _class.staticFieldId(
    r'TIME',
    r'J',
  );

  /// from: `static public final long TIME`
  static int get TIME => _id_TIME.get(_class, jni$_.jlong.type) as int;

  static final _id_TYPE = _class.staticFieldId(
    r'TYPE',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String TYPE`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get TYPE =>
      _id_TYPE.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_UNKNOWN = _class.staticFieldId(
    r'UNKNOWN',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String UNKNOWN`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get UNKNOWN =>
      _id_UNKNOWN.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_USER = _class.staticFieldId(
    r'USER',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String USER`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get USER =>
      _id_USER.get(_class, jni$_.JString.type) as jni$_.JString?;

  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Build() {
    return _new$(_class.reference.pointer, _id_new$.pointer).object<Build>();
  }

  static final _id_getFingerprintedPartitions = _class.staticMethodId(
    r'getFingerprintedPartitions',
    r'()Ljava/util/List;',
  );

  static final _getFingerprintedPartitions =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `static public java.util.List<android.os.Build$Partition> getFingerprintedPartitions()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JList<Build$Partition?>? getFingerprintedPartitions() {
    return _getFingerprintedPartitions(
            _class.reference.pointer, _id_getFingerprintedPartitions.pointer)
        .object<jni$_.JList<Build$Partition?>?>();
  }

  static final _id_getMajorSdkVersion = _class.staticMethodId(
    r'getMajorSdkVersion',
    r'(I)I',
  );

  static final _getMajorSdkVersion = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public int getMajorSdkVersion(int i)`
  static int getMajorSdkVersion(
    int i,
  ) {
    return _getMajorSdkVersion(
            _class.reference.pointer, _id_getMajorSdkVersion.pointer, i)
        .integer;
  }

  static final _id_getMinorSdkVersion = _class.staticMethodId(
    r'getMinorSdkVersion',
    r'(I)I',
  );

  static final _getMinorSdkVersion = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticIntMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public int getMinorSdkVersion(int i)`
  static int getMinorSdkVersion(
    int i,
  ) {
    return _getMinorSdkVersion(
            _class.reference.pointer, _id_getMinorSdkVersion.pointer, i)
        .integer;
  }

  static final _id_getRadioVersion = _class.staticMethodId(
    r'getRadioVersion',
    r'()Ljava/lang/String;',
  );

  static final _getRadioVersion = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String getRadioVersion()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? getRadioVersion() {
    return _getRadioVersion(
            _class.reference.pointer, _id_getRadioVersion.pointer)
        .object<jni$_.JString?>();
  }

  static final _id_getSerial = _class.staticMethodId(
    r'getSerial',
    r'()Ljava/lang/String;',
  );

  static final _getSerial = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.lang.String getSerial()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? getSerial() {
    return _getSerial(_class.reference.pointer, _id_getSerial.pointer)
        .object<jni$_.JString?>();
  }
}

final class $Build$Type$ extends jni$_.JType<Build> {
  @jni$_.internal
  const $Build$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/os/Build;';
}

/// from: `java.util.HashMap`
extension type HashMap<$K extends jni$_.JObject?, $V extends jni$_.JObject?>._(
    jni$_.JObject _$this) implements jni$_.JObject {
  static final _class = jni$_.JClass.forName(r'java/util/HashMap');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<HashMap> type = $HashMap$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap() {
    return _new$(_class.reference.pointer, _id_new$.pointer)
        .object<HashMap<$K, $V>>();
  }

  static final _id_new$1 = _class.constructorId(
    r'(I)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$1(
    int i,
  ) {
    return _new$1(_class.reference.pointer, _id_new$1.pointer, i)
        .object<HashMap<$K, $V>>();
  }

  static final _id_new$2 = _class.constructorId(
    r'(IF)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Double)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, double)>();

  /// from: `public void <init>(int i, float f)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$2(
    int i,
    double f,
  ) {
    return _new$2(_class.reference.pointer, _id_new$2.pointer, i, f)
        .object<HashMap<$K, $V>>();
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/util/Map;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.util.Map<? extends K, ? extends V> map)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HashMap.new$3(
    jni$_.JMap<$K?, $V?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _new$3(_class.reference.pointer, _id_new$3.pointer, _$map.pointer)
        .object<HashMap<$K, $V>>();
  }

  static final _id_clear = _class.instanceMethodId(
    r'clear',
    r'()V',
  );

  static final _clear = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void clear()`
  void clear() {
    _clear(reference.pointer, _id_clear.pointer).check();
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() {
    return _clone(reference.pointer, _id_clone.pointer)
        .object<jni$_.JObject?>();
  }

  static final _id_compute = _class.instanceMethodId(
    r'compute',
    r'(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _compute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V compute(K object, java.util.function.BiFunction<? super K, ? super V, ? extends V> biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? compute(
    $K? object,
    jni$_.JObject? biFunction,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$biFunction = biFunction?.reference ?? jni$_.jNullReference;
    return _compute(reference.pointer, _id_compute.pointer, _$object.pointer,
            _$biFunction.pointer)
        .object<$V?>();
  }

  static final _id_computeIfAbsent = _class.instanceMethodId(
    r'computeIfAbsent',
    r'(Ljava/lang/Object;Ljava/util/function/Function;)Ljava/lang/Object;',
  );

  static final _computeIfAbsent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V computeIfAbsent(K object, java.util.function.Function<? super K, ? extends V> function)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? computeIfAbsent(
    $K? object,
    jni$_.JObject? function,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$function = function?.reference ?? jni$_.jNullReference;
    return _computeIfAbsent(reference.pointer, _id_computeIfAbsent.pointer,
            _$object.pointer, _$function.pointer)
        .object<$V?>();
  }

  static final _id_computeIfPresent = _class.instanceMethodId(
    r'computeIfPresent',
    r'(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _computeIfPresent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V computeIfPresent(K object, java.util.function.BiFunction<? super K, ? super V, ? extends V> biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? computeIfPresent(
    $K? object,
    jni$_.JObject? biFunction,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$biFunction = biFunction?.reference ?? jni$_.jNullReference;
    return _computeIfPresent(reference.pointer, _id_computeIfPresent.pointer,
            _$object.pointer, _$biFunction.pointer)
        .object<$V?>();
  }

  static final _id_containsKey = _class.instanceMethodId(
    r'containsKey',
    r'(Ljava/lang/Object;)Z',
  );

  static final _containsKey = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean containsKey(java.lang.Object object)`
  core$_.bool containsKey(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _containsKey(
            reference.pointer, _id_containsKey.pointer, _$object.pointer)
        .boolean;
  }

  static final _id_containsValue = _class.instanceMethodId(
    r'containsValue',
    r'(Ljava/lang/Object;)Z',
  );

  static final _containsValue = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean containsValue(java.lang.Object object)`
  core$_.bool containsValue(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _containsValue(
            reference.pointer, _id_containsValue.pointer, _$object.pointer)
        .boolean;
  }

  static final _id_entrySet = _class.instanceMethodId(
    r'entrySet',
    r'()Ljava/util/Set;',
  );

  static final _entrySet = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Set<java.util.Map$Entry<K, V>> entrySet()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JObject?>? entrySet() {
    return _entrySet(reference.pointer, _id_entrySet.pointer)
        .object<jni$_.JSet<jni$_.JObject?>?>();
  }

  static final _id_forEach = _class.instanceMethodId(
    r'forEach',
    r'(Ljava/util/function/BiConsumer;)V',
  );

  static final _forEach = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void forEach(java.util.function.BiConsumer<? super K, ? super V> biConsumer)`
  void forEach(
    jni$_.JObject? biConsumer,
  ) {
    final _$biConsumer = biConsumer?.reference ?? jni$_.jNullReference;
    _forEach(reference.pointer, _id_forEach.pointer, _$biConsumer.pointer)
        .check();
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _get = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V get(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? get(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _get(reference.pointer, _id_get.pointer, _$object.pointer)
        .object<$V?>();
  }

  static final _id_getOrDefault = _class.instanceMethodId(
    r'getOrDefault',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _getOrDefault = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V getOrDefault(java.lang.Object object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? getOrDefault(
    jni$_.JObject? object,
    $V? object1,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _getOrDefault(reference.pointer, _id_getOrDefault.pointer,
            _$object.pointer, _$object1.pointer)
        .object<$V?>();
  }

  static final _id_isEmpty = _class.instanceMethodId(
    r'isEmpty',
    r'()Z',
  );

  static final _isEmpty = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEmpty()`
  core$_.bool isEmpty() {
    return _isEmpty(reference.pointer, _id_isEmpty.pointer).boolean;
  }

  static final _id_keySet = _class.instanceMethodId(
    r'keySet',
    r'()Ljava/util/Set;',
  );

  static final _keySet = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Set<K> keySet()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<$K?>? keySet() {
    return _keySet(reference.pointer, _id_keySet.pointer)
        .object<jni$_.JSet<$K?>?>();
  }

  static final _id_merge = _class.instanceMethodId(
    r'merge',
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;',
  );

  static final _merge = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V merge(K object, V object1, java.util.function.BiFunction<? super V, ? super V, ? extends V> biFunction)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? merge(
    $K? object,
    $V? object1,
    jni$_.JObject? biFunction,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    final _$biFunction = biFunction?.reference ?? jni$_.jNullReference;
    return _merge(reference.pointer, _id_merge.pointer, _$object.pointer,
            _$object1.pointer, _$biFunction.pointer)
        .object<$V?>();
  }

  static final _id_newHashMap = _class.staticMethodId(
    r'newHashMap',
    r'(I)Ljava/util/HashMap;',
  );

  static final _newHashMap = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.util.HashMap<K, V> newHashMap(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static HashMap<$K?, $V?>?
      newHashMap<$K extends jni$_.JObject?, $V extends jni$_.JObject?>(
    int i,
  ) {
    return _newHashMap(_class.reference.pointer, _id_newHashMap.pointer, i)
        .object<HashMap<$K?, $V?>?>();
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _put = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V put(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? put(
    $K? object,
    $V? object1,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _put(reference.pointer, _id_put.pointer, _$object.pointer,
            _$object1.pointer)
        .object<$V?>();
  }

  static final _id_putAll = _class.instanceMethodId(
    r'putAll',
    r'(Ljava/util/Map;)V',
  );

  static final _putAll = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void putAll(java.util.Map<? extends K, ? extends V> map)`
  void putAll(
    jni$_.JMap<$K?, $V?>? map,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _putAll(reference.pointer, _id_putAll.pointer, _$map.pointer).check();
  }

  static final _id_putIfAbsent = _class.instanceMethodId(
    r'putIfAbsent',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _putIfAbsent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V putIfAbsent(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? putIfAbsent(
    $K? object,
    $V? object1,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _putIfAbsent(reference.pointer, _id_putIfAbsent.pointer,
            _$object.pointer, _$object1.pointer)
        .object<$V?>();
  }

  static final _id_remove = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _remove = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V remove(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? remove(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _remove(reference.pointer, _id_remove.pointer, _$object.pointer)
        .object<$V?>();
  }

  static final _id_remove$1 = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Z',
  );

  static final _remove$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean remove(java.lang.Object object, java.lang.Object object1)`
  core$_.bool remove$1(
    jni$_.JObject? object,
    jni$_.JObject? object1,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _remove$1(reference.pointer, _id_remove$1.pointer, _$object.pointer,
            _$object1.pointer)
        .boolean;
  }

  static final _id_replace = _class.instanceMethodId(
    r'replace',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _replace = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public V replace(K object, V object1)`
  /// The returned object must be released after use, by calling the [release] method.
  $V? replace(
    $K? object,
    $V? object1,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _replace(reference.pointer, _id_replace.pointer, _$object.pointer,
            _$object1.pointer)
        .object<$V?>();
  }

  static final _id_replace$1 = _class.instanceMethodId(
    r'replace',
    r'(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Z',
  );

  static final _replace$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean replace(K object, V object1, V object2)`
  core$_.bool replace$1(
    $K? object,
    $V? object1,
    $V? object2,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    final _$object2 = object2?.reference ?? jni$_.jNullReference;
    return _replace$1(reference.pointer, _id_replace$1.pointer,
            _$object.pointer, _$object1.pointer, _$object2.pointer)
        .boolean;
  }

  static final _id_replaceAll = _class.instanceMethodId(
    r'replaceAll',
    r'(Ljava/util/function/BiFunction;)V',
  );

  static final _replaceAll = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V> biFunction)`
  void replaceAll(
    jni$_.JObject? biFunction,
  ) {
    final _$biFunction = biFunction?.reference ?? jni$_.jNullReference;
    _replaceAll(reference.pointer, _id_replaceAll.pointer, _$biFunction.pointer)
        .check();
  }

  static final _id_size = _class.instanceMethodId(
    r'size',
    r'()I',
  );

  static final _size = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int size()`
  int size() {
    return _size(reference.pointer, _id_size.pointer).integer;
  }

  static final _id_values = _class.instanceMethodId(
    r'values',
    r'()Ljava/util/Collection;',
  );

  static final _values = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.Collection<V> values()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? values() {
    return _values(reference.pointer, _id_values.pointer)
        .object<jni$_.JObject?>();
  }
}

final class $HashMap$Type$ extends jni$_.JType<HashMap> {
  @jni$_.internal
  const $HashMap$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/HashMap;';
}

/// from: `com.example.in_app_java.AndroidUtils`
extension type AndroidUtils._(jni$_.JObject _$this) implements jni$_.JObject {
  static final _class =
      jni$_.JClass.forName(r'com/example/in_app_java/AndroidUtils');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<AndroidUtils> type = $AndroidUtils$Type$();
  static final _id_showToast = _class.staticMethodId(
    r'showToast',
    r'(Landroid/app/Activity;Ljava/lang/CharSequence;I)V',
  );

  static final _showToast = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int)>();

  /// from: `static public void showToast(android.app.Activity mainActivity, java.lang.CharSequence text, int duration)`
  static void showToast(
    jni$_.JObject? mainActivity,
    jni$_.JObject? text,
    int duration,
  ) {
    final _$mainActivity = mainActivity?.reference ?? jni$_.jNullReference;
    final _$text = text?.reference ?? jni$_.jNullReference;
    _showToast(_class.reference.pointer, _id_showToast.pointer,
            _$mainActivity.pointer, _$text.pointer, duration)
        .check();
  }
}

final class $AndroidUtils$Type$ extends jni$_.JType<AndroidUtils> {
  @jni$_.internal
  const $AndroidUtils$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/example/in_app_java/AndroidUtils;';
}
