// Generated from Apache PDFBox library which is licensed under the Apache License 2.0.
// The following copyright from the original authors applies.
//
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show RawReceivePort, ReceivePort;

import 'package:jni/_internal.dart';
import 'package:jni/jni.dart' as jni;

import '../pdmodel/PDDocument.dart' as pddocument_;

/// from: `org.apache.pdfbox.text.PDFTextStripper`
///
/// This class will take a pdf document and strip out all of the text and ignore the formatting and such. Please note; it
/// is up to clients of this class to verify that a specific user has the correct permissions to extract text from the
/// PDF document.
///
/// The basic flow of this process is that we get a document and use a series of processXXX() functions that work on
/// smaller and smaller chunks of the page. Eventually, we fully process each page and then print it.
///@author Ben Litchfield
class PDFTextStripper extends jni.JObject {
  @override
  late final jni.JObjType<PDFTextStripper> $type = type;

  PDFTextStripper.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'org/apache/pdfbox/text/PDFTextStripper');

  /// The type which includes information such as the signature of this class.
  static const type = $PDFTextStripperType();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Instantiate a new PDFTextStripper object.
  ///@throws IOException If there is an error loading the properties.
  factory PDFTextStripper() {
    return PDFTextStripper.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getText = _class.instanceMethodId(
    r'getText',
    r'(Lorg/apache/pdfbox/pdmodel/PDDocument;)Ljava/lang/String;',
  );

  static final _getText = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public java.lang.String getText(org.apache.pdfbox.pdmodel.PDDocument doc)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will return the text of a document. See writeText. <br>
  /// NOTE: The document must not be encrypted when coming into this method.
  ///
  /// IMPORTANT: By default, text extraction is done in the same sequence as the text in the PDF page content stream.
  /// PDF is a graphic format, not a text format, and unlike HTML, it has no requirements that text one on page
  /// be rendered in a certain order. The order is the one that was determined by the software that created the
  /// PDF. To get text sorted from left to right and top to botton, use \#setSortByPosition(boolean).
  ///@param doc The document to get the text from.
  ///@return The text of the PDF document.
  ///@throws IOException if the doc state is invalid or it is encrypted.
  jni.JString getText(
    pddocument_.PDDocument doc,
  ) {
    return _getText(reference.pointer, _id_getText as jni.JMethodIDPtr,
            doc.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_writeText = _class.instanceMethodId(
    r'writeText',
    r'(Lorg/apache/pdfbox/pdmodel/PDDocument;Ljava/io/Writer;)V',
  );

  static final _writeText = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public void writeText(org.apache.pdfbox.pdmodel.PDDocument doc, java.io.Writer outputStream)`
  ///
  /// This will take a PDDocument and write the text of that document to the print writer.
  ///@param doc The document to get the data from.
  ///@param outputStream The location to put the text.
  ///@throws IOException If the doc is in an invalid state.
  void writeText(
    pddocument_.PDDocument doc,
    jni.JObject outputStream,
  ) {
    _writeText(reference.pointer, _id_writeText as jni.JMethodIDPtr,
            doc.reference.pointer, outputStream.reference.pointer)
        .check();
  }

  static final _id_processPage = _class.instanceMethodId(
    r'processPage',
    r'(Lorg/apache/pdfbox/pdmodel/PDPage;)V',
  );

  static final _processPage = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void processPage(org.apache.pdfbox.pdmodel.PDPage page)`
  ///
  /// This will process the contents of a page.
  ///@param page The page to process.
  ///@throws IOException If there is an error processing the page.
  void processPage(
    jni.JObject page,
  ) {
    _processPage(reference.pointer, _id_processPage as jni.JMethodIDPtr,
            page.reference.pointer)
        .check();
  }

  static final _id_getStartPage = _class.instanceMethodId(
    r'getStartPage',
    r'()I',
  );

  static final _getStartPage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getStartPage()`
  ///
  /// This is the page that the text extraction will start on. The pages start at page 1. For example in a 5 page PDF
  /// document, if the start page is 1 then all pages will be extracted. If the start page is 4 then pages 4 and 5 will
  /// be extracted. The default value is 1.
  ///@return Value of property startPage.
  int getStartPage() {
    return _getStartPage(
            reference.pointer, _id_getStartPage as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setStartPage = _class.instanceMethodId(
    r'setStartPage',
    r'(I)V',
  );

  static final _setStartPage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setStartPage(int startPageValue)`
  ///
  /// This will set the first page to be extracted by this class.
  ///@param startPageValue New value of 1-based startPage property.
  void setStartPage(
    int startPageValue,
  ) {
    _setStartPage(reference.pointer, _id_setStartPage as jni.JMethodIDPtr,
            startPageValue)
        .check();
  }

  static final _id_getEndPage = _class.instanceMethodId(
    r'getEndPage',
    r'()I',
  );

  static final _getEndPage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getEndPage()`
  ///
  /// This will get the last page that will be extracted. This is inclusive, for example if a 5 page PDF an endPage
  /// value of 5 would extract the entire document, an end page of 2 would extract pages 1 and 2. This defaults to
  /// Integer.MAX_VALUE such that all pages of the pdf will be extracted.
  ///@return Value of property endPage.
  int getEndPage() {
    return _getEndPage(reference.pointer, _id_getEndPage as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setEndPage = _class.instanceMethodId(
    r'setEndPage',
    r'(I)V',
  );

  static final _setEndPage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setEndPage(int endPageValue)`
  ///
  /// This will set the last page to be extracted by this class.
  ///@param endPageValue New value of 1-based endPage property.
  void setEndPage(
    int endPageValue,
  ) {
    _setEndPage(
            reference.pointer, _id_setEndPage as jni.JMethodIDPtr, endPageValue)
        .check();
  }

  static final _id_setLineSeparator = _class.instanceMethodId(
    r'setLineSeparator',
    r'(Ljava/lang/String;)V',
  );

  static final _setLineSeparator = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setLineSeparator(java.lang.String separator)`
  ///
  /// Set the desired line separator for output text. The line.separator system property is used if the line separator
  /// preference is not set explicitly using this method.
  ///@param separator The desired line separator string.
  void setLineSeparator(
    jni.JString separator,
  ) {
    _setLineSeparator(
            reference.pointer,
            _id_setLineSeparator as jni.JMethodIDPtr,
            separator.reference.pointer)
        .check();
  }

  static final _id_getLineSeparator = _class.instanceMethodId(
    r'getLineSeparator',
    r'()Ljava/lang/String;',
  );

  static final _getLineSeparator = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getLineSeparator()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the line separator.
  ///@return The desired line separator string.
  jni.JString getLineSeparator() {
    return _getLineSeparator(
            reference.pointer, _id_getLineSeparator as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getWordSeparator = _class.instanceMethodId(
    r'getWordSeparator',
    r'()Ljava/lang/String;',
  );

  static final _getWordSeparator = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getWordSeparator()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the word separator.
  ///@return The desired word separator string.
  jni.JString getWordSeparator() {
    return _getWordSeparator(
            reference.pointer, _id_getWordSeparator as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setWordSeparator = _class.instanceMethodId(
    r'setWordSeparator',
    r'(Ljava/lang/String;)V',
  );

  static final _setWordSeparator = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setWordSeparator(java.lang.String separator)`
  ///
  /// Set the desired word separator for output text. The PDFBox text extraction algorithm will output a space
  /// character if there is enough space between two words. By default a space character is used. If you need and
  /// accurate count of characters that are found in a PDF document then you might want to set the word separator to
  /// the empty string.
  ///@param separator The desired page separator string.
  void setWordSeparator(
    jni.JString separator,
  ) {
    _setWordSeparator(
            reference.pointer,
            _id_setWordSeparator as jni.JMethodIDPtr,
            separator.reference.pointer)
        .check();
  }

  static final _id_getSuppressDuplicateOverlappingText =
      _class.instanceMethodId(
    r'getSuppressDuplicateOverlappingText',
    r'()Z',
  );

  static final _getSuppressDuplicateOverlappingText =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: `public boolean getSuppressDuplicateOverlappingText()`
  ///
  /// @return Returns the suppressDuplicateOverlappingText.
  bool getSuppressDuplicateOverlappingText() {
    return _getSuppressDuplicateOverlappingText(reference.pointer,
            _id_getSuppressDuplicateOverlappingText as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setSuppressDuplicateOverlappingText =
      _class.instanceMethodId(
    r'setSuppressDuplicateOverlappingText',
    r'(Z)V',
  );

  static final _setSuppressDuplicateOverlappingText =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setSuppressDuplicateOverlappingText(boolean suppressDuplicateOverlappingTextValue)`
  ///
  /// By default the text stripper will attempt to remove text that overlapps each other. Word paints the same
  /// character several times in order to make it look bold. By setting this to false all text will be extracted, which
  /// means that certain sections will be duplicated, but better performance will be noticed.
  ///@param suppressDuplicateOverlappingTextValue The suppressDuplicateOverlappingText to set.
  void setSuppressDuplicateOverlappingText(
    bool suppressDuplicateOverlappingTextValue,
  ) {
    _setSuppressDuplicateOverlappingText(
            reference.pointer,
            _id_setSuppressDuplicateOverlappingText as jni.JMethodIDPtr,
            suppressDuplicateOverlappingTextValue ? 1 : 0)
        .check();
  }

  static final _id_getSeparateByBeads = _class.instanceMethodId(
    r'getSeparateByBeads',
    r'()Z',
  );

  static final _getSeparateByBeads = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getSeparateByBeads()`
  ///
  /// This will tell if the text stripper should separate by beads.
  ///@return If the text will be grouped by beads.
  bool getSeparateByBeads() {
    return _getSeparateByBeads(
            reference.pointer, _id_getSeparateByBeads as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setShouldSeparateByBeads = _class.instanceMethodId(
    r'setShouldSeparateByBeads',
    r'(Z)V',
  );

  static final _setShouldSeparateByBeads = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setShouldSeparateByBeads(boolean aShouldSeparateByBeads)`
  ///
  /// Set if the text stripper should group the text output by a list of beads. The default value is true!
  ///@param aShouldSeparateByBeads The new grouping of beads.
  void setShouldSeparateByBeads(
    bool aShouldSeparateByBeads,
  ) {
    _setShouldSeparateByBeads(
            reference.pointer,
            _id_setShouldSeparateByBeads as jni.JMethodIDPtr,
            aShouldSeparateByBeads ? 1 : 0)
        .check();
  }

  static final _id_getEndBookmark = _class.instanceMethodId(
    r'getEndBookmark',
    r'()Lorg/apache/pdfbox/pdmodel/interactive/documentnavigation/outline/PDOutlineItem;',
  );

  static final _getEndBookmark = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem getEndBookmark()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the bookmark where text extraction should end, inclusive. Default is null.
  ///@return The ending bookmark.
  jni.JObject getEndBookmark() {
    return _getEndBookmark(
            reference.pointer, _id_getEndBookmark as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setEndBookmark = _class.instanceMethodId(
    r'setEndBookmark',
    r'(Lorg/apache/pdfbox/pdmodel/interactive/documentnavigation/outline/PDOutlineItem;)V',
  );

  static final _setEndBookmark = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setEndBookmark(org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem aEndBookmark)`
  ///
  /// Set the bookmark where the text extraction should stop.
  ///@param aEndBookmark The ending bookmark.
  void setEndBookmark(
    jni.JObject aEndBookmark,
  ) {
    _setEndBookmark(reference.pointer, _id_setEndBookmark as jni.JMethodIDPtr,
            aEndBookmark.reference.pointer)
        .check();
  }

  static final _id_getStartBookmark = _class.instanceMethodId(
    r'getStartBookmark',
    r'()Lorg/apache/pdfbox/pdmodel/interactive/documentnavigation/outline/PDOutlineItem;',
  );

  static final _getStartBookmark = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem getStartBookmark()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the bookmark where text extraction should start, inclusive. Default is null.
  ///@return The starting bookmark.
  jni.JObject getStartBookmark() {
    return _getStartBookmark(
            reference.pointer, _id_getStartBookmark as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setStartBookmark = _class.instanceMethodId(
    r'setStartBookmark',
    r'(Lorg/apache/pdfbox/pdmodel/interactive/documentnavigation/outline/PDOutlineItem;)V',
  );

  static final _setStartBookmark = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setStartBookmark(org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem aStartBookmark)`
  ///
  /// Set the bookmark where text extraction should start, inclusive.
  ///@param aStartBookmark The starting bookmark.
  void setStartBookmark(
    jni.JObject aStartBookmark,
  ) {
    _setStartBookmark(
            reference.pointer,
            _id_setStartBookmark as jni.JMethodIDPtr,
            aStartBookmark.reference.pointer)
        .check();
  }

  static final _id_getAddMoreFormatting = _class.instanceMethodId(
    r'getAddMoreFormatting',
    r'()Z',
  );

  static final _getAddMoreFormatting = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getAddMoreFormatting()`
  ///
  /// This will tell if the text stripper should add some more text formatting.
  ///@return true if some more text formatting will be added
  bool getAddMoreFormatting() {
    return _getAddMoreFormatting(
            reference.pointer, _id_getAddMoreFormatting as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAddMoreFormatting = _class.instanceMethodId(
    r'setAddMoreFormatting',
    r'(Z)V',
  );

  static final _setAddMoreFormatting = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setAddMoreFormatting(boolean newAddMoreFormatting)`
  ///
  /// There will some additional text formatting be added if addMoreFormatting is set to true. Default is false.
  ///@param newAddMoreFormatting Tell PDFBox to add some more text formatting
  void setAddMoreFormatting(
    bool newAddMoreFormatting,
  ) {
    _setAddMoreFormatting(
            reference.pointer,
            _id_setAddMoreFormatting as jni.JMethodIDPtr,
            newAddMoreFormatting ? 1 : 0)
        .check();
  }

  static final _id_getSortByPosition = _class.instanceMethodId(
    r'getSortByPosition',
    r'()Z',
  );

  static final _getSortByPosition = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean getSortByPosition()`
  ///
  /// This will tell if the text stripper should sort the text tokens before writing to the stream.
  ///@return true If the text tokens will be sorted before being written.
  bool getSortByPosition() {
    return _getSortByPosition(
            reference.pointer, _id_getSortByPosition as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setSortByPosition = _class.instanceMethodId(
    r'setSortByPosition',
    r'(Z)V',
  );

  static final _setSortByPosition = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public void setSortByPosition(boolean newSortByPosition)`
  ///
  /// The order of the text tokens in a PDF file may not be in the same as they appear visually on the screen. For
  /// example, a PDF writer may write out all text by font, so all bold or larger text, then make a second pass and
  /// write out the normal text.<br>
  /// The default is to __not__ sort by position.<br>
  /// <br>
  /// A PDF writer could choose to write each character in a different order. By default PDFBox does __not__ sort
  /// the text tokens before processing them due to performance reasons.
  ///@param newSortByPosition Tell PDFBox to sort the text positions.
  void setSortByPosition(
    bool newSortByPosition,
  ) {
    _setSortByPosition(
            reference.pointer,
            _id_setSortByPosition as jni.JMethodIDPtr,
            newSortByPosition ? 1 : 0)
        .check();
  }

  static final _id_getSpacingTolerance = _class.instanceMethodId(
    r'getSpacingTolerance',
    r'()F',
  );

  static final _getSpacingTolerance = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float getSpacingTolerance()`
  ///
  /// Get the current space width-based tolerance value that is being used to estimate where spaces in text should be
  /// added. Note that the default value for this has been determined from trial and error.
  ///@return The current tolerance / scaling factor
  double getSpacingTolerance() {
    return _getSpacingTolerance(
            reference.pointer, _id_getSpacingTolerance as jni.JMethodIDPtr)
        .float;
  }

  static final _id_setSpacingTolerance = _class.instanceMethodId(
    r'setSpacingTolerance',
    r'(F)V',
  );

  static final _setSpacingTolerance = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public void setSpacingTolerance(float spacingToleranceValue)`
  ///
  /// Set the space width-based tolerance value that is used to estimate where spaces in text should be added. Note
  /// that the default value for this has been determined from trial and error. Setting this value larger will reduce
  /// the number of spaces added.
  ///@param spacingToleranceValue tolerance / scaling factor to use
  void setSpacingTolerance(
    double spacingToleranceValue,
  ) {
    _setSpacingTolerance(reference.pointer,
            _id_setSpacingTolerance as jni.JMethodIDPtr, spacingToleranceValue)
        .check();
  }

  static final _id_getAverageCharTolerance = _class.instanceMethodId(
    r'getAverageCharTolerance',
    r'()F',
  );

  static final _getAverageCharTolerance = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float getAverageCharTolerance()`
  ///
  /// Get the current character width-based tolerance value that is being used to estimate where spaces in text should
  /// be added. Note that the default value for this has been determined from trial and error.
  ///@return The current tolerance / scaling factor
  double getAverageCharTolerance() {
    return _getAverageCharTolerance(
            reference.pointer, _id_getAverageCharTolerance as jni.JMethodIDPtr)
        .float;
  }

  static final _id_setAverageCharTolerance = _class.instanceMethodId(
    r'setAverageCharTolerance',
    r'(F)V',
  );

  static final _setAverageCharTolerance = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public void setAverageCharTolerance(float averageCharToleranceValue)`
  ///
  /// Set the character width-based tolerance value that is used to estimate where spaces in text should be added. Note
  /// that the default value for this has been determined from trial and error. Setting this value larger will reduce
  /// the number of spaces added.
  ///@param averageCharToleranceValue average tolerance / scaling factor to use
  void setAverageCharTolerance(
    double averageCharToleranceValue,
  ) {
    _setAverageCharTolerance(
            reference.pointer,
            _id_setAverageCharTolerance as jni.JMethodIDPtr,
            averageCharToleranceValue)
        .check();
  }

  static final _id_getIndentThreshold = _class.instanceMethodId(
    r'getIndentThreshold',
    r'()F',
  );

  static final _getIndentThreshold = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float getIndentThreshold()`
  ///
  /// returns the multiple of whitespace character widths for the current text which the current line start can be
  /// indented from the previous line start beyond which the current line start is considered to be a paragraph start.
  ///@return the number of whitespace character widths to use when detecting paragraph indents.
  double getIndentThreshold() {
    return _getIndentThreshold(
            reference.pointer, _id_getIndentThreshold as jni.JMethodIDPtr)
        .float;
  }

  static final _id_setIndentThreshold = _class.instanceMethodId(
    r'setIndentThreshold',
    r'(F)V',
  );

  static final _setIndentThreshold = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public void setIndentThreshold(float indentThresholdValue)`
  ///
  /// sets the multiple of whitespace character widths for the current text which the current line start can be
  /// indented from the previous line start beyond which the current line start is considered to be a paragraph start.
  /// The default value is 2.0.
  ///@param indentThresholdValue the number of whitespace character widths to use when detecting paragraph indents.
  void setIndentThreshold(
    double indentThresholdValue,
  ) {
    _setIndentThreshold(reference.pointer,
            _id_setIndentThreshold as jni.JMethodIDPtr, indentThresholdValue)
        .check();
  }

  static final _id_getDropThreshold = _class.instanceMethodId(
    r'getDropThreshold',
    r'()F',
  );

  static final _getDropThreshold = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float getDropThreshold()`
  ///
  /// the minimum whitespace, as a multiple of the max height of the current characters beyond which the current line
  /// start is considered to be a paragraph start.
  ///@return the character height multiple for max allowed whitespace between lines in the same paragraph.
  double getDropThreshold() {
    return _getDropThreshold(
            reference.pointer, _id_getDropThreshold as jni.JMethodIDPtr)
        .float;
  }

  static final _id_setDropThreshold = _class.instanceMethodId(
    r'setDropThreshold',
    r'(F)V',
  );

  static final _setDropThreshold = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, double)>();

  /// from: `public void setDropThreshold(float dropThresholdValue)`
  ///
  /// sets the minimum whitespace, as a multiple of the max height of the current characters beyond which the current
  /// line start is considered to be a paragraph start. The default value is 2.5.
  ///@param dropThresholdValue the character height multiple for max allowed whitespace between lines in the same
  /// paragraph.
  void setDropThreshold(
    double dropThresholdValue,
  ) {
    _setDropThreshold(reference.pointer,
            _id_setDropThreshold as jni.JMethodIDPtr, dropThresholdValue)
        .check();
  }

  static final _id_getParagraphStart = _class.instanceMethodId(
    r'getParagraphStart',
    r'()Ljava/lang/String;',
  );

  static final _getParagraphStart = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getParagraphStart()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the string which will be used at the beginning of a paragraph.
  ///@return the paragraph start string
  jni.JString getParagraphStart() {
    return _getParagraphStart(
            reference.pointer, _id_getParagraphStart as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setParagraphStart = _class.instanceMethodId(
    r'setParagraphStart',
    r'(Ljava/lang/String;)V',
  );

  static final _setParagraphStart = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setParagraphStart(java.lang.String s)`
  ///
  /// Sets the string which will be used at the beginning of a paragraph.
  ///@param s the paragraph start string
  void setParagraphStart(
    jni.JString s,
  ) {
    _setParagraphStart(reference.pointer,
            _id_setParagraphStart as jni.JMethodIDPtr, s.reference.pointer)
        .check();
  }

  static final _id_getParagraphEnd = _class.instanceMethodId(
    r'getParagraphEnd',
    r'()Ljava/lang/String;',
  );

  static final _getParagraphEnd = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getParagraphEnd()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the string which will be used at the end of a paragraph.
  ///@return the paragraph end string
  jni.JString getParagraphEnd() {
    return _getParagraphEnd(
            reference.pointer, _id_getParagraphEnd as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setParagraphEnd = _class.instanceMethodId(
    r'setParagraphEnd',
    r'(Ljava/lang/String;)V',
  );

  static final _setParagraphEnd = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setParagraphEnd(java.lang.String s)`
  ///
  /// Sets the string which will be used at the end of a paragraph.
  ///@param s the paragraph end string
  void setParagraphEnd(
    jni.JString s,
  ) {
    _setParagraphEnd(reference.pointer, _id_setParagraphEnd as jni.JMethodIDPtr,
            s.reference.pointer)
        .check();
  }

  static final _id_getPageStart = _class.instanceMethodId(
    r'getPageStart',
    r'()Ljava/lang/String;',
  );

  static final _getPageStart = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getPageStart()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the string which will be used at the beginning of a page.
  ///@return the page start string
  jni.JString getPageStart() {
    return _getPageStart(
            reference.pointer, _id_getPageStart as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setPageStart = _class.instanceMethodId(
    r'setPageStart',
    r'(Ljava/lang/String;)V',
  );

  static final _setPageStart = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setPageStart(java.lang.String pageStartValue)`
  ///
  /// Sets the string which will be used at the beginning of a page.
  ///@param pageStartValue the page start string
  void setPageStart(
    jni.JString pageStartValue,
  ) {
    _setPageStart(reference.pointer, _id_setPageStart as jni.JMethodIDPtr,
            pageStartValue.reference.pointer)
        .check();
  }

  static final _id_getPageEnd = _class.instanceMethodId(
    r'getPageEnd',
    r'()Ljava/lang/String;',
  );

  static final _getPageEnd = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getPageEnd()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the string which will be used at the end of a page.
  ///@return the page end string
  jni.JString getPageEnd() {
    return _getPageEnd(reference.pointer, _id_getPageEnd as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setPageEnd = _class.instanceMethodId(
    r'setPageEnd',
    r'(Ljava/lang/String;)V',
  );

  static final _setPageEnd = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setPageEnd(java.lang.String pageEndValue)`
  ///
  /// Sets the string which will be used at the end of a page.
  ///@param pageEndValue the page end string
  void setPageEnd(
    jni.JString pageEndValue,
  ) {
    _setPageEnd(reference.pointer, _id_setPageEnd as jni.JMethodIDPtr,
            pageEndValue.reference.pointer)
        .check();
  }

  static final _id_getArticleStart = _class.instanceMethodId(
    r'getArticleStart',
    r'()Ljava/lang/String;',
  );

  static final _getArticleStart = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getArticleStart()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the string which will be used at the beginning of an article.
  ///@return the article start string
  jni.JString getArticleStart() {
    return _getArticleStart(
            reference.pointer, _id_getArticleStart as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setArticleStart = _class.instanceMethodId(
    r'setArticleStart',
    r'(Ljava/lang/String;)V',
  );

  static final _setArticleStart = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setArticleStart(java.lang.String articleStartValue)`
  ///
  /// Sets the string which will be used at the beginning of an article.
  ///@param articleStartValue the article start string
  void setArticleStart(
    jni.JString articleStartValue,
  ) {
    _setArticleStart(reference.pointer, _id_setArticleStart as jni.JMethodIDPtr,
            articleStartValue.reference.pointer)
        .check();
  }

  static final _id_getArticleEnd = _class.instanceMethodId(
    r'getArticleEnd',
    r'()Ljava/lang/String;',
  );

  static final _getArticleEnd = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getArticleEnd()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the string which will be used at the end of an article.
  ///@return the article end string
  jni.JString getArticleEnd() {
    return _getArticleEnd(
            reference.pointer, _id_getArticleEnd as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_setArticleEnd = _class.instanceMethodId(
    r'setArticleEnd',
    r'(Ljava/lang/String;)V',
  );

  static final _setArticleEnd = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void setArticleEnd(java.lang.String articleEndValue)`
  ///
  /// Sets the string which will be used at the end of an article.
  ///@param articleEndValue the article end string
  void setArticleEnd(
    jni.JString articleEndValue,
  ) {
    _setArticleEnd(reference.pointer, _id_setArticleEnd as jni.JMethodIDPtr,
            articleEndValue.reference.pointer)
        .check();
  }
}

final class $PDFTextStripperType extends jni.JObjType<PDFTextStripper> {
  const $PDFTextStripperType();

  @override
  String get signature => r'Lorg/apache/pdfbox/text/PDFTextStripper;';

  @override
  PDFTextStripper fromReference(jni.JReference reference) =>
      PDFTextStripper.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PDFTextStripperType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PDFTextStripperType) &&
        other is $PDFTextStripperType;
  }
}
