// Generated from Apache PDFBox library which is licensed under the Apache License 2.0.
// The following copyright from the original authors applies.
//
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../pdmodel/PDDocument.dart' as pddocument$_;

/// from: `org.apache.pdfbox.text.PDFTextStripper`
///
/// This class will take a pdf document and strip out all of the text and ignore the formatting and such. Please note; it
/// is up to clients of this class to verify that a specific user has the correct permissions to extract text from the
/// PDF document.
///
/// The basic flow of this process is that we get a document and use a series of processXXX() functions that work on
/// smaller and smaller chunks of the page. Eventually, we fully process each page and then print it.
///@author Ben Litchfield
class PDFTextStripper extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PDFTextStripper> $type;

  @jni$_.internal
  PDFTextStripper.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'org/apache/pdfbox/text/PDFTextStripper');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PDFTextStripper$NullableType();
  static const type = $PDFTextStripper$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Instantiate a new PDFTextStripper object.
  ///@throws IOException If there is an error loading the properties.
  factory PDFTextStripper() {
    return PDFTextStripper.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_getText = _class.instanceMethodId(
    r'getText',
    r'(Lorg/apache/pdfbox/pdmodel/PDDocument;)Ljava/lang/String;',
  );

  static final _getText = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String getText(org.apache.pdfbox.pdmodel.PDDocument doc)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will return the text of a document. See writeText. <br>
  /// NOTE: The document must not be encrypted when coming into this method.
  ///
  /// IMPORTANT: By default, text extraction is done in the same sequence as the text in the PDF page content stream.
  /// PDF is a graphic format, not a text format, and unlike HTML, it has no requirements that text one on page
  /// be rendered in a certain order. The order is the one that was determined by the software that created the
  /// PDF. To get text sorted from left to right and top to botton, use \#setSortByPosition(boolean).
  ///@param doc The document to get the text from.
  ///@return The text of the PDF document.
  ///@throws IOException if the doc state is invalid or it is encrypted.
  jni$_.JString? getText(
    pddocument$_.PDDocument? doc,
  ) {
    final _$doc = doc?.reference ?? jni$_.jNullReference;
    return _getText(
            reference.pointer, _id_getText as jni$_.JMethodIDPtr, _$doc.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_writeText = _class.instanceMethodId(
    r'writeText',
    r'(Lorg/apache/pdfbox/pdmodel/PDDocument;Ljava/io/Writer;)V',
  );

  static final _writeText = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void writeText(org.apache.pdfbox.pdmodel.PDDocument doc, java.io.Writer outputStream)`
  ///
  /// This will take a PDDocument and write the text of that document to the print writer.
  ///@param doc The document to get the data from.
  ///@param outputStream The location to put the text.
  ///@throws IOException If the doc is in an invalid state.
  void writeText(
    pddocument$_.PDDocument? doc,
    jni$_.JObject? outputStream,
  ) {
    final _$doc = doc?.reference ?? jni$_.jNullReference;
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    _writeText(reference.pointer, _id_writeText as jni$_.JMethodIDPtr,
            _$doc.pointer, _$outputStream.pointer)
        .check();
  }

  static final _id_processPage = _class.instanceMethodId(
    r'processPage',
    r'(Lorg/apache/pdfbox/pdmodel/PDPage;)V',
  );

  static final _processPage = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void processPage(org.apache.pdfbox.pdmodel.PDPage page)`
  ///
  /// This will process the contents of a page.
  ///@param page The page to process.
  ///@throws IOException If there is an error processing the page.
  void processPage(
    jni$_.JObject? page,
  ) {
    final _$page = page?.reference ?? jni$_.jNullReference;
    _processPage(reference.pointer, _id_processPage as jni$_.JMethodIDPtr,
            _$page.pointer)
        .check();
  }

  static final _id_getStartPage = _class.instanceMethodId(
    r'getStartPage',
    r'()I',
  );

  static final _getStartPage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getStartPage()`
  ///
  /// This is the page that the text extraction will start on. The pages start at page 1. For example in a 5 page PDF
  /// document, if the start page is 1 then all pages will be extracted. If the start page is 4 then pages 4 and 5 will
  /// be extracted. The default value is 1.
  ///@return Value of property startPage.
  int getStartPage() {
    return _getStartPage(
            reference.pointer, _id_getStartPage as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setStartPage = _class.instanceMethodId(
    r'setStartPage',
    r'(I)V',
  );

  static final _setStartPage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setStartPage(int startPageValue)`
  ///
  /// This will set the first page to be extracted by this class.
  ///@param startPageValue New value of 1-based startPage property.
  void setStartPage(
    int startPageValue,
  ) {
    _setStartPage(reference.pointer, _id_setStartPage as jni$_.JMethodIDPtr,
            startPageValue)
        .check();
  }

  static final _id_getEndPage = _class.instanceMethodId(
    r'getEndPage',
    r'()I',
  );

  static final _getEndPage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getEndPage()`
  ///
  /// This will get the last page that will be extracted. This is inclusive, for example if a 5 page PDF an endPage
  /// value of 5 would extract the entire document, an end page of 2 would extract pages 1 and 2. This defaults to
  /// Integer.MAX_VALUE such that all pages of the pdf will be extracted.
  ///@return Value of property endPage.
  int getEndPage() {
    return _getEndPage(reference.pointer, _id_getEndPage as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_setEndPage = _class.instanceMethodId(
    r'setEndPage',
    r'(I)V',
  );

  static final _setEndPage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setEndPage(int endPageValue)`
  ///
  /// This will set the last page to be extracted by this class.
  ///@param endPageValue New value of 1-based endPage property.
  void setEndPage(
    int endPageValue,
  ) {
    _setEndPage(reference.pointer, _id_setEndPage as jni$_.JMethodIDPtr,
            endPageValue)
        .check();
  }

  static final _id_setLineSeparator = _class.instanceMethodId(
    r'setLineSeparator',
    r'(Ljava/lang/String;)V',
  );

  static final _setLineSeparator = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setLineSeparator(java.lang.String separator)`
  ///
  /// Set the desired line separator for output text. The line.separator system property is used if the line separator
  /// preference is not set explicitly using this method.
  ///@param separator The desired line separator string.
  void setLineSeparator(
    jni$_.JString? separator,
  ) {
    final _$separator = separator?.reference ?? jni$_.jNullReference;
    _setLineSeparator(reference.pointer,
            _id_setLineSeparator as jni$_.JMethodIDPtr, _$separator.pointer)
        .check();
  }

  static final _id_getLineSeparator = _class.instanceMethodId(
    r'getLineSeparator',
    r'()Ljava/lang/String;',
  );

  static final _getLineSeparator = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getLineSeparator()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the line separator.
  ///@return The desired line separator string.
  jni$_.JString? getLineSeparator() {
    return _getLineSeparator(
            reference.pointer, _id_getLineSeparator as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getWordSeparator = _class.instanceMethodId(
    r'getWordSeparator',
    r'()Ljava/lang/String;',
  );

  static final _getWordSeparator = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getWordSeparator()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the word separator.
  ///@return The desired word separator string.
  jni$_.JString? getWordSeparator() {
    return _getWordSeparator(
            reference.pointer, _id_getWordSeparator as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setWordSeparator = _class.instanceMethodId(
    r'setWordSeparator',
    r'(Ljava/lang/String;)V',
  );

  static final _setWordSeparator = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setWordSeparator(java.lang.String separator)`
  ///
  /// Set the desired word separator for output text. The PDFBox text extraction algorithm will output a space
  /// character if there is enough space between two words. By default a space character is used. If you need and
  /// accurate count of characters that are found in a PDF document then you might want to set the word separator to
  /// the empty string.
  ///@param separator The desired page separator string.
  void setWordSeparator(
    jni$_.JString? separator,
  ) {
    final _$separator = separator?.reference ?? jni$_.jNullReference;
    _setWordSeparator(reference.pointer,
            _id_setWordSeparator as jni$_.JMethodIDPtr, _$separator.pointer)
        .check();
  }

  static final _id_getSuppressDuplicateOverlappingText =
      _class.instanceMethodId(
    r'getSuppressDuplicateOverlappingText',
    r'()Z',
  );

  static final _getSuppressDuplicateOverlappingText =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public boolean getSuppressDuplicateOverlappingText()`
  ///
  /// @return Returns the suppressDuplicateOverlappingText.
  bool getSuppressDuplicateOverlappingText() {
    return _getSuppressDuplicateOverlappingText(reference.pointer,
            _id_getSuppressDuplicateOverlappingText as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setSuppressDuplicateOverlappingText =
      _class.instanceMethodId(
    r'setSuppressDuplicateOverlappingText',
    r'(Z)V',
  );

  static final _setSuppressDuplicateOverlappingText =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setSuppressDuplicateOverlappingText(boolean suppressDuplicateOverlappingTextValue)`
  ///
  /// By default the text stripper will attempt to remove text that overlapps each other. Word paints the same
  /// character several times in order to make it look bold. By setting this to false all text will be extracted, which
  /// means that certain sections will be duplicated, but better performance will be noticed.
  ///@param suppressDuplicateOverlappingTextValue The suppressDuplicateOverlappingText to set.
  void setSuppressDuplicateOverlappingText(
    bool suppressDuplicateOverlappingTextValue,
  ) {
    _setSuppressDuplicateOverlappingText(
            reference.pointer,
            _id_setSuppressDuplicateOverlappingText as jni$_.JMethodIDPtr,
            suppressDuplicateOverlappingTextValue ? 1 : 0)
        .check();
  }

  static final _id_getSeparateByBeads = _class.instanceMethodId(
    r'getSeparateByBeads',
    r'()Z',
  );

  static final _getSeparateByBeads = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getSeparateByBeads()`
  ///
  /// This will tell if the text stripper should separate by beads.
  ///@return If the text will be grouped by beads.
  bool getSeparateByBeads() {
    return _getSeparateByBeads(
            reference.pointer, _id_getSeparateByBeads as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setShouldSeparateByBeads = _class.instanceMethodId(
    r'setShouldSeparateByBeads',
    r'(Z)V',
  );

  static final _setShouldSeparateByBeads = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setShouldSeparateByBeads(boolean aShouldSeparateByBeads)`
  ///
  /// Set if the text stripper should group the text output by a list of beads. The default value is true!
  ///@param aShouldSeparateByBeads The new grouping of beads.
  void setShouldSeparateByBeads(
    bool aShouldSeparateByBeads,
  ) {
    _setShouldSeparateByBeads(
            reference.pointer,
            _id_setShouldSeparateByBeads as jni$_.JMethodIDPtr,
            aShouldSeparateByBeads ? 1 : 0)
        .check();
  }

  static final _id_getEndBookmark = _class.instanceMethodId(
    r'getEndBookmark',
    r'()Lorg/apache/pdfbox/pdmodel/interactive/documentnavigation/outline/PDOutlineItem;',
  );

  static final _getEndBookmark = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem getEndBookmark()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the bookmark where text extraction should end, inclusive. Default is null.
  ///@return The ending bookmark.
  jni$_.JObject? getEndBookmark() {
    return _getEndBookmark(
            reference.pointer, _id_getEndBookmark as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setEndBookmark = _class.instanceMethodId(
    r'setEndBookmark',
    r'(Lorg/apache/pdfbox/pdmodel/interactive/documentnavigation/outline/PDOutlineItem;)V',
  );

  static final _setEndBookmark = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setEndBookmark(org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem aEndBookmark)`
  ///
  /// Set the bookmark where the text extraction should stop.
  ///@param aEndBookmark The ending bookmark.
  void setEndBookmark(
    jni$_.JObject? aEndBookmark,
  ) {
    final _$aEndBookmark = aEndBookmark?.reference ?? jni$_.jNullReference;
    _setEndBookmark(reference.pointer, _id_setEndBookmark as jni$_.JMethodIDPtr,
            _$aEndBookmark.pointer)
        .check();
  }

  static final _id_getStartBookmark = _class.instanceMethodId(
    r'getStartBookmark',
    r'()Lorg/apache/pdfbox/pdmodel/interactive/documentnavigation/outline/PDOutlineItem;',
  );

  static final _getStartBookmark = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem getStartBookmark()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the bookmark where text extraction should start, inclusive. Default is null.
  ///@return The starting bookmark.
  jni$_.JObject? getStartBookmark() {
    return _getStartBookmark(
            reference.pointer, _id_getStartBookmark as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setStartBookmark = _class.instanceMethodId(
    r'setStartBookmark',
    r'(Lorg/apache/pdfbox/pdmodel/interactive/documentnavigation/outline/PDOutlineItem;)V',
  );

  static final _setStartBookmark = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setStartBookmark(org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem aStartBookmark)`
  ///
  /// Set the bookmark where text extraction should start, inclusive.
  ///@param aStartBookmark The starting bookmark.
  void setStartBookmark(
    jni$_.JObject? aStartBookmark,
  ) {
    final _$aStartBookmark = aStartBookmark?.reference ?? jni$_.jNullReference;
    _setStartBookmark(
            reference.pointer,
            _id_setStartBookmark as jni$_.JMethodIDPtr,
            _$aStartBookmark.pointer)
        .check();
  }

  static final _id_getAddMoreFormatting = _class.instanceMethodId(
    r'getAddMoreFormatting',
    r'()Z',
  );

  static final _getAddMoreFormatting = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getAddMoreFormatting()`
  ///
  /// This will tell if the text stripper should add some more text formatting.
  ///@return true if some more text formatting will be added
  bool getAddMoreFormatting() {
    return _getAddMoreFormatting(
            reference.pointer, _id_getAddMoreFormatting as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAddMoreFormatting = _class.instanceMethodId(
    r'setAddMoreFormatting',
    r'(Z)V',
  );

  static final _setAddMoreFormatting = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAddMoreFormatting(boolean newAddMoreFormatting)`
  ///
  /// There will some additional text formatting be added if addMoreFormatting is set to true. Default is false.
  ///@param newAddMoreFormatting Tell PDFBox to add some more text formatting
  void setAddMoreFormatting(
    bool newAddMoreFormatting,
  ) {
    _setAddMoreFormatting(
            reference.pointer,
            _id_setAddMoreFormatting as jni$_.JMethodIDPtr,
            newAddMoreFormatting ? 1 : 0)
        .check();
  }

  static final _id_getSortByPosition = _class.instanceMethodId(
    r'getSortByPosition',
    r'()Z',
  );

  static final _getSortByPosition = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean getSortByPosition()`
  ///
  /// This will tell if the text stripper should sort the text tokens before writing to the stream.
  ///@return true If the text tokens will be sorted before being written.
  bool getSortByPosition() {
    return _getSortByPosition(
            reference.pointer, _id_getSortByPosition as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setSortByPosition = _class.instanceMethodId(
    r'setSortByPosition',
    r'(Z)V',
  );

  static final _setSortByPosition = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setSortByPosition(boolean newSortByPosition)`
  ///
  /// The order of the text tokens in a PDF file may not be in the same as they appear visually on the screen. For
  /// example, a PDF writer may write out all text by font, so all bold or larger text, then make a second pass and
  /// write out the normal text.<br>
  /// The default is to __not__ sort by position.<br>
  /// <br>
  /// A PDF writer could choose to write each character in a different order. By default PDFBox does __not__ sort
  /// the text tokens before processing them due to performance reasons.
  ///@param newSortByPosition Tell PDFBox to sort the text positions.
  void setSortByPosition(
    bool newSortByPosition,
  ) {
    _setSortByPosition(
            reference.pointer,
            _id_setSortByPosition as jni$_.JMethodIDPtr,
            newSortByPosition ? 1 : 0)
        .check();
  }

  static final _id_getSpacingTolerance = _class.instanceMethodId(
    r'getSpacingTolerance',
    r'()F',
  );

  static final _getSpacingTolerance = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public float getSpacingTolerance()`
  ///
  /// Get the current space width-based tolerance value that is being used to estimate where spaces in text should be
  /// added. Note that the default value for this has been determined from trial and error.
  ///@return The current tolerance / scaling factor
  double getSpacingTolerance() {
    return _getSpacingTolerance(
            reference.pointer, _id_getSpacingTolerance as jni$_.JMethodIDPtr)
        .float;
  }

  static final _id_setSpacingTolerance = _class.instanceMethodId(
    r'setSpacingTolerance',
    r'(F)V',
  );

  static final _setSpacingTolerance = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public void setSpacingTolerance(float spacingToleranceValue)`
  ///
  /// Set the space width-based tolerance value that is used to estimate where spaces in text should be added. Note
  /// that the default value for this has been determined from trial and error. Setting this value larger will reduce
  /// the number of spaces added.
  ///@param spacingToleranceValue tolerance / scaling factor to use
  void setSpacingTolerance(
    double spacingToleranceValue,
  ) {
    _setSpacingTolerance(
            reference.pointer,
            _id_setSpacingTolerance as jni$_.JMethodIDPtr,
            spacingToleranceValue)
        .check();
  }

  static final _id_getAverageCharTolerance = _class.instanceMethodId(
    r'getAverageCharTolerance',
    r'()F',
  );

  static final _getAverageCharTolerance = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public float getAverageCharTolerance()`
  ///
  /// Get the current character width-based tolerance value that is being used to estimate where spaces in text should
  /// be added. Note that the default value for this has been determined from trial and error.
  ///@return The current tolerance / scaling factor
  double getAverageCharTolerance() {
    return _getAverageCharTolerance(reference.pointer,
            _id_getAverageCharTolerance as jni$_.JMethodIDPtr)
        .float;
  }

  static final _id_setAverageCharTolerance = _class.instanceMethodId(
    r'setAverageCharTolerance',
    r'(F)V',
  );

  static final _setAverageCharTolerance = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public void setAverageCharTolerance(float averageCharToleranceValue)`
  ///
  /// Set the character width-based tolerance value that is used to estimate where spaces in text should be added. Note
  /// that the default value for this has been determined from trial and error. Setting this value larger will reduce
  /// the number of spaces added.
  ///@param averageCharToleranceValue average tolerance / scaling factor to use
  void setAverageCharTolerance(
    double averageCharToleranceValue,
  ) {
    _setAverageCharTolerance(
            reference.pointer,
            _id_setAverageCharTolerance as jni$_.JMethodIDPtr,
            averageCharToleranceValue)
        .check();
  }

  static final _id_getIndentThreshold = _class.instanceMethodId(
    r'getIndentThreshold',
    r'()F',
  );

  static final _getIndentThreshold = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public float getIndentThreshold()`
  ///
  /// returns the multiple of whitespace character widths for the current text which the current line start can be
  /// indented from the previous line start beyond which the current line start is considered to be a paragraph start.
  ///@return the number of whitespace character widths to use when detecting paragraph indents.
  double getIndentThreshold() {
    return _getIndentThreshold(
            reference.pointer, _id_getIndentThreshold as jni$_.JMethodIDPtr)
        .float;
  }

  static final _id_setIndentThreshold = _class.instanceMethodId(
    r'setIndentThreshold',
    r'(F)V',
  );

  static final _setIndentThreshold = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public void setIndentThreshold(float indentThresholdValue)`
  ///
  /// sets the multiple of whitespace character widths for the current text which the current line start can be
  /// indented from the previous line start beyond which the current line start is considered to be a paragraph start.
  /// The default value is 2.0.
  ///@param indentThresholdValue the number of whitespace character widths to use when detecting paragraph indents.
  void setIndentThreshold(
    double indentThresholdValue,
  ) {
    _setIndentThreshold(reference.pointer,
            _id_setIndentThreshold as jni$_.JMethodIDPtr, indentThresholdValue)
        .check();
  }

  static final _id_getDropThreshold = _class.instanceMethodId(
    r'getDropThreshold',
    r'()F',
  );

  static final _getDropThreshold = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public float getDropThreshold()`
  ///
  /// the minimum whitespace, as a multiple of the max height of the current characters beyond which the current line
  /// start is considered to be a paragraph start.
  ///@return the character height multiple for max allowed whitespace between lines in the same paragraph.
  double getDropThreshold() {
    return _getDropThreshold(
            reference.pointer, _id_getDropThreshold as jni$_.JMethodIDPtr)
        .float;
  }

  static final _id_setDropThreshold = _class.instanceMethodId(
    r'setDropThreshold',
    r'(F)V',
  );

  static final _setDropThreshold = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public void setDropThreshold(float dropThresholdValue)`
  ///
  /// sets the minimum whitespace, as a multiple of the max height of the current characters beyond which the current
  /// line start is considered to be a paragraph start. The default value is 2.5.
  ///@param dropThresholdValue the character height multiple for max allowed whitespace between lines in the same
  /// paragraph.
  void setDropThreshold(
    double dropThresholdValue,
  ) {
    _setDropThreshold(reference.pointer,
            _id_setDropThreshold as jni$_.JMethodIDPtr, dropThresholdValue)
        .check();
  }

  static final _id_getParagraphStart = _class.instanceMethodId(
    r'getParagraphStart',
    r'()Ljava/lang/String;',
  );

  static final _getParagraphStart = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getParagraphStart()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the string which will be used at the beginning of a paragraph.
  ///@return the paragraph start string
  jni$_.JString? getParagraphStart() {
    return _getParagraphStart(
            reference.pointer, _id_getParagraphStart as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setParagraphStart = _class.instanceMethodId(
    r'setParagraphStart',
    r'(Ljava/lang/String;)V',
  );

  static final _setParagraphStart = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setParagraphStart(java.lang.String s)`
  ///
  /// Sets the string which will be used at the beginning of a paragraph.
  ///@param s the paragraph start string
  void setParagraphStart(
    jni$_.JString? s,
  ) {
    final _$s = s?.reference ?? jni$_.jNullReference;
    _setParagraphStart(reference.pointer,
            _id_setParagraphStart as jni$_.JMethodIDPtr, _$s.pointer)
        .check();
  }

  static final _id_getParagraphEnd = _class.instanceMethodId(
    r'getParagraphEnd',
    r'()Ljava/lang/String;',
  );

  static final _getParagraphEnd = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getParagraphEnd()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the string which will be used at the end of a paragraph.
  ///@return the paragraph end string
  jni$_.JString? getParagraphEnd() {
    return _getParagraphEnd(
            reference.pointer, _id_getParagraphEnd as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setParagraphEnd = _class.instanceMethodId(
    r'setParagraphEnd',
    r'(Ljava/lang/String;)V',
  );

  static final _setParagraphEnd = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setParagraphEnd(java.lang.String s)`
  ///
  /// Sets the string which will be used at the end of a paragraph.
  ///@param s the paragraph end string
  void setParagraphEnd(
    jni$_.JString? s,
  ) {
    final _$s = s?.reference ?? jni$_.jNullReference;
    _setParagraphEnd(reference.pointer,
            _id_setParagraphEnd as jni$_.JMethodIDPtr, _$s.pointer)
        .check();
  }

  static final _id_getPageStart = _class.instanceMethodId(
    r'getPageStart',
    r'()Ljava/lang/String;',
  );

  static final _getPageStart = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getPageStart()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the string which will be used at the beginning of a page.
  ///@return the page start string
  jni$_.JString? getPageStart() {
    return _getPageStart(
            reference.pointer, _id_getPageStart as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setPageStart = _class.instanceMethodId(
    r'setPageStart',
    r'(Ljava/lang/String;)V',
  );

  static final _setPageStart = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setPageStart(java.lang.String pageStartValue)`
  ///
  /// Sets the string which will be used at the beginning of a page.
  ///@param pageStartValue the page start string
  void setPageStart(
    jni$_.JString? pageStartValue,
  ) {
    final _$pageStartValue = pageStartValue?.reference ?? jni$_.jNullReference;
    _setPageStart(reference.pointer, _id_setPageStart as jni$_.JMethodIDPtr,
            _$pageStartValue.pointer)
        .check();
  }

  static final _id_getPageEnd = _class.instanceMethodId(
    r'getPageEnd',
    r'()Ljava/lang/String;',
  );

  static final _getPageEnd = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getPageEnd()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the string which will be used at the end of a page.
  ///@return the page end string
  jni$_.JString? getPageEnd() {
    return _getPageEnd(reference.pointer, _id_getPageEnd as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setPageEnd = _class.instanceMethodId(
    r'setPageEnd',
    r'(Ljava/lang/String;)V',
  );

  static final _setPageEnd = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setPageEnd(java.lang.String pageEndValue)`
  ///
  /// Sets the string which will be used at the end of a page.
  ///@param pageEndValue the page end string
  void setPageEnd(
    jni$_.JString? pageEndValue,
  ) {
    final _$pageEndValue = pageEndValue?.reference ?? jni$_.jNullReference;
    _setPageEnd(reference.pointer, _id_setPageEnd as jni$_.JMethodIDPtr,
            _$pageEndValue.pointer)
        .check();
  }

  static final _id_getArticleStart = _class.instanceMethodId(
    r'getArticleStart',
    r'()Ljava/lang/String;',
  );

  static final _getArticleStart = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getArticleStart()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the string which will be used at the beginning of an article.
  ///@return the article start string
  jni$_.JString? getArticleStart() {
    return _getArticleStart(
            reference.pointer, _id_getArticleStart as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setArticleStart = _class.instanceMethodId(
    r'setArticleStart',
    r'(Ljava/lang/String;)V',
  );

  static final _setArticleStart = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setArticleStart(java.lang.String articleStartValue)`
  ///
  /// Sets the string which will be used at the beginning of an article.
  ///@param articleStartValue the article start string
  void setArticleStart(
    jni$_.JString? articleStartValue,
  ) {
    final _$articleStartValue =
        articleStartValue?.reference ?? jni$_.jNullReference;
    _setArticleStart(
            reference.pointer,
            _id_setArticleStart as jni$_.JMethodIDPtr,
            _$articleStartValue.pointer)
        .check();
  }

  static final _id_getArticleEnd = _class.instanceMethodId(
    r'getArticleEnd',
    r'()Ljava/lang/String;',
  );

  static final _getArticleEnd = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getArticleEnd()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the string which will be used at the end of an article.
  ///@return the article end string
  jni$_.JString? getArticleEnd() {
    return _getArticleEnd(
            reference.pointer, _id_getArticleEnd as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setArticleEnd = _class.instanceMethodId(
    r'setArticleEnd',
    r'(Ljava/lang/String;)V',
  );

  static final _setArticleEnd = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setArticleEnd(java.lang.String articleEndValue)`
  ///
  /// Sets the string which will be used at the end of an article.
  ///@param articleEndValue the article end string
  void setArticleEnd(
    jni$_.JString? articleEndValue,
  ) {
    final _$articleEndValue =
        articleEndValue?.reference ?? jni$_.jNullReference;
    _setArticleEnd(reference.pointer, _id_setArticleEnd as jni$_.JMethodIDPtr,
            _$articleEndValue.pointer)
        .check();
  }
}

final class $PDFTextStripper$NullableType
    extends jni$_.JObjType<PDFTextStripper?> {
  @jni$_.internal
  const $PDFTextStripper$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/apache/pdfbox/text/PDFTextStripper;';

  @jni$_.internal
  @core$_.override
  PDFTextStripper? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : PDFTextStripper.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PDFTextStripper?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PDFTextStripper$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PDFTextStripper$NullableType) &&
        other is $PDFTextStripper$NullableType;
  }
}

final class $PDFTextStripper$Type extends jni$_.JObjType<PDFTextStripper> {
  @jni$_.internal
  const $PDFTextStripper$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/apache/pdfbox/text/PDFTextStripper;';

  @jni$_.internal
  @core$_.override
  PDFTextStripper fromReference(jni$_.JReference reference) =>
      PDFTextStripper.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PDFTextStripper?> get nullableType =>
      const $PDFTextStripper$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PDFTextStripper$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PDFTextStripper$Type) &&
        other is $PDFTextStripper$Type;
  }
}
