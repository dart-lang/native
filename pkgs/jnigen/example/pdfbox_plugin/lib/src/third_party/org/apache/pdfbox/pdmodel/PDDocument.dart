// Generated from Apache PDFBox library which is licensed under the Apache License 2.0.
// The following copyright from the original authors applies.
//
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'PDDocumentInformation.dart' as pddocumentinformation$_;

/// from: `org.apache.pdfbox.pdmodel.PDDocument`
///
/// This is the in-memory representation of the PDF document.
/// The \#close() method must be called once the document is no longer needed.
///@author Ben Litchfield
class PDDocument extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PDDocument> $type;

  @jni$_.internal
  PDDocument.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'org/apache/pdfbox/pdmodel/PDDocument');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PDDocument$NullableType();
  static const type = $PDDocument$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates an empty PDF document.
  /// You need to add at least one page for the document to be valid.
  factory PDDocument() {
    return PDDocument.fromReference(
        _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Lorg/apache/pdfbox/io/MemoryUsageSetting;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates an empty PDF document.
  /// You need to add at least one page for the document to be valid.
  ///@param memUsageSetting defines how memory is used for buffering PDF streams
  factory PDDocument.new$1(
    jni$_.JObject? memUsageSetting,
  ) {
    final _$memUsageSetting =
        memUsageSetting?.reference ?? jni$_.jNullReference;
    return PDDocument.fromReference(_new$1(_class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr, _$memUsageSetting.pointer)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Lorg/apache/pdfbox/cos/COSDocument;)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(org.apache.pdfbox.cos.COSDocument doc)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructor that uses an existing document. The COSDocument that is passed in must be valid.
  ///@param doc The COSDocument that this document wraps.
  factory PDDocument.new$2(
    jni$_.JObject? doc,
  ) {
    final _$doc = doc?.reference ?? jni$_.jNullReference;
    return PDDocument.fromReference(_new$2(_class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr, _$doc.pointer)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Lorg/apache/pdfbox/cos/COSDocument;Lorg/apache/pdfbox/io/RandomAccessRead;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(org.apache.pdfbox.cos.COSDocument doc, org.apache.pdfbox.io.RandomAccessRead source)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructor that uses an existing document. The COSDocument that is passed in must be valid.
  ///@param doc The COSDocument that this document wraps.
  ///@param source the parser which is used to read the pdf
  factory PDDocument.new$3(
    jni$_.JObject? doc,
    jni$_.JObject? source,
  ) {
    final _$doc = doc?.reference ?? jni$_.jNullReference;
    final _$source = source?.reference ?? jni$_.jNullReference;
    return PDDocument.fromReference(_new$3(_class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr, _$doc.pointer, _$source.pointer)
        .reference);
  }

  static final _id_new$4 = _class.constructorId(
    r'(Lorg/apache/pdfbox/cos/COSDocument;Lorg/apache/pdfbox/io/RandomAccessRead;Lorg/apache/pdfbox/pdmodel/encryption/AccessPermission;)V',
  );

  static final _new$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(org.apache.pdfbox.cos.COSDocument doc, org.apache.pdfbox.io.RandomAccessRead source, org.apache.pdfbox.pdmodel.encryption.AccessPermission permission)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructor that uses an existing document. The COSDocument that is passed in must be valid.
  ///@param doc The COSDocument that this document wraps.
  ///@param source the parser which is used to read the pdf
  ///@param permission he access permissions of the pdf
  factory PDDocument.new$4(
    jni$_.JObject? doc,
    jni$_.JObject? source,
    jni$_.JObject? permission,
  ) {
    final _$doc = doc?.reference ?? jni$_.jNullReference;
    final _$source = source?.reference ?? jni$_.jNullReference;
    final _$permission = permission?.reference ?? jni$_.jNullReference;
    return PDDocument.fromReference(_new$4(
            _class.reference.pointer,
            _id_new$4 as jni$_.JMethodIDPtr,
            _$doc.pointer,
            _$source.pointer,
            _$permission.pointer)
        .reference);
  }

  static final _id_addPage = _class.instanceMethodId(
    r'addPage',
    r'(Lorg/apache/pdfbox/pdmodel/PDPage;)V',
  );

  static final _addPage = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addPage(org.apache.pdfbox.pdmodel.PDPage page)`
  ///
  /// This will add a page to the document. This is a convenience method, that will add the page to the root of the
  /// hierarchy and set the parent of the page to the root.
  ///@param page The page to add to the document.
  void addPage(
    jni$_.JObject? page,
  ) {
    final _$page = page?.reference ?? jni$_.jNullReference;
    _addPage(reference.pointer, _id_addPage as jni$_.JMethodIDPtr,
            _$page.pointer)
        .check();
  }

  static final _id_addSignature = _class.instanceMethodId(
    r'addSignature',
    r'(Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/PDSignature;)V',
  );

  static final _addSignature = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addSignature(org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature sigObject)`
  ///
  /// Add parameters of signature to be created externally using default signature options. See
  /// \#saveIncrementalForExternalSigning(OutputStream) method description on external
  /// signature creation scenario details.
  ///
  /// Only one signature may be added in a document. To sign several times,
  /// load document, add signature, save incremental and close again.
  ///@param sigObject is the PDSignatureField model
  ///@throws IOException if there is an error creating required fields
  ///@throws IllegalStateException if one attempts to add several signature
  /// fields.
  void addSignature(
    jni$_.JObject? sigObject,
  ) {
    final _$sigObject = sigObject?.reference ?? jni$_.jNullReference;
    _addSignature(reference.pointer, _id_addSignature as jni$_.JMethodIDPtr,
            _$sigObject.pointer)
        .check();
  }

  static final _id_addSignature$1 = _class.instanceMethodId(
    r'addSignature',
    r'(Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/PDSignature;Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/SignatureOptions;)V',
  );

  static final _addSignature$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addSignature(org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature sigObject, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions options)`
  ///
  /// Add parameters of signature to be created externally. See
  /// \#saveIncrementalForExternalSigning(OutputStream) method description on external
  /// signature creation scenario details.
  ///
  /// Only one signature may be added in a document. To sign several times,
  /// load document, add signature, save incremental and close again.
  ///@param sigObject is the PDSignatureField model
  ///@param options signature options
  ///@throws IOException if there is an error creating required fields
  ///@throws IllegalStateException if one attempts to add several signature
  /// fields.
  void addSignature$1(
    jni$_.JObject? sigObject,
    jni$_.JObject? options,
  ) {
    final _$sigObject = sigObject?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    _addSignature$1(reference.pointer, _id_addSignature$1 as jni$_.JMethodIDPtr,
            _$sigObject.pointer, _$options.pointer)
        .check();
  }

  static final _id_addSignature$2 = _class.instanceMethodId(
    r'addSignature',
    r'(Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/PDSignature;Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/SignatureInterface;)V',
  );

  static final _addSignature$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addSignature(org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature sigObject, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureInterface signatureInterface)`
  ///
  /// Add a signature to be created using the instance of given interface.
  ///
  /// Only one signature may be added in a document. To sign several times,
  /// load document, add signature, save incremental and close again.
  ///@param sigObject is the PDSignatureField model
  ///@param signatureInterface is an interface whose implementation provides
  /// signing capabilities. Can be null if external signing if used.
  ///@throws IOException if there is an error creating required fields
  ///@throws IllegalStateException if one attempts to add several signature
  /// fields.
  void addSignature$2(
    jni$_.JObject? sigObject,
    jni$_.JObject? signatureInterface,
  ) {
    final _$sigObject = sigObject?.reference ?? jni$_.jNullReference;
    final _$signatureInterface =
        signatureInterface?.reference ?? jni$_.jNullReference;
    _addSignature$2(reference.pointer, _id_addSignature$2 as jni$_.JMethodIDPtr,
            _$sigObject.pointer, _$signatureInterface.pointer)
        .check();
  }

  static final _id_addSignature$3 = _class.instanceMethodId(
    r'addSignature',
    r'(Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/PDSignature;Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/SignatureInterface;Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/SignatureOptions;)V',
  );

  static final _addSignature$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addSignature(org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature sigObject, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureInterface signatureInterface, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions options)`
  ///
  /// This will add a signature to the document. If the 0-based page number in the options
  /// parameter is smaller than 0 or larger than max, the nearest valid page number will be used
  /// (i.e. 0 or max) and no exception will be thrown.
  ///
  /// Only one signature may be added in a document. To sign several times,
  /// load document, add signature, save incremental and close again.
  ///@param sigObject is the PDSignatureField model
  ///@param signatureInterface is an interface whose implementation provides
  /// signing capabilities. Can be null if external signing if used.
  ///@param options signature options
  ///@throws IOException if there is an error creating required fields
  ///@throws IllegalStateException if one attempts to add several signature
  /// fields.
  void addSignature$3(
    jni$_.JObject? sigObject,
    jni$_.JObject? signatureInterface,
    jni$_.JObject? options,
  ) {
    final _$sigObject = sigObject?.reference ?? jni$_.jNullReference;
    final _$signatureInterface =
        signatureInterface?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    _addSignature$3(
            reference.pointer,
            _id_addSignature$3 as jni$_.JMethodIDPtr,
            _$sigObject.pointer,
            _$signatureInterface.pointer,
            _$options.pointer)
        .check();
  }

  static final _id_addSignatureField = _class.instanceMethodId(
    r'addSignatureField',
    r'(Ljava/util/List;Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/SignatureInterface;Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/SignatureOptions;)V',
  );

  static final _addSignatureField = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void addSignatureField(java.util.List<org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField> sigFields, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureInterface signatureInterface, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions options)`
  ///
  /// This will add a list of signature fields to the document.
  ///@param sigFields are the PDSignatureFields that should be added to the document
  ///@param signatureInterface is an interface whose implementation provides
  /// signing capabilities. Can be null if external signing if used.
  ///@param options signature options
  ///@throws IOException if there is an error creating required fields
  ///@deprecated The method is misleading, because only one signature may be
  /// added in a document. The method will be removed in the future.
  void addSignatureField(
    jni$_.JList<jni$_.JObject?>? sigFields,
    jni$_.JObject? signatureInterface,
    jni$_.JObject? options,
  ) {
    final _$sigFields = sigFields?.reference ?? jni$_.jNullReference;
    final _$signatureInterface =
        signatureInterface?.reference ?? jni$_.jNullReference;
    final _$options = options?.reference ?? jni$_.jNullReference;
    _addSignatureField(
            reference.pointer,
            _id_addSignatureField as jni$_.JMethodIDPtr,
            _$sigFields.pointer,
            _$signatureInterface.pointer,
            _$options.pointer)
        .check();
  }

  static final _id_removePage = _class.instanceMethodId(
    r'removePage',
    r'(Lorg/apache/pdfbox/pdmodel/PDPage;)V',
  );

  static final _removePage = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void removePage(org.apache.pdfbox.pdmodel.PDPage page)`
  ///
  /// Remove the page from the document.
  ///@param page The page to remove from the document.
  void removePage(
    jni$_.JObject? page,
  ) {
    final _$page = page?.reference ?? jni$_.jNullReference;
    _removePage(reference.pointer, _id_removePage as jni$_.JMethodIDPtr,
            _$page.pointer)
        .check();
  }

  static final _id_removePage$1 = _class.instanceMethodId(
    r'removePage',
    r'(I)V',
  );

  static final _removePage$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void removePage(int pageNumber)`
  ///
  /// Remove the page from the document.
  ///@param pageNumber 0 based index to page number.
  void removePage$1(
    int pageNumber,
  ) {
    _removePage$1(reference.pointer, _id_removePage$1 as jni$_.JMethodIDPtr,
            pageNumber)
        .check();
  }

  static final _id_importPage = _class.instanceMethodId(
    r'importPage',
    r'(Lorg/apache/pdfbox/pdmodel/PDPage;)Lorg/apache/pdfbox/pdmodel/PDPage;',
  );

  static final _importPage = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.apache.pdfbox.pdmodel.PDPage importPage(org.apache.pdfbox.pdmodel.PDPage page)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will import and copy the contents from another location. Currently the content stream is
  /// stored in a scratch file. The scratch file is associated with the document. If you are adding
  /// a page to this document from another document and want to copy the contents to this
  /// document's scratch file then use this method otherwise just use the \#addPage addPage()
  /// method.
  ///
  /// Unlike \#addPage addPage(), this method creates a new PDPage object. If your page has
  /// annotations, and if these link to pages not in the target document, then the target document
  /// might become huge. What you need to do is to delete page references of such annotations. See
  /// <a href="http://stackoverflow.com/a/35477351/535646">here</a> for how to do this.
  ///
  /// Inherited (global) resources are ignored because these can contain resources not needed for
  /// this page which could bloat your document, see
  /// <a href="https://issues.apache.org/jira/browse/PDFBOX-28">PDFBOX-28</a> and related issues.
  /// If you need them, call <code>importedPage.setResources(page.getResources());</code>
  ///
  /// This method should only be used to import a page from a loaded document, not from a generated
  /// document because these can contain unfinished parts, e.g. font subsetting information.
  ///@param page The page to import.
  ///@return The page that was imported.
  ///@throws IOException If there is an error copying the page.
  jni$_.JObject? importPage(
    jni$_.JObject? page,
  ) {
    final _$page = page?.reference ?? jni$_.jNullReference;
    return _importPage(reference.pointer, _id_importPage as jni$_.JMethodIDPtr,
            _$page.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getDocument = _class.instanceMethodId(
    r'getDocument',
    r'()Lorg/apache/pdfbox/cos/COSDocument;',
  );

  static final _getDocument = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.cos.COSDocument getDocument()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the low level document.
  ///@return The document that this layer sits on top of.
  jni$_.JObject? getDocument() {
    return _getDocument(
            reference.pointer, _id_getDocument as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getDocumentInformation = _class.instanceMethodId(
    r'getDocumentInformation',
    r'()Lorg/apache/pdfbox/pdmodel/PDDocumentInformation;',
  );

  static final _getDocumentInformation = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.pdmodel.PDDocumentInformation getDocumentInformation()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the document info dictionary. If it doesn't exist, an empty document info
  /// dictionary is created in the document trailer.
  ///
  /// In PDF 2.0 this is deprecated except for two entries, /CreationDate and /ModDate. For any other
  /// document level metadata, a metadata stream should be used instead, see
  /// PDDocumentCatalog\#getMetadata().
  ///@return The documents /Info dictionary, never null.
  pddocumentinformation$_.PDDocumentInformation? getDocumentInformation() {
    return _getDocumentInformation(
            reference.pointer, _id_getDocumentInformation as jni$_.JMethodIDPtr)
        .object<pddocumentinformation$_.PDDocumentInformation?>(
            const pddocumentinformation$_
                .$PDDocumentInformation$NullableType());
  }

  static final _id_setDocumentInformation = _class.instanceMethodId(
    r'setDocumentInformation',
    r'(Lorg/apache/pdfbox/pdmodel/PDDocumentInformation;)V',
  );

  static final _setDocumentInformation = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDocumentInformation(org.apache.pdfbox.pdmodel.PDDocumentInformation info)`
  ///
  /// This will set the document information for this document.
  ///
  /// In PDF 2.0 this is deprecated except for two entries, /CreationDate and /ModDate. For any other
  /// document level metadata, a metadata stream should be used instead, see
  /// PDDocumentCatalog\#setMetadata(org.apache.pdfbox.pdmodel.common.PDMetadata) PDDocumentCatalog\#setMetadata(PDMetadata).
  ///@param info The updated document information.
  void setDocumentInformation(
    pddocumentinformation$_.PDDocumentInformation? info,
  ) {
    final _$info = info?.reference ?? jni$_.jNullReference;
    _setDocumentInformation(reference.pointer,
            _id_setDocumentInformation as jni$_.JMethodIDPtr, _$info.pointer)
        .check();
  }

  static final _id_getDocumentCatalog = _class.instanceMethodId(
    r'getDocumentCatalog',
    r'()Lorg/apache/pdfbox/pdmodel/PDDocumentCatalog;',
  );

  static final _getDocumentCatalog = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.pdmodel.PDDocumentCatalog getDocumentCatalog()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the document CATALOG. This is guaranteed to not return null.
  ///@return The documents /Root dictionary
  jni$_.JObject? getDocumentCatalog() {
    return _getDocumentCatalog(
            reference.pointer, _id_getDocumentCatalog as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isEncrypted = _class.instanceMethodId(
    r'isEncrypted',
    r'()Z',
  );

  static final _isEncrypted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isEncrypted()`
  ///
  /// This will tell if this document is encrypted or not.
  ///@return true If this document is encrypted.
  bool isEncrypted() {
    return _isEncrypted(
            reference.pointer, _id_isEncrypted as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getEncryption = _class.instanceMethodId(
    r'getEncryption',
    r'()Lorg/apache/pdfbox/pdmodel/encryption/PDEncryption;',
  );

  static final _getEncryption = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.pdmodel.encryption.PDEncryption getEncryption()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the encryption dictionary for this document. This will still return the parameters if the document
  /// was decrypted. As the encryption architecture in PDF documents is pluggable this returns an abstract class,
  /// but the only supported subclass at this time is a
  /// PDStandardEncryption object.
  ///@return The encryption dictionary(most likely a PDStandardEncryption object)
  jni$_.JObject? getEncryption() {
    return _getEncryption(
            reference.pointer, _id_getEncryption as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setEncryptionDictionary = _class.instanceMethodId(
    r'setEncryptionDictionary',
    r'(Lorg/apache/pdfbox/pdmodel/encryption/PDEncryption;)V',
  );

  static final _setEncryptionDictionary = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setEncryptionDictionary(org.apache.pdfbox.pdmodel.encryption.PDEncryption encryption)`
  ///
  /// This will set the encryption dictionary for this document.
  ///@param encryption The encryption dictionary(most likely a PDStandardEncryption object)
  ///@throws IOException If there is an error determining which security handler to use.
  void setEncryptionDictionary(
    jni$_.JObject? encryption,
  ) {
    final _$encryption = encryption?.reference ?? jni$_.jNullReference;
    _setEncryptionDictionary(
            reference.pointer,
            _id_setEncryptionDictionary as jni$_.JMethodIDPtr,
            _$encryption.pointer)
        .check();
  }

  static final _id_getLastSignatureDictionary = _class.instanceMethodId(
    r'getLastSignatureDictionary',
    r'()Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/PDSignature;',
  );

  static final _getLastSignatureDictionary =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature getLastSignatureDictionary()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will return the last signature from the field tree. Note that this may not be the
  /// last in time when empty signature fields are created first but signed after other fields.
  ///@return the last signature as <code>PDSignatureField</code>.
  ///@throws IOException if no document catalog can be found.
  jni$_.JObject? getLastSignatureDictionary() {
    return _getLastSignatureDictionary(reference.pointer,
            _id_getLastSignatureDictionary as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getSignatureFields = _class.instanceMethodId(
    r'getSignatureFields',
    r'()Ljava/util/List;',
  );

  static final _getSignatureFields = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField> getSignatureFields()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Retrieve all signature fields from the document.
  ///@return a <code>List</code> of <code>PDSignatureField</code>s
  ///@throws IOException if no document catalog can be found.
  jni$_.JList<jni$_.JObject?>? getSignatureFields() {
    return _getSignatureFields(
            reference.pointer, _id_getSignatureFields as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_getSignatureDictionaries = _class.instanceMethodId(
    r'getSignatureDictionaries',
    r'()Ljava/util/List;',
  );

  static final _getSignatureDictionaries = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature> getSignatureDictionaries()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Retrieve all signature dictionaries from the document.
  ///@return a <code>List</code> of <code>PDSignatureField</code>s
  ///@throws IOException if no document catalog can be found.
  jni$_.JList<jni$_.JObject?>? getSignatureDictionaries() {
    return _getSignatureDictionaries(reference.pointer,
            _id_getSignatureDictionaries as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.JListNullableType<jni$_.JObject?>(
                jni$_.JObjectNullableType()));
  }

  static final _id_registerTrueTypeFontForClosing = _class.instanceMethodId(
    r'registerTrueTypeFontForClosing',
    r'(Lorg/apache/fontbox/ttf/TrueTypeFont;)V',
  );

  static final _registerTrueTypeFontForClosing =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void registerTrueTypeFontForClosing(org.apache.fontbox.ttf.TrueTypeFont ttf)`
  ///
  /// For internal PDFBox use when creating PDF documents: register a TrueTypeFont to make sure it
  /// is closed when the PDDocument is closed to avoid memory leaks. Users don't have to call this
  /// method, it is done by the appropriate PDFont classes.
  ///@param ttf
  void registerTrueTypeFontForClosing(
    jni$_.JObject? ttf,
  ) {
    final _$ttf = ttf?.reference ?? jni$_.jNullReference;
    _registerTrueTypeFontForClosing(
            reference.pointer,
            _id_registerTrueTypeFontForClosing as jni$_.JMethodIDPtr,
            _$ttf.pointer)
        .check();
  }

  static final _id_load = _class.staticMethodId(
    r'load',
    r'(Ljava/io/File;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param file file to be loaded
  ///@return loaded document
  ///@throws InvalidPasswordException If the file required a non-empty password.
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument? load(
    jni$_.JObject? file,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _load(_class.reference.pointer, _id_load as jni$_.JMethodIDPtr,
            _$file.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$1 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/File;Lorg/apache/pdfbox/io/MemoryUsageSetting;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF.
  ///@param file file to be loaded
  ///@param memUsageSetting defines how memory is used for buffering PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the file required a non-empty password.
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument? load$1(
    jni$_.JObject? file,
    jni$_.JObject? memUsageSetting,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$memUsageSetting =
        memUsageSetting?.reference ?? jni$_.jNullReference;
    return _load$1(_class.reference.pointer, _id_load$1 as jni$_.JMethodIDPtr,
            _$file.pointer, _$memUsageSetting.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$2 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/File;Ljava/lang/String;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, java.lang.String password)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param file file to be loaded
  ///@param password password to be used for decryption
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument? load$2(
    jni$_.JObject? file,
    jni$_.JString? password,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$password = password?.reference ?? jni$_.jNullReference;
    return _load$2(_class.reference.pointer, _id_load$2 as jni$_.JMethodIDPtr,
            _$file.pointer, _$password.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$3 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/File;Ljava/lang/String;Lorg/apache/pdfbox/io/MemoryUsageSetting;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, java.lang.String password, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF.
  ///@param file file to be loaded
  ///@param password password to be used for decryption
  ///@param memUsageSetting defines how memory is used for buffering PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument? load$3(
    jni$_.JObject? file,
    jni$_.JString? password,
    jni$_.JObject? memUsageSetting,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$password = password?.reference ?? jni$_.jNullReference;
    final _$memUsageSetting =
        memUsageSetting?.reference ?? jni$_.jNullReference;
    return _load$3(_class.reference.pointer, _id_load$3 as jni$_.JMethodIDPtr,
            _$file.pointer, _$password.pointer, _$memUsageSetting.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$4 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/File;Ljava/lang/String;Ljava/io/InputStream;Ljava/lang/String;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param file file to be loaded
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@return loaded document
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument? load$4(
    jni$_.JObject? file,
    jni$_.JString? password,
    jni$_.JObject? keyStore,
    jni$_.JString? alias,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$password = password?.reference ?? jni$_.jNullReference;
    final _$keyStore = keyStore?.reference ?? jni$_.jNullReference;
    final _$alias = alias?.reference ?? jni$_.jNullReference;
    return _load$4(
            _class.reference.pointer,
            _id_load$4 as jni$_.JMethodIDPtr,
            _$file.pointer,
            _$password.pointer,
            _$keyStore.pointer,
            _$alias.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$5 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/File;Ljava/lang/String;Ljava/io/InputStream;Ljava/lang/String;Lorg/apache/pdfbox/io/MemoryUsageSetting;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF.
  ///@param file file to be loaded
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@param memUsageSetting defines how memory is used for buffering PDF streams
  ///@return loaded document
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument? load$5(
    jni$_.JObject? file,
    jni$_.JString? password,
    jni$_.JObject? keyStore,
    jni$_.JString? alias,
    jni$_.JObject? memUsageSetting,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$password = password?.reference ?? jni$_.jNullReference;
    final _$keyStore = keyStore?.reference ?? jni$_.jNullReference;
    final _$alias = alias?.reference ?? jni$_.jNullReference;
    final _$memUsageSetting =
        memUsageSetting?.reference ?? jni$_.jNullReference;
    return _load$5(
            _class.reference.pointer,
            _id_load$5 as jni$_.JMethodIDPtr,
            _$file.pointer,
            _$password.pointer,
            _$keyStore.pointer,
            _$alias.pointer,
            _$memUsageSetting.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$6 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/InputStream;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$6 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. The given input stream is copied to the memory to enable random access to the
  /// pdf. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@return loaded document
  ///@throws InvalidPasswordException If the PDF required a non-empty password.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument? load$6(
    jni$_.JObject? input,
  ) {
    final _$input = input?.reference ?? jni$_.jNullReference;
    return _load$6(_class.reference.pointer, _id_load$6 as jni$_.JMethodIDPtr,
            _$input.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$7 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/InputStream;Lorg/apache/pdfbox/io/MemoryUsageSetting;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$7 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Depending on the memory settings parameter the given input stream is either
  /// copied to main memory or to a temporary file to enable random access to the pdf.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param memUsageSetting defines how memory is used for buffering input stream and PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the PDF required a non-empty password.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument? load$7(
    jni$_.JObject? input,
    jni$_.JObject? memUsageSetting,
  ) {
    final _$input = input?.reference ?? jni$_.jNullReference;
    final _$memUsageSetting =
        memUsageSetting?.reference ?? jni$_.jNullReference;
    return _load$7(_class.reference.pointer, _id_load$7 as jni$_.JMethodIDPtr,
            _$input.pointer, _$memUsageSetting.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$8 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/InputStream;Ljava/lang/String;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$8 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, java.lang.String password)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. The given input stream is copied to the memory to enable random access to the
  /// pdf. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param password password to be used for decryption
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument? load$8(
    jni$_.JObject? input,
    jni$_.JString? password,
  ) {
    final _$input = input?.reference ?? jni$_.jNullReference;
    final _$password = password?.reference ?? jni$_.jNullReference;
    return _load$8(_class.reference.pointer, _id_load$8 as jni$_.JMethodIDPtr,
            _$input.pointer, _$password.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$9 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/InputStream;Ljava/lang/String;Ljava/io/InputStream;Ljava/lang/String;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$9 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. The given input stream is copied to the memory to enable random access to the
  /// pdf. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@return loaded document
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument? load$9(
    jni$_.JObject? input,
    jni$_.JString? password,
    jni$_.JObject? keyStore,
    jni$_.JString? alias,
  ) {
    final _$input = input?.reference ?? jni$_.jNullReference;
    final _$password = password?.reference ?? jni$_.jNullReference;
    final _$keyStore = keyStore?.reference ?? jni$_.jNullReference;
    final _$alias = alias?.reference ?? jni$_.jNullReference;
    return _load$9(
            _class.reference.pointer,
            _id_load$9 as jni$_.JMethodIDPtr,
            _$input.pointer,
            _$password.pointer,
            _$keyStore.pointer,
            _$alias.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$10 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/InputStream;Ljava/lang/String;Lorg/apache/pdfbox/io/MemoryUsageSetting;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$10 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, java.lang.String password, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Depending on the memory settings parameter the given input stream is either
  /// copied to main memory or to a temporary file to enable random access to the pdf.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param password password to be used for decryption
  ///@param memUsageSetting defines how memory is used for buffering input stream and PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument? load$10(
    jni$_.JObject? input,
    jni$_.JString? password,
    jni$_.JObject? memUsageSetting,
  ) {
    final _$input = input?.reference ?? jni$_.jNullReference;
    final _$password = password?.reference ?? jni$_.jNullReference;
    final _$memUsageSetting =
        memUsageSetting?.reference ?? jni$_.jNullReference;
    return _load$10(_class.reference.pointer, _id_load$10 as jni$_.JMethodIDPtr,
            _$input.pointer, _$password.pointer, _$memUsageSetting.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$11 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/InputStream;Ljava/lang/String;Ljava/io/InputStream;Ljava/lang/String;Lorg/apache/pdfbox/io/MemoryUsageSetting;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$11 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Depending on the memory settings parameter the given input stream is either
  /// copied to memory or to a temporary file to enable random access to the pdf.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@param memUsageSetting defines how memory is used for buffering input stream and PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument? load$11(
    jni$_.JObject? input,
    jni$_.JString? password,
    jni$_.JObject? keyStore,
    jni$_.JString? alias,
    jni$_.JObject? memUsageSetting,
  ) {
    final _$input = input?.reference ?? jni$_.jNullReference;
    final _$password = password?.reference ?? jni$_.jNullReference;
    final _$keyStore = keyStore?.reference ?? jni$_.jNullReference;
    final _$alias = alias?.reference ?? jni$_.jNullReference;
    final _$memUsageSetting =
        memUsageSetting?.reference ?? jni$_.jNullReference;
    return _load$11(
            _class.reference.pointer,
            _id_load$11 as jni$_.JMethodIDPtr,
            _$input.pointer,
            _$password.pointer,
            _$keyStore.pointer,
            _$alias.pointer,
            _$memUsageSetting.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$12 = _class.staticMethodId(
    r'load',
    r'([B)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$12 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(byte[] input)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input byte array that contains the document.
  ///@return loaded document
  ///@throws InvalidPasswordException If the PDF required a non-empty password.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument? load$12(
    jni$_.JByteArray? input,
  ) {
    final _$input = input?.reference ?? jni$_.jNullReference;
    return _load$12(_class.reference.pointer, _id_load$12 as jni$_.JMethodIDPtr,
            _$input.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$13 = _class.staticMethodId(
    r'load',
    r'([BLjava/lang/String;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$13 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(byte[] input, java.lang.String password)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input byte array that contains the document.
  ///@param password password to be used for decryption
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument? load$13(
    jni$_.JByteArray? input,
    jni$_.JString? password,
  ) {
    final _$input = input?.reference ?? jni$_.jNullReference;
    final _$password = password?.reference ?? jni$_.jNullReference;
    return _load$13(_class.reference.pointer, _id_load$13 as jni$_.JMethodIDPtr,
            _$input.pointer, _$password.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$14 = _class.staticMethodId(
    r'load',
    r'([BLjava/lang/String;Ljava/io/InputStream;Ljava/lang/String;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$14 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(byte[] input, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input byte array that contains the document.
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument? load$14(
    jni$_.JByteArray? input,
    jni$_.JString? password,
    jni$_.JObject? keyStore,
    jni$_.JString? alias,
  ) {
    final _$input = input?.reference ?? jni$_.jNullReference;
    final _$password = password?.reference ?? jni$_.jNullReference;
    final _$keyStore = keyStore?.reference ?? jni$_.jNullReference;
    final _$alias = alias?.reference ?? jni$_.jNullReference;
    return _load$14(
            _class.reference.pointer,
            _id_load$14 as jni$_.JMethodIDPtr,
            _$input.pointer,
            _$password.pointer,
            _$keyStore.pointer,
            _$alias.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_load$15 = _class.staticMethodId(
    r'load',
    r'([BLjava/lang/String;Ljava/io/InputStream;Ljava/lang/String;Lorg/apache/pdfbox/io/MemoryUsageSetting;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$15 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(byte[] input, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF.
  ///@param input byte array that contains the document.
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@param memUsageSetting defines how memory is used for buffering input stream and PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument? load$15(
    jni$_.JByteArray? input,
    jni$_.JString? password,
    jni$_.JObject? keyStore,
    jni$_.JString? alias,
    jni$_.JObject? memUsageSetting,
  ) {
    final _$input = input?.reference ?? jni$_.jNullReference;
    final _$password = password?.reference ?? jni$_.jNullReference;
    final _$keyStore = keyStore?.reference ?? jni$_.jNullReference;
    final _$alias = alias?.reference ?? jni$_.jNullReference;
    final _$memUsageSetting =
        memUsageSetting?.reference ?? jni$_.jNullReference;
    return _load$15(
            _class.reference.pointer,
            _id_load$15 as jni$_.JMethodIDPtr,
            _$input.pointer,
            _$password.pointer,
            _$keyStore.pointer,
            _$alias.pointer,
            _$memUsageSetting.pointer)
        .object<PDDocument?>(const $PDDocument$NullableType());
  }

  static final _id_save = _class.instanceMethodId(
    r'save',
    r'(Ljava/lang/String;)V',
  );

  static final _save = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void save(java.lang.String fileName)`
  ///
  /// Save the document to a file.
  ///
  /// If encryption has been activated (with
  /// \#protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy) protect(ProtectionPolicy)),
  /// do not use the document after saving because the contents are now encrypted.
  ///@param fileName The file to save as.
  ///@throws IOException if the output could not be written
  void save(
    jni$_.JString? fileName,
  ) {
    final _$fileName = fileName?.reference ?? jni$_.jNullReference;
    _save(reference.pointer, _id_save as jni$_.JMethodIDPtr, _$fileName.pointer)
        .check();
  }

  static final _id_save$1 = _class.instanceMethodId(
    r'save',
    r'(Ljava/io/File;)V',
  );

  static final _save$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void save(java.io.File file)`
  ///
  /// Save the document to a file.
  ///
  /// If encryption has been activated (with
  /// \#protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy) protect(ProtectionPolicy)),
  /// do not use the document after saving because the contents are now encrypted.
  ///@param file The file to save as.
  ///@throws IOException if the output could not be written
  void save$1(
    jni$_.JObject? file,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    _save$1(reference.pointer, _id_save$1 as jni$_.JMethodIDPtr, _$file.pointer)
        .check();
  }

  static final _id_save$2 = _class.instanceMethodId(
    r'save',
    r'(Ljava/io/OutputStream;)V',
  );

  static final _save$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void save(java.io.OutputStream output)`
  ///
  /// This will save the document to an output stream.
  ///
  /// If encryption has been activated (with
  /// \#protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy) protect(ProtectionPolicy)),
  /// do not use the document after saving because the contents are now encrypted.
  ///@param output The stream to write to. It will be closed when done. It is recommended to wrap
  /// it in a java.io.BufferedOutputStream, unless it is already buffered.
  ///@throws IOException if the output could not be written
  void save$2(
    jni$_.JObject? output,
  ) {
    final _$output = output?.reference ?? jni$_.jNullReference;
    _save$2(reference.pointer, _id_save$2 as jni$_.JMethodIDPtr,
            _$output.pointer)
        .check();
  }

  static final _id_saveIncremental = _class.instanceMethodId(
    r'saveIncremental',
    r'(Ljava/io/OutputStream;)V',
  );

  static final _saveIncremental = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void saveIncremental(java.io.OutputStream output)`
  ///
  /// Save the PDF as an incremental update. This is only possible if the PDF was loaded from a
  /// file or a stream, not if the document was created in PDFBox itself. There must be a path of
  /// objects that have COSUpdateInfo\#isNeedToBeUpdated() set, starting from the document
  /// catalog. For signatures this is taken care by PDFBox itself.
  ///
  /// Other usages of this method are for experienced users only. You will usually never need it.
  /// It is useful only if you are required to keep the current revision and append the changes. A
  /// typical use case is changing a signed file without invalidating the signature.
  ///@param output stream to write to. It will be closed when done. It
  /// <i>__must never__</i> point to the source file or that one will be
  /// harmed!
  ///@throws IOException if the output could not be written
  ///@throws IllegalStateException if the document was not loaded from a file or a stream.
  void saveIncremental(
    jni$_.JObject? output,
  ) {
    final _$output = output?.reference ?? jni$_.jNullReference;
    _saveIncremental(reference.pointer,
            _id_saveIncremental as jni$_.JMethodIDPtr, _$output.pointer)
        .check();
  }

  static final _id_saveIncremental$1 = _class.instanceMethodId(
    r'saveIncremental',
    r'(Ljava/io/OutputStream;Ljava/util/Set;)V',
  );

  static final _saveIncremental$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void saveIncremental(java.io.OutputStream output, java.util.Set<org.apache.pdfbox.cos.COSDictionary> objectsToWrite)`
  ///
  /// Save the PDF as an incremental update. This is only possible if the PDF was loaded from a
  /// file or a stream, not if the document was created in PDFBox itself. This allows to include
  /// objects even if there is no path of objects that have
  /// COSUpdateInfo\#isNeedToBeUpdated() set so the incremental update gets smaller. Only
  /// dictionaries are supported; if you need to update other objects classes, then add their
  /// parent dictionary.
  ///
  /// This method is for experienced users only. You will usually never need it. It is useful only
  /// if you are required to keep the current revision and append the changes. A typical use case
  /// is changing a signed file without invalidating the signature. To know which objects are
  /// getting changed, you need to have some understanding of the PDF specification, and look at
  /// the saved file with an editor to verify that you are updating the correct objects. You should
  /// also inspect the page and document structures of the file with PDFDebugger.
  ///@param output stream to write to. It will be closed when done. It
  /// <i>__must never__</i> point to the source file or that one will be harmed!
  ///@param objectsToWrite objects that __must__ be part of the incremental saving.
  ///@throws IOException if the output could not be written
  ///@throws IllegalStateException if the document was not loaded from a file or a stream.
  void saveIncremental$1(
    jni$_.JObject? output,
    jni$_.JSet<jni$_.JObject?>? objectsToWrite,
  ) {
    final _$output = output?.reference ?? jni$_.jNullReference;
    final _$objectsToWrite = objectsToWrite?.reference ?? jni$_.jNullReference;
    _saveIncremental$1(
            reference.pointer,
            _id_saveIncremental$1 as jni$_.JMethodIDPtr,
            _$output.pointer,
            _$objectsToWrite.pointer)
        .check();
  }

  static final _id_saveIncrementalForExternalSigning = _class.instanceMethodId(
    r'saveIncrementalForExternalSigning',
    r'(Ljava/io/OutputStream;)Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/ExternalSigningSupport;',
  );

  static final _saveIncrementalForExternalSigning =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.apache.pdfbox.pdmodel.interactive.digitalsignature.ExternalSigningSupport saveIncrementalForExternalSigning(java.io.OutputStream output)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  ///
  /// __(This is a new feature for 2.0.3. The API for external signing might change based on feedback after release!)__
  ///
  /// Save PDF incrementally without closing for external signature creation scenario. The general
  /// sequence is:
  /// <pre>
  ///    PDDocument pdDocument = ...;
  ///    OutputStream outputStream = ...;
  ///    SignatureOptions signatureOptions = ...; // options to specify fine tuned signature options or null for defaults
  ///    PDSignature pdSignature = ...;
  ///
  ///    // add signature parameters to be used when creating signature dictionary
  ///    pdDocument.addSignature(pdSignature, signatureOptions);
  ///    // prepare PDF for signing and obtain helper class to be used
  ///    ExternalSigningSupport externalSigningSupport = pdDocument.saveIncrementalForExternalSigning(outputStream);
  ///    // get data to be signed
  ///    InputStream dataToBeSigned = externalSigningSupport.getContent();
  ///    // invoke signature service
  ///    byte[] signature = sign(dataToBeSigned);
  ///    // set resulted CMS signature
  ///    externalSigningSupport.setSignature(signature);
  ///
  ///    // last step is to close the document
  ///    pdDocument.close();
  /// </pre>
  ///
  /// Note that after calling this method, only {@code close()} method may invoked for
  /// {@code PDDocument} instance and only AFTER ExternalSigningSupport instance is used.
  ///
  ///
  ///@param output stream to write the final PDF. It will be closed when the
  /// document is closed. It <i>__must never__</i> point to the source file
  /// or that one will be harmed!
  ///@return instance to be used for external signing and setting CMS signature
  ///@throws IOException if the output could not be written
  ///@throws IllegalStateException if the document was not loaded from a file or a stream or
  /// signature options were not set.
  jni$_.JObject? saveIncrementalForExternalSigning(
    jni$_.JObject? output,
  ) {
    final _$output = output?.reference ?? jni$_.jNullReference;
    return _saveIncrementalForExternalSigning(
            reference.pointer,
            _id_saveIncrementalForExternalSigning as jni$_.JMethodIDPtr,
            _$output.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getPage = _class.instanceMethodId(
    r'getPage',
    r'(I)Lorg/apache/pdfbox/pdmodel/PDPage;',
  );

  static final _getPage = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.apache.pdfbox.pdmodel.PDPage getPage(int pageIndex)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the page at the given 0-based index.
  ///
  /// This method is too slow to get all the pages from a large PDF document
  /// (1000 pages or more). For such documents, use the iterator of
  /// PDDocument\#getPages() instead.
  ///@param pageIndex the 0-based page index
  ///@return the page at the given index.
  jni$_.JObject? getPage(
    int pageIndex,
  ) {
    return _getPage(
            reference.pointer, _id_getPage as jni$_.JMethodIDPtr, pageIndex)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getPages = _class.instanceMethodId(
    r'getPages',
    r'()Lorg/apache/pdfbox/pdmodel/PDPageTree;',
  );

  static final _getPages = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.pdmodel.PDPageTree getPages()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the page tree.
  ///@return the page tree
  jni$_.JObject? getPages() {
    return _getPages(reference.pointer, _id_getPages as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getNumberOfPages = _class.instanceMethodId(
    r'getNumberOfPages',
    r'()I',
  );

  static final _getNumberOfPages = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getNumberOfPages()`
  ///
  /// This will return the total page count of the PDF document.
  ///@return The total number of pages in the PDF document.
  int getNumberOfPages() {
    return _getNumberOfPages(
            reference.pointer, _id_getNumberOfPages as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public void close()`
  ///
  /// This will close the underlying COSDocument object.
  ///@throws IOException If there is an error releasing resources.
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_protect = _class.instanceMethodId(
    r'protect',
    r'(Lorg/apache/pdfbox/pdmodel/encryption/ProtectionPolicy;)V',
  );

  static final _protect = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy policy)`
  ///
  /// Protects the document with a protection policy. The document content will be really
  /// encrypted when it will be saved. This method only marks the document for encryption. It also
  /// calls \#setAllSecurityToBeRemoved(boolean) with a false argument if it was set to true
  /// previously and logs a warning.
  ///
  /// Do not use the document after saving, because the structures are encrypted.
  ///@see org.apache.pdfbox.pdmodel.encryption.StandardProtectionPolicy
  ///@see org.apache.pdfbox.pdmodel.encryption.PublicKeyProtectionPolicy
  ///@param policy The protection policy.
  ///@throws IOException if there isn't any suitable security handler.
  void protect(
    jni$_.JObject? policy,
  ) {
    final _$policy = policy?.reference ?? jni$_.jNullReference;
    _protect(reference.pointer, _id_protect as jni$_.JMethodIDPtr,
            _$policy.pointer)
        .check();
  }

  static final _id_getCurrentAccessPermission = _class.instanceMethodId(
    r'getCurrentAccessPermission',
    r'()Lorg/apache/pdfbox/pdmodel/encryption/AccessPermission;',
  );

  static final _getCurrentAccessPermission =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public org.apache.pdfbox.pdmodel.encryption.AccessPermission getCurrentAccessPermission()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the access permissions granted when the document was decrypted. If the document was not decrypted this
  /// method returns the access permission for a document owner (ie can do everything). The returned object is in read
  /// only mode so that permissions cannot be changed. Methods providing access to content should rely on this object
  /// to verify if the current user is allowed to proceed.
  ///@return the access permissions for the current user on the document.
  jni$_.JObject? getCurrentAccessPermission() {
    return _getCurrentAccessPermission(reference.pointer,
            _id_getCurrentAccessPermission as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isAllSecurityToBeRemoved = _class.instanceMethodId(
    r'isAllSecurityToBeRemoved',
    r'()Z',
  );

  static final _isAllSecurityToBeRemoved = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public boolean isAllSecurityToBeRemoved()`
  ///
  /// Indicates if all security is removed or not when writing the pdf.
  ///@return returns true if all security shall be removed otherwise false
  bool isAllSecurityToBeRemoved() {
    return _isAllSecurityToBeRemoved(reference.pointer,
            _id_isAllSecurityToBeRemoved as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAllSecurityToBeRemoved = _class.instanceMethodId(
    r'setAllSecurityToBeRemoved',
    r'(Z)V',
  );

  static final _setAllSecurityToBeRemoved = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void setAllSecurityToBeRemoved(boolean removeAllSecurity)`
  ///
  /// Activates/Deactivates the removal of all security when writing the pdf.
  ///@param removeAllSecurity remove all security if set to true
  void setAllSecurityToBeRemoved(
    bool removeAllSecurity,
  ) {
    _setAllSecurityToBeRemoved(
            reference.pointer,
            _id_setAllSecurityToBeRemoved as jni$_.JMethodIDPtr,
            removeAllSecurity ? 1 : 0)
        .check();
  }

  static final _id_getDocumentId = _class.instanceMethodId(
    r'getDocumentId',
    r'()Ljava/lang/Long;',
  );

  static final _getDocumentId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Long getDocumentId()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Provides the document ID.
  ///@return the document ID
  jni$_.JLong? getDocumentId() {
    return _getDocumentId(
            reference.pointer, _id_getDocumentId as jni$_.JMethodIDPtr)
        .object<jni$_.JLong?>(const jni$_.JLongNullableType());
  }

  static final _id_setDocumentId = _class.instanceMethodId(
    r'setDocumentId',
    r'(Ljava/lang/Long;)V',
  );

  static final _setDocumentId = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setDocumentId(java.lang.Long docId)`
  ///
  /// Sets the document ID to the given value.
  ///@param docId the new document ID
  void setDocumentId(
    jni$_.JLong? docId,
  ) {
    final _$docId = docId?.reference ?? jni$_.jNullReference;
    _setDocumentId(reference.pointer, _id_setDocumentId as jni$_.JMethodIDPtr,
            _$docId.pointer)
        .check();
  }

  static final _id_getVersion = _class.instanceMethodId(
    r'getVersion',
    r'()F',
  );

  static final _getVersion = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public float getVersion()`
  ///
  /// Returns the PDF specification version this document conforms to.
  ///@return the PDF version (e.g. 1.4f)
  double getVersion() {
    return _getVersion(reference.pointer, _id_getVersion as jni$_.JMethodIDPtr)
        .float;
  }

  static final _id_setVersion = _class.instanceMethodId(
    r'setVersion',
    r'(F)V',
  );

  static final _setVersion = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, double)>();

  /// from: `public void setVersion(float newVersion)`
  ///
  /// Sets the PDF specification version for this document.
  ///@param newVersion the new PDF version (e.g. 1.4f)
  void setVersion(
    double newVersion,
  ) {
    _setVersion(
            reference.pointer, _id_setVersion as jni$_.JMethodIDPtr, newVersion)
        .check();
  }

  static final _id_getResourceCache = _class.instanceMethodId(
    r'getResourceCache',
    r'()Lorg/apache/pdfbox/pdmodel/ResourceCache;',
  );

  static final _getResourceCache = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.pdmodel.ResourceCache getResourceCache()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the resource cache associated with this document, or null if there is none.
  ///@return the resource cache or null.
  jni$_.JObject? getResourceCache() {
    return _getResourceCache(
            reference.pointer, _id_getResourceCache as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setResourceCache = _class.instanceMethodId(
    r'setResourceCache',
    r'(Lorg/apache/pdfbox/pdmodel/ResourceCache;)V',
  );

  static final _setResourceCache = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void setResourceCache(org.apache.pdfbox.pdmodel.ResourceCache resourceCache)`
  ///
  /// Sets the resource cache associated with this document.
  ///@param resourceCache A resource cache, or null.
  void setResourceCache(
    jni$_.JObject? resourceCache,
  ) {
    final _$resourceCache = resourceCache?.reference ?? jni$_.jNullReference;
    _setResourceCache(reference.pointer,
            _id_setResourceCache as jni$_.JMethodIDPtr, _$resourceCache.pointer)
        .check();
  }
}

final class $PDDocument$NullableType extends jni$_.JObjType<PDDocument?> {
  @jni$_.internal
  const $PDDocument$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/apache/pdfbox/pdmodel/PDDocument;';

  @jni$_.internal
  @core$_.override
  PDDocument? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : PDDocument.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PDDocument?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PDDocument$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PDDocument$NullableType) &&
        other is $PDDocument$NullableType;
  }
}

final class $PDDocument$Type extends jni$_.JObjType<PDDocument> {
  @jni$_.internal
  const $PDDocument$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/apache/pdfbox/pdmodel/PDDocument;';

  @jni$_.internal
  @core$_.override
  PDDocument fromReference(jni$_.JReference reference) =>
      PDDocument.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PDDocument?> get nullableType =>
      const $PDDocument$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PDDocument$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PDDocument$Type) && other is $PDDocument$Type;
  }
}
