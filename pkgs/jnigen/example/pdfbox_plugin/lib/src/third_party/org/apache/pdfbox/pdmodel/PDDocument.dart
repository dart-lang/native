// Generated from Apache PDFBox library which is licensed under the Apache License 2.0.
// The following copyright from the original authors applies.
//
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as _$core;

import 'package:jni/_internal.dart' as _$jni;
import 'package:jni/jni.dart' as _$jni;

import 'PDDocumentInformation.dart' as pddocumentinformation_;

/// from: `org.apache.pdfbox.pdmodel.PDDocument`
///
/// This is the in-memory representation of the PDF document.
/// The \#close() method must be called once the document is no longer needed.
///@author Ben Litchfield
class PDDocument extends _$jni.JObject {
  @_$jni.internal
  @_$core.override
  final _$jni.JObjType<PDDocument> $type;

  @_$jni.internal
  PDDocument.fromReference(
    _$jni.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      _$jni.JClass.forName(r'org/apache/pdfbox/pdmodel/PDDocument');

  /// The type which includes information such as the signature of this class.
  static const type = $PDDocument$Type();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates an empty PDF document.
  /// You need to add at least one page for the document to be valid.
  factory PDDocument() {
    return PDDocument.fromReference(
        _new$(_class.reference.pointer, _id_new$ as _$jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Lorg/apache/pdfbox/io/MemoryUsageSetting;)V',
  );

  static final _new$1 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates an empty PDF document.
  /// You need to add at least one page for the document to be valid.
  ///@param memUsageSetting defines how memory is used for buffering PDF streams
  factory PDDocument.new$1(
    _$jni.JObject memUsageSetting,
  ) {
    return PDDocument.fromReference(_new$1(_class.reference.pointer,
            _id_new$1 as _$jni.JMethodIDPtr, memUsageSetting.reference.pointer)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Lorg/apache/pdfbox/cos/COSDocument;)V',
  );

  static final _new$2 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(org.apache.pdfbox.cos.COSDocument doc)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructor that uses an existing document. The COSDocument that is passed in must be valid.
  ///@param doc The COSDocument that this document wraps.
  factory PDDocument.new$2(
    _$jni.JObject doc,
  ) {
    return PDDocument.fromReference(_new$2(_class.reference.pointer,
            _id_new$2 as _$jni.JMethodIDPtr, doc.reference.pointer)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Lorg/apache/pdfbox/cos/COSDocument;Lorg/apache/pdfbox/io/RandomAccessRead;)V',
  );

  static final _new$3 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(org.apache.pdfbox.cos.COSDocument doc, org.apache.pdfbox.io.RandomAccessRead source)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructor that uses an existing document. The COSDocument that is passed in must be valid.
  ///@param doc The COSDocument that this document wraps.
  ///@param source the parser which is used to read the pdf
  factory PDDocument.new$3(
    _$jni.JObject doc,
    _$jni.JObject source,
  ) {
    return PDDocument.fromReference(_new$3(
            _class.reference.pointer,
            _id_new$3 as _$jni.JMethodIDPtr,
            doc.reference.pointer,
            source.reference.pointer)
        .reference);
  }

  static final _id_new$4 = _class.constructorId(
    r'(Lorg/apache/pdfbox/cos/COSDocument;Lorg/apache/pdfbox/io/RandomAccessRead;Lorg/apache/pdfbox/pdmodel/encryption/AccessPermission;)V',
  );

  static final _new$4 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void <init>(org.apache.pdfbox.cos.COSDocument doc, org.apache.pdfbox.io.RandomAccessRead source, org.apache.pdfbox.pdmodel.encryption.AccessPermission permission)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constructor that uses an existing document. The COSDocument that is passed in must be valid.
  ///@param doc The COSDocument that this document wraps.
  ///@param source the parser which is used to read the pdf
  ///@param permission he access permissions of the pdf
  factory PDDocument.new$4(
    _$jni.JObject doc,
    _$jni.JObject source,
    _$jni.JObject permission,
  ) {
    return PDDocument.fromReference(_new$4(
            _class.reference.pointer,
            _id_new$4 as _$jni.JMethodIDPtr,
            doc.reference.pointer,
            source.reference.pointer,
            permission.reference.pointer)
        .reference);
  }

  static final _id_addPage = _class.instanceMethodId(
    r'addPage',
    r'(Lorg/apache/pdfbox/pdmodel/PDPage;)V',
  );

  static final _addPage = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addPage(org.apache.pdfbox.pdmodel.PDPage page)`
  ///
  /// This will add a page to the document. This is a convenience method, that will add the page to the root of the
  /// hierarchy and set the parent of the page to the root.
  ///@param page The page to add to the document.
  void addPage(
    _$jni.JObject page,
  ) {
    _addPage(reference.pointer, _id_addPage as _$jni.JMethodIDPtr,
            page.reference.pointer)
        .check();
  }

  static final _id_addSignature = _class.instanceMethodId(
    r'addSignature',
    r'(Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/PDSignature;)V',
  );

  static final _addSignature = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addSignature(org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature sigObject)`
  ///
  /// Add parameters of signature to be created externally using default signature options. See
  /// \#saveIncrementalForExternalSigning(OutputStream) method description on external
  /// signature creation scenario details.
  ///
  /// Only one signature may be added in a document. To sign several times,
  /// load document, add signature, save incremental and close again.
  ///@param sigObject is the PDSignatureField model
  ///@throws IOException if there is an error creating required fields
  ///@throws IllegalStateException if one attempts to add several signature
  /// fields.
  void addSignature(
    _$jni.JObject sigObject,
  ) {
    _addSignature(reference.pointer, _id_addSignature as _$jni.JMethodIDPtr,
            sigObject.reference.pointer)
        .check();
  }

  static final _id_addSignature$1 = _class.instanceMethodId(
    r'addSignature',
    r'(Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/PDSignature;Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/SignatureOptions;)V',
  );

  static final _addSignature$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addSignature(org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature sigObject, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions options)`
  ///
  /// Add parameters of signature to be created externally. See
  /// \#saveIncrementalForExternalSigning(OutputStream) method description on external
  /// signature creation scenario details.
  ///
  /// Only one signature may be added in a document. To sign several times,
  /// load document, add signature, save incremental and close again.
  ///@param sigObject is the PDSignatureField model
  ///@param options signature options
  ///@throws IOException if there is an error creating required fields
  ///@throws IllegalStateException if one attempts to add several signature
  /// fields.
  void addSignature$1(
    _$jni.JObject sigObject,
    _$jni.JObject options,
  ) {
    _addSignature$1(reference.pointer, _id_addSignature$1 as _$jni.JMethodIDPtr,
            sigObject.reference.pointer, options.reference.pointer)
        .check();
  }

  static final _id_addSignature$2 = _class.instanceMethodId(
    r'addSignature',
    r'(Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/PDSignature;Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/SignatureInterface;)V',
  );

  static final _addSignature$2 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addSignature(org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature sigObject, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureInterface signatureInterface)`
  ///
  /// Add a signature to be created using the instance of given interface.
  ///
  /// Only one signature may be added in a document. To sign several times,
  /// load document, add signature, save incremental and close again.
  ///@param sigObject is the PDSignatureField model
  ///@param signatureInterface is an interface whose implementation provides
  /// signing capabilities. Can be null if external signing if used.
  ///@throws IOException if there is an error creating required fields
  ///@throws IllegalStateException if one attempts to add several signature
  /// fields.
  void addSignature$2(
    _$jni.JObject sigObject,
    _$jni.JObject signatureInterface,
  ) {
    _addSignature$2(reference.pointer, _id_addSignature$2 as _$jni.JMethodIDPtr,
            sigObject.reference.pointer, signatureInterface.reference.pointer)
        .check();
  }

  static final _id_addSignature$3 = _class.instanceMethodId(
    r'addSignature',
    r'(Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/PDSignature;Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/SignatureInterface;Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/SignatureOptions;)V',
  );

  static final _addSignature$3 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addSignature(org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature sigObject, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureInterface signatureInterface, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions options)`
  ///
  /// This will add a signature to the document. If the 0-based page number in the options
  /// parameter is smaller than 0 or larger than max, the nearest valid page number will be used
  /// (i.e. 0 or max) and no exception will be thrown.
  ///
  /// Only one signature may be added in a document. To sign several times,
  /// load document, add signature, save incremental and close again.
  ///@param sigObject is the PDSignatureField model
  ///@param signatureInterface is an interface whose implementation provides
  /// signing capabilities. Can be null if external signing if used.
  ///@param options signature options
  ///@throws IOException if there is an error creating required fields
  ///@throws IllegalStateException if one attempts to add several signature
  /// fields.
  void addSignature$3(
    _$jni.JObject sigObject,
    _$jni.JObject signatureInterface,
    _$jni.JObject options,
  ) {
    _addSignature$3(
            reference.pointer,
            _id_addSignature$3 as _$jni.JMethodIDPtr,
            sigObject.reference.pointer,
            signatureInterface.reference.pointer,
            options.reference.pointer)
        .check();
  }

  static final _id_addSignatureField = _class.instanceMethodId(
    r'addSignatureField',
    r'(Ljava/util/List;Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/SignatureInterface;Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/SignatureOptions;)V',
  );

  static final _addSignatureField = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void addSignatureField(java.util.List<org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField> sigFields, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureInterface signatureInterface, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions options)`
  ///
  /// This will add a list of signature fields to the document.
  ///@param sigFields are the PDSignatureFields that should be added to the document
  ///@param signatureInterface is an interface whose implementation provides
  /// signing capabilities. Can be null if external signing if used.
  ///@param options signature options
  ///@throws IOException if there is an error creating required fields
  ///@deprecated The method is misleading, because only one signature may be
  /// added in a document. The method will be removed in the future.
  void addSignatureField(
    _$jni.JList<_$jni.JObject> sigFields,
    _$jni.JObject signatureInterface,
    _$jni.JObject options,
  ) {
    _addSignatureField(
            reference.pointer,
            _id_addSignatureField as _$jni.JMethodIDPtr,
            sigFields.reference.pointer,
            signatureInterface.reference.pointer,
            options.reference.pointer)
        .check();
  }

  static final _id_removePage = _class.instanceMethodId(
    r'removePage',
    r'(Lorg/apache/pdfbox/pdmodel/PDPage;)V',
  );

  static final _removePage = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void removePage(org.apache.pdfbox.pdmodel.PDPage page)`
  ///
  /// Remove the page from the document.
  ///@param page The page to remove from the document.
  void removePage(
    _$jni.JObject page,
  ) {
    _removePage(reference.pointer, _id_removePage as _$jni.JMethodIDPtr,
            page.reference.pointer)
        .check();
  }

  static final _id_removePage$1 = _class.instanceMethodId(
    r'removePage',
    r'(I)V',
  );

  static final _removePage$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void removePage(int pageNumber)`
  ///
  /// Remove the page from the document.
  ///@param pageNumber 0 based index to page number.
  void removePage$1(
    int pageNumber,
  ) {
    _removePage$1(reference.pointer, _id_removePage$1 as _$jni.JMethodIDPtr,
            pageNumber)
        .check();
  }

  static final _id_importPage = _class.instanceMethodId(
    r'importPage',
    r'(Lorg/apache/pdfbox/pdmodel/PDPage;)Lorg/apache/pdfbox/pdmodel/PDPage;',
  );

  static final _importPage = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public org.apache.pdfbox.pdmodel.PDPage importPage(org.apache.pdfbox.pdmodel.PDPage page)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will import and copy the contents from another location. Currently the content stream is
  /// stored in a scratch file. The scratch file is associated with the document. If you are adding
  /// a page to this document from another document and want to copy the contents to this
  /// document's scratch file then use this method otherwise just use the \#addPage addPage()
  /// method.
  ///
  /// Unlike \#addPage addPage(), this method creates a new PDPage object. If your page has
  /// annotations, and if these link to pages not in the target document, then the target document
  /// might become huge. What you need to do is to delete page references of such annotations. See
  /// <a href="http://stackoverflow.com/a/35477351/535646">here</a> for how to do this.
  ///
  /// Inherited (global) resources are ignored because these can contain resources not needed for
  /// this page which could bloat your document, see
  /// <a href="https://issues.apache.org/jira/browse/PDFBOX-28">PDFBOX-28</a> and related issues.
  /// If you need them, call <code>importedPage.setResources(page.getResources());</code>
  ///
  /// This method should only be used to import a page from a loaded document, not from a generated
  /// document because these can contain unfinished parts, e.g. font subsetting information.
  ///@param page The page to import.
  ///@return The page that was imported.
  ///@throws IOException If there is an error copying the page.
  _$jni.JObject importPage(
    _$jni.JObject page,
  ) {
    return _importPage(reference.pointer, _id_importPage as _$jni.JMethodIDPtr,
            page.reference.pointer)
        .object(const _$jni.JObjectType());
  }

  static final _id_getDocument = _class.instanceMethodId(
    r'getDocument',
    r'()Lorg/apache/pdfbox/cos/COSDocument;',
  );

  static final _getDocument = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.cos.COSDocument getDocument()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the low level document.
  ///@return The document that this layer sits on top of.
  _$jni.JObject getDocument() {
    return _getDocument(
            reference.pointer, _id_getDocument as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_getDocumentInformation = _class.instanceMethodId(
    r'getDocumentInformation',
    r'()Lorg/apache/pdfbox/pdmodel/PDDocumentInformation;',
  );

  static final _getDocumentInformation = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.pdmodel.PDDocumentInformation getDocumentInformation()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the document info dictionary. If it doesn't exist, an empty document info
  /// dictionary is created in the document trailer.
  ///
  /// In PDF 2.0 this is deprecated except for two entries, /CreationDate and /ModDate. For any other
  /// document level metadata, a metadata stream should be used instead, see
  /// PDDocumentCatalog\#getMetadata().
  ///@return The documents /Info dictionary, never null.
  pddocumentinformation_.PDDocumentInformation getDocumentInformation() {
    return _getDocumentInformation(
            reference.pointer, _id_getDocumentInformation as _$jni.JMethodIDPtr)
        .object(const pddocumentinformation_.$PDDocumentInformation$Type());
  }

  static final _id_setDocumentInformation = _class.instanceMethodId(
    r'setDocumentInformation',
    r'(Lorg/apache/pdfbox/pdmodel/PDDocumentInformation;)V',
  );

  static final _setDocumentInformation = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setDocumentInformation(org.apache.pdfbox.pdmodel.PDDocumentInformation info)`
  ///
  /// This will set the document information for this document.
  ///
  /// In PDF 2.0 this is deprecated except for two entries, /CreationDate and /ModDate. For any other
  /// document level metadata, a metadata stream should be used instead, see
  /// PDDocumentCatalog\#setMetadata(org.apache.pdfbox.pdmodel.common.PDMetadata) PDDocumentCatalog\#setMetadata(PDMetadata).
  ///@param info The updated document information.
  void setDocumentInformation(
    pddocumentinformation_.PDDocumentInformation info,
  ) {
    _setDocumentInformation(
            reference.pointer,
            _id_setDocumentInformation as _$jni.JMethodIDPtr,
            info.reference.pointer)
        .check();
  }

  static final _id_getDocumentCatalog = _class.instanceMethodId(
    r'getDocumentCatalog',
    r'()Lorg/apache/pdfbox/pdmodel/PDDocumentCatalog;',
  );

  static final _getDocumentCatalog = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.pdmodel.PDDocumentCatalog getDocumentCatalog()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the document CATALOG. This is guaranteed to not return null.
  ///@return The documents /Root dictionary
  _$jni.JObject getDocumentCatalog() {
    return _getDocumentCatalog(
            reference.pointer, _id_getDocumentCatalog as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_isEncrypted = _class.instanceMethodId(
    r'isEncrypted',
    r'()Z',
  );

  static final _isEncrypted = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public boolean isEncrypted()`
  ///
  /// This will tell if this document is encrypted or not.
  ///@return true If this document is encrypted.
  bool isEncrypted() {
    return _isEncrypted(
            reference.pointer, _id_isEncrypted as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getEncryption = _class.instanceMethodId(
    r'getEncryption',
    r'()Lorg/apache/pdfbox/pdmodel/encryption/PDEncryption;',
  );

  static final _getEncryption = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.pdmodel.encryption.PDEncryption getEncryption()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will get the encryption dictionary for this document. This will still return the parameters if the document
  /// was decrypted. As the encryption architecture in PDF documents is pluggable this returns an abstract class,
  /// but the only supported subclass at this time is a
  /// PDStandardEncryption object.
  ///@return The encryption dictionary(most likely a PDStandardEncryption object)
  _$jni.JObject getEncryption() {
    return _getEncryption(
            reference.pointer, _id_getEncryption as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_setEncryptionDictionary = _class.instanceMethodId(
    r'setEncryptionDictionary',
    r'(Lorg/apache/pdfbox/pdmodel/encryption/PDEncryption;)V',
  );

  static final _setEncryptionDictionary = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setEncryptionDictionary(org.apache.pdfbox.pdmodel.encryption.PDEncryption encryption)`
  ///
  /// This will set the encryption dictionary for this document.
  ///@param encryption The encryption dictionary(most likely a PDStandardEncryption object)
  ///@throws IOException If there is an error determining which security handler to use.
  void setEncryptionDictionary(
    _$jni.JObject encryption,
  ) {
    _setEncryptionDictionary(
            reference.pointer,
            _id_setEncryptionDictionary as _$jni.JMethodIDPtr,
            encryption.reference.pointer)
        .check();
  }

  static final _id_getLastSignatureDictionary = _class.instanceMethodId(
    r'getLastSignatureDictionary',
    r'()Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/PDSignature;',
  );

  static final _getLastSignatureDictionary =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature getLastSignatureDictionary()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// This will return the last signature from the field tree. Note that this may not be the
  /// last in time when empty signature fields are created first but signed after other fields.
  ///@return the last signature as <code>PDSignatureField</code>.
  ///@throws IOException if no document catalog can be found.
  _$jni.JObject getLastSignatureDictionary() {
    return _getLastSignatureDictionary(reference.pointer,
            _id_getLastSignatureDictionary as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_getSignatureFields = _class.instanceMethodId(
    r'getSignatureFields',
    r'()Ljava/util/List;',
  );

  static final _getSignatureFields = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField> getSignatureFields()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Retrieve all signature fields from the document.
  ///@return a <code>List</code> of <code>PDSignatureField</code>s
  ///@throws IOException if no document catalog can be found.
  _$jni.JList<_$jni.JObject> getSignatureFields() {
    return _getSignatureFields(
            reference.pointer, _id_getSignatureFields as _$jni.JMethodIDPtr)
        .object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_getSignatureDictionaries = _class.instanceMethodId(
    r'getSignatureDictionaries',
    r'()Ljava/util/List;',
  );

  static final _getSignatureDictionaries = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.util.List<org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature> getSignatureDictionaries()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Retrieve all signature dictionaries from the document.
  ///@return a <code>List</code> of <code>PDSignatureField</code>s
  ///@throws IOException if no document catalog can be found.
  _$jni.JList<_$jni.JObject> getSignatureDictionaries() {
    return _getSignatureDictionaries(reference.pointer,
            _id_getSignatureDictionaries as _$jni.JMethodIDPtr)
        .object(const _$jni.JListType(_$jni.JObjectType()));
  }

  static final _id_registerTrueTypeFontForClosing = _class.instanceMethodId(
    r'registerTrueTypeFontForClosing',
    r'(Lorg/apache/fontbox/ttf/TrueTypeFont;)V',
  );

  static final _registerTrueTypeFontForClosing =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JThrowablePtr Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void registerTrueTypeFontForClosing(org.apache.fontbox.ttf.TrueTypeFont ttf)`
  ///
  /// For internal PDFBox use when creating PDF documents: register a TrueTypeFont to make sure it
  /// is closed when the PDDocument is closed to avoid memory leaks. Users don't have to call this
  /// method, it is done by the appropriate PDFont classes.
  ///@param ttf
  void registerTrueTypeFontForClosing(
    _$jni.JObject ttf,
  ) {
    _registerTrueTypeFontForClosing(
            reference.pointer,
            _id_registerTrueTypeFontForClosing as _$jni.JMethodIDPtr,
            ttf.reference.pointer)
        .check();
  }

  static final _id_load = _class.staticMethodId(
    r'load',
    r'(Ljava/io/File;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param file file to be loaded
  ///@return loaded document
  ///@throws InvalidPasswordException If the file required a non-empty password.
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument load(
    _$jni.JObject file,
  ) {
    return _load(_class.reference.pointer, _id_load as _$jni.JMethodIDPtr,
            file.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$1 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/File;Lorg/apache/pdfbox/io/MemoryUsageSetting;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF.
  ///@param file file to be loaded
  ///@param memUsageSetting defines how memory is used for buffering PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the file required a non-empty password.
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument load$1(
    _$jni.JObject file,
    _$jni.JObject memUsageSetting,
  ) {
    return _load$1(_class.reference.pointer, _id_load$1 as _$jni.JMethodIDPtr,
            file.reference.pointer, memUsageSetting.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$2 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/File;Ljava/lang/String;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$2 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, java.lang.String password)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param file file to be loaded
  ///@param password password to be used for decryption
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument load$2(
    _$jni.JObject file,
    _$jni.JString password,
  ) {
    return _load$2(_class.reference.pointer, _id_load$2 as _$jni.JMethodIDPtr,
            file.reference.pointer, password.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$3 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/File;Ljava/lang/String;Lorg/apache/pdfbox/io/MemoryUsageSetting;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$3 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, java.lang.String password, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF.
  ///@param file file to be loaded
  ///@param password password to be used for decryption
  ///@param memUsageSetting defines how memory is used for buffering PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument load$3(
    _$jni.JObject file,
    _$jni.JString password,
    _$jni.JObject memUsageSetting,
  ) {
    return _load$3(
            _class.reference.pointer,
            _id_load$3 as _$jni.JMethodIDPtr,
            file.reference.pointer,
            password.reference.pointer,
            memUsageSetting.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$4 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/File;Ljava/lang/String;Ljava/io/InputStream;Ljava/lang/String;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$4 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param file file to be loaded
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@return loaded document
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument load$4(
    _$jni.JObject file,
    _$jni.JString password,
    _$jni.JObject keyStore,
    _$jni.JString alias,
  ) {
    return _load$4(
            _class.reference.pointer,
            _id_load$4 as _$jni.JMethodIDPtr,
            file.reference.pointer,
            password.reference.pointer,
            keyStore.reference.pointer,
            alias.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$5 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/File;Ljava/lang/String;Ljava/io/InputStream;Ljava/lang/String;Lorg/apache/pdfbox/io/MemoryUsageSetting;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$5 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF.
  ///@param file file to be loaded
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@param memUsageSetting defines how memory is used for buffering PDF streams
  ///@return loaded document
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument load$5(
    _$jni.JObject file,
    _$jni.JString password,
    _$jni.JObject keyStore,
    _$jni.JString alias,
    _$jni.JObject memUsageSetting,
  ) {
    return _load$5(
            _class.reference.pointer,
            _id_load$5 as _$jni.JMethodIDPtr,
            file.reference.pointer,
            password.reference.pointer,
            keyStore.reference.pointer,
            alias.reference.pointer,
            memUsageSetting.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$6 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/InputStream;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$6 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. The given input stream is copied to the memory to enable random access to the
  /// pdf. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@return loaded document
  ///@throws InvalidPasswordException If the PDF required a non-empty password.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load$6(
    _$jni.JObject input,
  ) {
    return _load$6(_class.reference.pointer, _id_load$6 as _$jni.JMethodIDPtr,
            input.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$7 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/InputStream;Lorg/apache/pdfbox/io/MemoryUsageSetting;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$7 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Depending on the memory settings parameter the given input stream is either
  /// copied to main memory or to a temporary file to enable random access to the pdf.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param memUsageSetting defines how memory is used for buffering input stream and PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the PDF required a non-empty password.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load$7(
    _$jni.JObject input,
    _$jni.JObject memUsageSetting,
  ) {
    return _load$7(_class.reference.pointer, _id_load$7 as _$jni.JMethodIDPtr,
            input.reference.pointer, memUsageSetting.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$8 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/InputStream;Ljava/lang/String;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$8 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, java.lang.String password)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. The given input stream is copied to the memory to enable random access to the
  /// pdf. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param password password to be used for decryption
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load$8(
    _$jni.JObject input,
    _$jni.JString password,
  ) {
    return _load$8(_class.reference.pointer, _id_load$8 as _$jni.JMethodIDPtr,
            input.reference.pointer, password.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$9 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/InputStream;Ljava/lang/String;Ljava/io/InputStream;Ljava/lang/String;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$9 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. The given input stream is copied to the memory to enable random access to the
  /// pdf. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@return loaded document
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load$9(
    _$jni.JObject input,
    _$jni.JString password,
    _$jni.JObject keyStore,
    _$jni.JString alias,
  ) {
    return _load$9(
            _class.reference.pointer,
            _id_load$9 as _$jni.JMethodIDPtr,
            input.reference.pointer,
            password.reference.pointer,
            keyStore.reference.pointer,
            alias.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$10 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/InputStream;Ljava/lang/String;Lorg/apache/pdfbox/io/MemoryUsageSetting;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$10 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, java.lang.String password, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Depending on the memory settings parameter the given input stream is either
  /// copied to main memory or to a temporary file to enable random access to the pdf.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param password password to be used for decryption
  ///@param memUsageSetting defines how memory is used for buffering input stream and PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load$10(
    _$jni.JObject input,
    _$jni.JString password,
    _$jni.JObject memUsageSetting,
  ) {
    return _load$10(
            _class.reference.pointer,
            _id_load$10 as _$jni.JMethodIDPtr,
            input.reference.pointer,
            password.reference.pointer,
            memUsageSetting.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$11 = _class.staticMethodId(
    r'load',
    r'(Ljava/io/InputStream;Ljava/lang/String;Ljava/io/InputStream;Ljava/lang/String;Lorg/apache/pdfbox/io/MemoryUsageSetting;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$11 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Depending on the memory settings parameter the given input stream is either
  /// copied to memory or to a temporary file to enable random access to the pdf.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@param memUsageSetting defines how memory is used for buffering input stream and PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load$11(
    _$jni.JObject input,
    _$jni.JString password,
    _$jni.JObject keyStore,
    _$jni.JString alias,
    _$jni.JObject memUsageSetting,
  ) {
    return _load$11(
            _class.reference.pointer,
            _id_load$11 as _$jni.JMethodIDPtr,
            input.reference.pointer,
            password.reference.pointer,
            keyStore.reference.pointer,
            alias.reference.pointer,
            memUsageSetting.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$12 = _class.staticMethodId(
    r'load',
    r'([B)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$12 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(byte[] input)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input byte array that contains the document.
  ///@return loaded document
  ///@throws InvalidPasswordException If the PDF required a non-empty password.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load$12(
    _$jni.JArray<_$jni.jbyte> input,
  ) {
    return _load$12(_class.reference.pointer, _id_load$12 as _$jni.JMethodIDPtr,
            input.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$13 = _class.staticMethodId(
    r'load',
    r'([BLjava/lang/String;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$13 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(byte[] input, java.lang.String password)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input byte array that contains the document.
  ///@param password password to be used for decryption
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load$13(
    _$jni.JArray<_$jni.jbyte> input,
    _$jni.JString password,
  ) {
    return _load$13(_class.reference.pointer, _id_load$13 as _$jni.JMethodIDPtr,
            input.reference.pointer, password.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$14 = _class.staticMethodId(
    r'load',
    r'([BLjava/lang/String;Ljava/io/InputStream;Ljava/lang/String;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$14 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(byte[] input, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input byte array that contains the document.
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load$14(
    _$jni.JArray<_$jni.jbyte> input,
    _$jni.JString password,
    _$jni.JObject keyStore,
    _$jni.JString alias,
  ) {
    return _load$14(
            _class.reference.pointer,
            _id_load$14 as _$jni.JMethodIDPtr,
            input.reference.pointer,
            password.reference.pointer,
            keyStore.reference.pointer,
            alias.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_load$15 = _class.staticMethodId(
    r'load',
    r'([BLjava/lang/String;Ljava/io/InputStream;Ljava/lang/String;Lorg/apache/pdfbox/io/MemoryUsageSetting;)Lorg/apache/pdfbox/pdmodel/PDDocument;',
  );

  static final _load$15 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `static public org.apache.pdfbox.pdmodel.PDDocument load(byte[] input, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses a PDF.
  ///@param input byte array that contains the document.
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@param memUsageSetting defines how memory is used for buffering input stream and PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load$15(
    _$jni.JArray<_$jni.jbyte> input,
    _$jni.JString password,
    _$jni.JObject keyStore,
    _$jni.JString alias,
    _$jni.JObject memUsageSetting,
  ) {
    return _load$15(
            _class.reference.pointer,
            _id_load$15 as _$jni.JMethodIDPtr,
            input.reference.pointer,
            password.reference.pointer,
            keyStore.reference.pointer,
            alias.reference.pointer,
            memUsageSetting.reference.pointer)
        .object(const $PDDocument$Type());
  }

  static final _id_save = _class.instanceMethodId(
    r'save',
    r'(Ljava/lang/String;)V',
  );

  static final _save = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void save(java.lang.String fileName)`
  ///
  /// Save the document to a file.
  ///
  /// If encryption has been activated (with
  /// \#protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy) protect(ProtectionPolicy)),
  /// do not use the document after saving because the contents are now encrypted.
  ///@param fileName The file to save as.
  ///@throws IOException if the output could not be written
  void save(
    _$jni.JString fileName,
  ) {
    _save(reference.pointer, _id_save as _$jni.JMethodIDPtr,
            fileName.reference.pointer)
        .check();
  }

  static final _id_save$1 = _class.instanceMethodId(
    r'save',
    r'(Ljava/io/File;)V',
  );

  static final _save$1 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void save(java.io.File file)`
  ///
  /// Save the document to a file.
  ///
  /// If encryption has been activated (with
  /// \#protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy) protect(ProtectionPolicy)),
  /// do not use the document after saving because the contents are now encrypted.
  ///@param file The file to save as.
  ///@throws IOException if the output could not be written
  void save$1(
    _$jni.JObject file,
  ) {
    _save$1(reference.pointer, _id_save$1 as _$jni.JMethodIDPtr,
            file.reference.pointer)
        .check();
  }

  static final _id_save$2 = _class.instanceMethodId(
    r'save',
    r'(Ljava/io/OutputStream;)V',
  );

  static final _save$2 = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void save(java.io.OutputStream output)`
  ///
  /// This will save the document to an output stream.
  ///
  /// If encryption has been activated (with
  /// \#protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy) protect(ProtectionPolicy)),
  /// do not use the document after saving because the contents are now encrypted.
  ///@param output The stream to write to. It will be closed when done. It is recommended to wrap
  /// it in a java.io.BufferedOutputStream, unless it is already buffered.
  ///@throws IOException if the output could not be written
  void save$2(
    _$jni.JObject output,
  ) {
    _save$2(reference.pointer, _id_save$2 as _$jni.JMethodIDPtr,
            output.reference.pointer)
        .check();
  }

  static final _id_saveIncremental = _class.instanceMethodId(
    r'saveIncremental',
    r'(Ljava/io/OutputStream;)V',
  );

  static final _saveIncremental = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void saveIncremental(java.io.OutputStream output)`
  ///
  /// Save the PDF as an incremental update. This is only possible if the PDF was loaded from a
  /// file or a stream, not if the document was created in PDFBox itself. There must be a path of
  /// objects that have COSUpdateInfo\#isNeedToBeUpdated() set, starting from the document
  /// catalog. For signatures this is taken care by PDFBox itself.
  ///
  /// Other usages of this method are for experienced users only. You will usually never need it.
  /// It is useful only if you are required to keep the current revision and append the changes. A
  /// typical use case is changing a signed file without invalidating the signature.
  ///@param output stream to write to. It will be closed when done. It
  /// <i>__must never__</i> point to the source file or that one will be
  /// harmed!
  ///@throws IOException if the output could not be written
  ///@throws IllegalStateException if the document was not loaded from a file or a stream.
  void saveIncremental(
    _$jni.JObject output,
  ) {
    _saveIncremental(reference.pointer,
            _id_saveIncremental as _$jni.JMethodIDPtr, output.reference.pointer)
        .check();
  }

  static final _id_saveIncremental$1 = _class.instanceMethodId(
    r'saveIncremental',
    r'(Ljava/io/OutputStream;Ljava/util/Set;)V',
  );

  static final _saveIncremental$1 = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<
                      (
                        _$jni.Pointer<_$jni.Void>,
                        _$jni.Pointer<_$jni.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr,
              _$jni.Pointer<_$jni.Void>,
              _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void saveIncremental(java.io.OutputStream output, java.util.Set<org.apache.pdfbox.cos.COSDictionary> objectsToWrite)`
  ///
  /// Save the PDF as an incremental update. This is only possible if the PDF was loaded from a
  /// file or a stream, not if the document was created in PDFBox itself. This allows to include
  /// objects even if there is no path of objects that have
  /// COSUpdateInfo\#isNeedToBeUpdated() set so the incremental update gets smaller. Only
  /// dictionaries are supported; if you need to update other objects classes, then add their
  /// parent dictionary.
  ///
  /// This method is for experienced users only. You will usually never need it. It is useful only
  /// if you are required to keep the current revision and append the changes. A typical use case
  /// is changing a signed file without invalidating the signature. To know which objects are
  /// getting changed, you need to have some understanding of the PDF specification, and look at
  /// the saved file with an editor to verify that you are updating the correct objects. You should
  /// also inspect the page and document structures of the file with PDFDebugger.
  ///@param output stream to write to. It will be closed when done. It
  /// <i>__must never__</i> point to the source file or that one will be harmed!
  ///@param objectsToWrite objects that __must__ be part of the incremental saving.
  ///@throws IOException if the output could not be written
  ///@throws IllegalStateException if the document was not loaded from a file or a stream.
  void saveIncremental$1(
    _$jni.JObject output,
    _$jni.JSet<_$jni.JObject> objectsToWrite,
  ) {
    _saveIncremental$1(
            reference.pointer,
            _id_saveIncremental$1 as _$jni.JMethodIDPtr,
            output.reference.pointer,
            objectsToWrite.reference.pointer)
        .check();
  }

  static final _id_saveIncrementalForExternalSigning = _class.instanceMethodId(
    r'saveIncrementalForExternalSigning',
    r'(Ljava/io/OutputStream;)Lorg/apache/pdfbox/pdmodel/interactive/digitalsignature/ExternalSigningSupport;',
  );

  static final _saveIncrementalForExternalSigning =
      _$jni.ProtectedJniExtensions.lookup<
                  _$jni.NativeFunction<
                      _$jni.JniResult Function(
                          _$jni.Pointer<_$jni.Void>,
                          _$jni.JMethodIDPtr,
                          _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(_$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public org.apache.pdfbox.pdmodel.interactive.digitalsignature.ExternalSigningSupport saveIncrementalForExternalSigning(java.io.OutputStream output)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  ///
  /// __(This is a new feature for 2.0.3. The API for external signing might change based on feedback after release!)__
  ///
  /// Save PDF incrementally without closing for external signature creation scenario. The general
  /// sequence is:
  /// <pre>
  ///    PDDocument pdDocument = ...;
  ///    OutputStream outputStream = ...;
  ///    SignatureOptions signatureOptions = ...; // options to specify fine tuned signature options or null for defaults
  ///    PDSignature pdSignature = ...;
  ///
  ///    // add signature parameters to be used when creating signature dictionary
  ///    pdDocument.addSignature(pdSignature, signatureOptions);
  ///    // prepare PDF for signing and obtain helper class to be used
  ///    ExternalSigningSupport externalSigningSupport = pdDocument.saveIncrementalForExternalSigning(outputStream);
  ///    // get data to be signed
  ///    InputStream dataToBeSigned = externalSigningSupport.getContent();
  ///    // invoke signature service
  ///    byte[] signature = sign(dataToBeSigned);
  ///    // set resulted CMS signature
  ///    externalSigningSupport.setSignature(signature);
  ///
  ///    // last step is to close the document
  ///    pdDocument.close();
  /// </pre>
  ///
  /// Note that after calling this method, only {@code close()} method may invoked for
  /// {@code PDDocument} instance and only AFTER ExternalSigningSupport instance is used.
  ///
  ///
  ///@param output stream to write the final PDF. It will be closed when the
  /// document is closed. It <i>__must never__</i> point to the source file
  /// or that one will be harmed!
  ///@return instance to be used for external signing and setting CMS signature
  ///@throws IOException if the output could not be written
  ///@throws IllegalStateException if the document was not loaded from a file or a stream or
  /// signature options were not set.
  _$jni.JObject saveIncrementalForExternalSigning(
    _$jni.JObject output,
  ) {
    return _saveIncrementalForExternalSigning(
            reference.pointer,
            _id_saveIncrementalForExternalSigning as _$jni.JMethodIDPtr,
            output.reference.pointer)
        .object(const _$jni.JObjectType());
  }

  static final _id_getPage = _class.instanceMethodId(
    r'getPage',
    r'(I)Lorg/apache/pdfbox/pdmodel/PDPage;',
  );

  static final _getPage = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public org.apache.pdfbox.pdmodel.PDPage getPage(int pageIndex)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the page at the given 0-based index.
  ///
  /// This method is too slow to get all the pages from a large PDF document
  /// (1000 pages or more). For such documents, use the iterator of
  /// PDDocument\#getPages() instead.
  ///@param pageIndex the 0-based page index
  ///@return the page at the given index.
  _$jni.JObject getPage(
    int pageIndex,
  ) {
    return _getPage(
            reference.pointer, _id_getPage as _$jni.JMethodIDPtr, pageIndex)
        .object(const _$jni.JObjectType());
  }

  static final _id_getPages = _class.instanceMethodId(
    r'getPages',
    r'()Lorg/apache/pdfbox/pdmodel/PDPageTree;',
  );

  static final _getPages = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.pdmodel.PDPageTree getPages()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the page tree.
  ///@return the page tree
  _$jni.JObject getPages() {
    return _getPages(reference.pointer, _id_getPages as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_getNumberOfPages = _class.instanceMethodId(
    r'getNumberOfPages',
    r'()I',
  );

  static final _getNumberOfPages = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public int getNumberOfPages()`
  ///
  /// This will return the total page count of the PDF document.
  ///@return The total number of pages in the PDF document.
  int getNumberOfPages() {
    return _getNumberOfPages(
            reference.pointer, _id_getNumberOfPages as _$jni.JMethodIDPtr)
        .integer;
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public void close()`
  ///
  /// This will close the underlying COSDocument object.
  ///@throws IOException If there is an error releasing resources.
  void close() {
    _close(reference.pointer, _id_close as _$jni.JMethodIDPtr).check();
  }

  static final _id_protect = _class.instanceMethodId(
    r'protect',
    r'(Lorg/apache/pdfbox/pdmodel/encryption/ProtectionPolicy;)V',
  );

  static final _protect = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy policy)`
  ///
  /// Protects the document with a protection policy. The document content will be really
  /// encrypted when it will be saved. This method only marks the document for encryption. It also
  /// calls \#setAllSecurityToBeRemoved(boolean) with a false argument if it was set to true
  /// previously and logs a warning.
  ///
  /// Do not use the document after saving, because the structures are encrypted.
  ///@see org.apache.pdfbox.pdmodel.encryption.StandardProtectionPolicy
  ///@see org.apache.pdfbox.pdmodel.encryption.PublicKeyProtectionPolicy
  ///@param policy The protection policy.
  ///@throws IOException if there isn't any suitable security handler.
  void protect(
    _$jni.JObject policy,
  ) {
    _protect(reference.pointer, _id_protect as _$jni.JMethodIDPtr,
            policy.reference.pointer)
        .check();
  }

  static final _id_getCurrentAccessPermission = _class.instanceMethodId(
    r'getCurrentAccessPermission',
    r'()Lorg/apache/pdfbox/pdmodel/encryption/AccessPermission;',
  );

  static final _getCurrentAccessPermission =
      _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JniResult Function(
                    _$jni.Pointer<_$jni.Void>,
                    _$jni.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>();

  /// from: `public org.apache.pdfbox.pdmodel.encryption.AccessPermission getCurrentAccessPermission()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the access permissions granted when the document was decrypted. If the document was not decrypted this
  /// method returns the access permission for a document owner (ie can do everything). The returned object is in read
  /// only mode so that permissions cannot be changed. Methods providing access to content should rely on this object
  /// to verify if the current user is allowed to proceed.
  ///@return the access permissions for the current user on the document.
  _$jni.JObject getCurrentAccessPermission() {
    return _getCurrentAccessPermission(reference.pointer,
            _id_getCurrentAccessPermission as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_isAllSecurityToBeRemoved = _class.instanceMethodId(
    r'isAllSecurityToBeRemoved',
    r'()Z',
  );

  static final _isAllSecurityToBeRemoved = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public boolean isAllSecurityToBeRemoved()`
  ///
  /// Indicates if all security is removed or not when writing the pdf.
  ///@return returns true if all security shall be removed otherwise false
  bool isAllSecurityToBeRemoved() {
    return _isAllSecurityToBeRemoved(reference.pointer,
            _id_isAllSecurityToBeRemoved as _$jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_setAllSecurityToBeRemoved = _class.instanceMethodId(
    r'setAllSecurityToBeRemoved',
    r'(Z)V',
  );

  static final _setAllSecurityToBeRemoved = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, int)>();

  /// from: `public void setAllSecurityToBeRemoved(boolean removeAllSecurity)`
  ///
  /// Activates/Deactivates the removal of all security when writing the pdf.
  ///@param removeAllSecurity remove all security if set to true
  void setAllSecurityToBeRemoved(
    bool removeAllSecurity,
  ) {
    _setAllSecurityToBeRemoved(
            reference.pointer,
            _id_setAllSecurityToBeRemoved as _$jni.JMethodIDPtr,
            removeAllSecurity ? 1 : 0)
        .check();
  }

  static final _id_getDocumentId = _class.instanceMethodId(
    r'getDocumentId',
    r'()Ljava/lang/Long;',
  );

  static final _getDocumentId = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Long getDocumentId()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Provides the document ID.
  ///@return the document ID
  _$jni.JLong getDocumentId() {
    return _getDocumentId(
            reference.pointer, _id_getDocumentId as _$jni.JMethodIDPtr)
        .object(const _$jni.JLongType());
  }

  static final _id_setDocumentId = _class.instanceMethodId(
    r'setDocumentId',
    r'(Ljava/lang/Long;)V',
  );

  static final _setDocumentId = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setDocumentId(java.lang.Long docId)`
  ///
  /// Sets the document ID to the given value.
  ///@param docId the new document ID
  void setDocumentId(
    _$jni.JLong docId,
  ) {
    _setDocumentId(reference.pointer, _id_setDocumentId as _$jni.JMethodIDPtr,
            docId.reference.pointer)
        .check();
  }

  static final _id_getVersion = _class.instanceMethodId(
    r'getVersion',
    r'()F',
  );

  static final _getVersion = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public float getVersion()`
  ///
  /// Returns the PDF specification version this document conforms to.
  ///@return the PDF version (e.g. 1.4f)
  double getVersion() {
    return _getVersion(reference.pointer, _id_getVersion as _$jni.JMethodIDPtr)
        .float;
  }

  static final _id_setVersion = _class.instanceMethodId(
    r'setVersion',
    r'(F)V',
  );

  static final _setVersion = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JThrowablePtr Function(
                  _$jni.Pointer<_$jni.Void>,
                  _$jni.JMethodIDPtr,
                  _$jni.VarArgs<(_$jni.Double,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(
              _$jni.Pointer<_$jni.Void>, _$jni.JMethodIDPtr, double)>();

  /// from: `public void setVersion(float newVersion)`
  ///
  /// Sets the PDF specification version for this document.
  ///@param newVersion the new PDF version (e.g. 1.4f)
  void setVersion(
    double newVersion,
  ) {
    _setVersion(
            reference.pointer, _id_setVersion as _$jni.JMethodIDPtr, newVersion)
        .check();
  }

  static final _id_getResourceCache = _class.instanceMethodId(
    r'getResourceCache',
    r'()Lorg/apache/pdfbox/pdmodel/ResourceCache;',
  );

  static final _getResourceCache = _$jni.ProtectedJniExtensions.lookup<
          _$jni.NativeFunction<
              _$jni.JniResult Function(
                _$jni.Pointer<_$jni.Void>,
                _$jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          _$jni.JniResult Function(
            _$jni.Pointer<_$jni.Void>,
            _$jni.JMethodIDPtr,
          )>();

  /// from: `public org.apache.pdfbox.pdmodel.ResourceCache getResourceCache()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the resource cache associated with this document, or null if there is none.
  ///@return the resource cache or null.
  _$jni.JObject getResourceCache() {
    return _getResourceCache(
            reference.pointer, _id_getResourceCache as _$jni.JMethodIDPtr)
        .object(const _$jni.JObjectType());
  }

  static final _id_setResourceCache = _class.instanceMethodId(
    r'setResourceCache',
    r'(Lorg/apache/pdfbox/pdmodel/ResourceCache;)V',
  );

  static final _setResourceCache = _$jni.ProtectedJniExtensions.lookup<
              _$jni.NativeFunction<
                  _$jni.JThrowablePtr Function(
                      _$jni.Pointer<_$jni.Void>,
                      _$jni.JMethodIDPtr,
                      _$jni.VarArgs<(_$jni.Pointer<_$jni.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          _$jni.JThrowablePtr Function(_$jni.Pointer<_$jni.Void>,
              _$jni.JMethodIDPtr, _$jni.Pointer<_$jni.Void>)>();

  /// from: `public void setResourceCache(org.apache.pdfbox.pdmodel.ResourceCache resourceCache)`
  ///
  /// Sets the resource cache associated with this document.
  ///@param resourceCache A resource cache, or null.
  void setResourceCache(
    _$jni.JObject resourceCache,
  ) {
    _setResourceCache(
            reference.pointer,
            _id_setResourceCache as _$jni.JMethodIDPtr,
            resourceCache.reference.pointer)
        .check();
  }
}

final class $PDDocument$Type extends _$jni.JObjType<PDDocument> {
  const $PDDocument$Type();

  @_$core.override
  String get signature => r'Lorg/apache/pdfbox/pdmodel/PDDocument;';

  @_$jni.internal
  @_$core.override
  PDDocument fromReference(_$jni.JReference reference) =>
      PDDocument.fromReference(reference);

  @_$core.override
  _$jni.JObjType get superType => const _$jni.JObjectType();

  @_$core.override
  final superCount = 1;

  @_$core.override
  int get hashCode => ($PDDocument$Type).hashCode;

  @_$core.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PDDocument$Type) && other is $PDDocument$Type;
  }
}
