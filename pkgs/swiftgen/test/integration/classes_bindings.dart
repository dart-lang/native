// Copyright (c) 2025, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// coverage:ignore-file

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<
  ffi.Pointer<objc.ObjCObject> Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
  )
>()
external ffi.Pointer<objc.ObjCObject> _classes_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

late final _class_TestClassWrapper = objc.getClass("classes.TestClassWrapper");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_create = objc.registerName("create");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _class_TestOtherClassWrapper = objc.getClass(
  "classes.TestOtherClassWrapper",
);
late final _sel_times10WithX_ = objc.registerName("times10WithX:");
final _objc_msgSend_12hwf9n = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_self = objc.registerName("self");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
  >
  fromFunction(
    objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
        > {
  objc.ObjCObjectBase call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");

/// TestOtherClassWrapper
class TestOtherClassWrapper extends objc.NSObject {
  TestOtherClassWrapper._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [TestOtherClassWrapper] that points to the same underlying object as [other].
  TestOtherClassWrapper.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [TestOtherClassWrapper] that wraps the given raw object pointer.
  TestOtherClassWrapper.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [TestOtherClassWrapper].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_TestOtherClassWrapper,
    );
  }

  /// alloc
  static TestOtherClassWrapper alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_TestOtherClassWrapper,
      _sel_alloc,
    );
    return TestOtherClassWrapper.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static TestOtherClassWrapper allocWithZone(ffi.Pointer<objc.NSZone> zone$1) {
    final $ret = _objc_msgSend_1cwp428(
      _class_TestOtherClassWrapper,
      _sel_allocWithZone_,
      zone$1,
    );
    return TestOtherClassWrapper.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static TestOtherClassWrapper new$() {
    final $ret = _objc_msgSend_151sglz(_class_TestOtherClassWrapper, _sel_new);
    return TestOtherClassWrapper.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of TestOtherClassWrapper constructed with the default `new` method.
  factory TestOtherClassWrapper() => new$();
}

extension TestOtherClassWrapper$Methods on TestOtherClassWrapper {
  /// autorelease
  TestOtherClassWrapper autorelease() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return TestOtherClassWrapper.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// init
  TestOtherClassWrapper init() {
    objc.checkOsVersionInternal(
      'TestOtherClassWrapper.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      this.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return TestOtherClassWrapper.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// retain
  TestOtherClassWrapper retain() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return TestOtherClassWrapper.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// self
  TestOtherClassWrapper self() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return TestOtherClassWrapper.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// times10WithX:
  int times10WithX(int x) {
    return _objc_msgSend_12hwf9n(this.ref.pointer, _sel_times10WithX_, x);
  }
}

late final _sel_myMethod = objc.registerName("myMethod");

/// TestClassWrapper
class TestClassWrapper extends objc.NSObject {
  TestClassWrapper._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [TestClassWrapper] that points to the same underlying object as [other].
  TestClassWrapper.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [TestClassWrapper] that wraps the given raw object pointer.
  TestClassWrapper.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [TestClassWrapper].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_TestClassWrapper,
    );
  }

  /// alloc
  static TestClassWrapper alloc() {
    final $ret = _objc_msgSend_151sglz(_class_TestClassWrapper, _sel_alloc);
    return TestClassWrapper.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static TestClassWrapper allocWithZone(ffi.Pointer<objc.NSZone> zone$1) {
    final $ret = _objc_msgSend_1cwp428(
      _class_TestClassWrapper,
      _sel_allocWithZone_,
      zone$1,
    );
    return TestClassWrapper.castFromPointer($ret, retain: false, release: true);
  }

  /// create
  static TestClassWrapper create() {
    final $ret = _objc_msgSend_151sglz(_class_TestClassWrapper, _sel_create);
    return TestClassWrapper.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static TestClassWrapper new$() {
    final $ret = _objc_msgSend_151sglz(_class_TestClassWrapper, _sel_new);
    return TestClassWrapper.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of TestClassWrapper constructed with the default `new` method.
  factory TestClassWrapper() => new$();
}

extension TestClassWrapper$Methods on TestClassWrapper {
  /// autorelease
  TestClassWrapper autorelease() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return TestClassWrapper.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  TestClassWrapper init() {
    objc.checkOsVersionInternal(
      'TestClassWrapper.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      this.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return TestClassWrapper.castFromPointer($ret, retain: false, release: true);
  }

  /// myMethod
  TestOtherClassWrapper myMethod() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_myMethod);
    return TestOtherClassWrapper.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// retain
  TestClassWrapper retain() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return TestClassWrapper.castFromPointer($ret, retain: true, release: true);
  }

  /// self
  TestClassWrapper self() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return TestClassWrapper.castFromPointer($ret, retain: true, release: true);
  }
}
