// Copyright (c) 2024, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Bindings for `src/objective_c_runtime.h`.
// Regenerate bindings with `dart run tool/generate_code.dart`.

// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// coverage:ignore-file

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;

@ffi.Array.multi([32])
@ffi.Native<ffi.Array<ffi.Pointer<ffi.Void>>>(symbol: '_NSConcreteAutoBlock')
external ffi.Array<ffi.Pointer<ffi.Void>> NSConcreteAutoBlock;

@ffi.Array.multi([32])
@ffi.Native<ffi.Array<ffi.Pointer<ffi.Void>>>(
  symbol: '_NSConcreteFinalizingBlock',
)
external ffi.Array<ffi.Pointer<ffi.Void>> NSConcreteFinalizingBlock;

@ffi.Array.multi([32])
@ffi.Native<ffi.Array<ffi.Pointer<ffi.Void>>>(symbol: '_NSConcreteGlobalBlock')
external ffi.Array<ffi.Pointer<ffi.Void>> NSConcreteGlobalBlock;

@ffi.Array.multi([32])
@ffi.Native<ffi.Array<ffi.Pointer<ffi.Void>>>(symbol: '_NSConcreteMallocBlock')
external ffi.Array<ffi.Pointer<ffi.Void>> NSConcreteMallocBlock;

@ffi.Array.multi([32])
@ffi.Native<ffi.Array<ffi.Pointer<ffi.Void>>>(symbol: '_NSConcreteStackBlock')
external ffi.Array<ffi.Pointer<ffi.Void>> NSConcreteStackBlock;

@ffi.Native<ffi.Pointer<ObjCObjectImpl>>()
external ffi.Pointer<ObjCObjectImpl> NSKeyValueChangeIndexesKey;

@ffi.Native<ffi.Pointer<ObjCObjectImpl>>()
external ffi.Pointer<ObjCObjectImpl> NSKeyValueChangeKindKey;

@ffi.Native<ffi.Pointer<ObjCObjectImpl>>()
external ffi.Pointer<ObjCObjectImpl> NSKeyValueChangeNewKey;

@ffi.Native<ffi.Pointer<ObjCObjectImpl>>()
external ffi.Pointer<ObjCObjectImpl> NSKeyValueChangeNotificationIsPriorKey;

@ffi.Native<ffi.Pointer<ObjCObjectImpl>>()
external ffi.Pointer<ObjCObjectImpl> NSKeyValueChangeOldKey;

@ffi.Native<ffi.Pointer<ObjCObjectImpl>>()
external ffi.Pointer<ObjCObjectImpl> NSLocalizedDescriptionKey;

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
  symbol: 'objc_autoreleasePoolPop',
  isLeaf: true,
)
external void autoreleasePoolPop(ffi.Pointer<ffi.Void> pool);

@ffi.Native<ffi.Pointer<ffi.Void> Function()>(
  symbol: 'objc_autoreleasePoolPush',
  isLeaf: true,
)
external ffi.Pointer<ffi.Void> autoreleasePoolPush();

@ffi.Native<ffi.Pointer<ObjCObjectImpl> Function(ffi.Pointer<ObjCObjectImpl>)>(
  symbol: 'objc_retainBlock',
  isLeaf: true,
)
external ffi.Pointer<ObjCObjectImpl> blockRetain(
  ffi.Pointer<ObjCObjectImpl> object,
);

@ffi.Native<
  ffi.Pointer<ffi.Pointer<ObjCObjectImpl>> Function(
    ffi.Pointer<ffi.UnsignedInt>,
  )
>(symbol: 'objc_copyClassList', isLeaf: true)
external ffi.Pointer<ffi.Pointer<ObjCObjectImpl>> copyClassList(
  ffi.Pointer<ffi.UnsignedInt> count,
);

@ffi.Native<ffi.Pointer<ObjCObjectImpl> Function(ffi.Pointer<ffi.Char>)>(
  symbol: 'objc_getClass',
  isLeaf: true,
)
external ffi.Pointer<ObjCObjectImpl> getClass(ffi.Pointer<ffi.Char> name);

@ffi.Native<
  ObjCMethodDesc Function(
    ffi.Pointer<ObjCProtocolImpl>,
    ffi.Pointer<ObjCSelector>,
    ffi.Bool,
    ffi.Bool,
  )
>(symbol: 'protocol_getMethodDescription', isLeaf: true)
external ObjCMethodDesc getMethodDescription(
  ffi.Pointer<ObjCProtocolImpl> protocol,
  ffi.Pointer<ObjCSelector> sel,
  bool isRequiredMethod,
  bool isInstanceMethod,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ObjCSelector>)>(
  symbol: 'sel_getName',
  isLeaf: true,
)
external ffi.Pointer<ffi.Char> getName(ffi.Pointer<ObjCSelector> sel);

@ffi.Native<ffi.Pointer<ObjCObjectImpl> Function(ffi.Pointer<ObjCObjectImpl>)>(
  symbol: 'object_getClass',
  isLeaf: true,
)
external ffi.Pointer<ObjCObjectImpl> getObjectClass(
  ffi.Pointer<ObjCObjectImpl> object,
);

@ffi.Native<ffi.Pointer<ObjCProtocolImpl> Function(ffi.Pointer<ffi.Char>)>(
  symbol: 'objc_getProtocol',
  isLeaf: true,
)
external ffi.Pointer<ObjCProtocolImpl> getProtocol(ffi.Pointer<ffi.Char> name);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ObjCProtocolImpl>)>(
  symbol: 'protocol_getName',
  isLeaf: true,
)
external ffi.Pointer<ffi.Char> getProtocolName(
  ffi.Pointer<ObjCProtocolImpl> proto,
);

@ffi.Native<ffi.Void Function()>(symbol: 'objc_msgSend')
external void msgSend();

@ffi.Native<ffi.Void Function()>(symbol: 'objc_msgSend_fpret')
external void msgSendFpret();

@ffi.Native<ffi.Void Function()>(symbol: 'objc_msgSend_stret')
external void msgSendStret();

@ffi.Native<ffi.Pointer<ObjCObjectImpl> Function(ffi.Pointer<ObjCObjectImpl>)>(
  symbol: 'objc_autorelease',
  isLeaf: true,
)
external ffi.Pointer<ObjCObjectImpl> objectAutorelease(
  ffi.Pointer<ObjCObjectImpl> object,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ObjCObjectImpl>)>(
  symbol: 'objc_release',
  isLeaf: true,
)
external void objectRelease(ffi.Pointer<ObjCObjectImpl> object);

@ffi.Native<ffi.Pointer<ObjCObjectImpl> Function(ffi.Pointer<ObjCObjectImpl>)>(
  symbol: 'objc_retain',
  isLeaf: true,
)
external ffi.Pointer<ObjCObjectImpl> objectRetain(
  ffi.Pointer<ObjCObjectImpl> object,
);

@ffi.Native<ffi.Pointer<ObjCSelector> Function(ffi.Pointer<ffi.Char>)>(
  symbol: 'sel_registerName',
  isLeaf: true,
)
external ffi.Pointer<ObjCSelector> registerName(ffi.Pointer<ffi.Char> name);

final class ObjCMethodDesc extends ffi.Struct {
  external ffi.Pointer<ObjCSelector> name;

  external ffi.Pointer<ffi.Char> types;

  static ffi.Pointer<ObjCMethodDesc> $allocate(
    ffi.Allocator $allocator, {
    required ffi.Pointer<ObjCSelector> name,
    required ffi.Pointer<ffi.Char> types,
  }) => $allocator<ObjCMethodDesc>()
    ..ref.name = name
    ..ref.types = types;
}

final class ObjCObjectImpl extends ffi.Opaque {}

final class ObjCProtocolImpl extends ffi.Opaque {}

final class ObjCSelector extends ffi.Opaque {}
