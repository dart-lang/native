// Copyright (c) 2024, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Bindings for `src/foundation.h`.
// Regenerate bindings with `dart run tool/generate_code.dart`.

// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// coverage:ignore-file
import 'dart:collection';

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import '../objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<ffi.Pointer<objc.ObjCObject>>(symbol: 'NSKeyValueChangeIndexesKey')
external ffi.Pointer<objc.ObjCObject> _NSKeyValueChangeIndexesKey;

NSString get NSKeyValueChangeIndexesKey => NSString.castFromPointer(
  _NSKeyValueChangeIndexesKey,
  retain: true,
  release: true,
);

set NSKeyValueChangeIndexesKey(NSString value) {
  NSString.castFromPointer(
    _NSKeyValueChangeIndexesKey,
    retain: false,
    release: true,
  ).ref.release();
  _NSKeyValueChangeIndexesKey = value.ref.retainAndReturnPointer();
}

@ffi.Native<ffi.Pointer<objc.ObjCObject>>(symbol: 'NSKeyValueChangeKindKey')
external ffi.Pointer<objc.ObjCObject> _NSKeyValueChangeKindKey;

NSString get NSKeyValueChangeKindKey => NSString.castFromPointer(
  _NSKeyValueChangeKindKey,
  retain: true,
  release: true,
);

set NSKeyValueChangeKindKey(NSString value) {
  NSString.castFromPointer(
    _NSKeyValueChangeKindKey,
    retain: false,
    release: true,
  ).ref.release();
  _NSKeyValueChangeKindKey = value.ref.retainAndReturnPointer();
}

@ffi.Native<ffi.Pointer<objc.ObjCObject>>(symbol: 'NSKeyValueChangeNewKey')
external ffi.Pointer<objc.ObjCObject> _NSKeyValueChangeNewKey;

NSString get NSKeyValueChangeNewKey => NSString.castFromPointer(
  _NSKeyValueChangeNewKey,
  retain: true,
  release: true,
);

set NSKeyValueChangeNewKey(NSString value) {
  NSString.castFromPointer(
    _NSKeyValueChangeNewKey,
    retain: false,
    release: true,
  ).ref.release();
  _NSKeyValueChangeNewKey = value.ref.retainAndReturnPointer();
}

@ffi.Native<ffi.Pointer<objc.ObjCObject>>(
  symbol: 'NSKeyValueChangeNotificationIsPriorKey',
)
external ffi.Pointer<objc.ObjCObject> _NSKeyValueChangeNotificationIsPriorKey;

NSString get NSKeyValueChangeNotificationIsPriorKey => NSString.castFromPointer(
  _NSKeyValueChangeNotificationIsPriorKey,
  retain: true,
  release: true,
);

set NSKeyValueChangeNotificationIsPriorKey(NSString value) {
  NSString.castFromPointer(
    _NSKeyValueChangeNotificationIsPriorKey,
    retain: false,
    release: true,
  ).ref.release();
  _NSKeyValueChangeNotificationIsPriorKey = value.ref.retainAndReturnPointer();
}

@ffi.Native<ffi.Pointer<objc.ObjCObject>>(symbol: 'NSKeyValueChangeOldKey')
external ffi.Pointer<objc.ObjCObject> _NSKeyValueChangeOldKey;

NSString get NSKeyValueChangeOldKey => NSString.castFromPointer(
  _NSKeyValueChangeOldKey,
  retain: true,
  release: true,
);

set NSKeyValueChangeOldKey(NSString value) {
  NSString.castFromPointer(
    _NSKeyValueChangeOldKey,
    retain: false,
    release: true,
  ).ref.release();
  _NSKeyValueChangeOldKey = value.ref.retainAndReturnPointer();
}

@ffi.Native<ffi.Pointer<objc.ObjCObject>>(symbol: 'NSLocalizedDescriptionKey')
external ffi.Pointer<objc.ObjCObject> _NSLocalizedDescriptionKey;

NSString get NSLocalizedDescriptionKey => NSString.castFromPointer(
  _NSLocalizedDescriptionKey,
  retain: true,
  release: true,
);

set NSLocalizedDescriptionKey(NSString value) {
  NSString.castFromPointer(
    _NSLocalizedDescriptionKey,
    retain: false,
    release: true,
  ).ref.release();
  _NSLocalizedDescriptionKey = value.ref.retainAndReturnPointer();
}

@ffi.Native<
  ffi.UnsignedLong Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<NSFastEnumerationState>,
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
    ffi.UnsignedLong,
  )
>()
external int _ObjectiveCBindings_protocolTrampoline_17ap02x(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<NSFastEnumerationState> arg1,
  ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2,
  int arg3,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObject> Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<NSZone>,
  )
>()
external ffi.Pointer<objc.ObjCObject>
_ObjectiveCBindings_protocolTrampoline_18nsem0(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<NSZone> arg1,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>()
external void _ObjectiveCBindings_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
  ffi.Pointer<NSZone> Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
  )
>()
external ffi.Pointer<NSZone> _ObjectiveCBindings_protocolTrampoline_1a8cl66(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)
>()
external int _ObjectiveCBindings_protocolTrampoline_1ckyi24(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Long Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>()
external int _ObjectiveCBindings_protocolTrampoline_1ldqghh(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObject> Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
  )
>()
external ffi.Pointer<objc.ObjCObject>
_ObjectiveCBindings_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObject> Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCSelector>,
    ffi.Pointer<objc.ObjCObject>,
  )
>()
external ffi.Pointer<objc.ObjCObject>
_ObjectiveCBindings_protocolTrampoline_1mllhpc(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCSelector> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObject> Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external ffi.Pointer<objc.ObjCObject>
_ObjectiveCBindings_protocolTrampoline_1q0i84(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCBlockImpl> arg2,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
  )
>()
external void _ObjectiveCBindings_protocolTrampoline_1sr3ozv(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
  ffi.Pointer<ffi.Void> arg4,
);

@ffi.Native<
  ffi.Bool Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>()
external bool _ObjectiveCBindings_protocolTrampoline_3su7tt(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObject> Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCSelector>,
  )
>()
external ffi.Pointer<objc.ObjCObject>
_ObjectiveCBindings_protocolTrampoline_50as9u(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCSelector> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObject> Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCSelector>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>()
external ffi.Pointer<objc.ObjCObject>
_ObjectiveCBindings_protocolTrampoline_c7gk2u(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCSelector> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
);

@ffi.Native<
  ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)
>()
external bool _ObjectiveCBindings_protocolTrampoline_e3qsqz(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.UnsignedLong,
  )
>()
external void _ObjectiveCBindings_protocolTrampoline_hoampi(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  int arg2,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)
>()
external void _ObjectiveCBindings_protocolTrampoline_ovsamd(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Bool Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCSelector>,
  )
>()
external bool _ObjectiveCBindings_protocolTrampoline_w1e3k0(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCSelector> arg1,
);

@ffi.Native<
  instancetype Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>()
external instancetype _ObjectiveCBindings_protocolTrampoline_xr62hr(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_1b3bb6a(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_1o83rbn(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_1p9ui4q(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_1q8ia8l(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_1sr3ozv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_hoampi(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_lmc3p5(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_q5jeyk(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_rnu2c5(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_t8l8el(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_vhbh5h(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_zkjmn1(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapBlockingBlock_zuf90e(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_1b3bb6a(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_1o83rbn(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_1p9ui4q(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_1q8ia8l(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_1sr3ozv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_hoampi(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_lmc3p5(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_q5jeyk(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_rnu2c5(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_t8l8el(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_vhbh5h(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_zkjmn1(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ObjectiveCBindings_wrapListenerBlock_zuf90e(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Packed(2)
final class AEDesc extends ffi.Struct {
  @ffi.UnsignedInt()
  external int descriptorType;

  external ffi.Pointer<ffi.Pointer<OpaqueAEDataStorageType>> dataHandle;
}

final class CFRunLoop extends ffi.Opaque {}

final class CFString extends ffi.Opaque {}

typedef CFStringRef = ffi.Pointer<CFString>;

final class CGPoint extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;
}

final class CGRect extends ffi.Struct {
  external CGPoint origin;

  external CGSize size;
}

final class CGSize extends ffi.Struct {
  @ffi.Double()
  external double width;

  @ffi.Double()
  external double height;
}

/// Represents a single KVO observation. Each observation creates a new
/// DOBJCObservation, even for the same observer, observed object, and keyPath.
extension type DOBJCObservation.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [DOBJCObservation] that wraps the given raw object pointer.
  DOBJCObservation.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [DOBJCObservation].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_DOBJCObservation,
    );
  }

  /// alloc
  static DOBJCObservation alloc() {
    final $ret = _objc_msgSend_151sglz(_class_DOBJCObservation, _sel_alloc);
    return DOBJCObservation.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static DOBJCObservation allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_DOBJCObservation,
      _sel_allocWithZone_,
      zone,
    );
    return DOBJCObservation.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static DOBJCObservation new$() {
    final $ret = _objc_msgSend_151sglz(_class_DOBJCObservation, _sel_new);
    return DOBJCObservation.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of DOBJCObservation constructed with the default `new` method.
  DOBJCObservation() : this.castFrom(new$()._$);
}

extension DOBJCObservation$Methods on DOBJCObservation {
  /// dealloc
  void dealloc() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_dealloc);
  }

  /// debugObserver
  ffi.Pointer<ffi.Void> debugObserver() {
    return _objc_msgSend_6ex6p5(_$.ref.pointer, _sel_debugObserver);
  }

  /// init
  DOBJCObservation init() {
    objc.checkOsVersionInternal(
      'DOBJCObservation.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return DOBJCObservation.castFromPointer($ret, retain: false, release: true);
  }

  /// initForKeyPath:ofObject:withObserver:options:context:
  DOBJCObservation initForKeyPath(
    NSString keyPath, {
    required objc.ObjCObjectBase ofObject,
    required Observer withObserver,
    required int options,
    required ffi.Pointer<ffi.Void> context,
  }) {
    final $ret = _objc_msgSend_1jiinfj(
      _$.ref.retainAndReturnPointer(),
      _sel_initForKeyPath_ofObject_withObserver_options_context_,
      keyPath.ref.pointer,
      ofObject.ref.pointer,
      withObserver.ref.pointer,
      options,
      context,
    );
    return DOBJCObservation.castFromPointer($ret, retain: false, release: true);
  }

  /// remove
  void remove() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_remove);
  }
}

/// Helper class to adapt a Dart stream into a `NSInputStream`.
extension type DartInputStreamAdapter.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSInputStream, NSStreamDelegate {
  /// Constructs a [DartInputStreamAdapter] that wraps the given raw object pointer.
  DartInputStreamAdapter.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [DartInputStreamAdapter].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_DOBJCDartInputStreamAdapter,
    );
  }

  /// alloc
  static DartInputStreamAdapter alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_DOBJCDartInputStreamAdapter,
      _sel_alloc,
    );
    return DartInputStreamAdapter.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static DartInputStreamAdapter allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_DOBJCDartInputStreamAdapter,
      _sel_allocWithZone_,
      zone,
    );
    return DartInputStreamAdapter.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// inputStreamWithData:
  static DartInputStreamAdapter? inputStreamWithData(NSData data) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_DOBJCDartInputStreamAdapter,
      _sel_inputStreamWithData_,
      data.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : DartInputStreamAdapter.castFromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// inputStreamWithFileAtPath:
  static DartInputStreamAdapter? inputStreamWithFileAtPath(NSString path) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_DOBJCDartInputStreamAdapter,
      _sel_inputStreamWithFileAtPath_,
      path.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : DartInputStreamAdapter.castFromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// Creates the adapter.
  /// @param sendPort A port to that is will receive two types of messages:
  /// -1 => The `NSInputStream` has been closed and the port can be closed.
  /// _  => The number of types being required in a `read:maxLength` call.
  static DartInputStreamAdapter inputStreamWithPort(int sendPort) {
    final $ret = _objc_msgSend_1ya1kjn(
      _class_DOBJCDartInputStreamAdapter,
      _sel_inputStreamWithPort_,
      sendPort,
    );
    return DartInputStreamAdapter.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// inputStreamWithURL:
  static DartInputStreamAdapter? inputStreamWithURL(NSURL url) {
    objc.checkOsVersionInternal(
      'DOBJCDartInputStreamAdapter.inputStreamWithURL:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_DOBJCDartInputStreamAdapter,
      _sel_inputStreamWithURL_,
      url.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : DartInputStreamAdapter.castFromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// new
  static DartInputStreamAdapter new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_DOBJCDartInputStreamAdapter,
      _sel_new,
    );
    return DartInputStreamAdapter.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of DartInputStreamAdapter constructed with the default `new` method.
  DartInputStreamAdapter() : this.castFrom(new$()._$);
}

extension DartInputStreamAdapter$Methods on DartInputStreamAdapter {
  /// addData:
  int addData(NSData data) {
    return _objc_msgSend_1vd1c5m(
      _$.ref.pointer,
      _sel_addData_,
      data.ref.pointer,
    );
  }

  /// init
  DartInputStreamAdapter init() {
    objc.checkOsVersionInternal(
      'DOBJCDartInputStreamAdapter.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return DartInputStreamAdapter.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithData:
  DartInputStreamAdapter initWithData(NSData data) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithData_,
      data.ref.pointer,
    );
    return DartInputStreamAdapter.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithFileAtPath:
  DartInputStreamAdapter? initWithFileAtPath(NSString path) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithFileAtPath_,
      path.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : DartInputStreamAdapter.castFromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// initWithURL:
  DartInputStreamAdapter? initWithURL(NSURL url) {
    objc.checkOsVersionInternal(
      'DOBJCDartInputStreamAdapter.initWithURL:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithURL_,
      url.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : DartInputStreamAdapter.castFromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// setDone
  void setDone() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_setDone);
  }

  /// setError:
  void setError(NSError error) {
    _objc_msgSend_xtuoz7(_$.ref.pointer, _sel_setError_, error.ref.pointer);
  }

  /// stream:handleEvent:
  void stream(NSStream aStream, {required int handleEvent}) {
    if (!objc.respondsToSelector(_$.ref.pointer, _sel_stream_handleEvent_)) {
      throw objc.UnimplementedOptionalMethodException(
        'DOBJCDartInputStreamAdapter',
        'stream:handleEvent:',
      );
    }
    _objc_msgSend_3l8zum(
      _$.ref.pointer,
      _sel_stream_handleEvent_,
      aStream.ref.pointer,
      handleEvent,
    );
  }
}

/// Helper class that contains a weak reference to a `DOBJCDartInputStreamAdapter`.
extension type DartInputStreamAdapterWeakHolder.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [DartInputStreamAdapterWeakHolder] that wraps the given raw object pointer.
  DartInputStreamAdapterWeakHolder.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [DartInputStreamAdapterWeakHolder].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_DOBJCDartInputStreamAdapterWeakHolder,
    );
  }

  /// alloc
  static DartInputStreamAdapterWeakHolder alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_DOBJCDartInputStreamAdapterWeakHolder,
      _sel_alloc,
    );
    return DartInputStreamAdapterWeakHolder.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static DartInputStreamAdapterWeakHolder allocWithZone(
    ffi.Pointer<NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_DOBJCDartInputStreamAdapterWeakHolder,
      _sel_allocWithZone_,
      zone,
    );
    return DartInputStreamAdapterWeakHolder.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// holderWithInputStreamAdapter:
  static DartInputStreamAdapterWeakHolder holderWithInputStreamAdapter(
    DartInputStreamAdapter adapter,
  ) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_DOBJCDartInputStreamAdapterWeakHolder,
      _sel_holderWithInputStreamAdapter_,
      adapter.ref.pointer,
    );
    return DartInputStreamAdapterWeakHolder.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// new
  static DartInputStreamAdapterWeakHolder new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_DOBJCDartInputStreamAdapterWeakHolder,
      _sel_new,
    );
    return DartInputStreamAdapterWeakHolder.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of DartInputStreamAdapterWeakHolder constructed with the default `new` method.
  DartInputStreamAdapterWeakHolder() : this.castFrom(new$()._$);
}

extension DartInputStreamAdapterWeakHolder$Methods
    on DartInputStreamAdapterWeakHolder {
  /// adapter
  DartInputStreamAdapter get adapter {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_adapter);
    return DartInputStreamAdapter.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// init
  DartInputStreamAdapterWeakHolder init() {
    objc.checkOsVersionInternal(
      'DOBJCDartInputStreamAdapterWeakHolder.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return DartInputStreamAdapterWeakHolder.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }
}

/// Base class of all classes DOBJCDartProtocolBuilder creates.
extension type DartProtocol.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [DartProtocol] that wraps the given raw object pointer.
  DartProtocol.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [DartProtocol].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_DOBJCDartProtocol,
    );
  }

  /// alloc
  static DartProtocol alloc() {
    final $ret = _objc_msgSend_151sglz(_class_DOBJCDartProtocol, _sel_alloc);
    return DartProtocol.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static DartProtocol allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_DOBJCDartProtocol,
      _sel_allocWithZone_,
      zone,
    );
    return DartProtocol.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static DartProtocol new$() {
    final $ret = _objc_msgSend_151sglz(_class_DOBJCDartProtocol, _sel_new);
    return DartProtocol.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of DartProtocol constructed with the default `new` method.
  DartProtocol() : this.castFrom(new$()._$);
}

extension DartProtocol$Methods on DartProtocol {
  /// dealloc
  void dealloc() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_dealloc);
  }

  /// getDOBJCDartProtocolMethodForSelector:
  objc.ObjCObjectBase getDOBJCDartProtocolMethodForSelector(
    ffi.Pointer<objc.ObjCSelector> sel,
  ) {
    final $ret = _objc_msgSend_3ctkt6(
      _$.ref.pointer,
      _sel_getDOBJCDartProtocolMethodForSelector_,
      sel,
    );
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// init
  DartProtocol init() {
    objc.checkOsVersionInternal(
      'DOBJCDartProtocol.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return DartProtocol.castFromPointer($ret, retain: false, release: true);
  }

  /// initDOBJCDartProtocolFromDartProtocolBuilder:withDisposePort:
  DartProtocol initDOBJCDartProtocolFromDartProtocolBuilder(
    DartProtocolBuilder builder, {
    required int withDisposePort,
  }) {
    final $ret = _objc_msgSend_dbvvll(
      _$.ref.retainAndReturnPointer(),
      _sel_initDOBJCDartProtocolFromDartProtocolBuilder_withDisposePort_,
      builder.ref.pointer,
      withDisposePort,
    );
    return DartProtocol.castFromPointer($ret, retain: false, release: true);
  }
}

/// Used by the Dart ObjCProtocolBuilder to construct ObjC classes at runtime to
/// implement protocols.
extension type DartProtocolBuilder.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [DartProtocolBuilder] that wraps the given raw object pointer.
  DartProtocolBuilder.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [DartProtocolBuilder].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_DOBJCDartProtocolBuilder,
    );
  }

  /// alloc
  static DartProtocolBuilder alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_DOBJCDartProtocolBuilder,
      _sel_alloc,
    );
    return DartProtocolBuilder.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static DartProtocolBuilder allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_DOBJCDartProtocolBuilder,
      _sel_allocWithZone_,
      zone,
    );
    return DartProtocolBuilder.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static DartProtocolBuilder new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_DOBJCDartProtocolBuilder,
      _sel_new,
    );
    return DartProtocolBuilder.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of DartProtocolBuilder constructed with the default `new` method.
  DartProtocolBuilder() : this.castFrom(new$()._$);
}

extension DartProtocolBuilder$Methods on DartProtocolBuilder {
  /// addProtocol:
  void addProtocol(Protocol protocol) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_addProtocol_,
      protocol.ref.pointer,
    );
  }

  /// buildInstance:
  DartProtocol buildInstance(int port) {
    final $ret = _objc_msgSend_1ya1kjn(
      _$.ref.pointer,
      _sel_buildInstance_,
      port,
    );
    return DartProtocol.castFromPointer($ret, retain: true, release: true);
  }

  /// implementMethod:withBlock:withTrampoline:withSignature:
  void implementMethod(
    ffi.Pointer<objc.ObjCSelector> sel, {
    required ffi.Pointer<ffi.Void> withBlock,
    required ffi.Pointer<ffi.Void> withTrampoline,
    required ffi.Pointer<ffi.Char> withSignature,
  }) {
    _objc_msgSend_1s2gdyk(
      _$.ref.pointer,
      _sel_implementMethod_withBlock_withTrampoline_withSignature_,
      sel,
      withBlock,
      withTrampoline,
      withSignature,
    );
  }

  /// init
  DartProtocolBuilder init() {
    objc.checkOsVersionInternal(
      'DOBJCDartProtocolBuilder.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return DartProtocolBuilder.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithClassName:
  DartProtocolBuilder initWithClassName(ffi.Pointer<ffi.Char> name) {
    final $ret = _objc_msgSend_56zxyn(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithClassName_,
      name,
    );
    return DartProtocolBuilder.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// registerClass
  void registerClass() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_registerClass);
  }
}

/// iOS: unavailable
/// macOS: introduced 10.11.0
sealed class NSAppleEventSendOptions {
  static const NSAppleEventSendNoReply = 1;
  static const NSAppleEventSendQueueReply = 2;
  static const NSAppleEventSendWaitForReply = 3;
  static const NSAppleEventSendNeverInteract = 16;
  static const NSAppleEventSendCanInteract = 32;
  static const NSAppleEventSendAlwaysInteract = 48;
  static const NSAppleEventSendCanSwitchLayer = 64;
  static const NSAppleEventSendDontRecord = 4096;
  static const NSAppleEventSendDontExecute = 8192;
  static const NSAppleEventSendDontAnnotate = 65536;
  static const NSAppleEventSendDefaultOptions = 35;
}

/// NSArray
extension type NSArray.castFrom(objc.ObjCObjectBase _$)
    implements
        objc.ObjCObjectBase,
        NSObject,
        NSCopying,
        NSMutableCopying,
        NSSecureCoding,
        NSFastEnumeration {
  /// Constructs a [NSArray] that wraps the given raw object pointer.
  NSArray.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSArray].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSArray,
    );
  }

  /// alloc
  static NSArray alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSArray, _sel_alloc);
    return NSArray.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSArray allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSArray,
      _sel_allocWithZone_,
      zone,
    );
    return NSArray.castFromPointer($ret, retain: false, release: true);
  }

  /// array
  static NSArray array() {
    final $ret = _objc_msgSend_151sglz(_class_NSArray, _sel_array);
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// arrayWithArray:
  static NSArray arrayWithArray(NSArray array) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSArray,
      _sel_arrayWithArray_,
      array.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// arrayWithObject:
  static NSArray arrayWithObject(objc.ObjCObjectBase anObject) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSArray,
      _sel_arrayWithObject_,
      anObject.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// arrayWithObjects:
  static NSArray arrayWithObjects(objc.ObjCObjectBase firstObj) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSArray,
      _sel_arrayWithObjects_,
      firstObj.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// arrayWithObjects:count:
  static NSArray arrayWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required int count,
  }) {
    final $ret = _objc_msgSend_zmbtbd(
      _class_NSArray,
      _sel_arrayWithObjects_count_,
      objects,
      count,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSArray new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSArray, _sel_new);
    return NSArray.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSArray, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSArray constructed with the default `new` method.
  NSArray() : this.castFrom(new$()._$);
}

extension NSArray$Methods on NSArray {
  /// count
  int get count {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_count);
  }

  /// countByEnumeratingWithState:objects:count:
  int countByEnumeratingWithState(
    ffi.Pointer<NSFastEnumerationState> state, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects,
    required int count,
  }) {
    return _objc_msgSend_1b5ysjl(
      _$.ref.pointer,
      _sel_countByEnumeratingWithState_objects_count_,
      state,
      objects,
      count,
    );
  }

  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  NSArray init() {
    objc.checkOsVersionInternal(
      'NSArray.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSArray.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithArray:
  NSArray initWithArray(NSArray array) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithArray_,
      array.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithArray:copyItems:
  NSArray initWithArray$1(NSArray array, {required bool copyItems}) {
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithArray_copyItems_,
      array.ref.pointer,
      copyItems,
    );
    return NSArray.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSArray? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSArray.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObjects:
  NSArray initWithObjects(objc.ObjCObjectBase firstObj) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_,
      firstObj.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObjects:count:
  NSArray initWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required int count,
  }) {
    final $ret = _objc_msgSend_zmbtbd(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_count_,
      objects,
      count,
    );
    return NSArray.castFromPointer($ret, retain: false, release: true);
  }

  /// objectAtIndex:
  objc.ObjCObjectBase objectAtIndex(int index) {
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.pointer,
      _sel_objectAtIndex_,
      index,
    );
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }
}

/// NSAttributedString
extension type NSAttributedString.castFrom(objc.ObjCObjectBase _$)
    implements
        objc.ObjCObjectBase,
        NSObject,
        NSCopying,
        NSMutableCopying,
        NSSecureCoding {
  /// Constructs a [NSAttributedString] that wraps the given raw object pointer.
  NSAttributedString.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSAttributedString].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSAttributedString,
    );
  }

  /// alloc
  static NSAttributedString alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSAttributedString, _sel_alloc);
    return NSAttributedString.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NSAttributedString allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSAttributedString,
      _sel_allocWithZone_,
      zone,
    );
    return NSAttributedString.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// localizedAttributedStringWithFormat:
  ///
  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  static NSAttributedString localizedAttributedStringWithFormat(
    NSAttributedString format,
  ) {
    objc.checkOsVersionInternal(
      'NSAttributedString.localizedAttributedStringWithFormat:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSAttributedString,
      _sel_localizedAttributedStringWithFormat_,
      format.ref.pointer,
    );
    return NSAttributedString.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// localizedAttributedStringWithFormat:context:
  ///
  /// iOS: introduced 17.0.0
  /// macOS: introduced 14.0.0
  static NSAttributedString localizedAttributedStringWithFormat$1(
    NSAttributedString format, {
    required NSDictionary context,
  }) {
    objc.checkOsVersionInternal(
      'NSAttributedString.localizedAttributedStringWithFormat:context:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_NSAttributedString,
      _sel_localizedAttributedStringWithFormat_context_,
      format.ref.pointer,
      context.ref.pointer,
    );
    return NSAttributedString.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// localizedAttributedStringWithFormat:options:
  ///
  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  static NSAttributedString localizedAttributedStringWithFormat$2(
    NSAttributedString format, {
    required int options,
  }) {
    objc.checkOsVersionInternal(
      'NSAttributedString.localizedAttributedStringWithFormat:options:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_s058d2(
      _class_NSAttributedString,
      _sel_localizedAttributedStringWithFormat_options_,
      format.ref.pointer,
      options,
    );
    return NSAttributedString.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// localizedAttributedStringWithFormat:options:context:
  ///
  /// iOS: introduced 17.0.0
  /// macOS: introduced 14.0.0
  static NSAttributedString localizedAttributedStringWithFormat$3(
    NSAttributedString format, {
    required int options,
    required NSDictionary context,
  }) {
    objc.checkOsVersionInternal(
      'NSAttributedString.localizedAttributedStringWithFormat:options:context:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_187k8ck(
      _class_NSAttributedString,
      _sel_localizedAttributedStringWithFormat_options_context_,
      format.ref.pointer,
      options,
      context.ref.pointer,
    );
    return NSAttributedString.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// new
  static NSAttributedString new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSAttributedString, _sel_new);
    return NSAttributedString.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_NSAttributedString,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of NSAttributedString constructed with the default `new` method.
  NSAttributedString() : this.castFrom(new$()._$);
}

extension NSAttributedString$Methods on NSAttributedString {
  /// attributesAtIndex:effectiveRange:
  NSDictionary attributesAtIndex(
    int location, {
    required ffi.Pointer<NSRange> effectiveRange,
  }) {
    objc.checkOsVersionInternal(
      'NSAttributedString.attributesAtIndex:effectiveRange:',
      iOS: (false, (3, 2, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1776v9k(
      _$.ref.pointer,
      _sel_attributesAtIndex_effectiveRange_,
      location,
      effectiveRange,
    );
    return NSDictionary.castFromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  NSAttributedString init() {
    objc.checkOsVersionInternal(
      'NSAttributedString.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSAttributedString.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithAttributedString:
  NSAttributedString initWithAttributedString(NSAttributedString attrStr) {
    objc.checkOsVersionInternal(
      'NSAttributedString.initWithAttributedString:',
      iOS: (false, (3, 2, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithAttributedString_,
      attrStr.ref.pointer,
    );
    return NSAttributedString.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCoder:
  NSAttributedString? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSAttributedString.castFromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// initWithContentsOfMarkdownFileAtURL:options:baseURL:error:
  ///
  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  NSAttributedString? initWithContentsOfMarkdownFileAtURL(
    NSURL markdownFile, {
    NSAttributedStringMarkdownParsingOptions? options,
    NSURL? baseURL,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSAttributedString.initWithContentsOfMarkdownFileAtURL:options:baseURL:error:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_1k0ezzm(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfMarkdownFileAtURL_options_baseURL_error_,
      markdownFile.ref.pointer,
      options?.ref.pointer ?? ffi.nullptr,
      baseURL?.ref.pointer ?? ffi.nullptr,
      error,
    );
    return $ret.address == 0
        ? null
        : NSAttributedString.castFromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// initWithFormat:options:locale:
  ///
  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  NSAttributedString initWithFormat(
    NSAttributedString format, {
    required int options,
    NSLocale? locale,
  }) {
    objc.checkOsVersionInternal(
      'NSAttributedString.initWithFormat:options:locale:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_187k8ck(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithFormat_options_locale_,
      format.ref.pointer,
      options,
      locale?.ref.pointer ?? ffi.nullptr,
    );
    return NSAttributedString.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithFormat:options:locale:context:
  ///
  /// iOS: introduced 17.0.0
  /// macOS: introduced 14.0.0
  NSAttributedString initWithFormat$1(
    NSAttributedString format, {
    required int options,
    NSLocale? locale,
    required NSDictionary context,
  }) {
    objc.checkOsVersionInternal(
      'NSAttributedString.initWithFormat:options:locale:context:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_3fn4ca(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithFormat_options_locale_context_,
      format.ref.pointer,
      options,
      locale?.ref.pointer ?? ffi.nullptr,
      context.ref.pointer,
    );
    return NSAttributedString.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithMarkdown:options:baseURL:error:
  ///
  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  NSAttributedString? initWithMarkdown(
    NSData markdown, {
    NSAttributedStringMarkdownParsingOptions? options,
    NSURL? baseURL,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSAttributedString.initWithMarkdown:options:baseURL:error:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_1k0ezzm(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithMarkdown_options_baseURL_error_,
      markdown.ref.pointer,
      options?.ref.pointer ?? ffi.nullptr,
      baseURL?.ref.pointer ?? ffi.nullptr,
      error,
    );
    return $ret.address == 0
        ? null
        : NSAttributedString.castFromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// initWithMarkdownString:options:baseURL:error:
  ///
  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  NSAttributedString? initWithMarkdownString(
    NSString markdownString, {
    NSAttributedStringMarkdownParsingOptions? options,
    NSURL? baseURL,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSAttributedString.initWithMarkdownString:options:baseURL:error:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_1k0ezzm(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithMarkdownString_options_baseURL_error_,
      markdownString.ref.pointer,
      options?.ref.pointer ?? ffi.nullptr,
      baseURL?.ref.pointer ?? ffi.nullptr,
      error,
    );
    return $ret.address == 0
        ? null
        : NSAttributedString.castFromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// initWithString:
  NSAttributedString initWithString(NSString str) {
    objc.checkOsVersionInternal(
      'NSAttributedString.initWithString:',
      iOS: (false, (3, 2, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithString_,
      str.ref.pointer,
    );
    return NSAttributedString.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithString:attributes:
  NSAttributedString initWithString$1(
    NSString str, {
    NSDictionary? attributes,
  }) {
    objc.checkOsVersionInternal(
      'NSAttributedString.initWithString:attributes:',
      iOS: (false, (3, 2, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithString_attributes_,
      str.ref.pointer,
      attributes?.ref.pointer ?? ffi.nullptr,
    );
    return NSAttributedString.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// string
  NSString get string {
    objc.checkOsVersionInternal(
      'NSAttributedString.string',
      iOS: (false, (3, 2, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_string);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }
}

sealed class NSAttributedStringEnumerationOptions {
  static const NSAttributedStringEnumerationReverse = 2;
  static const NSAttributedStringEnumerationLongestEffectiveRangeNotRequired =
      1048576;
}

sealed class NSAttributedStringFormattingOptions {
  static const NSAttributedStringFormattingInsertArgumentAttributesWithoutMerging =
      1;
  static const NSAttributedStringFormattingApplyReplacementIndexAttribute = 2;
}

/// iOS: introduced 15.0.0
/// macOS: introduced 12.0.0
enum NSAttributedStringMarkdownInterpretedSyntax {
  NSAttributedStringMarkdownInterpretedSyntaxFull(0),
  NSAttributedStringMarkdownInterpretedSyntaxInlineOnly(1),
  NSAttributedStringMarkdownInterpretedSyntaxInlineOnlyPreservingWhitespace(2);

  final int value;
  const NSAttributedStringMarkdownInterpretedSyntax(this.value);

  static NSAttributedStringMarkdownInterpretedSyntax fromValue(
    int value,
  ) => switch (value) {
    0 => NSAttributedStringMarkdownInterpretedSyntaxFull,
    1 => NSAttributedStringMarkdownInterpretedSyntaxInlineOnly,
    2 =>
      NSAttributedStringMarkdownInterpretedSyntaxInlineOnlyPreservingWhitespace,
    _ => throw ArgumentError(
      'Unknown value for NSAttributedStringMarkdownInterpretedSyntax: $value',
    ),
  };
}

/// iOS: introduced 15.0.0
/// macOS: introduced 12.0.0
enum NSAttributedStringMarkdownParsingFailurePolicy {
  NSAttributedStringMarkdownParsingFailureReturnError(0),
  NSAttributedStringMarkdownParsingFailureReturnPartiallyParsedIfPossible(1);

  final int value;
  const NSAttributedStringMarkdownParsingFailurePolicy(this.value);

  static NSAttributedStringMarkdownParsingFailurePolicy fromValue(
    int value,
  ) => switch (value) {
    0 => NSAttributedStringMarkdownParsingFailureReturnError,
    1 =>
      NSAttributedStringMarkdownParsingFailureReturnPartiallyParsedIfPossible,
    _ => throw ArgumentError(
      'Unknown value for NSAttributedStringMarkdownParsingFailurePolicy: $value',
    ),
  };
}

/// NSAttributedStringMarkdownParsingOptions
///
/// iOS: introduced 15.0.0
/// macOS: introduced 12.0.0
extension type NSAttributedStringMarkdownParsingOptions.castFrom(
  objc.ObjCObjectBase _$
)
    implements objc.ObjCObjectBase, NSObject, NSCopying {
  /// Constructs a [NSAttributedStringMarkdownParsingOptions] that wraps the given raw object pointer.
  NSAttributedStringMarkdownParsingOptions.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSAttributedStringMarkdownParsingOptions].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSAttributedStringMarkdownParsingOptions,
    );
  }

  /// alloc
  static NSAttributedStringMarkdownParsingOptions alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSAttributedStringMarkdownParsingOptions,
      _sel_alloc,
    );
    return NSAttributedStringMarkdownParsingOptions.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NSAttributedStringMarkdownParsingOptions allocWithZone(
    ffi.Pointer<NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSAttributedStringMarkdownParsingOptions,
      _sel_allocWithZone_,
      zone,
    );
    return NSAttributedStringMarkdownParsingOptions.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static NSAttributedStringMarkdownParsingOptions new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSAttributedStringMarkdownParsingOptions,
      _sel_new,
    );
    return NSAttributedStringMarkdownParsingOptions.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of NSAttributedStringMarkdownParsingOptions constructed with the default `new` method.
  NSAttributedStringMarkdownParsingOptions() : this.castFrom(new$()._$);
}

extension NSAttributedStringMarkdownParsingOptions$Methods
    on NSAttributedStringMarkdownParsingOptions {
  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  bool get allowsExtendedAttributes {
    objc.checkOsVersionInternal(
      'NSAttributedStringMarkdownParsingOptions.allowsExtendedAttributes',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_allowsExtendedAttributes);
  }

  /// iOS: introduced 16.0.0
  /// macOS: introduced 13.0.0
  bool get appliesSourcePositionAttributes {
    objc.checkOsVersionInternal(
      'NSAttributedStringMarkdownParsingOptions.appliesSourcePositionAttributes',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_91o635(
      _$.ref.pointer,
      _sel_appliesSourcePositionAttributes,
    );
  }

  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  NSAttributedStringMarkdownParsingFailurePolicy get failurePolicy {
    objc.checkOsVersionInternal(
      'NSAttributedStringMarkdownParsingOptions.failurePolicy',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_194u5n2(_$.ref.pointer, _sel_failurePolicy);
    return NSAttributedStringMarkdownParsingFailurePolicy.fromValue($ret);
  }

  /// init
  NSAttributedStringMarkdownParsingOptions init() {
    objc.checkOsVersionInternal(
      'NSAttributedStringMarkdownParsingOptions.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSAttributedStringMarkdownParsingOptions.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  NSAttributedStringMarkdownInterpretedSyntax get interpretedSyntax {
    objc.checkOsVersionInternal(
      'NSAttributedStringMarkdownParsingOptions.interpretedSyntax',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_h0o9ch(_$.ref.pointer, _sel_interpretedSyntax);
    return NSAttributedStringMarkdownInterpretedSyntax.fromValue($ret);
  }

  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  NSString? get languageCode {
    objc.checkOsVersionInternal(
      'NSAttributedStringMarkdownParsingOptions.languageCode',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_languageCode);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  set allowsExtendedAttributes(bool value) {
    objc.checkOsVersionInternal(
      'NSAttributedStringMarkdownParsingOptions.setAllowsExtendedAttributes:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      _$.ref.pointer,
      _sel_setAllowsExtendedAttributes_,
      value,
    );
  }

  /// iOS: introduced 16.0.0
  /// macOS: introduced 13.0.0
  set appliesSourcePositionAttributes(bool value) {
    objc.checkOsVersionInternal(
      'NSAttributedStringMarkdownParsingOptions.setAppliesSourcePositionAttributes:',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      _$.ref.pointer,
      _sel_setAppliesSourcePositionAttributes_,
      value,
    );
  }

  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  set failurePolicy(NSAttributedStringMarkdownParsingFailurePolicy value) {
    objc.checkOsVersionInternal(
      'NSAttributedStringMarkdownParsingOptions.setFailurePolicy:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_mt0t38(_$.ref.pointer, _sel_setFailurePolicy_, value.value);
  }

  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  set interpretedSyntax(NSAttributedStringMarkdownInterpretedSyntax value) {
    objc.checkOsVersionInternal(
      'NSAttributedStringMarkdownParsingOptions.setInterpretedSyntax:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_1ay2tmt(
      _$.ref.pointer,
      _sel_setInterpretedSyntax_,
      value.value,
    );
  }

  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  set languageCode(NSString? value) {
    objc.checkOsVersionInternal(
      'NSAttributedStringMarkdownParsingOptions.setLanguageCode:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setLanguageCode_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

sealed class NSBinarySearchingOptions {
  static const NSBinarySearchingFirstEqual = 256;
  static const NSBinarySearchingLastEqual = 512;
  static const NSBinarySearchingInsertionIndex = 1024;
}

/// NSBundle
extension type NSBundle.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [NSBundle] that wraps the given raw object pointer.
  NSBundle.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSBundle].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSBundle,
    );
  }

  /// URLForResource:withExtension:subdirectory:inBundleWithURL:
  static NSURL? URLForResource$3(
    NSString? name, {
    NSString? withExtension,
    NSString? subdirectory,
    required NSURL inBundleWithURL,
  }) {
    objc.checkOsVersionInternal(
      'NSBundle.URLForResource:withExtension:subdirectory:inBundleWithURL:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_s92gih(
      _class_NSBundle,
      _sel_URLForResource_withExtension_subdirectory_inBundleWithURL_,
      name?.ref.pointer ?? ffi.nullptr,
      withExtension?.ref.pointer ?? ffi.nullptr,
      subdirectory?.ref.pointer ?? ffi.nullptr,
      inBundleWithURL.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// URLsForResourcesWithExtension:subdirectory:inBundleWithURL:
  static NSArray? URLsForResourcesWithExtension$2(
    NSString? ext, {
    NSString? subdirectory,
    required NSURL inBundleWithURL,
  }) {
    objc.checkOsVersionInternal(
      'NSBundle.URLsForResourcesWithExtension:subdirectory:inBundleWithURL:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      _class_NSBundle,
      _sel_URLsForResourcesWithExtension_subdirectory_inBundleWithURL_,
      ext?.ref.pointer ?? ffi.nullptr,
      subdirectory?.ref.pointer ?? ffi.nullptr,
      inBundleWithURL.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// allBundles
  static NSArray getAllBundles() {
    final $ret = _objc_msgSend_151sglz(_class_NSBundle, _sel_allBundles);
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// allFrameworks
  static NSArray getAllFrameworks() {
    final $ret = _objc_msgSend_151sglz(_class_NSBundle, _sel_allFrameworks);
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// alloc
  static NSBundle alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSBundle, _sel_alloc);
    return NSBundle.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSBundle allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSBundle,
      _sel_allocWithZone_,
      zone,
    );
    return NSBundle.castFromPointer($ret, retain: false, release: true);
  }

  /// bundleForClass:
  static NSBundle bundleForClass(objc.ObjCObjectBase aClass) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSBundle,
      _sel_bundleForClass_,
      aClass.ref.pointer,
    );
    return NSBundle.castFromPointer($ret, retain: true, release: true);
  }

  /// bundleWithIdentifier:
  static NSBundle? bundleWithIdentifier(NSString identifier) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSBundle,
      _sel_bundleWithIdentifier_,
      identifier.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSBundle.castFromPointer($ret, retain: true, release: true);
  }

  /// bundleWithPath:
  static NSBundle? bundleWithPath(NSString path) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSBundle,
      _sel_bundleWithPath_,
      path.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSBundle.castFromPointer($ret, retain: true, release: true);
  }

  /// bundleWithURL:
  static NSBundle? bundleWithURL(NSURL url) {
    objc.checkOsVersionInternal(
      'NSBundle.bundleWithURL:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSBundle,
      _sel_bundleWithURL_,
      url.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSBundle.castFromPointer($ret, retain: true, release: true);
  }

  /// mainBundle
  static NSBundle getMainBundle() {
    final $ret = _objc_msgSend_151sglz(_class_NSBundle, _sel_mainBundle);
    return NSBundle.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSBundle new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSBundle, _sel_new);
    return NSBundle.castFromPointer($ret, retain: false, release: true);
  }

  /// pathForResource:ofType:inDirectory:
  static NSString? pathForResource$3(
    NSString? name, {
    NSString? ofType,
    required NSString inDirectory,
  }) {
    final $ret = _objc_msgSend_11spmsz(
      _class_NSBundle,
      _sel_pathForResource_ofType_inDirectory_,
      name?.ref.pointer ?? ffi.nullptr,
      ofType?.ref.pointer ?? ffi.nullptr,
      inDirectory.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// pathsForResourcesOfType:inDirectory:
  static NSArray pathsForResourcesOfType$2(
    NSString? ext, {
    required NSString inDirectory,
  }) {
    final $ret = _objc_msgSend_15qeuct(
      _class_NSBundle,
      _sel_pathsForResourcesOfType_inDirectory_,
      ext?.ref.pointer ?? ffi.nullptr,
      inDirectory.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// preferredLocalizationsFromArray:
  static NSArray preferredLocalizationsFromArray(NSArray localizationsArray) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSBundle,
      _sel_preferredLocalizationsFromArray_,
      localizationsArray.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// preferredLocalizationsFromArray:forPreferences:
  static NSArray preferredLocalizationsFromArray$1(
    NSArray localizationsArray, {
    NSArray? forPreferences,
  }) {
    final $ret = _objc_msgSend_15qeuct(
      _class_NSBundle,
      _sel_preferredLocalizationsFromArray_forPreferences_,
      localizationsArray.ref.pointer,
      forPreferences?.ref.pointer ?? ffi.nullptr,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of NSBundle constructed with the default `new` method.
  NSBundle() : this.castFrom(new$()._$);
}

extension NSBundle$Methods on NSBundle {
  /// URLForAuxiliaryExecutable:
  NSURL? URLForAuxiliaryExecutable(NSString executableName) {
    objc.checkOsVersionInternal(
      'NSBundle.URLForAuxiliaryExecutable:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_URLForAuxiliaryExecutable_,
      executableName.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// URLForResource:withExtension:
  NSURL? URLForResource(NSString? name, {NSString? withExtension}) {
    objc.checkOsVersionInternal(
      'NSBundle.URLForResource:withExtension:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.pointer,
      _sel_URLForResource_withExtension_,
      name?.ref.pointer ?? ffi.nullptr,
      withExtension?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// URLForResource:withExtension:subdirectory:
  NSURL? URLForResource$1(
    NSString? name, {
    NSString? withExtension,
    NSString? subdirectory,
  }) {
    objc.checkOsVersionInternal(
      'NSBundle.URLForResource:withExtension:subdirectory:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      _$.ref.pointer,
      _sel_URLForResource_withExtension_subdirectory_,
      name?.ref.pointer ?? ffi.nullptr,
      withExtension?.ref.pointer ?? ffi.nullptr,
      subdirectory?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// URLForResource:withExtension:subdirectory:localization:
  NSURL? URLForResource$2(
    NSString? name, {
    NSString? withExtension,
    NSString? subdirectory,
    NSString? localization,
  }) {
    objc.checkOsVersionInternal(
      'NSBundle.URLForResource:withExtension:subdirectory:localization:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_s92gih(
      _$.ref.pointer,
      _sel_URLForResource_withExtension_subdirectory_localization_,
      name?.ref.pointer ?? ffi.nullptr,
      withExtension?.ref.pointer ?? ffi.nullptr,
      subdirectory?.ref.pointer ?? ffi.nullptr,
      localization?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// URLsForResourcesWithExtension:subdirectory:
  NSArray? URLsForResourcesWithExtension(
    NSString? ext, {
    NSString? subdirectory,
  }) {
    objc.checkOsVersionInternal(
      'NSBundle.URLsForResourcesWithExtension:subdirectory:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.pointer,
      _sel_URLsForResourcesWithExtension_subdirectory_,
      ext?.ref.pointer ?? ffi.nullptr,
      subdirectory?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// URLsForResourcesWithExtension:subdirectory:localization:
  NSArray? URLsForResourcesWithExtension$1(
    NSString? ext, {
    NSString? subdirectory,
    NSString? localization,
  }) {
    objc.checkOsVersionInternal(
      'NSBundle.URLsForResourcesWithExtension:subdirectory:localization:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      _$.ref.pointer,
      _sel_URLsForResourcesWithExtension_subdirectory_localization_,
      ext?.ref.pointer ?? ffi.nullptr,
      subdirectory?.ref.pointer ?? ffi.nullptr,
      localization?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// appStoreReceiptURL
  NSURL? get appStoreReceiptURL {
    objc.checkOsVersionInternal(
      'NSBundle.appStoreReceiptURL',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_appStoreReceiptURL);
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// builtInPlugInsPath
  NSString? get builtInPlugInsPath {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_builtInPlugInsPath);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// builtInPlugInsURL
  NSURL? get builtInPlugInsURL {
    objc.checkOsVersionInternal(
      'NSBundle.builtInPlugInsURL',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_builtInPlugInsURL);
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// bundleIdentifier
  NSString? get bundleIdentifier {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_bundleIdentifier);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// bundlePath
  NSString get bundlePath {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_bundlePath);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// bundleURL
  NSURL get bundleURL {
    objc.checkOsVersionInternal(
      'NSBundle.bundleURL',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_bundleURL);
    return NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// classNamed:
  objc.ObjCObjectBase? classNamed(NSString className) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_classNamed_,
      className.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// developmentLocalization
  NSString? get developmentLocalization {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_developmentLocalization,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// executableArchitectures
  NSArray? get executableArchitectures {
    objc.checkOsVersionInternal(
      'NSBundle.executableArchitectures',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_executableArchitectures,
    );
    return $ret.address == 0
        ? null
        : NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// executablePath
  NSString? get executablePath {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_executablePath);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// executableURL
  NSURL? get executableURL {
    objc.checkOsVersionInternal(
      'NSBundle.executableURL',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_executableURL);
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// infoDictionary
  NSDictionary? get infoDictionary {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_infoDictionary);
    return $ret.address == 0
        ? null
        : NSDictionary.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  NSBundle init() {
    objc.checkOsVersionInternal(
      'NSBundle.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSBundle.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithPath:
  NSBundle? initWithPath(NSString path) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithPath_,
      path.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSBundle.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithURL:
  NSBundle? initWithURL(NSURL url) {
    objc.checkOsVersionInternal(
      'NSBundle.initWithURL:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithURL_,
      url.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSBundle.castFromPointer($ret, retain: false, release: true);
  }

  /// isLoaded
  bool get isLoaded {
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isLoaded);
  }

  /// load
  bool load$1() {
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_load);
  }

  /// loadAndReturnError:
  bool loadAndReturnError(ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal(
      'NSBundle.loadAndReturnError:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_1dom33q(
      _$.ref.pointer,
      _sel_loadAndReturnError_,
      error,
    );
  }

  /// localizations
  NSArray get localizations {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_localizations);
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// localizedAttributedStringForKey:value:table:
  ///
  /// iOS: introduced 15.0.0
  /// macOS: introduced 12.0.0
  NSAttributedString localizedAttributedStringForKey(
    NSString key, {
    NSString? value,
    NSString? table,
  }) {
    objc.checkOsVersionInternal(
      'NSBundle.localizedAttributedStringForKey:value:table:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      _$.ref.pointer,
      _sel_localizedAttributedStringForKey_value_table_,
      key.ref.pointer,
      value?.ref.pointer ?? ffi.nullptr,
      table?.ref.pointer ?? ffi.nullptr,
    );
    return NSAttributedString.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// localizedInfoDictionary
  NSDictionary? get localizedInfoDictionary {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_localizedInfoDictionary,
    );
    return $ret.address == 0
        ? null
        : NSDictionary.castFromPointer($ret, retain: true, release: true);
  }

  /// localizedStringForKey:value:table:
  NSString localizedStringForKey(
    NSString key, {
    NSString? value,
    NSString? table,
  }) {
    final $ret = _objc_msgSend_11spmsz(
      _$.ref.pointer,
      _sel_localizedStringForKey_value_table_,
      key.ref.pointer,
      value?.ref.pointer ?? ffi.nullptr,
      table?.ref.pointer ?? ffi.nullptr,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// objectForInfoDictionaryKey:
  objc.ObjCObjectBase? objectForInfoDictionaryKey(NSString key) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_objectForInfoDictionaryKey_,
      key.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// pathForAuxiliaryExecutable:
  NSString? pathForAuxiliaryExecutable(NSString executableName) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_pathForAuxiliaryExecutable_,
      executableName.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// pathForResource:ofType:
  NSString? pathForResource(NSString? name, {NSString? ofType}) {
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.pointer,
      _sel_pathForResource_ofType_,
      name?.ref.pointer ?? ffi.nullptr,
      ofType?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// pathForResource:ofType:inDirectory:
  NSString? pathForResource$1(
    NSString? name, {
    NSString? ofType,
    NSString? inDirectory,
  }) {
    final $ret = _objc_msgSend_11spmsz(
      _$.ref.pointer,
      _sel_pathForResource_ofType_inDirectory_,
      name?.ref.pointer ?? ffi.nullptr,
      ofType?.ref.pointer ?? ffi.nullptr,
      inDirectory?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// pathForResource:ofType:inDirectory:forLocalization:
  NSString? pathForResource$2(
    NSString? name, {
    NSString? ofType,
    NSString? inDirectory,
    NSString? forLocalization,
  }) {
    final $ret = _objc_msgSend_s92gih(
      _$.ref.pointer,
      _sel_pathForResource_ofType_inDirectory_forLocalization_,
      name?.ref.pointer ?? ffi.nullptr,
      ofType?.ref.pointer ?? ffi.nullptr,
      inDirectory?.ref.pointer ?? ffi.nullptr,
      forLocalization?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// pathsForResourcesOfType:inDirectory:
  NSArray pathsForResourcesOfType(NSString? ext, {NSString? inDirectory}) {
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.pointer,
      _sel_pathsForResourcesOfType_inDirectory_,
      ext?.ref.pointer ?? ffi.nullptr,
      inDirectory?.ref.pointer ?? ffi.nullptr,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// pathsForResourcesOfType:inDirectory:forLocalization:
  NSArray pathsForResourcesOfType$1(
    NSString? ext, {
    NSString? inDirectory,
    NSString? forLocalization,
  }) {
    final $ret = _objc_msgSend_11spmsz(
      _$.ref.pointer,
      _sel_pathsForResourcesOfType_inDirectory_forLocalization_,
      ext?.ref.pointer ?? ffi.nullptr,
      inDirectory?.ref.pointer ?? ffi.nullptr,
      forLocalization?.ref.pointer ?? ffi.nullptr,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// preferredLocalizations
  NSArray get preferredLocalizations {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_preferredLocalizations,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// preflightAndReturnError:
  bool preflightAndReturnError(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  ) {
    objc.checkOsVersionInternal(
      'NSBundle.preflightAndReturnError:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_1dom33q(
      _$.ref.pointer,
      _sel_preflightAndReturnError_,
      error,
    );
  }

  /// principalClass
  objc.ObjCObjectBase? get principalClass {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_principalClass);
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// privateFrameworksPath
  NSString? get privateFrameworksPath {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_privateFrameworksPath,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// privateFrameworksURL
  NSURL? get privateFrameworksURL {
    objc.checkOsVersionInternal(
      'NSBundle.privateFrameworksURL',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_privateFrameworksURL,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// resourcePath
  NSString? get resourcePath {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_resourcePath);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// resourceURL
  NSURL? get resourceURL {
    objc.checkOsVersionInternal(
      'NSBundle.resourceURL',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_resourceURL);
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// sharedFrameworksPath
  NSString? get sharedFrameworksPath {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_sharedFrameworksPath,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// sharedFrameworksURL
  NSURL? get sharedFrameworksURL {
    objc.checkOsVersionInternal(
      'NSBundle.sharedFrameworksURL',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_sharedFrameworksURL,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// sharedSupportPath
  NSString? get sharedSupportPath {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_sharedSupportPath);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// sharedSupportURL
  NSURL? get sharedSupportURL {
    objc.checkOsVersionInternal(
      'NSBundle.sharedSupportURL',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_sharedSupportURL);
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// unload
  bool unload() {
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_unload);
  }
}

/// NSCharacterSet
extension type NSCharacterSet.castFrom(objc.ObjCObjectBase _$)
    implements
        objc.ObjCObjectBase,
        NSObject,
        NSCopying,
        NSMutableCopying,
        NSSecureCoding {
  /// Constructs a [NSCharacterSet] that wraps the given raw object pointer.
  NSCharacterSet.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSCharacterSet].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSCharacterSet,
    );
  }

  /// alloc
  static NSCharacterSet alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSCharacterSet, _sel_alloc);
    return NSCharacterSet.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSCharacterSet allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSCharacterSet,
      _sel_allocWithZone_,
      zone,
    );
    return NSCharacterSet.castFromPointer($ret, retain: false, release: true);
  }

  /// alphanumericCharacterSet
  static NSCharacterSet getAlphanumericCharacterSet() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_alphanumericCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// capitalizedLetterCharacterSet
  static NSCharacterSet getCapitalizedLetterCharacterSet() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_capitalizedLetterCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// characterSetWithBitmapRepresentation:
  static NSCharacterSet characterSetWithBitmapRepresentation(NSData data) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSCharacterSet,
      _sel_characterSetWithBitmapRepresentation_,
      data.ref.pointer,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// characterSetWithCharactersInString:
  static NSCharacterSet characterSetWithCharactersInString(NSString aString) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSCharacterSet,
      _sel_characterSetWithCharactersInString_,
      aString.ref.pointer,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// characterSetWithContentsOfFile:
  static NSCharacterSet? characterSetWithContentsOfFile(NSString fName) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSCharacterSet,
      _sel_characterSetWithContentsOfFile_,
      fName.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// characterSetWithRange:
  static NSCharacterSet characterSetWithRange(NSRange aRange) {
    final $ret = _objc_msgSend_1k1o1s7(
      _class_NSCharacterSet,
      _sel_characterSetWithRange_,
      aRange,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// controlCharacterSet
  static NSCharacterSet getControlCharacterSet() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_controlCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// decimalDigitCharacterSet
  static NSCharacterSet getDecimalDigitCharacterSet() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_decimalDigitCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// decomposableCharacterSet
  static NSCharacterSet getDecomposableCharacterSet() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_decomposableCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// illegalCharacterSet
  static NSCharacterSet getIllegalCharacterSet() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_illegalCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// letterCharacterSet
  static NSCharacterSet getLetterCharacterSet() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_letterCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// lowercaseLetterCharacterSet
  static NSCharacterSet getLowercaseLetterCharacterSet() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_lowercaseLetterCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSCharacterSet new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSCharacterSet, _sel_new);
    return NSCharacterSet.castFromPointer($ret, retain: false, release: true);
  }

  /// newlineCharacterSet
  static NSCharacterSet getNewlineCharacterSet() {
    objc.checkOsVersionInternal(
      'NSCharacterSet.newlineCharacterSet',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_newlineCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// nonBaseCharacterSet
  static NSCharacterSet getNonBaseCharacterSet() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_nonBaseCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// punctuationCharacterSet
  static NSCharacterSet getPunctuationCharacterSet() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_punctuationCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_NSCharacterSet,
      _sel_supportsSecureCoding,
    );
  }

  /// symbolCharacterSet
  static NSCharacterSet getSymbolCharacterSet() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_symbolCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// uppercaseLetterCharacterSet
  static NSCharacterSet getUppercaseLetterCharacterSet() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_uppercaseLetterCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// whitespaceAndNewlineCharacterSet
  static NSCharacterSet getWhitespaceAndNewlineCharacterSet() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_whitespaceAndNewlineCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// whitespaceCharacterSet
  static NSCharacterSet getWhitespaceCharacterSet() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSCharacterSet,
      _sel_whitespaceCharacterSet,
    );
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of NSCharacterSet constructed with the default `new` method.
  NSCharacterSet() : this.castFrom(new$()._$);
}

extension NSCharacterSet$Methods on NSCharacterSet {
  /// bitmapRepresentation
  NSData get bitmapRepresentation {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_bitmapRepresentation,
    );
    return NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// characterIsMember:
  bool characterIsMember(int aCharacter) {
    return _objc_msgSend_1co9mn4(
      _$.ref.pointer,
      _sel_characterIsMember_,
      aCharacter,
    );
  }

  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// hasMemberInPlane:
  bool hasMemberInPlane(int thePlane) {
    return _objc_msgSend_gerswc(
      _$.ref.pointer,
      _sel_hasMemberInPlane_,
      thePlane,
    );
  }

  /// init
  NSCharacterSet init() {
    objc.checkOsVersionInternal(
      'NSCharacterSet.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSCharacterSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSCharacterSet? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSCharacterSet.castFromPointer($ret, retain: false, release: true);
  }

  /// invertedSet
  NSCharacterSet get invertedSet {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_invertedSet);
    return NSCharacterSet.castFromPointer($ret, retain: true, release: true);
  }

  /// isSupersetOfSet:
  bool isSupersetOfSet(NSCharacterSet theOtherSet) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isSupersetOfSet_,
      theOtherSet.ref.pointer,
    );
  }

  /// longCharacterIsMember:
  bool longCharacterIsMember(int theLongChar) {
    return _objc_msgSend_jsclrq(
      _$.ref.pointer,
      _sel_longCharacterIsMember_,
      theLongChar,
    );
  }
}

/// NSCoder
extension type NSCoder.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [NSCoder] that wraps the given raw object pointer.
  NSCoder.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSCoder].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSCoder,
    );
  }

  /// alloc
  static NSCoder alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSCoder, _sel_alloc);
    return NSCoder.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSCoder allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSCoder,
      _sel_allocWithZone_,
      zone,
    );
    return NSCoder.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSCoder new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSCoder, _sel_new);
    return NSCoder.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSCoder constructed with the default `new` method.
  NSCoder() : this.castFrom(new$()._$);
}

extension NSCoder$Methods on NSCoder {
  /// decodeDataObject
  NSData? decodeDataObject() {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_decodeDataObject);
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// decodeValueOfObjCType:at:size:
  void decodeValueOfObjCType(
    ffi.Pointer<ffi.Char> type, {
    required ffi.Pointer<ffi.Void> at,
    required int size,
  }) {
    objc.checkOsVersionInternal(
      'NSCoder.decodeValueOfObjCType:at:size:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_nc6uds(
      _$.ref.pointer,
      _sel_decodeValueOfObjCType_at_size_,
      type,
      at,
      size,
    );
  }

  /// encodeDataObject:
  void encodeDataObject(NSData data) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeDataObject_,
      data.ref.pointer,
    );
  }

  /// encodeValueOfObjCType:at:
  void encodeValueOfObjCType(
    ffi.Pointer<ffi.Char> type, {
    required ffi.Pointer<ffi.Void> at,
  }) {
    _objc_msgSend_1flkydz(
      _$.ref.pointer,
      _sel_encodeValueOfObjCType_at_,
      type,
      at,
    );
  }

  /// init
  NSCoder init() {
    objc.checkOsVersionInternal(
      'NSCoder.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSCoder.castFromPointer($ret, retain: false, release: true);
  }

  /// versionForClassName:
  int versionForClassName(NSString className) {
    return _objc_msgSend_1r6ymhb(
      _$.ref.pointer,
      _sel_versionForClassName_,
      className.ref.pointer,
    );
  }
}

/// NSCoding
extension type NSCoding.castFrom(objc.ObjCProtocolBase _$)
    implements objc.ObjCProtocolBase {
  /// Constructs a [NSCoding] that wraps the given raw object pointer.
  NSCoding.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCProtocolBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSCoding].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_NSCoding,
    );
  }
}

extension NSCoding$Methods on NSCoding {
  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// initWithCoder:
  NSCoding? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSCoding.castFromPointer($ret, retain: false, release: true);
  }
}

interface class NSCoding$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_NSCoding.cast());

  /// Builds an object that implements the NSCoding protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSCoding implement({
    required void Function(NSCoder) encodeWithCoder_,
    required Dartinstancetype? Function(NSCoder) initWithCoder_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSCoding');
    NSCoding$Builder.encodeWithCoder_.implement(builder, encodeWithCoder_);
    NSCoding$Builder.initWithCoder_.implement(builder, initWithCoder_);
    builder.addProtocol($protocol);
    return NSCoding.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSCoding protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    required void Function(NSCoder) encodeWithCoder_,
    required Dartinstancetype? Function(NSCoder) initWithCoder_,
    bool $keepIsolateAlive = true,
  }) {
    NSCoding$Builder.encodeWithCoder_.implement(builder, encodeWithCoder_);
    NSCoding$Builder.initWithCoder_.implement(builder, initWithCoder_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSCoding protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSCoding implementAsListener({
    required void Function(NSCoder) encodeWithCoder_,
    required Dartinstancetype? Function(NSCoder) initWithCoder_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSCoding');
    NSCoding$Builder.encodeWithCoder_.implementAsListener(
      builder,
      encodeWithCoder_,
    );
    NSCoding$Builder.initWithCoder_.implement(builder, initWithCoder_);
    builder.addProtocol($protocol);
    return NSCoding.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSCoding protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    required void Function(NSCoder) encodeWithCoder_,
    required Dartinstancetype? Function(NSCoder) initWithCoder_,
    bool $keepIsolateAlive = true,
  }) {
    NSCoding$Builder.encodeWithCoder_.implementAsListener(
      builder,
      encodeWithCoder_,
    );
    NSCoding$Builder.initWithCoder_.implement(builder, initWithCoder_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSCoding protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSCoding implementAsBlocking({
    required void Function(NSCoder) encodeWithCoder_,
    required Dartinstancetype? Function(NSCoder) initWithCoder_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSCoding');
    NSCoding$Builder.encodeWithCoder_.implementAsBlocking(
      builder,
      encodeWithCoder_,
    );
    NSCoding$Builder.initWithCoder_.implement(builder, initWithCoder_);
    builder.addProtocol($protocol);
    return NSCoding.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSCoding protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    required void Function(NSCoder) encodeWithCoder_,
    required Dartinstancetype? Function(NSCoder) initWithCoder_,
    bool $keepIsolateAlive = true,
  }) {
    NSCoding$Builder.encodeWithCoder_.implementAsBlocking(
      builder,
      encodeWithCoder_,
    );
    NSCoding$Builder.initWithCoder_.implement(builder, initWithCoder_);
    builder.addProtocol($protocol);
  }

  /// encodeWithCoder:
  static final encodeWithCoder_ =
      objc.ObjCProtocolListenableMethod<void Function(NSCoder)>(
        _protocol_NSCoding,
        _sel_encodeWithCoder_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_18v1jvf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSCoding,
          _sel_encodeWithCoder_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (void Function(NSCoder) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSCoder.fromFunction(
              (ffi.Pointer<ffi.Void> _, NSCoder arg1) => func(arg1),
            ),
        (void Function(NSCoder) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSCoder.listener(
              (ffi.Pointer<ffi.Void> _, NSCoder arg1) => func(arg1),
            ),
        (void Function(NSCoder) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSCoder.blocking(
              (ffi.Pointer<ffi.Void> _, NSCoder arg1) => func(arg1),
            ),
      );

  /// initWithCoder:
  static final initWithCoder_ =
      objc.ObjCProtocolMethod<Dartinstancetype? Function(NSCoder)>(
        _protocol_NSCoding,
        _sel_initWithCoder_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_xr62hr)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSCoding,
          _sel_initWithCoder_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (Dartinstancetype? Function(NSCoder) func) =>
            ObjCBlock_instancetype_ffiVoid_NSCoder.fromFunction(
              (ffi.Pointer<ffi.Void> _, NSCoder arg1) => func(arg1),
            ),
      );
}

/// iOS: introduced 13.0.0
/// macOS: introduced 10.15.0
enum NSCollectionChangeType {
  NSCollectionChangeInsert(0),
  NSCollectionChangeRemove(1);

  final int value;
  const NSCollectionChangeType(this.value);

  static NSCollectionChangeType fromValue(int value) => switch (value) {
    0 => NSCollectionChangeInsert,
    1 => NSCollectionChangeRemove,
    _ => throw ArgumentError(
      'Unknown value for NSCollectionChangeType: $value',
    ),
  };
}

enum NSComparisonResult {
  NSOrderedAscending(-1),
  NSOrderedSame(0),
  NSOrderedDescending(1);

  final int value;
  const NSComparisonResult(this.value);

  static NSComparisonResult fromValue(int value) => switch (value) {
    -1 => NSOrderedAscending,
    0 => NSOrderedSame,
    1 => NSOrderedDescending,
    _ => throw ArgumentError('Unknown value for NSComparisonResult: $value'),
  };
}

/// NSCopying
extension type NSCopying.castFrom(objc.ObjCProtocolBase _$)
    implements objc.ObjCProtocolBase {
  /// Constructs a [NSCopying] that wraps the given raw object pointer.
  NSCopying.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCProtocolBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSCopying].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_NSCopying,
    );
  }
}

extension NSCopying$Methods on NSCopying {
  /// copyWithZone:
  objc.ObjCObjectBase copyWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _$.ref.pointer,
      _sel_copyWithZone_,
      zone,
    );
    return objc.ObjCObjectBase($ret, retain: false, release: true);
  }
}

interface class NSCopying$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_NSCopying.cast());

  /// Builds an object that implements the NSCopying protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSCopying implement({
    required objc.ObjCObjectBase Function(ffi.Pointer<NSZone>) copyWithZone_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSCopying');
    NSCopying$Builder.copyWithZone_.implement(builder, copyWithZone_);
    builder.addProtocol($protocol);
    return NSCopying.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSCopying protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    required objc.ObjCObjectBase Function(ffi.Pointer<NSZone>) copyWithZone_,
    bool $keepIsolateAlive = true,
  }) {
    NSCopying$Builder.copyWithZone_.implement(builder, copyWithZone_);
    builder.addProtocol($protocol);
  }

  /// copyWithZone:
  static final copyWithZone_ =
      objc.ObjCProtocolMethod<
        objc.ObjCObjectBase Function(ffi.Pointer<NSZone>)
      >(
        _protocol_NSCopying,
        _sel_copyWithZone_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<NSZone>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_18nsem0)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSCopying,
          _sel_copyWithZone_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (objc.ObjCObjectBase Function(ffi.Pointer<NSZone>) func) =>
            ObjCBlock_objcObjCObject_ffiVoid_NSZone.fromFunction(
              (ffi.Pointer<ffi.Void> _, ffi.Pointer<NSZone> arg1) => func(arg1),
            ),
      );
}

/// NSData
extension type NSData.castFrom(objc.ObjCObjectBase _$)
    implements
        objc.ObjCObjectBase,
        NSObject,
        NSCopying,
        NSMutableCopying,
        NSSecureCoding {
  /// Constructs a [NSData] that wraps the given raw object pointer.
  NSData.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSData].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSData,
    );
  }

  /// alloc
  static NSData alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSData, _sel_alloc);
    return NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSData allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSData,
      _sel_allocWithZone_,
      zone,
    );
    return NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// data
  static NSData data() {
    final $ret = _objc_msgSend_151sglz(_class_NSData, _sel_data);
    return NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithBytes:length:
  static NSData dataWithBytes(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
  }) {
    final $ret = _objc_msgSend_3nbx5e(
      _class_NSData,
      _sel_dataWithBytes_length_,
      bytes,
      length,
    );
    return NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithBytesNoCopy:length:
  static NSData dataWithBytesNoCopy(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
  }) {
    final $ret = _objc_msgSend_3nbx5e(
      _class_NSData,
      _sel_dataWithBytesNoCopy_length_,
      bytes,
      length,
    );
    return NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithBytesNoCopy:length:freeWhenDone:
  static NSData dataWithBytesNoCopy$1(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
    required bool freeWhenDone,
  }) {
    final $ret = _objc_msgSend_161ne8y(
      _class_NSData,
      _sel_dataWithBytesNoCopy_length_freeWhenDone_,
      bytes,
      length,
      freeWhenDone,
    );
    return NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithContentsOfFile:
  static NSData? dataWithContentsOfFile(NSString path) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSData,
      _sel_dataWithContentsOfFile_,
      path.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithContentsOfFile:options:error:
  static NSData? dataWithContentsOfFile$1(
    NSString path, {
    required int options,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_8321cp(
      _class_NSData,
      _sel_dataWithContentsOfFile_options_error_,
      path.ref.pointer,
      options,
      error,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithContentsOfURL:
  static NSData? dataWithContentsOfURL(NSURL url) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSData,
      _sel_dataWithContentsOfURL_,
      url.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithContentsOfURL:options:error:
  static NSData? dataWithContentsOfURL$1(
    NSURL url, {
    required int options,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_8321cp(
      _class_NSData,
      _sel_dataWithContentsOfURL_options_error_,
      url.ref.pointer,
      options,
      error,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithData:
  static NSData dataWithData(NSData data) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSData,
      _sel_dataWithData_,
      data.ref.pointer,
    );
    return NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSData new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSData, _sel_new);
    return NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSData, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSData constructed with the default `new` method.
  NSData() : this.castFrom(new$()._$);
}

extension NSData$Methods on NSData {
  /// bytes
  ffi.Pointer<ffi.Void> get bytes {
    return _objc_msgSend_6ex6p5(_$.ref.pointer, _sel_bytes);
  }

  /// compressedDataUsingAlgorithm:error:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  NSData? compressedDataUsingAlgorithm(
    NSDataCompressionAlgorithm algorithm, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSData.compressedDataUsingAlgorithm:error:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1vnlaqg(
      _$.ref.pointer,
      _sel_compressedDataUsingAlgorithm_error_,
      algorithm.value,
      error,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// decompressedDataUsingAlgorithm:error:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  NSData? decompressedDataUsingAlgorithm(
    NSDataCompressionAlgorithm algorithm, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSData.decompressedDataUsingAlgorithm:error:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1vnlaqg(
      _$.ref.pointer,
      _sel_decompressedDataUsingAlgorithm_error_,
      algorithm.value,
      error,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  NSData init() {
    objc.checkOsVersionInternal(
      'NSData.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBase64EncodedData:options:
  NSData? initWithBase64EncodedData(NSData base64Data, {required int options}) {
    objc.checkOsVersionInternal(
      'NSData.initWithBase64EncodedData:options:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_7kpg7m(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBase64EncodedData_options_,
      base64Data.ref.pointer,
      options,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBase64EncodedString:options:
  NSData? initWithBase64EncodedString(
    NSString base64String, {
    required int options,
  }) {
    objc.checkOsVersionInternal(
      'NSData.initWithBase64EncodedString:options:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_7kpg7m(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBase64EncodedString_options_,
      base64String.ref.pointer,
      options,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytes:length:
  NSData initWithBytes(ffi.Pointer<ffi.Void> bytes, {required int length}) {
    final $ret = _objc_msgSend_3nbx5e(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytes_length_,
      bytes,
      length,
    );
    return NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytesNoCopy:length:
  NSData initWithBytesNoCopy(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
  }) {
    final $ret = _objc_msgSend_3nbx5e(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytesNoCopy_length_,
      bytes,
      length,
    );
    return NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytesNoCopy:length:deallocator:
  NSData initWithBytesNoCopy$1(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>?
    deallocator,
  }) {
    objc.checkOsVersionInternal(
      'NSData.initWithBytesNoCopy:length:deallocator:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_134vhyh(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytesNoCopy_length_deallocator_,
      bytes,
      length,
      deallocator?.ref.pointer ?? ffi.nullptr,
    );
    return NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytesNoCopy:length:freeWhenDone:
  NSData initWithBytesNoCopy$2(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
    required bool freeWhenDone,
  }) {
    final $ret = _objc_msgSend_161ne8y(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytesNoCopy_length_freeWhenDone_,
      bytes,
      length,
      freeWhenDone,
    );
    return NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSData? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfFile:
  NSData? initWithContentsOfFile(NSString path) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfFile_,
      path.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfFile:options:error:
  NSData? initWithContentsOfFile$1(
    NSString path, {
    required int options,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_8321cp(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfFile_options_error_,
      path.ref.pointer,
      options,
      error,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:
  NSData? initWithContentsOfURL(NSURL url) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfURL_,
      url.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:options:error:
  NSData? initWithContentsOfURL$1(
    NSURL url, {
    required int options,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_8321cp(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfURL_options_error_,
      url.ref.pointer,
      options,
      error,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithData:
  NSData initWithData(NSData data) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithData_,
      data.ref.pointer,
    );
    return NSData.castFromPointer($ret, retain: false, release: true);
  }

  /// length
  int get length {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_length);
  }
}

sealed class NSDataBase64DecodingOptions {
  static const NSDataBase64DecodingIgnoreUnknownCharacters = 1;
}

sealed class NSDataBase64EncodingOptions {
  static const NSDataBase64Encoding64CharacterLineLength = 1;
  static const NSDataBase64Encoding76CharacterLineLength = 2;
  static const NSDataBase64EncodingEndLineWithCarriageReturn = 16;
  static const NSDataBase64EncodingEndLineWithLineFeed = 32;
}

/// iOS: introduced 13.0.0
/// macOS: introduced 10.15.0
enum NSDataCompressionAlgorithm {
  NSDataCompressionAlgorithmLZFSE(0),
  NSDataCompressionAlgorithmLZ4(1),
  NSDataCompressionAlgorithmLZMA(2),
  NSDataCompressionAlgorithmZlib(3);

  final int value;
  const NSDataCompressionAlgorithm(this.value);

  static NSDataCompressionAlgorithm fromValue(int value) => switch (value) {
    0 => NSDataCompressionAlgorithmLZFSE,
    1 => NSDataCompressionAlgorithmLZ4,
    2 => NSDataCompressionAlgorithmLZMA,
    3 => NSDataCompressionAlgorithmZlib,
    _ => throw ArgumentError(
      'Unknown value for NSDataCompressionAlgorithm: $value',
    ),
  };
}

/// NSDataCreation
extension NSDataCreation on NSData {}

sealed class NSDataReadingOptions {
  static const NSDataReadingMappedIfSafe = 1;
  static const NSDataReadingUncached = 2;
  static const NSDataReadingMappedAlways = 8;
  static const NSDataReadingMapped = 1;
  static const NSMappedRead = 1;
  static const NSUncachedRead = 2;
}

sealed class NSDataSearchOptions {
  static const NSDataSearchBackwards = 1;
  static const NSDataSearchAnchored = 2;
}

sealed class NSDataWritingOptions {
  static const NSDataWritingAtomic = 1;
  static const NSDataWritingWithoutOverwriting = 2;
  static const NSDataWritingFileProtectionNone = 268435456;
  static const NSDataWritingFileProtectionComplete = 536870912;
  static const NSDataWritingFileProtectionCompleteUnlessOpen = 805306368;
  static const NSDataWritingFileProtectionCompleteUntilFirstUserAuthentication =
      1073741824;
  static const NSDataWritingFileProtectionCompleteWhenUserInactive = 1342177280;
  static const NSDataWritingFileProtectionMask = 4026531840;
  static const NSAtomicWrite = 1;
}

/// NSDate
extension type NSDate.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject, NSCopying, NSSecureCoding {
  /// Constructs a [NSDate] that wraps the given raw object pointer.
  NSDate.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSDate].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSDate,
    );
  }

  /// alloc
  static NSDate alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSDate, _sel_alloc);
    return NSDate.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSDate allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSDate,
      _sel_allocWithZone_,
      zone,
    );
    return NSDate.castFromPointer($ret, retain: false, release: true);
  }

  /// date
  static NSDate date() {
    final $ret = _objc_msgSend_151sglz(_class_NSDate, _sel_date);
    return NSDate.castFromPointer($ret, retain: true, release: true);
  }

  /// dateWithTimeInterval:sinceDate:
  static NSDate dateWithTimeInterval(
    double secsToBeAdded, {
    required NSDate sinceDate,
  }) {
    final $ret = _objc_msgSend_1ozwf6k(
      _class_NSDate,
      _sel_dateWithTimeInterval_sinceDate_,
      secsToBeAdded,
      sinceDate.ref.pointer,
    );
    return NSDate.castFromPointer($ret, retain: true, release: true);
  }

  /// dateWithTimeIntervalSince1970:
  static NSDate dateWithTimeIntervalSince1970(double secs) {
    final $ret = _objc_msgSend_oa8mke(
      _class_NSDate,
      _sel_dateWithTimeIntervalSince1970_,
      secs,
    );
    return NSDate.castFromPointer($ret, retain: true, release: true);
  }

  /// dateWithTimeIntervalSinceNow:
  static NSDate dateWithTimeIntervalSinceNow(double secs) {
    final $ret = _objc_msgSend_oa8mke(
      _class_NSDate,
      _sel_dateWithTimeIntervalSinceNow_,
      secs,
    );
    return NSDate.castFromPointer($ret, retain: true, release: true);
  }

  /// dateWithTimeIntervalSinceReferenceDate:
  static NSDate dateWithTimeIntervalSinceReferenceDate(double ti) {
    final $ret = _objc_msgSend_oa8mke(
      _class_NSDate,
      _sel_dateWithTimeIntervalSinceReferenceDate_,
      ti,
    );
    return NSDate.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSDate new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSDate, _sel_new);
    return NSDate.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSDate, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSDate constructed with the default `new` method.
  NSDate() : this.castFrom(new$()._$);
}

extension NSDate$Methods on NSDate {
  /// dateByAddingTimeInterval:
  NSDate dateByAddingTimeInterval(double ti) {
    objc.checkOsVersionInternal(
      'NSDate.dateByAddingTimeInterval:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_oa8mke(
      _$.ref.pointer,
      _sel_dateByAddingTimeInterval_,
      ti,
    );
    return NSDate.castFromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  NSDate init() {
    objc.checkOsVersionInternal(
      'NSDate.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSDate.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSDate? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSDate.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithTimeInterval:sinceDate:
  NSDate initWithTimeInterval(
    double secsToBeAdded, {
    required NSDate sinceDate,
  }) {
    final $ret = _objc_msgSend_1ozwf6k(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithTimeInterval_sinceDate_,
      secsToBeAdded,
      sinceDate.ref.pointer,
    );
    return NSDate.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithTimeIntervalSince1970:
  NSDate initWithTimeIntervalSince1970(double secs) {
    final $ret = _objc_msgSend_oa8mke(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithTimeIntervalSince1970_,
      secs,
    );
    return NSDate.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithTimeIntervalSinceNow:
  NSDate initWithTimeIntervalSinceNow(double secs) {
    final $ret = _objc_msgSend_oa8mke(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithTimeIntervalSinceNow_,
      secs,
    );
    return NSDate.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithTimeIntervalSinceReferenceDate:
  NSDate initWithTimeIntervalSinceReferenceDate(double ti) {
    final $ret = _objc_msgSend_oa8mke(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithTimeIntervalSinceReferenceDate_,
      ti,
    );
    return NSDate.castFromPointer($ret, retain: false, release: true);
  }

  /// timeIntervalSinceReferenceDate
  double get timeIntervalSinceReferenceDate {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            _$.ref.pointer,
            _sel_timeIntervalSinceReferenceDate,
          )
        : _objc_msgSend_1ukqyt8(
            _$.ref.pointer,
            _sel_timeIntervalSinceReferenceDate,
          );
  }
}

enum NSDecodingFailurePolicy {
  NSDecodingFailurePolicyRaiseException(0),
  NSDecodingFailurePolicySetErrorAndReturn(1);

  final int value;
  const NSDecodingFailurePolicy(this.value);

  static NSDecodingFailurePolicy fromValue(int value) => switch (value) {
    0 => NSDecodingFailurePolicyRaiseException,
    1 => NSDecodingFailurePolicySetErrorAndReturn,
    _ => throw ArgumentError(
      'Unknown value for NSDecodingFailurePolicy: $value',
    ),
  };
}

/// NSDictionary
extension type NSDictionary.castFrom(objc.ObjCObjectBase _$)
    implements
        objc.ObjCObjectBase,
        NSObject,
        NSCopying,
        NSMutableCopying,
        NSSecureCoding,
        NSFastEnumeration {
  /// Constructs a [NSDictionary] that wraps the given raw object pointer.
  NSDictionary.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSDictionary].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSDictionary,
    );
  }

  /// alloc
  static NSDictionary alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSDictionary, _sel_alloc);
    return NSDictionary.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSDictionary allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSDictionary,
      _sel_allocWithZone_,
      zone,
    );
    return NSDictionary.castFromPointer($ret, retain: false, release: true);
  }

  /// dictionary
  static NSDictionary dictionary() {
    final $ret = _objc_msgSend_151sglz(_class_NSDictionary, _sel_dictionary);
    return NSDictionary.castFromPointer($ret, retain: true, release: true);
  }

  /// dictionaryWithDictionary:
  static NSDictionary dictionaryWithDictionary(NSDictionary dict) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSDictionary,
      _sel_dictionaryWithDictionary_,
      dict.ref.pointer,
    );
    return NSDictionary.castFromPointer($ret, retain: true, release: true);
  }

  /// dictionaryWithObject:forKey:
  static NSDictionary dictionaryWithObject(
    objc.ObjCObjectBase object, {
    required NSCopying forKey,
  }) {
    final $ret = _objc_msgSend_15qeuct(
      _class_NSDictionary,
      _sel_dictionaryWithObject_forKey_,
      object.ref.pointer,
      forKey.ref.pointer,
    );
    return NSDictionary.castFromPointer($ret, retain: true, release: true);
  }

  /// dictionaryWithObjects:forKeys:
  static NSDictionary dictionaryWithObjects(
    NSArray objects, {
    required NSArray forKeys,
  }) {
    final $ret = _objc_msgSend_15qeuct(
      _class_NSDictionary,
      _sel_dictionaryWithObjects_forKeys_,
      objects.ref.pointer,
      forKeys.ref.pointer,
    );
    return NSDictionary.castFromPointer($ret, retain: true, release: true);
  }

  /// dictionaryWithObjects:forKeys:count:
  static NSDictionary dictionaryWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> forKeys,
    required int count,
  }) {
    final $ret = _objc_msgSend_1dydpdi(
      _class_NSDictionary,
      _sel_dictionaryWithObjects_forKeys_count_,
      objects,
      forKeys,
      count,
    );
    return NSDictionary.castFromPointer($ret, retain: true, release: true);
  }

  /// dictionaryWithObjectsAndKeys:
  static NSDictionary dictionaryWithObjectsAndKeys(
    objc.ObjCObjectBase firstObject,
  ) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSDictionary,
      _sel_dictionaryWithObjectsAndKeys_,
      firstObject.ref.pointer,
    );
    return NSDictionary.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSDictionary new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSDictionary, _sel_new);
    return NSDictionary.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSDictionary, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSDictionary constructed with the default `new` method.
  NSDictionary() : this.castFrom(new$()._$);
}

extension NSDictionary$Methods on NSDictionary {
  /// count
  int get count {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_count);
  }

  /// countByEnumeratingWithState:objects:count:
  int countByEnumeratingWithState(
    ffi.Pointer<NSFastEnumerationState> state, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects,
    required int count,
  }) {
    return _objc_msgSend_1b5ysjl(
      _$.ref.pointer,
      _sel_countByEnumeratingWithState_objects_count_,
      state,
      objects,
      count,
    );
  }

  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  NSDictionary init() {
    objc.checkOsVersionInternal(
      'NSDictionary.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSDictionary.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSDictionary? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSDictionary.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithDictionary:
  NSDictionary initWithDictionary(NSDictionary otherDictionary) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithDictionary_,
      otherDictionary.ref.pointer,
    );
    return NSDictionary.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithDictionary:copyItems:
  NSDictionary initWithDictionary$1(
    NSDictionary otherDictionary, {
    required bool copyItems,
  }) {
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithDictionary_copyItems_,
      otherDictionary.ref.pointer,
      copyItems,
    );
    return NSDictionary.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObjects:forKeys:
  NSDictionary initWithObjects(NSArray objects, {required NSArray forKeys}) {
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_forKeys_,
      objects.ref.pointer,
      forKeys.ref.pointer,
    );
    return NSDictionary.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObjects:forKeys:count:
  NSDictionary initWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> forKeys,
    required int count,
  }) {
    final $ret = _objc_msgSend_1dydpdi(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_forKeys_count_,
      objects,
      forKeys,
      count,
    );
    return NSDictionary.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObjectsAndKeys:
  NSDictionary initWithObjectsAndKeys(objc.ObjCObjectBase firstObject) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjectsAndKeys_,
      firstObject.ref.pointer,
    );
    return NSDictionary.castFromPointer($ret, retain: false, release: true);
  }

  /// keyEnumerator
  NSEnumerator keyEnumerator() {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_keyEnumerator);
    return NSEnumerator.castFromPointer($ret, retain: true, release: true);
  }

  /// objectForKey:
  objc.ObjCObjectBase? objectForKey(objc.ObjCObjectBase aKey) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_objectForKey_,
      aKey.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }
}

final class NSEdgeInsets extends ffi.Struct {
  @ffi.Double()
  external double top;

  @ffi.Double()
  external double left;

  @ffi.Double()
  external double bottom;

  @ffi.Double()
  external double right;
}

sealed class NSEnumerationOptions {
  static const NSEnumerationConcurrent = 1;
  static const NSEnumerationReverse = 2;
}

/// NSEnumerator
extension type NSEnumerator.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject, NSFastEnumeration {
  /// Constructs a [NSEnumerator] that wraps the given raw object pointer.
  NSEnumerator.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSEnumerator].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSEnumerator,
    );
  }

  /// alloc
  static NSEnumerator alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSEnumerator, _sel_alloc);
    return NSEnumerator.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSEnumerator allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSEnumerator,
      _sel_allocWithZone_,
      zone,
    );
    return NSEnumerator.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSEnumerator new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSEnumerator, _sel_new);
    return NSEnumerator.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSEnumerator constructed with the default `new` method.
  NSEnumerator() : this.castFrom(new$()._$);
}

extension NSEnumerator$Methods on NSEnumerator {
  /// countByEnumeratingWithState:objects:count:
  int countByEnumeratingWithState(
    ffi.Pointer<NSFastEnumerationState> state, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects,
    required int count,
  }) {
    return _objc_msgSend_1b5ysjl(
      _$.ref.pointer,
      _sel_countByEnumeratingWithState_objects_count_,
      state,
      objects,
      count,
    );
  }

  /// init
  NSEnumerator init() {
    objc.checkOsVersionInternal(
      'NSEnumerator.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSEnumerator.castFromPointer($ret, retain: false, release: true);
  }

  /// nextObject
  objc.ObjCObjectBase? nextObject() {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_nextObject);
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }
}

/// NSError
extension type NSError.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject, NSCopying, NSSecureCoding {
  /// Constructs a [NSError] that wraps the given raw object pointer.
  NSError.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSError].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSError,
    );
  }

  /// alloc
  static NSError alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSError, _sel_alloc);
    return NSError.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSError allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSError,
      _sel_allocWithZone_,
      zone,
    );
    return NSError.castFromPointer($ret, retain: false, release: true);
  }

  /// errorWithDomain:code:userInfo:
  static NSError errorWithDomain(
    NSString domain, {
    required int code,
    NSDictionary? userInfo,
  }) {
    final $ret = _objc_msgSend_rc4ypv(
      _class_NSError,
      _sel_errorWithDomain_code_userInfo_,
      domain.ref.pointer,
      code,
      userInfo?.ref.pointer ?? ffi.nullptr,
    );
    return NSError.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSError new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSError, _sel_new);
    return NSError.castFromPointer($ret, retain: false, release: true);
  }

  /// setUserInfoValueProviderForDomain:provider:
  static void setUserInfoValueProviderForDomain(
    NSString errorDomain, {
    objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(NSError, NSString)>?
    provider,
  }) {
    objc.checkOsVersionInternal(
      'NSError.setUserInfoValueProviderForDomain:provider:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_o762yo(
      _class_NSError,
      _sel_setUserInfoValueProviderForDomain_provider_,
      errorDomain.ref.pointer,
      provider?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSError, _sel_supportsSecureCoding);
  }

  /// userInfoValueProviderForDomain:
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject>? Function(NSError, NSString)
  >?
  userInfoValueProviderForDomain_(
    NSError err, {
    required NSString userInfoKey,
    required NSString errorDomain,
  }) {
    objc.checkOsVersionInternal(
      'NSError.userInfoValueProviderForDomain:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_cnxxyq(
      _class_NSError,
      _sel_userInfoValueProviderForDomain_,
      err.ref.pointer,
      userInfoKey.ref.pointer,
      errorDomain.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : ObjCBlock_objcObjCObject_NSError_NSErrorUserInfoKey.castFromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// Returns a new instance of NSError constructed with the default `new` method.
  NSError() : this.castFrom(new$()._$);
}

extension NSError$Methods on NSError {
  /// code
  int get code {
    return _objc_msgSend_1hz7y9r(_$.ref.pointer, _sel_code);
  }

  /// domain
  NSString get domain {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_domain);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// helpAnchor
  NSString? get helpAnchor {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_helpAnchor);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  NSError init() {
    objc.checkOsVersionInternal(
      'NSError.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSError.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSError? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSError.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithDomain:code:userInfo:
  NSError initWithDomain(
    NSString domain, {
    required int code,
    NSDictionary? userInfo,
  }) {
    final $ret = _objc_msgSend_rc4ypv(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithDomain_code_userInfo_,
      domain.ref.pointer,
      code,
      userInfo?.ref.pointer ?? ffi.nullptr,
    );
    return NSError.castFromPointer($ret, retain: false, release: true);
  }

  /// localizedDescription
  NSString get localizedDescription {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_localizedDescription,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// localizedFailureReason
  NSString? get localizedFailureReason {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_localizedFailureReason,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// localizedRecoveryOptions
  NSArray? get localizedRecoveryOptions {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_localizedRecoveryOptions,
    );
    return $ret.address == 0
        ? null
        : NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// localizedRecoverySuggestion
  NSString? get localizedRecoverySuggestion {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_localizedRecoverySuggestion,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// recoveryAttempter
  objc.ObjCObjectBase? get recoveryAttempter {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_recoveryAttempter);
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// iOS: introduced 14.5.0
  /// macOS: introduced 11.3.0
  NSArray get underlyingErrors {
    objc.checkOsVersionInternal(
      'NSError.underlyingErrors',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_underlyingErrors);
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// userInfo
  NSDictionary get userInfo {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_userInfo);
    return NSDictionary.castFromPointer($ret, retain: true, release: true);
  }
}

/// NSExtendedArray
extension NSExtendedArray on NSArray {
  /// arrayByAddingObject:
  NSArray arrayByAddingObject(objc.ObjCObjectBase anObject) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_arrayByAddingObject_,
      anObject.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// arrayByAddingObjectsFromArray:
  NSArray arrayByAddingObjectsFromArray(NSArray otherArray) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_arrayByAddingObjectsFromArray_,
      otherArray.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// componentsJoinedByString:
  NSString componentsJoinedByString(NSString separator) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_componentsJoinedByString_,
      separator.ref.pointer,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// containsObject:
  bool containsObject(objc.ObjCObjectBase anObject) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_containsObject_,
      anObject.ref.pointer,
    );
  }

  /// description
  NSString get description$1 {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_description);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// descriptionWithLocale:
  NSString descriptionWithLocale(objc.ObjCObjectBase? locale) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_descriptionWithLocale_,
      locale?.ref.pointer ?? ffi.nullptr,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// descriptionWithLocale:indent:
  NSString descriptionWithLocale$1(
    objc.ObjCObjectBase? locale, {
    required int indent,
  }) {
    final $ret = _objc_msgSend_1k4kd9s(
      _$.ref.pointer,
      _sel_descriptionWithLocale_indent_,
      locale?.ref.pointer ?? ffi.nullptr,
      indent,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// enumerateObjectsAtIndexes:options:usingBlock:
  void enumerateObjectsAtIndexes(
    NSIndexSet s, {
    required int options,
    required objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    usingBlock,
  }) {
    objc.checkOsVersionInternal(
      'NSArray.enumerateObjectsAtIndexes:options:usingBlock:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_a3wp08(
      _$.ref.pointer,
      _sel_enumerateObjectsAtIndexes_options_usingBlock_,
      s.ref.pointer,
      options,
      usingBlock.ref.pointer,
    );
  }

  /// enumerateObjectsUsingBlock:
  void enumerateObjectsUsingBlock(
    objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    block,
  ) {
    objc.checkOsVersionInternal(
      'NSArray.enumerateObjectsUsingBlock:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_f167m6(
      _$.ref.pointer,
      _sel_enumerateObjectsUsingBlock_,
      block.ref.pointer,
    );
  }

  /// enumerateObjectsWithOptions:usingBlock:
  void enumerateObjectsWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    usingBlock,
  }) {
    objc.checkOsVersionInternal(
      'NSArray.enumerateObjectsWithOptions:usingBlock:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_yx8yc6(
      _$.ref.pointer,
      _sel_enumerateObjectsWithOptions_usingBlock_,
      opts,
      usingBlock.ref.pointer,
    );
  }

  /// firstObject
  objc.ObjCObjectBase? get firstObject {
    objc.checkOsVersionInternal(
      'NSArray.firstObject',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_firstObject);
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// firstObjectCommonWithArray:
  objc.ObjCObjectBase? firstObjectCommonWithArray(NSArray otherArray) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_firstObjectCommonWithArray_,
      otherArray.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// getObjects:range:
  void getObjects(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required NSRange range,
  }) {
    _objc_msgSend_o16d3k(
      _$.ref.pointer,
      _sel_getObjects_range_,
      objects,
      range,
    );
  }

  /// indexOfObject:
  int indexOfObject(objc.ObjCObjectBase anObject) {
    return _objc_msgSend_1vd1c5m(
      _$.ref.pointer,
      _sel_indexOfObject_,
      anObject.ref.pointer,
    );
  }

  /// indexOfObject:inRange:
  int indexOfObject$1(
    objc.ObjCObjectBase anObject, {
    required NSRange inRange,
  }) {
    return _objc_msgSend_zug4wi(
      _$.ref.pointer,
      _sel_indexOfObject_inRange_,
      anObject.ref.pointer,
      inRange,
    );
  }

  /// indexOfObject:inSortedRange:options:usingComparator:
  int indexOfObject$2(
    objc.ObjCObjectBase obj, {
    required NSRange inSortedRange,
    required int options,
    required objc.ObjCBlock<
      ffi.Long Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >
    usingComparator,
  }) {
    objc.checkOsVersionInternal(
      'NSArray.indexOfObject:inSortedRange:options:usingComparator:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_kshx9d(
      _$.ref.pointer,
      _sel_indexOfObject_inSortedRange_options_usingComparator_,
      obj.ref.pointer,
      inSortedRange,
      options,
      usingComparator.ref.pointer,
    );
  }

  /// indexOfObjectAtIndexes:options:passingTest:
  int indexOfObjectAtIndexes(
    NSIndexSet s, {
    required int options,
    required objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    passingTest,
  }) {
    objc.checkOsVersionInternal(
      'NSArray.indexOfObjectAtIndexes:options:passingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_k1x6mt(
      _$.ref.pointer,
      _sel_indexOfObjectAtIndexes_options_passingTest_,
      s.ref.pointer,
      options,
      passingTest.ref.pointer,
    );
  }

  /// indexOfObjectIdenticalTo:
  int indexOfObjectIdenticalTo(objc.ObjCObjectBase anObject) {
    return _objc_msgSend_1vd1c5m(
      _$.ref.pointer,
      _sel_indexOfObjectIdenticalTo_,
      anObject.ref.pointer,
    );
  }

  /// indexOfObjectIdenticalTo:inRange:
  int indexOfObjectIdenticalTo$1(
    objc.ObjCObjectBase anObject, {
    required NSRange inRange,
  }) {
    return _objc_msgSend_zug4wi(
      _$.ref.pointer,
      _sel_indexOfObjectIdenticalTo_inRange_,
      anObject.ref.pointer,
      inRange,
    );
  }

  /// indexOfObjectPassingTest:
  int indexOfObjectPassingTest(
    objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    predicate,
  ) {
    objc.checkOsVersionInternal(
      'NSArray.indexOfObjectPassingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_10mlopr(
      _$.ref.pointer,
      _sel_indexOfObjectPassingTest_,
      predicate.ref.pointer,
    );
  }

  /// indexOfObjectWithOptions:passingTest:
  int indexOfObjectWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    passingTest,
  }) {
    objc.checkOsVersionInternal(
      'NSArray.indexOfObjectWithOptions:passingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_1698hqz(
      _$.ref.pointer,
      _sel_indexOfObjectWithOptions_passingTest_,
      opts,
      passingTest.ref.pointer,
    );
  }

  /// indexesOfObjectsAtIndexes:options:passingTest:
  NSIndexSet indexesOfObjectsAtIndexes(
    NSIndexSet s, {
    required int options,
    required objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    passingTest,
  }) {
    objc.checkOsVersionInternal(
      'NSArray.indexesOfObjectsAtIndexes:options:passingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1i9v144(
      _$.ref.pointer,
      _sel_indexesOfObjectsAtIndexes_options_passingTest_,
      s.ref.pointer,
      options,
      passingTest.ref.pointer,
    );
    return NSIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// indexesOfObjectsPassingTest:
  NSIndexSet indexesOfObjectsPassingTest(
    objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    predicate,
  ) {
    objc.checkOsVersionInternal(
      'NSArray.indexesOfObjectsPassingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_nnxkei(
      _$.ref.pointer,
      _sel_indexesOfObjectsPassingTest_,
      predicate.ref.pointer,
    );
    return NSIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// indexesOfObjectsWithOptions:passingTest:
  NSIndexSet indexesOfObjectsWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    passingTest,
  }) {
    objc.checkOsVersionInternal(
      'NSArray.indexesOfObjectsWithOptions:passingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_13x5boi(
      _$.ref.pointer,
      _sel_indexesOfObjectsWithOptions_passingTest_,
      opts,
      passingTest.ref.pointer,
    );
    return NSIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// isEqualToArray:
  bool isEqualToArray(NSArray otherArray) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isEqualToArray_,
      otherArray.ref.pointer,
    );
  }

  /// lastObject
  objc.ObjCObjectBase? get lastObject {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_lastObject);
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// makeObjectsPerformSelector:
  void makeObjectsPerformSelector(ffi.Pointer<objc.ObjCSelector> aSelector) {
    _objc_msgSend_1d9e4oe(
      _$.ref.pointer,
      _sel_makeObjectsPerformSelector_,
      aSelector,
    );
  }

  /// makeObjectsPerformSelector:withObject:
  void makeObjectsPerformSelector$1(
    ffi.Pointer<objc.ObjCSelector> aSelector, {
    objc.ObjCObjectBase? withObject,
  }) {
    _objc_msgSend_1qv0eq4(
      _$.ref.pointer,
      _sel_makeObjectsPerformSelector_withObject_,
      aSelector,
      withObject?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// objectAtIndexedSubscript:
  objc.ObjCObjectBase objectAtIndexedSubscript(int idx) {
    objc.checkOsVersionInternal(
      'NSArray.objectAtIndexedSubscript:',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.pointer,
      _sel_objectAtIndexedSubscript_,
      idx,
    );
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// objectEnumerator
  NSEnumerator objectEnumerator() {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_objectEnumerator);
    return NSEnumerator.castFromPointer($ret, retain: true, release: true);
  }

  /// objectsAtIndexes:
  NSArray objectsAtIndexes(NSIndexSet indexes) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_objectsAtIndexes_,
      indexes.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// reverseObjectEnumerator
  NSEnumerator reverseObjectEnumerator() {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_reverseObjectEnumerator,
    );
    return NSEnumerator.castFromPointer($ret, retain: true, release: true);
  }

  /// sortedArrayHint
  NSData get sortedArrayHint {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_sortedArrayHint);
    return NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// sortedArrayUsingComparator:
  NSArray sortedArrayUsingComparator(
    objc.ObjCBlock<
      ffi.Long Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >
    cmptr,
  ) {
    objc.checkOsVersionInternal(
      'NSArray.sortedArrayUsingComparator:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_nnxkei(
      _$.ref.pointer,
      _sel_sortedArrayUsingComparator_,
      cmptr.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// sortedArrayUsingFunction:context:
  NSArray sortedArrayUsingFunction(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >
    comparator, {
    required ffi.Pointer<ffi.Void> context,
  }) {
    final $ret = _objc_msgSend_1ffoev1(
      _$.ref.pointer,
      _sel_sortedArrayUsingFunction_context_,
      comparator,
      context,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// sortedArrayUsingFunction:context:hint:
  NSArray sortedArrayUsingFunction$1(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >
    comparator, {
    required ffi.Pointer<ffi.Void> context,
    NSData? hint,
  }) {
    final $ret = _objc_msgSend_1i2r70j(
      _$.ref.pointer,
      _sel_sortedArrayUsingFunction_context_hint_,
      comparator,
      context,
      hint?.ref.pointer ?? ffi.nullptr,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// sortedArrayUsingSelector:
  NSArray sortedArrayUsingSelector(ffi.Pointer<objc.ObjCSelector> comparator) {
    final $ret = _objc_msgSend_3ctkt6(
      _$.ref.pointer,
      _sel_sortedArrayUsingSelector_,
      comparator,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// sortedArrayWithOptions:usingComparator:
  NSArray sortedArrayWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Long Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >
    usingComparator,
  }) {
    objc.checkOsVersionInternal(
      'NSArray.sortedArrayWithOptions:usingComparator:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1x5ew3h(
      _$.ref.pointer,
      _sel_sortedArrayWithOptions_usingComparator_,
      opts,
      usingComparator.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// subarrayWithRange:
  NSArray subarrayWithRange(NSRange range) {
    final $ret = _objc_msgSend_1k1o1s7(
      _$.ref.pointer,
      _sel_subarrayWithRange_,
      range,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// writeToURL:error:
  bool writeToURL(
    NSURL url, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSArray.writeToURL:error:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    return _objc_msgSend_l9p60w(
      _$.ref.pointer,
      _sel_writeToURL_error_,
      url.ref.pointer,
      error,
    );
  }
}

/// NSExtendedData
extension NSExtendedData on NSData {
  /// description
  NSString get description$1 {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_description);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// enumerateByteRangesUsingBlock:
  void enumerateByteRangesUsingBlock(
    objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>)
    >
    block,
  ) {
    objc.checkOsVersionInternal(
      'NSData.enumerateByteRangesUsingBlock:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_f167m6(
      _$.ref.pointer,
      _sel_enumerateByteRangesUsingBlock_,
      block.ref.pointer,
    );
  }

  /// getBytes:length:
  void getBytes(ffi.Pointer<ffi.Void> buffer, {required int length}) {
    _objc_msgSend_zuf90e(_$.ref.pointer, _sel_getBytes_length_, buffer, length);
  }

  /// getBytes:range:
  void getBytes$1(ffi.Pointer<ffi.Void> buffer, {required NSRange range}) {
    _objc_msgSend_xpqfd7(_$.ref.pointer, _sel_getBytes_range_, buffer, range);
  }

  /// isEqualToData:
  bool isEqualToData(NSData other) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isEqualToData_,
      other.ref.pointer,
    );
  }

  /// rangeOfData:options:range:
  NSRange rangeOfData(
    NSData dataToFind, {
    required int options,
    required NSRange range,
  }) {
    objc.checkOsVersionInternal(
      'NSData.rangeOfData:options:range:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1d8s65wStret(
            $ptr,
            _$.ref.pointer,
            _sel_rangeOfData_options_range_,
            dataToFind.ref.pointer,
            options,
            range,
          )
        : $ptr.ref = _objc_msgSend_1d8s65w(
            _$.ref.pointer,
            _sel_rangeOfData_options_range_,
            dataToFind.ref.pointer,
            options,
            range,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSRange>($finalizable);
  }

  /// subdataWithRange:
  NSData subdataWithRange(NSRange range) {
    final $ret = _objc_msgSend_1k1o1s7(
      _$.ref.pointer,
      _sel_subdataWithRange_,
      range,
    );
    return NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// writeToFile:atomically:
  bool writeToFile(NSString path, {required bool atomically}) {
    return _objc_msgSend_1iyq28l(
      _$.ref.pointer,
      _sel_writeToFile_atomically_,
      path.ref.pointer,
      atomically,
    );
  }

  /// writeToFile:options:error:
  bool writeToFile$1(
    NSString path, {
    required int options,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    return _objc_msgSend_1xi08ar(
      _$.ref.pointer,
      _sel_writeToFile_options_error_,
      path.ref.pointer,
      options,
      error,
    );
  }

  /// writeToURL:atomically:
  bool writeToURL(NSURL url, {required bool atomically}) {
    return _objc_msgSend_1iyq28l(
      _$.ref.pointer,
      _sel_writeToURL_atomically_,
      url.ref.pointer,
      atomically,
    );
  }

  /// writeToURL:options:error:
  bool writeToURL$1(
    NSURL url, {
    required int options,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    return _objc_msgSend_1xi08ar(
      _$.ref.pointer,
      _sel_writeToURL_options_error_,
      url.ref.pointer,
      options,
      error,
    );
  }
}

/// NSExtendedDate
extension NSExtendedDate on NSDate {
  /// compare:
  NSComparisonResult compare(NSDate other) {
    final $ret = _objc_msgSend_1ym6zyw(
      _$.ref.pointer,
      _sel_compare_,
      other.ref.pointer,
    );
    return NSComparisonResult.fromValue($ret);
  }

  /// description
  NSString get description$1 {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_description);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// descriptionWithLocale:
  NSString descriptionWithLocale(objc.ObjCObjectBase? locale) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_descriptionWithLocale_,
      locale?.ref.pointer ?? ffi.nullptr,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// earlierDate:
  NSDate earlierDate(NSDate anotherDate) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_earlierDate_,
      anotherDate.ref.pointer,
    );
    return NSDate.castFromPointer($ret, retain: true, release: true);
  }

  /// isEqualToDate:
  bool isEqualToDate(NSDate otherDate) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isEqualToDate_,
      otherDate.ref.pointer,
    );
  }

  /// laterDate:
  NSDate laterDate(NSDate anotherDate) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_laterDate_,
      anotherDate.ref.pointer,
    );
    return NSDate.castFromPointer($ret, retain: true, release: true);
  }

  /// timeIntervalSince1970
  double get timeIntervalSince1970 {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_$.ref.pointer, _sel_timeIntervalSince1970)
        : _objc_msgSend_1ukqyt8(_$.ref.pointer, _sel_timeIntervalSince1970);
  }

  /// timeIntervalSinceDate:
  double timeIntervalSinceDate(NSDate anotherDate) {
    return objc.useMsgSendVariants
        ? _objc_msgSend_mabicuFpret(
            _$.ref.pointer,
            _sel_timeIntervalSinceDate_,
            anotherDate.ref.pointer,
          )
        : _objc_msgSend_mabicu(
            _$.ref.pointer,
            _sel_timeIntervalSinceDate_,
            anotherDate.ref.pointer,
          );
  }

  /// timeIntervalSinceNow
  double get timeIntervalSinceNow {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_$.ref.pointer, _sel_timeIntervalSinceNow)
        : _objc_msgSend_1ukqyt8(_$.ref.pointer, _sel_timeIntervalSinceNow);
  }

  /// timeIntervalSinceReferenceDate
  static double getTimeIntervalSinceReferenceDate$1() {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            _class_NSDate,
            _sel_timeIntervalSinceReferenceDate,
          )
        : _objc_msgSend_1ukqyt8(
            _class_NSDate,
            _sel_timeIntervalSinceReferenceDate,
          );
  }
}

/// NSExtendedDictionary
extension NSExtendedDictionary on NSDictionary {
  /// allKeys
  NSArray get allKeys {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_allKeys);
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// allKeysForObject:
  NSArray allKeysForObject(objc.ObjCObjectBase anObject) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_allKeysForObject_,
      anObject.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// allValues
  NSArray get allValues {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_allValues);
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// description
  NSString get description$1 {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_description);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// descriptionInStringsFileFormat
  NSString get descriptionInStringsFileFormat {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_descriptionInStringsFileFormat,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// descriptionWithLocale:
  NSString descriptionWithLocale(objc.ObjCObjectBase? locale) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_descriptionWithLocale_,
      locale?.ref.pointer ?? ffi.nullptr,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// descriptionWithLocale:indent:
  NSString descriptionWithLocale$1(
    objc.ObjCObjectBase? locale, {
    required int indent,
  }) {
    final $ret = _objc_msgSend_1k4kd9s(
      _$.ref.pointer,
      _sel_descriptionWithLocale_indent_,
      locale?.ref.pointer ?? ffi.nullptr,
      indent,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// enumerateKeysAndObjectsUsingBlock:
  void enumerateKeysAndObjectsUsingBlock(
    objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Bool>,
      )
    >
    block,
  ) {
    objc.checkOsVersionInternal(
      'NSDictionary.enumerateKeysAndObjectsUsingBlock:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_f167m6(
      _$.ref.pointer,
      _sel_enumerateKeysAndObjectsUsingBlock_,
      block.ref.pointer,
    );
  }

  /// enumerateKeysAndObjectsWithOptions:usingBlock:
  void enumerateKeysAndObjectsWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Bool>,
      )
    >
    usingBlock,
  }) {
    objc.checkOsVersionInternal(
      'NSDictionary.enumerateKeysAndObjectsWithOptions:usingBlock:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_yx8yc6(
      _$.ref.pointer,
      _sel_enumerateKeysAndObjectsWithOptions_usingBlock_,
      opts,
      usingBlock.ref.pointer,
    );
  }

  /// getObjects:andKeys:count:
  void getObjects(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> andKeys,
    required int count,
  }) {
    objc.checkOsVersionInternal(
      'NSDictionary.getObjects:andKeys:count:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_n2svg2(
      _$.ref.pointer,
      _sel_getObjects_andKeys_count_,
      objects,
      andKeys,
      count,
    );
  }

  /// isEqualToDictionary:
  bool isEqualToDictionary(NSDictionary otherDictionary) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isEqualToDictionary_,
      otherDictionary.ref.pointer,
    );
  }

  /// keysOfEntriesPassingTest:
  NSSet keysOfEntriesPassingTest(
    objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Bool>,
      )
    >
    predicate,
  ) {
    objc.checkOsVersionInternal(
      'NSDictionary.keysOfEntriesPassingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_nnxkei(
      _$.ref.pointer,
      _sel_keysOfEntriesPassingTest_,
      predicate.ref.pointer,
    );
    return NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// keysOfEntriesWithOptions:passingTest:
  NSSet keysOfEntriesWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Bool>,
      )
    >
    passingTest,
  }) {
    objc.checkOsVersionInternal(
      'NSDictionary.keysOfEntriesWithOptions:passingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_13x5boi(
      _$.ref.pointer,
      _sel_keysOfEntriesWithOptions_passingTest_,
      opts,
      passingTest.ref.pointer,
    );
    return NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// keysSortedByValueUsingComparator:
  NSArray keysSortedByValueUsingComparator(
    objc.ObjCBlock<
      ffi.Long Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >
    cmptr,
  ) {
    objc.checkOsVersionInternal(
      'NSDictionary.keysSortedByValueUsingComparator:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_nnxkei(
      _$.ref.pointer,
      _sel_keysSortedByValueUsingComparator_,
      cmptr.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// keysSortedByValueUsingSelector:
  NSArray keysSortedByValueUsingSelector(
    ffi.Pointer<objc.ObjCSelector> comparator,
  ) {
    final $ret = _objc_msgSend_3ctkt6(
      _$.ref.pointer,
      _sel_keysSortedByValueUsingSelector_,
      comparator,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// keysSortedByValueWithOptions:usingComparator:
  NSArray keysSortedByValueWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Long Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >
    usingComparator,
  }) {
    objc.checkOsVersionInternal(
      'NSDictionary.keysSortedByValueWithOptions:usingComparator:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1x5ew3h(
      _$.ref.pointer,
      _sel_keysSortedByValueWithOptions_usingComparator_,
      opts,
      usingComparator.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// objectEnumerator
  NSEnumerator objectEnumerator() {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_objectEnumerator);
    return NSEnumerator.castFromPointer($ret, retain: true, release: true);
  }

  /// objectForKeyedSubscript:
  objc.ObjCObjectBase? objectForKeyedSubscript(objc.ObjCObjectBase key) {
    objc.checkOsVersionInternal(
      'NSDictionary.objectForKeyedSubscript:',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_objectForKeyedSubscript_,
      key.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// objectsForKeys:notFoundMarker:
  NSArray objectsForKeys(
    NSArray keys, {
    required objc.ObjCObjectBase notFoundMarker,
  }) {
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.pointer,
      _sel_objectsForKeys_notFoundMarker_,
      keys.ref.pointer,
      notFoundMarker.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// writeToURL:error:
  bool writeToURL(
    NSURL url, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSDictionary.writeToURL:error:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    return _objc_msgSend_l9p60w(
      _$.ref.pointer,
      _sel_writeToURL_error_,
      url.ref.pointer,
      error,
    );
  }
}

/// NSExtendedEnumerator
extension NSExtendedEnumerator on NSEnumerator {
  /// allObjects
  NSArray get allObjects {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_allObjects);
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }
}

/// NSExtendedMutableArray
extension NSExtendedMutableArray on NSMutableArray {
  /// addObjectsFromArray:
  void addObjectsFromArray(NSArray otherArray) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_addObjectsFromArray_,
      otherArray.ref.pointer,
    );
  }

  /// exchangeObjectAtIndex:withObjectAtIndex:
  void exchangeObjectAtIndex(int idx1, {required int withObjectAtIndex}) {
    _objc_msgSend_bfp043(
      _$.ref.pointer,
      _sel_exchangeObjectAtIndex_withObjectAtIndex_,
      idx1,
      withObjectAtIndex,
    );
  }

  /// insertObjects:atIndexes:
  void insertObjects(NSArray objects, {required NSIndexSet atIndexes}) {
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_insertObjects_atIndexes_,
      objects.ref.pointer,
      atIndexes.ref.pointer,
    );
  }

  /// removeAllObjects
  void removeAllObjects() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_removeAllObjects);
  }

  /// removeObject:
  void removeObject(objc.ObjCObjectBase anObject) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_removeObject_,
      anObject.ref.pointer,
    );
  }

  /// removeObject:inRange:
  void removeObject$1(
    objc.ObjCObjectBase anObject, {
    required NSRange inRange,
  }) {
    _objc_msgSend_1oteutl(
      _$.ref.pointer,
      _sel_removeObject_inRange_,
      anObject.ref.pointer,
      inRange,
    );
  }

  /// removeObjectIdenticalTo:
  void removeObjectIdenticalTo(objc.ObjCObjectBase anObject) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_removeObjectIdenticalTo_,
      anObject.ref.pointer,
    );
  }

  /// removeObjectIdenticalTo:inRange:
  void removeObjectIdenticalTo$1(
    objc.ObjCObjectBase anObject, {
    required NSRange inRange,
  }) {
    _objc_msgSend_1oteutl(
      _$.ref.pointer,
      _sel_removeObjectIdenticalTo_inRange_,
      anObject.ref.pointer,
      inRange,
    );
  }

  /// removeObjectsAtIndexes:
  void removeObjectsAtIndexes(NSIndexSet indexes) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_removeObjectsAtIndexes_,
      indexes.ref.pointer,
    );
  }

  /// removeObjectsInArray:
  void removeObjectsInArray(NSArray otherArray) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_removeObjectsInArray_,
      otherArray.ref.pointer,
    );
  }

  /// removeObjectsInRange:
  void removeObjectsInRange(NSRange range) {
    _objc_msgSend_1e3pm0z(_$.ref.pointer, _sel_removeObjectsInRange_, range);
  }

  /// replaceObjectsAtIndexes:withObjects:
  void replaceObjectsAtIndexes(
    NSIndexSet indexes, {
    required NSArray withObjects,
  }) {
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_replaceObjectsAtIndexes_withObjects_,
      indexes.ref.pointer,
      withObjects.ref.pointer,
    );
  }

  /// replaceObjectsInRange:withObjectsFromArray:
  void replaceObjectsInRange(
    NSRange range, {
    required NSArray withObjectsFromArray,
  }) {
    _objc_msgSend_1tv4uax(
      _$.ref.pointer,
      _sel_replaceObjectsInRange_withObjectsFromArray_,
      range,
      withObjectsFromArray.ref.pointer,
    );
  }

  /// replaceObjectsInRange:withObjectsFromArray:range:
  void replaceObjectsInRange$1(
    NSRange range, {
    required NSArray withObjectsFromArray,
    required NSRange range$1,
  }) {
    _objc_msgSend_15bolr3(
      _$.ref.pointer,
      _sel_replaceObjectsInRange_withObjectsFromArray_range_,
      range,
      withObjectsFromArray.ref.pointer,
      range$1,
    );
  }

  /// setArray:
  void setArray(NSArray otherArray) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setArray_,
      otherArray.ref.pointer,
    );
  }

  /// setObject:atIndexedSubscript:
  void setObject(objc.ObjCObjectBase obj, {required int atIndexedSubscript}) {
    objc.checkOsVersionInternal(
      'NSMutableArray.setObject:atIndexedSubscript:',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
    _objc_msgSend_djsa9o(
      _$.ref.pointer,
      _sel_setObject_atIndexedSubscript_,
      obj.ref.pointer,
      atIndexedSubscript,
    );
  }

  /// sortUsingComparator:
  void sortUsingComparator(
    objc.ObjCBlock<
      ffi.Long Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >
    cmptr,
  ) {
    objc.checkOsVersionInternal(
      'NSMutableArray.sortUsingComparator:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_f167m6(
      _$.ref.pointer,
      _sel_sortUsingComparator_,
      cmptr.ref.pointer,
    );
  }

  /// sortUsingFunction:context:
  void sortUsingFunction(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >
    compare, {
    required ffi.Pointer<ffi.Void> context,
  }) {
    _objc_msgSend_1bvics1(
      _$.ref.pointer,
      _sel_sortUsingFunction_context_,
      compare,
      context,
    );
  }

  /// sortUsingSelector:
  void sortUsingSelector(ffi.Pointer<objc.ObjCSelector> comparator) {
    _objc_msgSend_1d9e4oe(_$.ref.pointer, _sel_sortUsingSelector_, comparator);
  }

  /// sortWithOptions:usingComparator:
  void sortWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Long Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >
    usingComparator,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableArray.sortWithOptions:usingComparator:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_jjgvjt(
      _$.ref.pointer,
      _sel_sortWithOptions_usingComparator_,
      opts,
      usingComparator.ref.pointer,
    );
  }
}

/// NSExtendedMutableData
extension NSExtendedMutableData on NSMutableData {
  /// appendBytes:length:
  void appendBytes(ffi.Pointer<ffi.Void> bytes, {required int length}) {
    _objc_msgSend_zuf90e(
      _$.ref.pointer,
      _sel_appendBytes_length_,
      bytes,
      length,
    );
  }

  /// appendData:
  void appendData(NSData other) {
    _objc_msgSend_xtuoz7(_$.ref.pointer, _sel_appendData_, other.ref.pointer);
  }

  /// increaseLengthBy:
  void increaseLengthBy(int extraLength) {
    _objc_msgSend_1i9r4xy(_$.ref.pointer, _sel_increaseLengthBy_, extraLength);
  }

  /// replaceBytesInRange:withBytes:
  void replaceBytesInRange(
    NSRange range, {
    required ffi.Pointer<ffi.Void> withBytes,
  }) {
    _objc_msgSend_eh32gn(
      _$.ref.pointer,
      _sel_replaceBytesInRange_withBytes_,
      range,
      withBytes,
    );
  }

  /// replaceBytesInRange:withBytes:length:
  void replaceBytesInRange$1(
    NSRange range, {
    required ffi.Pointer<ffi.Void> withBytes,
    required int length,
  }) {
    _objc_msgSend_c0vg4w(
      _$.ref.pointer,
      _sel_replaceBytesInRange_withBytes_length_,
      range,
      withBytes,
      length,
    );
  }

  /// resetBytesInRange:
  void resetBytesInRange(NSRange range) {
    _objc_msgSend_1e3pm0z(_$.ref.pointer, _sel_resetBytesInRange_, range);
  }

  /// setData:
  void setData(NSData data) {
    _objc_msgSend_xtuoz7(_$.ref.pointer, _sel_setData_, data.ref.pointer);
  }
}

/// NSExtendedMutableDictionary
extension NSExtendedMutableDictionary on NSMutableDictionary {
  /// addEntriesFromDictionary:
  void addEntriesFromDictionary(NSDictionary otherDictionary) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_addEntriesFromDictionary_,
      otherDictionary.ref.pointer,
    );
  }

  /// removeAllObjects
  void removeAllObjects() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_removeAllObjects);
  }

  /// removeObjectsForKeys:
  void removeObjectsForKeys(NSArray keyArray) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_removeObjectsForKeys_,
      keyArray.ref.pointer,
    );
  }

  /// setDictionary:
  void setDictionary(NSDictionary otherDictionary) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setDictionary_,
      otherDictionary.ref.pointer,
    );
  }

  /// setObject:forKeyedSubscript:
  void setObject$1(
    objc.ObjCObjectBase? obj, {
    required NSCopying forKeyedSubscript,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableDictionary.setObject:forKeyedSubscript:',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_setObject_forKeyedSubscript_,
      obj?.ref.pointer ?? ffi.nullptr,
      forKeyedSubscript.ref.pointer,
    );
  }
}

/// NSExtendedMutableOrderedSet
extension NSExtendedMutableOrderedSet on NSMutableOrderedSet {
  /// addObject:
  void addObject(objc.ObjCObjectBase object) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.addObject:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(_$.ref.pointer, _sel_addObject_, object.ref.pointer);
  }

  /// addObjects:count:
  void addObjects(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required int count,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.addObjects:count:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_gcjqkl(
      _$.ref.pointer,
      _sel_addObjects_count_,
      objects,
      count,
    );
  }

  /// addObjectsFromArray:
  void addObjectsFromArray(NSArray array) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.addObjectsFromArray:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_addObjectsFromArray_,
      array.ref.pointer,
    );
  }

  /// exchangeObjectAtIndex:withObjectAtIndex:
  void exchangeObjectAtIndex(int idx1, {required int withObjectAtIndex}) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.exchangeObjectAtIndex:withObjectAtIndex:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_bfp043(
      _$.ref.pointer,
      _sel_exchangeObjectAtIndex_withObjectAtIndex_,
      idx1,
      withObjectAtIndex,
    );
  }

  /// insertObjects:atIndexes:
  void insertObjects(NSArray objects, {required NSIndexSet atIndexes}) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.insertObjects:atIndexes:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_insertObjects_atIndexes_,
      objects.ref.pointer,
      atIndexes.ref.pointer,
    );
  }

  /// intersectOrderedSet:
  void intersectOrderedSet(NSOrderedSet other) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.intersectOrderedSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_intersectOrderedSet_,
      other.ref.pointer,
    );
  }

  /// intersectSet:
  void intersectSet(NSSet other) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.intersectSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(_$.ref.pointer, _sel_intersectSet_, other.ref.pointer);
  }

  /// minusOrderedSet:
  void minusOrderedSet(NSOrderedSet other) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.minusOrderedSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_minusOrderedSet_,
      other.ref.pointer,
    );
  }

  /// minusSet:
  void minusSet(NSSet other) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.minusSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(_$.ref.pointer, _sel_minusSet_, other.ref.pointer);
  }

  /// moveObjectsAtIndexes:toIndex:
  void moveObjectsAtIndexes(NSIndexSet indexes, {required int toIndex}) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.moveObjectsAtIndexes:toIndex:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_djsa9o(
      _$.ref.pointer,
      _sel_moveObjectsAtIndexes_toIndex_,
      indexes.ref.pointer,
      toIndex,
    );
  }

  /// removeAllObjects
  void removeAllObjects() {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.removeAllObjects',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_removeAllObjects);
  }

  /// removeObject:
  void removeObject(objc.ObjCObjectBase object) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.removeObject:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_removeObject_,
      object.ref.pointer,
    );
  }

  /// removeObjectsAtIndexes:
  void removeObjectsAtIndexes(NSIndexSet indexes) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.removeObjectsAtIndexes:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_removeObjectsAtIndexes_,
      indexes.ref.pointer,
    );
  }

  /// removeObjectsInArray:
  void removeObjectsInArray(NSArray array) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.removeObjectsInArray:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_removeObjectsInArray_,
      array.ref.pointer,
    );
  }

  /// removeObjectsInRange:
  void removeObjectsInRange(NSRange range) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.removeObjectsInRange:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1e3pm0z(_$.ref.pointer, _sel_removeObjectsInRange_, range);
  }

  /// replaceObjectsAtIndexes:withObjects:
  void replaceObjectsAtIndexes(
    NSIndexSet indexes, {
    required NSArray withObjects,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.replaceObjectsAtIndexes:withObjects:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_replaceObjectsAtIndexes_withObjects_,
      indexes.ref.pointer,
      withObjects.ref.pointer,
    );
  }

  /// replaceObjectsInRange:withObjects:count:
  void replaceObjectsInRange(
    NSRange range, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> withObjects,
    required int count,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.replaceObjectsInRange:withObjects:count:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_122v0cv(
      _$.ref.pointer,
      _sel_replaceObjectsInRange_withObjects_count_,
      range,
      withObjects,
      count,
    );
  }

  /// setObject:atIndex:
  void setObject(objc.ObjCObjectBase obj, {required int atIndex}) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.setObject:atIndex:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_djsa9o(
      _$.ref.pointer,
      _sel_setObject_atIndex_,
      obj.ref.pointer,
      atIndex,
    );
  }

  /// setObject:atIndexedSubscript:
  void setObject$1(objc.ObjCObjectBase obj, {required int atIndexedSubscript}) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.setObject:atIndexedSubscript:',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
    _objc_msgSend_djsa9o(
      _$.ref.pointer,
      _sel_setObject_atIndexedSubscript_,
      obj.ref.pointer,
      atIndexedSubscript,
    );
  }

  /// sortRange:options:usingComparator:
  void sortRange(
    NSRange range, {
    required int options,
    required objc.ObjCBlock<
      ffi.Long Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >
    usingComparator,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.sortRange:options:usingComparator:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_arew0j(
      _$.ref.pointer,
      _sel_sortRange_options_usingComparator_,
      range,
      options,
      usingComparator.ref.pointer,
    );
  }

  /// sortUsingComparator:
  void sortUsingComparator(
    objc.ObjCBlock<
      ffi.Long Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >
    cmptr,
  ) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.sortUsingComparator:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_f167m6(
      _$.ref.pointer,
      _sel_sortUsingComparator_,
      cmptr.ref.pointer,
    );
  }

  /// sortWithOptions:usingComparator:
  void sortWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Long Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >
    usingComparator,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.sortWithOptions:usingComparator:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_jjgvjt(
      _$.ref.pointer,
      _sel_sortWithOptions_usingComparator_,
      opts,
      usingComparator.ref.pointer,
    );
  }

  /// unionOrderedSet:
  void unionOrderedSet(NSOrderedSet other) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.unionOrderedSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_unionOrderedSet_,
      other.ref.pointer,
    );
  }

  /// unionSet:
  void unionSet(NSSet other) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.unionSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(_$.ref.pointer, _sel_unionSet_, other.ref.pointer);
  }
}

/// NSExtendedMutableSet
extension NSExtendedMutableSet on NSMutableSet {
  /// addObjectsFromArray:
  void addObjectsFromArray(NSArray array) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_addObjectsFromArray_,
      array.ref.pointer,
    );
  }

  /// intersectSet:
  void intersectSet(NSSet otherSet) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_intersectSet_,
      otherSet.ref.pointer,
    );
  }

  /// minusSet:
  void minusSet(NSSet otherSet) {
    _objc_msgSend_xtuoz7(_$.ref.pointer, _sel_minusSet_, otherSet.ref.pointer);
  }

  /// removeAllObjects
  void removeAllObjects() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_removeAllObjects);
  }

  /// setSet:
  void setSet(NSSet otherSet) {
    _objc_msgSend_xtuoz7(_$.ref.pointer, _sel_setSet_, otherSet.ref.pointer);
  }

  /// unionSet:
  void unionSet(NSSet otherSet) {
    _objc_msgSend_xtuoz7(_$.ref.pointer, _sel_unionSet_, otherSet.ref.pointer);
  }
}

/// NSExtendedOrderedSet
extension NSExtendedOrderedSet on NSOrderedSet {
  /// array
  NSArray get array {
    objc.checkOsVersionInternal(
      'NSOrderedSet.array',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_array);
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// containsObject:
  bool containsObject(objc.ObjCObjectBase object) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.containsObject:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_containsObject_,
      object.ref.pointer,
    );
  }

  /// description
  NSString get description$1 {
    objc.checkOsVersionInternal(
      'NSOrderedSet.description',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_description);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// descriptionWithLocale:
  NSString descriptionWithLocale(objc.ObjCObjectBase? locale) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.descriptionWithLocale:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_descriptionWithLocale_,
      locale?.ref.pointer ?? ffi.nullptr,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// descriptionWithLocale:indent:
  NSString descriptionWithLocale$1(
    objc.ObjCObjectBase? locale, {
    required int indent,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.descriptionWithLocale:indent:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1k4kd9s(
      _$.ref.pointer,
      _sel_descriptionWithLocale_indent_,
      locale?.ref.pointer ?? ffi.nullptr,
      indent,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// enumerateObjectsAtIndexes:options:usingBlock:
  void enumerateObjectsAtIndexes(
    NSIndexSet s, {
    required int options,
    required objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    usingBlock,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.enumerateObjectsAtIndexes:options:usingBlock:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_a3wp08(
      _$.ref.pointer,
      _sel_enumerateObjectsAtIndexes_options_usingBlock_,
      s.ref.pointer,
      options,
      usingBlock.ref.pointer,
    );
  }

  /// enumerateObjectsUsingBlock:
  void enumerateObjectsUsingBlock(
    objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    block,
  ) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.enumerateObjectsUsingBlock:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_f167m6(
      _$.ref.pointer,
      _sel_enumerateObjectsUsingBlock_,
      block.ref.pointer,
    );
  }

  /// enumerateObjectsWithOptions:usingBlock:
  void enumerateObjectsWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    usingBlock,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.enumerateObjectsWithOptions:usingBlock:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_yx8yc6(
      _$.ref.pointer,
      _sel_enumerateObjectsWithOptions_usingBlock_,
      opts,
      usingBlock.ref.pointer,
    );
  }

  /// firstObject
  objc.ObjCObjectBase? get firstObject {
    objc.checkOsVersionInternal(
      'NSOrderedSet.firstObject',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_firstObject);
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// getObjects:range:
  void getObjects(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required NSRange range,
  }) {
    _objc_msgSend_o16d3k(
      _$.ref.pointer,
      _sel_getObjects_range_,
      objects,
      range,
    );
  }

  /// indexOfObject:inSortedRange:options:usingComparator:
  int indexOfObject$1(
    objc.ObjCObjectBase object, {
    required NSRange inSortedRange,
    required int options,
    required objc.ObjCBlock<
      ffi.Long Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >
    usingComparator,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.indexOfObject:inSortedRange:options:usingComparator:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_kshx9d(
      _$.ref.pointer,
      _sel_indexOfObject_inSortedRange_options_usingComparator_,
      object.ref.pointer,
      inSortedRange,
      options,
      usingComparator.ref.pointer,
    );
  }

  /// indexOfObjectAtIndexes:options:passingTest:
  int indexOfObjectAtIndexes(
    NSIndexSet s, {
    required int options,
    required objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    passingTest,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.indexOfObjectAtIndexes:options:passingTest:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_k1x6mt(
      _$.ref.pointer,
      _sel_indexOfObjectAtIndexes_options_passingTest_,
      s.ref.pointer,
      options,
      passingTest.ref.pointer,
    );
  }

  /// indexOfObjectPassingTest:
  int indexOfObjectPassingTest(
    objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    predicate,
  ) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.indexOfObjectPassingTest:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_10mlopr(
      _$.ref.pointer,
      _sel_indexOfObjectPassingTest_,
      predicate.ref.pointer,
    );
  }

  /// indexOfObjectWithOptions:passingTest:
  int indexOfObjectWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    passingTest,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.indexOfObjectWithOptions:passingTest:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_1698hqz(
      _$.ref.pointer,
      _sel_indexOfObjectWithOptions_passingTest_,
      opts,
      passingTest.ref.pointer,
    );
  }

  /// indexesOfObjectsAtIndexes:options:passingTest:
  NSIndexSet indexesOfObjectsAtIndexes(
    NSIndexSet s, {
    required int options,
    required objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    passingTest,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.indexesOfObjectsAtIndexes:options:passingTest:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1i9v144(
      _$.ref.pointer,
      _sel_indexesOfObjectsAtIndexes_options_passingTest_,
      s.ref.pointer,
      options,
      passingTest.ref.pointer,
    );
    return NSIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// indexesOfObjectsPassingTest:
  NSIndexSet indexesOfObjectsPassingTest(
    objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    predicate,
  ) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.indexesOfObjectsPassingTest:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_nnxkei(
      _$.ref.pointer,
      _sel_indexesOfObjectsPassingTest_,
      predicate.ref.pointer,
    );
    return NSIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// indexesOfObjectsWithOptions:passingTest:
  NSIndexSet indexesOfObjectsWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    passingTest,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.indexesOfObjectsWithOptions:passingTest:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_13x5boi(
      _$.ref.pointer,
      _sel_indexesOfObjectsWithOptions_passingTest_,
      opts,
      passingTest.ref.pointer,
    );
    return NSIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// intersectsOrderedSet:
  bool intersectsOrderedSet(NSOrderedSet other) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.intersectsOrderedSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_intersectsOrderedSet_,
      other.ref.pointer,
    );
  }

  /// intersectsSet:
  bool intersectsSet(NSSet set) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.intersectsSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_intersectsSet_,
      set.ref.pointer,
    );
  }

  /// isEqualToOrderedSet:
  bool isEqualToOrderedSet(NSOrderedSet other) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.isEqualToOrderedSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isEqualToOrderedSet_,
      other.ref.pointer,
    );
  }

  /// isSubsetOfOrderedSet:
  bool isSubsetOfOrderedSet(NSOrderedSet other) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.isSubsetOfOrderedSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isSubsetOfOrderedSet_,
      other.ref.pointer,
    );
  }

  /// isSubsetOfSet:
  bool isSubsetOfSet(NSSet set) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.isSubsetOfSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isSubsetOfSet_,
      set.ref.pointer,
    );
  }

  /// lastObject
  objc.ObjCObjectBase? get lastObject {
    objc.checkOsVersionInternal(
      'NSOrderedSet.lastObject',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_lastObject);
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// objectAtIndexedSubscript:
  objc.ObjCObjectBase objectAtIndexedSubscript(int idx) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.objectAtIndexedSubscript:',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.pointer,
      _sel_objectAtIndexedSubscript_,
      idx,
    );
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// objectEnumerator
  NSEnumerator objectEnumerator() {
    objc.checkOsVersionInternal(
      'NSOrderedSet.objectEnumerator',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_objectEnumerator);
    return NSEnumerator.castFromPointer($ret, retain: true, release: true);
  }

  /// objectsAtIndexes:
  NSArray objectsAtIndexes(NSIndexSet indexes) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.objectsAtIndexes:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_objectsAtIndexes_,
      indexes.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// reverseObjectEnumerator
  NSEnumerator reverseObjectEnumerator() {
    objc.checkOsVersionInternal(
      'NSOrderedSet.reverseObjectEnumerator',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_reverseObjectEnumerator,
    );
    return NSEnumerator.castFromPointer($ret, retain: true, release: true);
  }

  /// reversedOrderedSet
  NSOrderedSet get reversedOrderedSet {
    objc.checkOsVersionInternal(
      'NSOrderedSet.reversedOrderedSet',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_reversedOrderedSet);
    return NSOrderedSet.castFromPointer($ret, retain: true, release: true);
  }

  /// set
  NSSet get set {
    objc.checkOsVersionInternal(
      'NSOrderedSet.set',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_set);
    return NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// sortedArrayUsingComparator:
  NSArray sortedArrayUsingComparator(
    objc.ObjCBlock<
      ffi.Long Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >
    cmptr,
  ) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.sortedArrayUsingComparator:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_nnxkei(
      _$.ref.pointer,
      _sel_sortedArrayUsingComparator_,
      cmptr.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// sortedArrayWithOptions:usingComparator:
  NSArray sortedArrayWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Long Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >
    usingComparator,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.sortedArrayWithOptions:usingComparator:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1x5ew3h(
      _$.ref.pointer,
      _sel_sortedArrayWithOptions_usingComparator_,
      opts,
      usingComparator.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }
}

/// NSExtendedSet
extension NSExtendedSet on NSSet {
  /// allObjects
  NSArray get allObjects {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_allObjects);
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// anyObject
  objc.ObjCObjectBase? anyObject() {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_anyObject);
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// containsObject:
  bool containsObject(objc.ObjCObjectBase anObject) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_containsObject_,
      anObject.ref.pointer,
    );
  }

  /// description
  NSString get description$1 {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_description);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// descriptionWithLocale:
  NSString descriptionWithLocale(objc.ObjCObjectBase? locale) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_descriptionWithLocale_,
      locale?.ref.pointer ?? ffi.nullptr,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// enumerateObjectsUsingBlock:
  void enumerateObjectsUsingBlock(
    objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
    >
    block,
  ) {
    objc.checkOsVersionInternal(
      'NSSet.enumerateObjectsUsingBlock:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_f167m6(
      _$.ref.pointer,
      _sel_enumerateObjectsUsingBlock_,
      block.ref.pointer,
    );
  }

  /// enumerateObjectsWithOptions:usingBlock:
  void enumerateObjectsWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
    >
    usingBlock,
  }) {
    objc.checkOsVersionInternal(
      'NSSet.enumerateObjectsWithOptions:usingBlock:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_yx8yc6(
      _$.ref.pointer,
      _sel_enumerateObjectsWithOptions_usingBlock_,
      opts,
      usingBlock.ref.pointer,
    );
  }

  /// intersectsSet:
  bool intersectsSet(NSSet otherSet) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_intersectsSet_,
      otherSet.ref.pointer,
    );
  }

  /// isEqualToSet:
  bool isEqualToSet(NSSet otherSet) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isEqualToSet_,
      otherSet.ref.pointer,
    );
  }

  /// isSubsetOfSet:
  bool isSubsetOfSet(NSSet otherSet) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isSubsetOfSet_,
      otherSet.ref.pointer,
    );
  }

  /// makeObjectsPerformSelector:
  void makeObjectsPerformSelector(ffi.Pointer<objc.ObjCSelector> aSelector) {
    _objc_msgSend_1d9e4oe(
      _$.ref.pointer,
      _sel_makeObjectsPerformSelector_,
      aSelector,
    );
  }

  /// makeObjectsPerformSelector:withObject:
  void makeObjectsPerformSelector$1(
    ffi.Pointer<objc.ObjCSelector> aSelector, {
    objc.ObjCObjectBase? withObject,
  }) {
    _objc_msgSend_1qv0eq4(
      _$.ref.pointer,
      _sel_makeObjectsPerformSelector_withObject_,
      aSelector,
      withObject?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// objectsPassingTest:
  NSSet objectsPassingTest(
    objc.ObjCBlock<
      ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
    >
    predicate,
  ) {
    objc.checkOsVersionInternal(
      'NSSet.objectsPassingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_nnxkei(
      _$.ref.pointer,
      _sel_objectsPassingTest_,
      predicate.ref.pointer,
    );
    return NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// objectsWithOptions:passingTest:
  NSSet objectsWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
    >
    passingTest,
  }) {
    objc.checkOsVersionInternal(
      'NSSet.objectsWithOptions:passingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_13x5boi(
      _$.ref.pointer,
      _sel_objectsWithOptions_passingTest_,
      opts,
      passingTest.ref.pointer,
    );
    return NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// setByAddingObject:
  NSSet setByAddingObject(objc.ObjCObjectBase anObject) {
    objc.checkOsVersionInternal(
      'NSSet.setByAddingObject:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_setByAddingObject_,
      anObject.ref.pointer,
    );
    return NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// setByAddingObjectsFromArray:
  NSSet setByAddingObjectsFromArray(NSArray other) {
    objc.checkOsVersionInternal(
      'NSSet.setByAddingObjectsFromArray:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_setByAddingObjectsFromArray_,
      other.ref.pointer,
    );
    return NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// setByAddingObjectsFromSet:
  NSSet setByAddingObjectsFromSet(NSSet other) {
    objc.checkOsVersionInternal(
      'NSSet.setByAddingObjectsFromSet:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_setByAddingObjectsFromSet_,
      other.ref.pointer,
    );
    return NSSet.castFromPointer($ret, retain: true, release: true);
  }
}

/// NSFastEnumeration
extension type NSFastEnumeration.castFrom(objc.ObjCProtocolBase _$)
    implements objc.ObjCProtocolBase {
  /// Constructs a [NSFastEnumeration] that wraps the given raw object pointer.
  NSFastEnumeration.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCProtocolBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSFastEnumeration].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_NSFastEnumeration,
    );
  }
}

extension NSFastEnumeration$Methods on NSFastEnumeration {
  /// countByEnumeratingWithState:objects:count:
  int countByEnumeratingWithState(
    ffi.Pointer<NSFastEnumerationState> state, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects,
    required int count,
  }) {
    return _objc_msgSend_1b5ysjl(
      _$.ref.pointer,
      _sel_countByEnumeratingWithState_objects_count_,
      state,
      objects,
      count,
    );
  }
}

interface class NSFastEnumeration$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_NSFastEnumeration.cast());

  /// Builds an object that implements the NSFastEnumeration protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSFastEnumeration implement({
    required int Function(
      ffi.Pointer<NSFastEnumerationState>,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      int,
    )
    countByEnumeratingWithState_objects_count_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSFastEnumeration');
    NSFastEnumeration$Builder.countByEnumeratingWithState_objects_count_
        .implement(builder, countByEnumeratingWithState_objects_count_);
    builder.addProtocol($protocol);
    return NSFastEnumeration.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSFastEnumeration protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    required int Function(
      ffi.Pointer<NSFastEnumerationState>,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      int,
    )
    countByEnumeratingWithState_objects_count_,
    bool $keepIsolateAlive = true,
  }) {
    NSFastEnumeration$Builder.countByEnumeratingWithState_objects_count_
        .implement(builder, countByEnumeratingWithState_objects_count_);
    builder.addProtocol($protocol);
  }

  /// countByEnumeratingWithState:objects:count:
  static final countByEnumeratingWithState_objects_count_ =
      objc.ObjCProtocolMethod<
        int Function(
          ffi.Pointer<NSFastEnumerationState>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          int,
        )
      >(
        _protocol_NSFastEnumeration,
        _sel_countByEnumeratingWithState_objects_count_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.UnsignedLong Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<NSFastEnumerationState>,
                  ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                  ffi.UnsignedLong,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_17ap02x)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSFastEnumeration,
          _sel_countByEnumeratingWithState_objects_count_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (
          int Function(
            ffi.Pointer<NSFastEnumerationState>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            int,
          )
          func,
        ) =>
            ObjCBlock_NSUInteger_ffiVoid_NSFastEnumerationState_objcObjCObject_NSUInteger.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                ffi.Pointer<NSFastEnumerationState> arg1,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2,
                int arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );
}

final class NSFastEnumerationState extends ffi.Struct {
  @ffi.UnsignedLong()
  external int state;

  external ffi.Pointer<ffi.Pointer<objc.ObjCObject>> itemsPtr;

  external ffi.Pointer<ffi.UnsignedLong> mutationsPtr;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.UnsignedLong> extra;
}

/// NSIndexSet
extension type NSIndexSet.castFrom(objc.ObjCObjectBase _$)
    implements
        objc.ObjCObjectBase,
        NSObject,
        NSCopying,
        NSMutableCopying,
        NSSecureCoding {
  /// Constructs a [NSIndexSet] that wraps the given raw object pointer.
  NSIndexSet.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSIndexSet].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSIndexSet,
    );
  }

  /// alloc
  static NSIndexSet alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSIndexSet, _sel_alloc);
    return NSIndexSet.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSIndexSet allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSIndexSet,
      _sel_allocWithZone_,
      zone,
    );
    return NSIndexSet.castFromPointer($ret, retain: false, release: true);
  }

  /// indexSet
  static NSIndexSet indexSet() {
    final $ret = _objc_msgSend_151sglz(_class_NSIndexSet, _sel_indexSet);
    return NSIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// indexSetWithIndex:
  static NSIndexSet indexSetWithIndex(int value) {
    final $ret = _objc_msgSend_14hpxwa(
      _class_NSIndexSet,
      _sel_indexSetWithIndex_,
      value,
    );
    return NSIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// indexSetWithIndexesInRange:
  static NSIndexSet indexSetWithIndexesInRange(NSRange range) {
    final $ret = _objc_msgSend_1k1o1s7(
      _class_NSIndexSet,
      _sel_indexSetWithIndexesInRange_,
      range,
    );
    return NSIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSIndexSet new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSIndexSet, _sel_new);
    return NSIndexSet.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSIndexSet, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSIndexSet constructed with the default `new` method.
  NSIndexSet() : this.castFrom(new$()._$);
}

extension NSIndexSet$Methods on NSIndexSet {
  /// containsIndex:
  bool containsIndex(int value) {
    return _objc_msgSend_6peh6o(_$.ref.pointer, _sel_containsIndex_, value);
  }

  /// containsIndexes:
  bool containsIndexes(NSIndexSet indexSet) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_containsIndexes_,
      indexSet.ref.pointer,
    );
  }

  /// containsIndexesInRange:
  bool containsIndexesInRange(NSRange range) {
    return _objc_msgSend_p4nurx(
      _$.ref.pointer,
      _sel_containsIndexesInRange_,
      range,
    );
  }

  /// count
  int get count {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_count);
  }

  /// countOfIndexesInRange:
  int countOfIndexesInRange(NSRange range) {
    objc.checkOsVersionInternal(
      'NSIndexSet.countOfIndexesInRange:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_qm9f5w(
      _$.ref.pointer,
      _sel_countOfIndexesInRange_,
      range,
    );
  }

  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// enumerateIndexesInRange:options:usingBlock:
  void enumerateIndexesInRange(
    NSRange range, {
    required int options,
    required objc.ObjCBlock<
      ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
    >
    usingBlock,
  }) {
    objc.checkOsVersionInternal(
      'NSIndexSet.enumerateIndexesInRange:options:usingBlock:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_177cajs(
      _$.ref.pointer,
      _sel_enumerateIndexesInRange_options_usingBlock_,
      range,
      options,
      usingBlock.ref.pointer,
    );
  }

  /// enumerateIndexesUsingBlock:
  void enumerateIndexesUsingBlock(
    objc.ObjCBlock<ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>
    block,
  ) {
    objc.checkOsVersionInternal(
      'NSIndexSet.enumerateIndexesUsingBlock:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_f167m6(
      _$.ref.pointer,
      _sel_enumerateIndexesUsingBlock_,
      block.ref.pointer,
    );
  }

  /// enumerateIndexesWithOptions:usingBlock:
  void enumerateIndexesWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
    >
    usingBlock,
  }) {
    objc.checkOsVersionInternal(
      'NSIndexSet.enumerateIndexesWithOptions:usingBlock:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_yx8yc6(
      _$.ref.pointer,
      _sel_enumerateIndexesWithOptions_usingBlock_,
      opts,
      usingBlock.ref.pointer,
    );
  }

  /// enumerateRangesInRange:options:usingBlock:
  void enumerateRangesInRange(
    NSRange range, {
    required int options,
    required objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)>
    usingBlock,
  }) {
    objc.checkOsVersionInternal(
      'NSIndexSet.enumerateRangesInRange:options:usingBlock:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_177cajs(
      _$.ref.pointer,
      _sel_enumerateRangesInRange_options_usingBlock_,
      range,
      options,
      usingBlock.ref.pointer,
    );
  }

  /// enumerateRangesUsingBlock:
  void enumerateRangesUsingBlock(
    objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)> block,
  ) {
    objc.checkOsVersionInternal(
      'NSIndexSet.enumerateRangesUsingBlock:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_f167m6(
      _$.ref.pointer,
      _sel_enumerateRangesUsingBlock_,
      block.ref.pointer,
    );
  }

  /// enumerateRangesWithOptions:usingBlock:
  void enumerateRangesWithOptions(
    int opts, {
    required objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)>
    usingBlock,
  }) {
    objc.checkOsVersionInternal(
      'NSIndexSet.enumerateRangesWithOptions:usingBlock:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_yx8yc6(
      _$.ref.pointer,
      _sel_enumerateRangesWithOptions_usingBlock_,
      opts,
      usingBlock.ref.pointer,
    );
  }

  /// firstIndex
  int get firstIndex {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_firstIndex);
  }

  /// getIndexes:maxCount:inIndexRange:
  int getIndexes(
    ffi.Pointer<ffi.UnsignedLong> indexBuffer, {
    required int maxCount,
    required ffi.Pointer<NSRange> inIndexRange,
  }) {
    return _objc_msgSend_89xgla(
      _$.ref.pointer,
      _sel_getIndexes_maxCount_inIndexRange_,
      indexBuffer,
      maxCount,
      inIndexRange,
    );
  }

  /// indexGreaterThanIndex:
  int indexGreaterThanIndex(int value) {
    return _objc_msgSend_12py2ux(
      _$.ref.pointer,
      _sel_indexGreaterThanIndex_,
      value,
    );
  }

  /// indexGreaterThanOrEqualToIndex:
  int indexGreaterThanOrEqualToIndex(int value) {
    return _objc_msgSend_12py2ux(
      _$.ref.pointer,
      _sel_indexGreaterThanOrEqualToIndex_,
      value,
    );
  }

  /// indexInRange:options:passingTest:
  int indexInRange(
    NSRange range, {
    required int options,
    required objc.ObjCBlock<
      ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
    >
    passingTest,
  }) {
    objc.checkOsVersionInternal(
      'NSIndexSet.indexInRange:options:passingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_6jmuyz(
      _$.ref.pointer,
      _sel_indexInRange_options_passingTest_,
      range,
      options,
      passingTest.ref.pointer,
    );
  }

  /// indexLessThanIndex:
  int indexLessThanIndex(int value) {
    return _objc_msgSend_12py2ux(
      _$.ref.pointer,
      _sel_indexLessThanIndex_,
      value,
    );
  }

  /// indexLessThanOrEqualToIndex:
  int indexLessThanOrEqualToIndex(int value) {
    return _objc_msgSend_12py2ux(
      _$.ref.pointer,
      _sel_indexLessThanOrEqualToIndex_,
      value,
    );
  }

  /// indexPassingTest:
  int indexPassingTest(
    objc.ObjCBlock<ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>
    predicate,
  ) {
    objc.checkOsVersionInternal(
      'NSIndexSet.indexPassingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_10mlopr(
      _$.ref.pointer,
      _sel_indexPassingTest_,
      predicate.ref.pointer,
    );
  }

  /// indexWithOptions:passingTest:
  int indexWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
    >
    passingTest,
  }) {
    objc.checkOsVersionInternal(
      'NSIndexSet.indexWithOptions:passingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_1698hqz(
      _$.ref.pointer,
      _sel_indexWithOptions_passingTest_,
      opts,
      passingTest.ref.pointer,
    );
  }

  /// indexesInRange:options:passingTest:
  NSIndexSet indexesInRange(
    NSRange range, {
    required int options,
    required objc.ObjCBlock<
      ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
    >
    passingTest,
  }) {
    objc.checkOsVersionInternal(
      'NSIndexSet.indexesInRange:options:passingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1q30cs4(
      _$.ref.pointer,
      _sel_indexesInRange_options_passingTest_,
      range,
      options,
      passingTest.ref.pointer,
    );
    return NSIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// indexesPassingTest:
  NSIndexSet indexesPassingTest(
    objc.ObjCBlock<ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>
    predicate,
  ) {
    objc.checkOsVersionInternal(
      'NSIndexSet.indexesPassingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_nnxkei(
      _$.ref.pointer,
      _sel_indexesPassingTest_,
      predicate.ref.pointer,
    );
    return NSIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// indexesWithOptions:passingTest:
  NSIndexSet indexesWithOptions(
    int opts, {
    required objc.ObjCBlock<
      ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
    >
    passingTest,
  }) {
    objc.checkOsVersionInternal(
      'NSIndexSet.indexesWithOptions:passingTest:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_13x5boi(
      _$.ref.pointer,
      _sel_indexesWithOptions_passingTest_,
      opts,
      passingTest.ref.pointer,
    );
    return NSIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  NSIndexSet init() {
    objc.checkOsVersionInternal(
      'NSIndexSet.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSIndexSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSIndexSet? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSIndexSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithIndex:
  NSIndexSet initWithIndex(int value) {
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithIndex_,
      value,
    );
    return NSIndexSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithIndexSet:
  NSIndexSet initWithIndexSet(NSIndexSet indexSet) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithIndexSet_,
      indexSet.ref.pointer,
    );
    return NSIndexSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithIndexesInRange:
  NSIndexSet initWithIndexesInRange(NSRange range) {
    final $ret = _objc_msgSend_1k1o1s7(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithIndexesInRange_,
      range,
    );
    return NSIndexSet.castFromPointer($ret, retain: false, release: true);
  }

  /// intersectsIndexesInRange:
  bool intersectsIndexesInRange(NSRange range) {
    return _objc_msgSend_p4nurx(
      _$.ref.pointer,
      _sel_intersectsIndexesInRange_,
      range,
    );
  }

  /// isEqualToIndexSet:
  bool isEqualToIndexSet(NSIndexSet indexSet) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isEqualToIndexSet_,
      indexSet.ref.pointer,
    );
  }

  /// lastIndex
  int get lastIndex {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_lastIndex);
  }
}

/// NSInputStream
extension type NSInputStream.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSStream {
  /// Constructs a [NSInputStream] that wraps the given raw object pointer.
  NSInputStream.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSInputStream].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSInputStream,
    );
  }

  /// alloc
  static NSInputStream alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSInputStream, _sel_alloc);
    return NSInputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSInputStream allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSInputStream,
      _sel_allocWithZone_,
      zone,
    );
    return NSInputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// inputStreamWithData:
  static NSInputStream? inputStreamWithData(NSData data) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSInputStream,
      _sel_inputStreamWithData_,
      data.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSInputStream.castFromPointer($ret, retain: true, release: true);
  }

  /// inputStreamWithFileAtPath:
  static NSInputStream? inputStreamWithFileAtPath(NSString path) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSInputStream,
      _sel_inputStreamWithFileAtPath_,
      path.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSInputStream.castFromPointer($ret, retain: true, release: true);
  }

  /// inputStreamWithURL:
  static NSInputStream? inputStreamWithURL(NSURL url) {
    objc.checkOsVersionInternal(
      'NSInputStream.inputStreamWithURL:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSInputStream,
      _sel_inputStreamWithURL_,
      url.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSInputStream.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSInputStream new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSInputStream, _sel_new);
    return NSInputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSInputStream constructed with the default `new` method.
  NSInputStream() : this.castFrom(new$()._$);
}

extension NSInputStream$Methods on NSInputStream {
  /// getBuffer:length:
  bool getBuffer(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> buffer, {
    required ffi.Pointer<ffi.UnsignedLong> length,
  }) {
    return _objc_msgSend_19lrthf(
      _$.ref.pointer,
      _sel_getBuffer_length_,
      buffer,
      length,
    );
  }

  /// hasBytesAvailable
  bool get hasBytesAvailable {
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_hasBytesAvailable);
  }

  /// init
  NSInputStream init() {
    objc.checkOsVersionInternal(
      'NSInputStream.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSInputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithData:
  NSInputStream initWithData(NSData data) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithData_,
      data.ref.pointer,
    );
    return NSInputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFileAtPath:
  NSInputStream? initWithFileAtPath(NSString path) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithFileAtPath_,
      path.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSInputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithURL:
  NSInputStream? initWithURL(NSURL url) {
    objc.checkOsVersionInternal(
      'NSInputStream.initWithURL:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithURL_,
      url.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSInputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// read:maxLength:
  int read(ffi.Pointer<ffi.Uint8> buffer, {required int maxLength}) {
    return _objc_msgSend_11e9f5x(
      _$.ref.pointer,
      _sel_read_maxLength_,
      buffer,
      maxLength,
    );
  }
}

/// NSInvocation
extension type NSInvocation.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [NSInvocation] that wraps the given raw object pointer.
  NSInvocation.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSInvocation].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSInvocation,
    );
  }

  /// alloc
  static NSInvocation alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSInvocation, _sel_alloc);
    return NSInvocation.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSInvocation allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSInvocation,
      _sel_allocWithZone_,
      zone,
    );
    return NSInvocation.castFromPointer($ret, retain: false, release: true);
  }

  /// invocationWithMethodSignature:
  static NSInvocation invocationWithMethodSignature(NSMethodSignature sig) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSInvocation,
      _sel_invocationWithMethodSignature_,
      sig.ref.pointer,
    );
    return NSInvocation.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSInvocation new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSInvocation, _sel_new);
    return NSInvocation.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSInvocation constructed with the default `new` method.
  NSInvocation() : this.castFrom(new$()._$);
}

extension NSInvocation$Methods on NSInvocation {
  /// argumentsRetained
  bool get argumentsRetained {
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_argumentsRetained);
  }

  /// getArgument:atIndex:
  void getArgument(
    ffi.Pointer<ffi.Void> argumentLocation, {
    required int atIndex,
  }) {
    _objc_msgSend_unr2j3(
      _$.ref.pointer,
      _sel_getArgument_atIndex_,
      argumentLocation,
      atIndex,
    );
  }

  /// getReturnValue:
  void getReturnValue(ffi.Pointer<ffi.Void> retLoc) {
    _objc_msgSend_ovsamd(_$.ref.pointer, _sel_getReturnValue_, retLoc);
  }

  /// init
  NSInvocation init() {
    objc.checkOsVersionInternal(
      'NSInvocation.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSInvocation.castFromPointer($ret, retain: false, release: true);
  }

  /// invoke
  void invoke() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_invoke);
  }

  /// invokeUsingIMP:
  void invokeUsingIMP(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> imp,
  ) {
    _objc_msgSend_hk6irj(_$.ref.pointer, _sel_invokeUsingIMP_, imp);
  }

  /// invokeWithTarget:
  void invokeWithTarget(objc.ObjCObjectBase target) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_invokeWithTarget_,
      target.ref.pointer,
    );
  }

  /// methodSignature
  NSMethodSignature get methodSignature {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_methodSignature);
    return NSMethodSignature.castFromPointer($ret, retain: true, release: true);
  }

  /// retainArguments
  void retainArguments() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_retainArguments);
  }

  /// selector
  ffi.Pointer<objc.ObjCSelector> get selector {
    return _objc_msgSend_1ovaulg(_$.ref.pointer, _sel_selector);
  }

  /// setArgument:atIndex:
  void setArgument(
    ffi.Pointer<ffi.Void> argumentLocation, {
    required int atIndex,
  }) {
    _objc_msgSend_unr2j3(
      _$.ref.pointer,
      _sel_setArgument_atIndex_,
      argumentLocation,
      atIndex,
    );
  }

  /// setReturnValue:
  void setReturnValue(ffi.Pointer<ffi.Void> retLoc) {
    _objc_msgSend_ovsamd(_$.ref.pointer, _sel_setReturnValue_, retLoc);
  }

  /// setSelector:
  set selector(ffi.Pointer<objc.ObjCSelector> value) {
    _objc_msgSend_1d9e4oe(_$.ref.pointer, _sel_setSelector_, value);
  }

  /// setTarget:
  set target(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setTarget_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// target
  objc.ObjCObjectBase? get target {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_target);
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }
}

/// NSItemProvider
extension type NSItemProvider.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject, NSCopying {
  /// Constructs a [NSItemProvider] that wraps the given raw object pointer.
  NSItemProvider.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSItemProvider].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSItemProvider,
    );
  }

  /// alloc
  static NSItemProvider alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSItemProvider, _sel_alloc);
    return NSItemProvider.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSItemProvider allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSItemProvider,
      _sel_allocWithZone_,
      zone,
    );
    return NSItemProvider.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSItemProvider new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSItemProvider, _sel_new);
    return NSItemProvider.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSItemProvider constructed with the default `new` method.
  NSItemProvider() : this.castFrom(new$()._$);
}

extension NSItemProvider$Methods on NSItemProvider {
  /// canLoadObjectOfClass:
  bool canLoadObjectOfClass(NSItemProviderReading aClass) {
    objc.checkOsVersionInternal(
      'NSItemProvider.canLoadObjectOfClass:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_canLoadObjectOfClass_,
      aClass.ref.pointer,
    );
  }

  /// hasItemConformingToTypeIdentifier:
  bool hasItemConformingToTypeIdentifier(NSString typeIdentifier) {
    objc.checkOsVersionInternal(
      'NSItemProvider.hasItemConformingToTypeIdentifier:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_hasItemConformingToTypeIdentifier_,
      typeIdentifier.ref.pointer,
    );
  }

  /// hasRepresentationConformingToTypeIdentifier:fileOptions:
  bool hasRepresentationConformingToTypeIdentifier(
    NSString typeIdentifier, {
    required int fileOptions,
  }) {
    objc.checkOsVersionInternal(
      'NSItemProvider.hasRepresentationConformingToTypeIdentifier:fileOptions:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    return _objc_msgSend_1wdb8ji(
      _$.ref.pointer,
      _sel_hasRepresentationConformingToTypeIdentifier_fileOptions_,
      typeIdentifier.ref.pointer,
      fileOptions,
    );
  }

  /// init
  NSItemProvider init() {
    objc.checkOsVersionInternal(
      'NSItemProvider.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSItemProvider.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:
  NSItemProvider? initWithContentsOfURL(NSURL fileURL) {
    objc.checkOsVersionInternal(
      'NSItemProvider.initWithContentsOfURL:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfURL_,
      fileURL.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSItemProvider.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithItem:typeIdentifier:
  NSItemProvider initWithItem(
    NSSecureCoding? item, {
    NSString? typeIdentifier,
  }) {
    objc.checkOsVersionInternal(
      'NSItemProvider.initWithItem:typeIdentifier:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithItem_typeIdentifier_,
      item?.ref.pointer ?? ffi.nullptr,
      typeIdentifier?.ref.pointer ?? ffi.nullptr,
    );
    return NSItemProvider.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObject:
  NSItemProvider initWithObject(NSItemProviderWriting object) {
    objc.checkOsVersionInternal(
      'NSItemProvider.initWithObject:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObject_,
      object.ref.pointer,
    );
    return NSItemProvider.castFromPointer($ret, retain: false, release: true);
  }

  /// loadDataRepresentationForTypeIdentifier:completionHandler:
  NSProgress loadDataRepresentationForTypeIdentifier(
    NSString typeIdentifier, {
    required objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSItemProvider.loadDataRepresentationForTypeIdentifier:completionHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_r0bo0s(
      _$.ref.pointer,
      _sel_loadDataRepresentationForTypeIdentifier_completionHandler_,
      typeIdentifier.ref.pointer,
      completionHandler.ref.pointer,
    );
    return NSProgress.castFromPointer($ret, retain: true, release: true);
  }

  /// loadFileRepresentationForTypeIdentifier:completionHandler:
  NSProgress loadFileRepresentationForTypeIdentifier(
    NSString typeIdentifier, {
    required objc.ObjCBlock<ffi.Void Function(NSURL?, NSError?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSItemProvider.loadFileRepresentationForTypeIdentifier:completionHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_r0bo0s(
      _$.ref.pointer,
      _sel_loadFileRepresentationForTypeIdentifier_completionHandler_,
      typeIdentifier.ref.pointer,
      completionHandler.ref.pointer,
    );
    return NSProgress.castFromPointer($ret, retain: true, release: true);
  }

  /// loadInPlaceFileRepresentationForTypeIdentifier:completionHandler:
  NSProgress loadInPlaceFileRepresentationForTypeIdentifier(
    NSString typeIdentifier, {
    required objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSItemProvider.loadInPlaceFileRepresentationForTypeIdentifier:completionHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_r0bo0s(
      _$.ref.pointer,
      _sel_loadInPlaceFileRepresentationForTypeIdentifier_completionHandler_,
      typeIdentifier.ref.pointer,
      completionHandler.ref.pointer,
    );
    return NSProgress.castFromPointer($ret, retain: true, release: true);
  }

  /// loadItemForTypeIdentifier:options:completionHandler:
  void loadItemForTypeIdentifier(
    NSString typeIdentifier, {
    NSDictionary? options,
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSItemProvider.loadItemForTypeIdentifier:options:completionHandler:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_18qun1e(
      _$.ref.pointer,
      _sel_loadItemForTypeIdentifier_options_completionHandler_,
      typeIdentifier.ref.pointer,
      options?.ref.pointer ?? ffi.nullptr,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// loadObjectOfClass:completionHandler:
  NSProgress loadObjectOfClass(
    NSItemProviderReading aClass, {
    required objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSItemProvider.loadObjectOfClass:completionHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_r0bo0s(
      _$.ref.pointer,
      _sel_loadObjectOfClass_completionHandler_,
      aClass.ref.pointer,
      completionHandler.ref.pointer,
    );
    return NSProgress.castFromPointer($ret, retain: true, release: true);
  }

  /// registerDataRepresentationForTypeIdentifier:visibility:loadHandler:
  void registerDataRepresentationForTypeIdentifier(
    NSString typeIdentifier, {
    required NSItemProviderRepresentationVisibility visibility,
    required objc.ObjCBlock<
      NSProgress? Function(objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>)
    >
    loadHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSItemProvider.registerDataRepresentationForTypeIdentifier:visibility:loadHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_1pl40xc(
      _$.ref.pointer,
      _sel_registerDataRepresentationForTypeIdentifier_visibility_loadHandler_,
      typeIdentifier.ref.pointer,
      visibility.value,
      loadHandler.ref.pointer,
    );
  }

  /// registerFileRepresentationForTypeIdentifier:fileOptions:visibility:loadHandler:
  void registerFileRepresentationForTypeIdentifier(
    NSString typeIdentifier, {
    required int fileOptions,
    required NSItemProviderRepresentationVisibility visibility,
    required objc.ObjCBlock<
      NSProgress? Function(
        objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>,
      )
    >
    loadHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSItemProvider.registerFileRepresentationForTypeIdentifier:fileOptions:visibility:loadHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_t7arir(
      _$.ref.pointer,
      _sel_registerFileRepresentationForTypeIdentifier_fileOptions_visibility_loadHandler_,
      typeIdentifier.ref.pointer,
      fileOptions,
      visibility.value,
      loadHandler.ref.pointer,
    );
  }

  /// registerItemForTypeIdentifier:loadHandler:
  void registerItemForTypeIdentifier(
    NSString typeIdentifier, {
    required objc.ObjCBlock<
      ffi.Void Function(
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
        >,
        ffi.Pointer<objc.ObjCObject>,
        NSDictionary,
      )
    >
    loadHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSItemProvider.registerItemForTypeIdentifier:loadHandler:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_o762yo(
      _$.ref.pointer,
      _sel_registerItemForTypeIdentifier_loadHandler_,
      typeIdentifier.ref.pointer,
      loadHandler.ref.pointer,
    );
  }

  /// registerObject:visibility:
  void registerObject(
    NSItemProviderWriting object, {
    required NSItemProviderRepresentationVisibility visibility,
  }) {
    objc.checkOsVersionInternal(
      'NSItemProvider.registerObject:visibility:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_1k745tv(
      _$.ref.pointer,
      _sel_registerObject_visibility_,
      object.ref.pointer,
      visibility.value,
    );
  }

  /// registerObjectOfClass:visibility:loadHandler:
  void registerObjectOfClass(
    NSItemProviderWriting aClass, {
    required NSItemProviderRepresentationVisibility visibility,
    required objc.ObjCBlock<
      NSProgress? Function(
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
        >,
      )
    >
    loadHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSItemProvider.registerObjectOfClass:visibility:loadHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_1pl40xc(
      _$.ref.pointer,
      _sel_registerObjectOfClass_visibility_loadHandler_,
      aClass.ref.pointer,
      visibility.value,
      loadHandler.ref.pointer,
    );
  }

  /// registeredTypeIdentifiers
  NSArray get registeredTypeIdentifiers {
    objc.checkOsVersionInternal(
      'NSItemProvider.registeredTypeIdentifiers',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_registeredTypeIdentifiers,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// registeredTypeIdentifiersWithFileOptions:
  NSArray registeredTypeIdentifiersWithFileOptions(int fileOptions) {
    objc.checkOsVersionInternal(
      'NSItemProvider.registeredTypeIdentifiersWithFileOptions:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_7g3u2y(
      _$.ref.pointer,
      _sel_registeredTypeIdentifiersWithFileOptions_,
      fileOptions,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// setSuggestedName:
  set suggestedName(NSString? value) {
    objc.checkOsVersionInternal(
      'NSItemProvider.setSuggestedName:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setSuggestedName_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// suggestedName
  NSString? get suggestedName {
    objc.checkOsVersionInternal(
      'NSItemProvider.suggestedName',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 14, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_suggestedName);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }
}

sealed class NSItemProviderFileOptions {
  static const NSItemProviderFileOptionOpenInPlace = 1;
}

/// NSItemProviderReading
extension type NSItemProviderReading.castFrom(objc.ObjCProtocolBase _$)
    implements objc.ObjCProtocolBase, NSObjectProtocol {
  /// Constructs a [NSItemProviderReading] that wraps the given raw object pointer.
  NSItemProviderReading.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCProtocolBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSItemProviderReading].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_NSItemProviderReading,
    );
  }
}

extension NSItemProviderReading$Methods on NSItemProviderReading {}

interface class NSItemProviderReading$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_NSItemProviderReading.cast());

  /// Builds an object that implements the NSItemProviderReading protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSItemProviderReading implement({bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'NSItemProviderReading',
    );

    builder.addProtocol($protocol);
    return NSItemProviderReading.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSItemProviderReading protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    bool $keepIsolateAlive = true,
  }) {
    builder.addProtocol($protocol);
  }
}

enum NSItemProviderRepresentationVisibility {
  NSItemProviderRepresentationVisibilityAll(0),
  NSItemProviderRepresentationVisibilityTeam(1),
  NSItemProviderRepresentationVisibilityGroup(2),
  NSItemProviderRepresentationVisibilityOwnProcess(3);

  final int value;
  const NSItemProviderRepresentationVisibility(this.value);

  static NSItemProviderRepresentationVisibility fromValue(int value) =>
      switch (value) {
        0 => NSItemProviderRepresentationVisibilityAll,
        1 => NSItemProviderRepresentationVisibilityTeam,
        2 => NSItemProviderRepresentationVisibilityGroup,
        3 => NSItemProviderRepresentationVisibilityOwnProcess,
        _ => throw ArgumentError(
          'Unknown value for NSItemProviderRepresentationVisibility: $value',
        ),
      };
}

/// NSItemProviderWriting
extension type NSItemProviderWriting.castFrom(objc.ObjCProtocolBase _$)
    implements objc.ObjCProtocolBase, NSObjectProtocol {
  /// Constructs a [NSItemProviderWriting] that wraps the given raw object pointer.
  NSItemProviderWriting.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCProtocolBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSItemProviderWriting].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_NSItemProviderWriting,
    );
  }
}

extension NSItemProviderWriting$Methods on NSItemProviderWriting {
  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  NSItemProviderRepresentationVisibility
  itemProviderVisibilityForRepresentationWithTypeIdentifier(
    NSString typeIdentifier,
  ) {
    objc.checkOsVersionInternal(
      'NSItemProviderWriting.itemProviderVisibilityForRepresentationWithTypeIdentifier:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(
      _$.ref.pointer,
      _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSItemProviderWriting',
        'itemProviderVisibilityForRepresentationWithTypeIdentifier:',
      );
    }
    final $ret = _objc_msgSend_16fy0up(
      _$.ref.pointer,
      _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
      typeIdentifier.ref.pointer,
    );
    return NSItemProviderRepresentationVisibility.fromValue($ret);
  }

  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  NSProgress? loadDataWithTypeIdentifier(
    NSString typeIdentifier, {
    required objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>
    forItemProviderCompletionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSItemProviderWriting.loadDataWithTypeIdentifier:forItemProviderCompletionHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_r0bo0s(
      _$.ref.pointer,
      _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
      typeIdentifier.ref.pointer,
      forItemProviderCompletionHandler.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSProgress.castFromPointer($ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  NSArray get writableTypeIdentifiersForItemProvider {
    objc.checkOsVersionInternal(
      'NSItemProviderWriting.writableTypeIdentifiersForItemProvider',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(
      _$.ref.pointer,
      _sel_writableTypeIdentifiersForItemProvider,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSItemProviderWriting',
        'writableTypeIdentifiersForItemProvider',
      );
    }
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_writableTypeIdentifiersForItemProvider,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }
}

interface class NSItemProviderWriting$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_NSItemProviderWriting.cast());

  /// Builds an object that implements the NSItemProviderWriting protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSItemProviderWriting implement({
    NSItemProviderRepresentationVisibility Function(NSString)?
    itemProviderVisibilityForRepresentationWithTypeIdentifier_,
    required NSProgress? Function(
      NSString,
      objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
    )
    loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
    NSArray Function()? writableTypeIdentifiersForItemProvider,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'NSItemProviderWriting',
    );
    NSItemProviderWriting$Builder
        .itemProviderVisibilityForRepresentationWithTypeIdentifier_
        .implement(
          builder,
          itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        );
    NSItemProviderWriting$Builder
        .loadDataWithTypeIdentifier_forItemProviderCompletionHandler_
        .implement(
          builder,
          loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
        );
    NSItemProviderWriting$Builder.writableTypeIdentifiersForItemProvider
        .implement(builder, writableTypeIdentifiersForItemProvider);
    builder.addProtocol($protocol);
    return NSItemProviderWriting.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSItemProviderWriting protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    NSItemProviderRepresentationVisibility Function(NSString)?
    itemProviderVisibilityForRepresentationWithTypeIdentifier_,
    required NSProgress? Function(
      NSString,
      objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
    )
    loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
    NSArray Function()? writableTypeIdentifiersForItemProvider,
    bool $keepIsolateAlive = true,
  }) {
    NSItemProviderWriting$Builder
        .itemProviderVisibilityForRepresentationWithTypeIdentifier_
        .implement(
          builder,
          itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        );
    NSItemProviderWriting$Builder
        .loadDataWithTypeIdentifier_forItemProviderCompletionHandler_
        .implement(
          builder,
          loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
        );
    NSItemProviderWriting$Builder.writableTypeIdentifiersForItemProvider
        .implement(builder, writableTypeIdentifiersForItemProvider);
    builder.addProtocol($protocol);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  static final itemProviderVisibilityForRepresentationWithTypeIdentifier_ =
      objc.ObjCProtocolMethod<
        NSItemProviderRepresentationVisibility Function(NSString)
      >(
        _protocol_NSItemProviderWriting,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Long Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_1ldqghh)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSItemProviderWriting,
          _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (NSItemProviderRepresentationVisibility Function(NSString) func) =>
            ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString.fromFunction(
              (ffi.Pointer<ffi.Void> _, NSString arg1) => func(arg1),
            ),
      );

  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  static final loadDataWithTypeIdentifier_forItemProviderCompletionHandler_ =
      objc.ObjCProtocolMethod<
        NSProgress? Function(
          NSString,
          objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
        )
      >(
        _protocol_NSItemProviderWriting,
        _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_1q0i84)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSItemProviderWriting,
          _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (
          NSProgress? Function(
            NSString,
            objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
          )
          func,
        ) =>
            ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSString arg1,
                objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)> arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// writableTypeIdentifiersForItemProvider
  static final writableTypeIdentifiersForItemProvider =
      objc.ObjCProtocolMethod<NSArray Function()>(
        _protocol_NSItemProviderWriting,
        _sel_writableTypeIdentifiersForItemProvider,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_1mbt9g9)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSItemProviderWriting,
          _sel_writableTypeIdentifiersForItemProvider,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (NSArray Function() func) => ObjCBlock_NSArray_ffiVoid.fromFunction(
          (ffi.Pointer<ffi.Void> _) => func(),
        ),
      );
}

enum NSKeyValueChange {
  NSKeyValueChangeSetting(1),
  NSKeyValueChangeInsertion(2),
  NSKeyValueChangeRemoval(3),
  NSKeyValueChangeReplacement(4);

  final int value;
  const NSKeyValueChange(this.value);

  static NSKeyValueChange fromValue(int value) => switch (value) {
    1 => NSKeyValueChangeSetting,
    2 => NSKeyValueChangeInsertion,
    3 => NSKeyValueChangeRemoval,
    4 => NSKeyValueChangeReplacement,
    _ => throw ArgumentError('Unknown value for NSKeyValueChange: $value'),
  };
}

sealed class NSKeyValueObservingOptions {
  static const NSKeyValueObservingOptionNew = 1;
  static const NSKeyValueObservingOptionOld = 2;
  static const NSKeyValueObservingOptionInitial = 4;
  static const NSKeyValueObservingOptionPrior = 8;
}

enum NSKeyValueSetMutationKind {
  NSKeyValueUnionSetMutation(1),
  NSKeyValueMinusSetMutation(2),
  NSKeyValueIntersectSetMutation(3),
  NSKeyValueSetSetMutation(4);

  final int value;
  const NSKeyValueSetMutationKind(this.value);

  static NSKeyValueSetMutationKind fromValue(int value) => switch (value) {
    1 => NSKeyValueUnionSetMutation,
    2 => NSKeyValueMinusSetMutation,
    3 => NSKeyValueIntersectSetMutation,
    4 => NSKeyValueSetSetMutation,
    _ => throw ArgumentError(
      'Unknown value for NSKeyValueSetMutationKind: $value',
    ),
  };
}

sealed class NSLinguisticTaggerOptions {
  static const NSLinguisticTaggerOmitWords = 1;
  static const NSLinguisticTaggerOmitPunctuation = 2;
  static const NSLinguisticTaggerOmitWhitespace = 4;
  static const NSLinguisticTaggerOmitOther = 8;
  static const NSLinguisticTaggerJoinNames = 16;
}

/// NSLocale
extension type NSLocale.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject, NSCopying, NSSecureCoding {
  /// Constructs a [NSLocale] that wraps the given raw object pointer.
  NSLocale.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSLocale].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSLocale,
    );
  }

  /// alloc
  static NSLocale alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSLocale, _sel_alloc);
    return NSLocale.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSLocale allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSLocale,
      _sel_allocWithZone_,
      zone,
    );
    return NSLocale.castFromPointer($ret, retain: false, release: true);
  }

  /// localeWithLocaleIdentifier:
  static NSLocale localeWithLocaleIdentifier(NSString ident) {
    objc.checkOsVersionInternal(
      'NSLocale.localeWithLocaleIdentifier:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSLocale,
      _sel_localeWithLocaleIdentifier_,
      ident.ref.pointer,
    );
    return NSLocale.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSLocale new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSLocale, _sel_new);
    return NSLocale.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSLocale, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSLocale constructed with the default `new` method.
  NSLocale() : this.castFrom(new$()._$);
}

extension NSLocale$Methods on NSLocale {
  /// displayNameForKey:value:
  NSString? displayNameForKey(
    NSString key, {
    required objc.ObjCObjectBase value,
  }) {
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.pointer,
      _sel_displayNameForKey_value_,
      key.ref.pointer,
      value.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  NSLocale init() {
    objc.checkOsVersionInternal(
      'NSLocale.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSLocale.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSLocale? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSLocale.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithLocaleIdentifier:
  NSLocale initWithLocaleIdentifier(NSString string) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithLocaleIdentifier_,
      string.ref.pointer,
    );
    return NSLocale.castFromPointer($ret, retain: false, release: true);
  }

  /// objectForKey:
  objc.ObjCObjectBase? objectForKey(NSString key) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_objectForKey_,
      key.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }
}

enum NSLocaleLanguageDirection {
  NSLocaleLanguageDirectionUnknown(0),
  NSLocaleLanguageDirectionLeftToRight(1),
  NSLocaleLanguageDirectionRightToLeft(2),
  NSLocaleLanguageDirectionTopToBottom(3),
  NSLocaleLanguageDirectionBottomToTop(4);

  final int value;
  const NSLocaleLanguageDirection(this.value);

  static NSLocaleLanguageDirection fromValue(int value) => switch (value) {
    0 => NSLocaleLanguageDirectionUnknown,
    1 => NSLocaleLanguageDirectionLeftToRight,
    2 => NSLocaleLanguageDirectionRightToLeft,
    3 => NSLocaleLanguageDirectionTopToBottom,
    4 => NSLocaleLanguageDirectionBottomToTop,
    _ => throw ArgumentError(
      'Unknown value for NSLocaleLanguageDirection: $value',
    ),
  };
}

/// NSMethodSignature
extension type NSMethodSignature.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [NSMethodSignature] that wraps the given raw object pointer.
  NSMethodSignature.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSMethodSignature].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSMethodSignature,
    );
  }

  /// alloc
  static NSMethodSignature alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSMethodSignature, _sel_alloc);
    return NSMethodSignature.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NSMethodSignature allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSMethodSignature,
      _sel_allocWithZone_,
      zone,
    );
    return NSMethodSignature.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static NSMethodSignature new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSMethodSignature, _sel_new);
    return NSMethodSignature.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// signatureWithObjCTypes:
  static NSMethodSignature? signatureWithObjCTypes(
    ffi.Pointer<ffi.Char> types,
  ) {
    final $ret = _objc_msgSend_56zxyn(
      _class_NSMethodSignature,
      _sel_signatureWithObjCTypes_,
      types,
    );
    return $ret.address == 0
        ? null
        : NSMethodSignature.castFromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of NSMethodSignature constructed with the default `new` method.
  NSMethodSignature() : this.castFrom(new$()._$);
}

extension NSMethodSignature$Methods on NSMethodSignature {
  /// frameLength
  int get frameLength {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_frameLength);
  }

  /// getArgumentTypeAtIndex:
  ffi.Pointer<ffi.Char> getArgumentTypeAtIndex(int idx) {
    return _objc_msgSend_1jtxufi(
      _$.ref.pointer,
      _sel_getArgumentTypeAtIndex_,
      idx,
    );
  }

  /// init
  NSMethodSignature init() {
    objc.checkOsVersionInternal(
      'NSMethodSignature.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSMethodSignature.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// isOneway
  bool isOneway() {
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isOneway);
  }

  /// methodReturnLength
  int get methodReturnLength {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_methodReturnLength);
  }

  /// methodReturnType
  ffi.Pointer<ffi.Char> get methodReturnType {
    return _objc_msgSend_1fuqfwb(_$.ref.pointer, _sel_methodReturnType);
  }

  /// numberOfArguments
  int get numberOfArguments {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_numberOfArguments);
  }
}

/// NSMutableArray
extension type NSMutableArray.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSArray {
  /// Constructs a [NSMutableArray] that wraps the given raw object pointer.
  NSMutableArray.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSMutableArray].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSMutableArray,
    );
  }

  /// alloc
  static NSMutableArray alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableArray, _sel_alloc);
    return NSMutableArray.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSMutableArray allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSMutableArray,
      _sel_allocWithZone_,
      zone,
    );
    return NSMutableArray.castFromPointer($ret, retain: false, release: true);
  }

  /// array
  static NSMutableArray array() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableArray, _sel_array);
    return NSMutableArray.castFromPointer($ret, retain: true, release: true);
  }

  /// arrayWithArray:
  static NSMutableArray arrayWithArray(NSArray array) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableArray,
      _sel_arrayWithArray_,
      array.ref.pointer,
    );
    return NSMutableArray.castFromPointer($ret, retain: true, release: true);
  }

  /// arrayWithCapacity:
  static NSMutableArray arrayWithCapacity(int numItems) {
    final $ret = _objc_msgSend_14hpxwa(
      _class_NSMutableArray,
      _sel_arrayWithCapacity_,
      numItems,
    );
    return NSMutableArray.castFromPointer($ret, retain: true, release: true);
  }

  /// arrayWithObject:
  static NSMutableArray arrayWithObject(objc.ObjCObjectBase anObject) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableArray,
      _sel_arrayWithObject_,
      anObject.ref.pointer,
    );
    return NSMutableArray.castFromPointer($ret, retain: true, release: true);
  }

  /// arrayWithObjects:
  static NSMutableArray arrayWithObjects(objc.ObjCObjectBase firstObj) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableArray,
      _sel_arrayWithObjects_,
      firstObj.ref.pointer,
    );
    return NSMutableArray.castFromPointer($ret, retain: true, release: true);
  }

  /// arrayWithObjects:count:
  static NSMutableArray arrayWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required int count,
  }) {
    final $ret = _objc_msgSend_zmbtbd(
      _class_NSMutableArray,
      _sel_arrayWithObjects_count_,
      objects,
      count,
    );
    return NSMutableArray.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSMutableArray new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableArray, _sel_new);
    return NSMutableArray.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_NSMutableArray,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of NSMutableArray constructed with the default `new` method.
  NSMutableArray() : this.castFrom(new$()._$);
}

extension NSMutableArray$Methods on NSMutableArray {
  /// addObject:
  void addObject(objc.ObjCObjectBase anObject) {
    _objc_msgSend_xtuoz7(_$.ref.pointer, _sel_addObject_, anObject.ref.pointer);
  }

  /// init
  NSMutableArray init() {
    objc.checkOsVersionInternal(
      'NSMutableArray.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSMutableArray.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithArray:
  NSMutableArray initWithArray(NSArray array) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithArray_,
      array.ref.pointer,
    );
    return NSMutableArray.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithArray:copyItems:
  NSMutableArray initWithArray$1(NSArray array, {required bool copyItems}) {
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithArray_copyItems_,
      array.ref.pointer,
      copyItems,
    );
    return NSMutableArray.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCapacity:
  NSMutableArray initWithCapacity(int numItems) {
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCapacity_,
      numItems,
    );
    return NSMutableArray.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSMutableArray? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSMutableArray.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObjects:
  NSMutableArray initWithObjects(objc.ObjCObjectBase firstObj) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_,
      firstObj.ref.pointer,
    );
    return NSMutableArray.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObjects:count:
  NSMutableArray initWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required int count,
  }) {
    final $ret = _objc_msgSend_zmbtbd(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_count_,
      objects,
      count,
    );
    return NSMutableArray.castFromPointer($ret, retain: false, release: true);
  }

  /// insertObject:atIndex:
  void insertObject(objc.ObjCObjectBase anObject, {required int atIndex}) {
    _objc_msgSend_djsa9o(
      _$.ref.pointer,
      _sel_insertObject_atIndex_,
      anObject.ref.pointer,
      atIndex,
    );
  }

  /// removeLastObject
  void removeLastObject() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_removeLastObject);
  }

  /// removeObjectAtIndex:
  void removeObjectAtIndex(int index) {
    _objc_msgSend_1i9r4xy(_$.ref.pointer, _sel_removeObjectAtIndex_, index);
  }

  /// replaceObjectAtIndex:withObject:
  void replaceObjectAtIndex(
    int index, {
    required objc.ObjCObjectBase withObject,
  }) {
    _objc_msgSend_1gypgok(
      _$.ref.pointer,
      _sel_replaceObjectAtIndex_withObject_,
      index,
      withObject.ref.pointer,
    );
  }
}

/// NSMutableCopying
extension type NSMutableCopying.castFrom(objc.ObjCProtocolBase _$)
    implements objc.ObjCProtocolBase {
  /// Constructs a [NSMutableCopying] that wraps the given raw object pointer.
  NSMutableCopying.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCProtocolBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSMutableCopying].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_NSMutableCopying,
    );
  }
}

extension NSMutableCopying$Methods on NSMutableCopying {
  /// mutableCopyWithZone:
  objc.ObjCObjectBase mutableCopyWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _$.ref.pointer,
      _sel_mutableCopyWithZone_,
      zone,
    );
    return objc.ObjCObjectBase($ret, retain: false, release: true);
  }
}

interface class NSMutableCopying$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_NSMutableCopying.cast());

  /// Builds an object that implements the NSMutableCopying protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSMutableCopying implement({
    required objc.ObjCObjectBase Function(ffi.Pointer<NSZone>)
    mutableCopyWithZone_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSMutableCopying');
    NSMutableCopying$Builder.mutableCopyWithZone_.implement(
      builder,
      mutableCopyWithZone_,
    );
    builder.addProtocol($protocol);
    return NSMutableCopying.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSMutableCopying protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    required objc.ObjCObjectBase Function(ffi.Pointer<NSZone>)
    mutableCopyWithZone_,
    bool $keepIsolateAlive = true,
  }) {
    NSMutableCopying$Builder.mutableCopyWithZone_.implement(
      builder,
      mutableCopyWithZone_,
    );
    builder.addProtocol($protocol);
  }

  /// mutableCopyWithZone:
  static final mutableCopyWithZone_ =
      objc.ObjCProtocolMethod<
        objc.ObjCObjectBase Function(ffi.Pointer<NSZone>)
      >(
        _protocol_NSMutableCopying,
        _sel_mutableCopyWithZone_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<NSZone>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_18nsem0)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSMutableCopying,
          _sel_mutableCopyWithZone_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (objc.ObjCObjectBase Function(ffi.Pointer<NSZone>) func) =>
            ObjCBlock_objcObjCObject_ffiVoid_NSZone.fromFunction(
              (ffi.Pointer<ffi.Void> _, ffi.Pointer<NSZone> arg1) => func(arg1),
            ),
      );
}

/// NSMutableData
extension type NSMutableData.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSData {
  /// Constructs a [NSMutableData] that wraps the given raw object pointer.
  NSMutableData.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSMutableData].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSMutableData,
    );
  }

  /// alloc
  static NSMutableData alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableData, _sel_alloc);
    return NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSMutableData allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSMutableData,
      _sel_allocWithZone_,
      zone,
    );
    return NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// data
  static NSMutableData data() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableData, _sel_data);
    return NSMutableData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithBytes:length:
  static NSMutableData dataWithBytes(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
  }) {
    final $ret = _objc_msgSend_3nbx5e(
      _class_NSMutableData,
      _sel_dataWithBytes_length_,
      bytes,
      length,
    );
    return NSMutableData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithBytesNoCopy:length:
  static NSMutableData dataWithBytesNoCopy(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
  }) {
    final $ret = _objc_msgSend_3nbx5e(
      _class_NSMutableData,
      _sel_dataWithBytesNoCopy_length_,
      bytes,
      length,
    );
    return NSMutableData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithBytesNoCopy:length:freeWhenDone:
  static NSMutableData dataWithBytesNoCopy$1(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
    required bool freeWhenDone,
  }) {
    final $ret = _objc_msgSend_161ne8y(
      _class_NSMutableData,
      _sel_dataWithBytesNoCopy_length_freeWhenDone_,
      bytes,
      length,
      freeWhenDone,
    );
    return NSMutableData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithCapacity:
  static NSMutableData? dataWithCapacity(int aNumItems) {
    final $ret = _objc_msgSend_14hpxwa(
      _class_NSMutableData,
      _sel_dataWithCapacity_,
      aNumItems,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithContentsOfFile:
  static NSMutableData? dataWithContentsOfFile(NSString path) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableData,
      _sel_dataWithContentsOfFile_,
      path.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithContentsOfFile:options:error:
  static NSMutableData? dataWithContentsOfFile$1(
    NSString path, {
    required int options,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_8321cp(
      _class_NSMutableData,
      _sel_dataWithContentsOfFile_options_error_,
      path.ref.pointer,
      options,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithContentsOfURL:
  static NSMutableData? dataWithContentsOfURL(NSURL url) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableData,
      _sel_dataWithContentsOfURL_,
      url.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithContentsOfURL:options:error:
  static NSMutableData? dataWithContentsOfURL$1(
    NSURL url, {
    required int options,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_8321cp(
      _class_NSMutableData,
      _sel_dataWithContentsOfURL_options_error_,
      url.ref.pointer,
      options,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithData:
  static NSMutableData dataWithData(NSData data) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableData,
      _sel_dataWithData_,
      data.ref.pointer,
    );
    return NSMutableData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataWithLength:
  static NSMutableData? dataWithLength(int length) {
    final $ret = _objc_msgSend_14hpxwa(
      _class_NSMutableData,
      _sel_dataWithLength_,
      length,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSMutableData new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableData, _sel_new);
    return NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_NSMutableData,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of NSMutableData constructed with the default `new` method.
  NSMutableData() : this.castFrom(new$()._$);
}

extension NSMutableData$Methods on NSMutableData {
  /// compressedDataUsingAlgorithm:error:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  NSMutableData? compressedDataUsingAlgorithm(
    NSDataCompressionAlgorithm algorithm, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableData.compressedDataUsingAlgorithm:error:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1vnlaqg(
      _$.ref.pointer,
      _sel_compressedDataUsingAlgorithm_error_,
      algorithm.value,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: true, release: true);
  }

  /// decompressedDataUsingAlgorithm:error:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  NSMutableData? decompressedDataUsingAlgorithm(
    NSDataCompressionAlgorithm algorithm, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableData.decompressedDataUsingAlgorithm:error:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1vnlaqg(
      _$.ref.pointer,
      _sel_decompressedDataUsingAlgorithm_error_,
      algorithm.value,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  NSMutableData init() {
    objc.checkOsVersionInternal(
      'NSMutableData.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBase64EncodedData:options:
  NSMutableData? initWithBase64EncodedData(
    NSData base64Data, {
    required int options,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableData.initWithBase64EncodedData:options:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_7kpg7m(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBase64EncodedData_options_,
      base64Data.ref.pointer,
      options,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBase64EncodedString:options:
  NSMutableData? initWithBase64EncodedString(
    NSString base64String, {
    required int options,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableData.initWithBase64EncodedString:options:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_7kpg7m(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBase64EncodedString_options_,
      base64String.ref.pointer,
      options,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytes:length:
  NSMutableData initWithBytes(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
  }) {
    final $ret = _objc_msgSend_3nbx5e(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytes_length_,
      bytes,
      length,
    );
    return NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytesNoCopy:length:
  NSMutableData initWithBytesNoCopy(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
  }) {
    final $ret = _objc_msgSend_3nbx5e(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytesNoCopy_length_,
      bytes,
      length,
    );
    return NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytesNoCopy:length:deallocator:
  NSMutableData initWithBytesNoCopy$1(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>?
    deallocator,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableData.initWithBytesNoCopy:length:deallocator:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_134vhyh(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytesNoCopy_length_deallocator_,
      bytes,
      length,
      deallocator?.ref.pointer ?? ffi.nullptr,
    );
    return NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytesNoCopy:length:freeWhenDone:
  NSMutableData initWithBytesNoCopy$2(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
    required bool freeWhenDone,
  }) {
    final $ret = _objc_msgSend_161ne8y(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytesNoCopy_length_freeWhenDone_,
      bytes,
      length,
      freeWhenDone,
    );
    return NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCapacity:
  NSMutableData? initWithCapacity(int capacity) {
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCapacity_,
      capacity,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSMutableData? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfFile:
  NSMutableData? initWithContentsOfFile(NSString path) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfFile_,
      path.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfFile:options:error:
  NSMutableData? initWithContentsOfFile$1(
    NSString path, {
    required int options,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_8321cp(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfFile_options_error_,
      path.ref.pointer,
      options,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:
  NSMutableData? initWithContentsOfURL(NSURL url) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfURL_,
      url.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:options:error:
  NSMutableData? initWithContentsOfURL$1(
    NSURL url, {
    required int options,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_8321cp(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfURL_options_error_,
      url.ref.pointer,
      options,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithData:
  NSMutableData initWithData(NSData data) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithData_,
      data.ref.pointer,
    );
    return NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithLength:
  NSMutableData? initWithLength(int length) {
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithLength_,
      length,
    );
    return $ret.address == 0
        ? null
        : NSMutableData.castFromPointer($ret, retain: false, release: true);
  }

  /// length
  int get length {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_length);
  }

  /// mutableBytes
  ffi.Pointer<ffi.Void> get mutableBytes {
    return _objc_msgSend_6ex6p5(_$.ref.pointer, _sel_mutableBytes);
  }

  /// setLength:
  set length$1(int value) {
    _objc_msgSend_1i9r4xy(_$.ref.pointer, _sel_setLength_, value);
  }
}

/// NSMutableDictionary
extension type NSMutableDictionary.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSDictionary {
  /// Constructs a [NSMutableDictionary] that wraps the given raw object pointer.
  NSMutableDictionary.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSMutableDictionary].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSMutableDictionary,
    );
  }

  /// alloc
  static NSMutableDictionary alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableDictionary, _sel_alloc);
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NSMutableDictionary allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSMutableDictionary,
      _sel_allocWithZone_,
      zone,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// dictionary
  static NSMutableDictionary dictionary() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSMutableDictionary,
      _sel_dictionary,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// dictionaryWithCapacity:
  static NSMutableDictionary dictionaryWithCapacity(int numItems) {
    final $ret = _objc_msgSend_14hpxwa(
      _class_NSMutableDictionary,
      _sel_dictionaryWithCapacity_,
      numItems,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// dictionaryWithDictionary:
  static NSMutableDictionary dictionaryWithDictionary(NSDictionary dict) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableDictionary,
      _sel_dictionaryWithDictionary_,
      dict.ref.pointer,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// dictionaryWithObject:forKey:
  static NSMutableDictionary dictionaryWithObject(
    objc.ObjCObjectBase object, {
    required NSCopying forKey,
  }) {
    final $ret = _objc_msgSend_15qeuct(
      _class_NSMutableDictionary,
      _sel_dictionaryWithObject_forKey_,
      object.ref.pointer,
      forKey.ref.pointer,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// dictionaryWithObjects:forKeys:
  static NSMutableDictionary dictionaryWithObjects(
    NSArray objects, {
    required NSArray forKeys,
  }) {
    final $ret = _objc_msgSend_15qeuct(
      _class_NSMutableDictionary,
      _sel_dictionaryWithObjects_forKeys_,
      objects.ref.pointer,
      forKeys.ref.pointer,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// dictionaryWithObjects:forKeys:count:
  static NSMutableDictionary dictionaryWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> forKeys,
    required int count,
  }) {
    final $ret = _objc_msgSend_1dydpdi(
      _class_NSMutableDictionary,
      _sel_dictionaryWithObjects_forKeys_count_,
      objects,
      forKeys,
      count,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// dictionaryWithObjectsAndKeys:
  static NSMutableDictionary dictionaryWithObjectsAndKeys(
    objc.ObjCObjectBase firstObject,
  ) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableDictionary,
      _sel_dictionaryWithObjectsAndKeys_,
      firstObject.ref.pointer,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// new
  static NSMutableDictionary new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableDictionary, _sel_new);
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_NSMutableDictionary,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of NSMutableDictionary constructed with the default `new` method.
  NSMutableDictionary() : this.castFrom(new$()._$);
}

extension NSMutableDictionary$Methods on NSMutableDictionary {
  /// init
  NSMutableDictionary init() {
    objc.checkOsVersionInternal(
      'NSMutableDictionary.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCapacity:
  NSMutableDictionary initWithCapacity(int numItems) {
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCapacity_,
      numItems,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCoder:
  NSMutableDictionary? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSMutableDictionary.castFromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// initWithDictionary:
  NSMutableDictionary initWithDictionary(NSDictionary otherDictionary) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithDictionary_,
      otherDictionary.ref.pointer,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithDictionary:copyItems:
  NSMutableDictionary initWithDictionary$1(
    NSDictionary otherDictionary, {
    required bool copyItems,
  }) {
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithDictionary_copyItems_,
      otherDictionary.ref.pointer,
      copyItems,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithObjects:forKeys:
  NSMutableDictionary initWithObjects(
    NSArray objects, {
    required NSArray forKeys,
  }) {
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_forKeys_,
      objects.ref.pointer,
      forKeys.ref.pointer,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithObjects:forKeys:count:
  NSMutableDictionary initWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> forKeys,
    required int count,
  }) {
    final $ret = _objc_msgSend_1dydpdi(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_forKeys_count_,
      objects,
      forKeys,
      count,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithObjectsAndKeys:
  NSMutableDictionary initWithObjectsAndKeys(objc.ObjCObjectBase firstObject) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjectsAndKeys_,
      firstObject.ref.pointer,
    );
    return NSMutableDictionary.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// removeObjectForKey:
  void removeObjectForKey(objc.ObjCObjectBase aKey) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_removeObjectForKey_,
      aKey.ref.pointer,
    );
  }

  /// setObject:forKey:
  void setObject(objc.ObjCObjectBase anObject, {required NSCopying forKey}) {
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_setObject_forKey_,
      anObject.ref.pointer,
      forKey.ref.pointer,
    );
  }
}

/// NSMutableIndexSet
extension type NSMutableIndexSet.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSIndexSet {
  /// Constructs a [NSMutableIndexSet] that wraps the given raw object pointer.
  NSMutableIndexSet.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSMutableIndexSet].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSMutableIndexSet,
    );
  }

  /// alloc
  static NSMutableIndexSet alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableIndexSet, _sel_alloc);
    return NSMutableIndexSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NSMutableIndexSet allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSMutableIndexSet,
      _sel_allocWithZone_,
      zone,
    );
    return NSMutableIndexSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// indexSet
  static NSMutableIndexSet indexSet() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableIndexSet, _sel_indexSet);
    return NSMutableIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// indexSetWithIndex:
  static NSMutableIndexSet indexSetWithIndex(int value) {
    final $ret = _objc_msgSend_14hpxwa(
      _class_NSMutableIndexSet,
      _sel_indexSetWithIndex_,
      value,
    );
    return NSMutableIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// indexSetWithIndexesInRange:
  static NSMutableIndexSet indexSetWithIndexesInRange(NSRange range) {
    final $ret = _objc_msgSend_1k1o1s7(
      _class_NSMutableIndexSet,
      _sel_indexSetWithIndexesInRange_,
      range,
    );
    return NSMutableIndexSet.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSMutableIndexSet new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableIndexSet, _sel_new);
    return NSMutableIndexSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_NSMutableIndexSet,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of NSMutableIndexSet constructed with the default `new` method.
  NSMutableIndexSet() : this.castFrom(new$()._$);
}

extension NSMutableIndexSet$Methods on NSMutableIndexSet {
  /// addIndex:
  void addIndex(int value) {
    _objc_msgSend_1i9r4xy(_$.ref.pointer, _sel_addIndex_, value);
  }

  /// addIndexes:
  void addIndexes(NSIndexSet indexSet) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_addIndexes_,
      indexSet.ref.pointer,
    );
  }

  /// addIndexesInRange:
  void addIndexesInRange(NSRange range) {
    _objc_msgSend_1e3pm0z(_$.ref.pointer, _sel_addIndexesInRange_, range);
  }

  /// init
  NSMutableIndexSet init() {
    objc.checkOsVersionInternal(
      'NSMutableIndexSet.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSMutableIndexSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCoder:
  NSMutableIndexSet? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSMutableIndexSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithIndex:
  NSMutableIndexSet initWithIndex(int value) {
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithIndex_,
      value,
    );
    return NSMutableIndexSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithIndexSet:
  NSMutableIndexSet initWithIndexSet(NSIndexSet indexSet) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithIndexSet_,
      indexSet.ref.pointer,
    );
    return NSMutableIndexSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithIndexesInRange:
  NSMutableIndexSet initWithIndexesInRange(NSRange range) {
    final $ret = _objc_msgSend_1k1o1s7(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithIndexesInRange_,
      range,
    );
    return NSMutableIndexSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// removeAllIndexes
  void removeAllIndexes() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_removeAllIndexes);
  }

  /// removeIndex:
  void removeIndex(int value) {
    _objc_msgSend_1i9r4xy(_$.ref.pointer, _sel_removeIndex_, value);
  }

  /// removeIndexes:
  void removeIndexes(NSIndexSet indexSet) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_removeIndexes_,
      indexSet.ref.pointer,
    );
  }

  /// removeIndexesInRange:
  void removeIndexesInRange(NSRange range) {
    _objc_msgSend_1e3pm0z(_$.ref.pointer, _sel_removeIndexesInRange_, range);
  }

  /// shiftIndexesStartingAtIndex:by:
  void shiftIndexesStartingAtIndex(int index, {required int by}) {
    _objc_msgSend_otx1t4(
      _$.ref.pointer,
      _sel_shiftIndexesStartingAtIndex_by_,
      index,
      by,
    );
  }
}

/// NSMutableOrderedSet
extension type NSMutableOrderedSet.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSOrderedSet {
  /// Constructs a [NSMutableOrderedSet] that wraps the given raw object pointer.
  NSMutableOrderedSet.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSMutableOrderedSet].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSMutableOrderedSet,
    );
  }

  /// alloc
  static NSMutableOrderedSet alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableOrderedSet, _sel_alloc);
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NSMutableOrderedSet allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSMutableOrderedSet,
      _sel_allocWithZone_,
      zone,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static NSMutableOrderedSet new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableOrderedSet, _sel_new);
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// orderedSet
  static NSMutableOrderedSet orderedSet() {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.orderedSet',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _class_NSMutableOrderedSet,
      _sel_orderedSet,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// orderedSetWithArray:
  static NSMutableOrderedSet orderedSetWithArray(NSArray array) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.orderedSetWithArray:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableOrderedSet,
      _sel_orderedSetWithArray_,
      array.ref.pointer,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// orderedSetWithArray:range:copyItems:
  static NSMutableOrderedSet orderedSetWithArray$1(
    NSArray array, {
    required NSRange range,
    required bool copyItems,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.orderedSetWithArray:range:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_w9bq5x(
      _class_NSMutableOrderedSet,
      _sel_orderedSetWithArray_range_copyItems_,
      array.ref.pointer,
      range,
      copyItems,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// orderedSetWithCapacity:
  static NSMutableOrderedSet orderedSetWithCapacity(int numItems) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.orderedSetWithCapacity:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_14hpxwa(
      _class_NSMutableOrderedSet,
      _sel_orderedSetWithCapacity_,
      numItems,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// orderedSetWithObject:
  static NSMutableOrderedSet orderedSetWithObject(objc.ObjCObjectBase object) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.orderedSetWithObject:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableOrderedSet,
      _sel_orderedSetWithObject_,
      object.ref.pointer,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// orderedSetWithObjects:
  static NSMutableOrderedSet orderedSetWithObjects(
    objc.ObjCObjectBase firstObj,
  ) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.orderedSetWithObjects:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableOrderedSet,
      _sel_orderedSetWithObjects_,
      firstObj.ref.pointer,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// orderedSetWithObjects:count:
  static NSMutableOrderedSet orderedSetWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required int count,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.orderedSetWithObjects:count:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_zmbtbd(
      _class_NSMutableOrderedSet,
      _sel_orderedSetWithObjects_count_,
      objects,
      count,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// orderedSetWithOrderedSet:
  static NSMutableOrderedSet orderedSetWithOrderedSet(NSOrderedSet set) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.orderedSetWithOrderedSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableOrderedSet,
      _sel_orderedSetWithOrderedSet_,
      set.ref.pointer,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// orderedSetWithOrderedSet:range:copyItems:
  static NSMutableOrderedSet orderedSetWithOrderedSet$1(
    NSOrderedSet set, {
    required NSRange range,
    required bool copyItems,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.orderedSetWithOrderedSet:range:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_w9bq5x(
      _class_NSMutableOrderedSet,
      _sel_orderedSetWithOrderedSet_range_copyItems_,
      set.ref.pointer,
      range,
      copyItems,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// orderedSetWithSet:
  static NSMutableOrderedSet orderedSetWithSet(NSSet set) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.orderedSetWithSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableOrderedSet,
      _sel_orderedSetWithSet_,
      set.ref.pointer,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// orderedSetWithSet:copyItems:
  static NSMutableOrderedSet orderedSetWithSet$1(
    NSSet set, {
    required bool copyItems,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.orderedSetWithSet:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _class_NSMutableOrderedSet,
      _sel_orderedSetWithSet_copyItems_,
      set.ref.pointer,
      copyItems,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_NSMutableOrderedSet,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of NSMutableOrderedSet constructed with the default `new` method.
  NSMutableOrderedSet() : this.castFrom(new$()._$);
}

extension NSMutableOrderedSet$Methods on NSMutableOrderedSet {
  /// init
  NSMutableOrderedSet init() {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithArray:
  NSMutableOrderedSet initWithArray(NSArray array) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.initWithArray:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithArray_,
      array.ref.pointer,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithArray:copyItems:
  NSMutableOrderedSet initWithArray$1(NSArray set, {required bool copyItems}) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.initWithArray:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithArray_copyItems_,
      set.ref.pointer,
      copyItems,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithArray:range:copyItems:
  NSMutableOrderedSet initWithArray$2(
    NSArray set, {
    required NSRange range,
    required bool copyItems,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.initWithArray:range:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_w9bq5x(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithArray_range_copyItems_,
      set.ref.pointer,
      range,
      copyItems,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCapacity:
  NSMutableOrderedSet initWithCapacity(int numItems) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.initWithCapacity:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCapacity_,
      numItems,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCoder:
  NSMutableOrderedSet? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSMutableOrderedSet.castFromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// initWithObject:
  NSMutableOrderedSet initWithObject(objc.ObjCObjectBase object) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.initWithObject:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObject_,
      object.ref.pointer,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithObjects:
  NSMutableOrderedSet initWithObjects(objc.ObjCObjectBase firstObj) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.initWithObjects:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_,
      firstObj.ref.pointer,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithObjects:count:
  NSMutableOrderedSet initWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required int count,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.initWithObjects:count:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_zmbtbd(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_count_,
      objects,
      count,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithOrderedSet:
  NSMutableOrderedSet initWithOrderedSet(NSOrderedSet set) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.initWithOrderedSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithOrderedSet_,
      set.ref.pointer,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithOrderedSet:copyItems:
  NSMutableOrderedSet initWithOrderedSet$1(
    NSOrderedSet set, {
    required bool copyItems,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.initWithOrderedSet:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithOrderedSet_copyItems_,
      set.ref.pointer,
      copyItems,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithOrderedSet:range:copyItems:
  NSMutableOrderedSet initWithOrderedSet$2(
    NSOrderedSet set, {
    required NSRange range,
    required bool copyItems,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.initWithOrderedSet:range:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_w9bq5x(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithOrderedSet_range_copyItems_,
      set.ref.pointer,
      range,
      copyItems,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithSet:
  NSMutableOrderedSet initWithSet(NSSet set) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.initWithSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithSet_,
      set.ref.pointer,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithSet:copyItems:
  NSMutableOrderedSet initWithSet$1(NSSet set, {required bool copyItems}) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.initWithSet:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithSet_copyItems_,
      set.ref.pointer,
      copyItems,
    );
    return NSMutableOrderedSet.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// insertObject:atIndex:
  void insertObject(objc.ObjCObjectBase object, {required int atIndex}) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.insertObject:atIndex:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_djsa9o(
      _$.ref.pointer,
      _sel_insertObject_atIndex_,
      object.ref.pointer,
      atIndex,
    );
  }

  /// removeObjectAtIndex:
  void removeObjectAtIndex(int idx) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.removeObjectAtIndex:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1i9r4xy(_$.ref.pointer, _sel_removeObjectAtIndex_, idx);
  }

  /// replaceObjectAtIndex:withObject:
  void replaceObjectAtIndex(
    int idx, {
    required objc.ObjCObjectBase withObject,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableOrderedSet.replaceObjectAtIndex:withObject:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1gypgok(
      _$.ref.pointer,
      _sel_replaceObjectAtIndex_withObject_,
      idx,
      withObject.ref.pointer,
    );
  }
}

/// NSMutableSet
extension type NSMutableSet.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSSet {
  /// Constructs a [NSMutableSet] that wraps the given raw object pointer.
  NSMutableSet.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSMutableSet].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSMutableSet,
    );
  }

  /// alloc
  static NSMutableSet alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableSet, _sel_alloc);
    return NSMutableSet.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSMutableSet allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSMutableSet,
      _sel_allocWithZone_,
      zone,
    );
    return NSMutableSet.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSMutableSet new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableSet, _sel_new);
    return NSMutableSet.castFromPointer($ret, retain: false, release: true);
  }

  /// set
  static NSMutableSet set() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableSet, _sel_set);
    return NSMutableSet.castFromPointer($ret, retain: true, release: true);
  }

  /// setWithArray:
  static NSMutableSet setWithArray(NSArray array) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableSet,
      _sel_setWithArray_,
      array.ref.pointer,
    );
    return NSMutableSet.castFromPointer($ret, retain: true, release: true);
  }

  /// setWithCapacity:
  static NSMutableSet setWithCapacity(int numItems) {
    final $ret = _objc_msgSend_14hpxwa(
      _class_NSMutableSet,
      _sel_setWithCapacity_,
      numItems,
    );
    return NSMutableSet.castFromPointer($ret, retain: true, release: true);
  }

  /// setWithObject:
  static NSMutableSet setWithObject(objc.ObjCObjectBase object) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableSet,
      _sel_setWithObject_,
      object.ref.pointer,
    );
    return NSMutableSet.castFromPointer($ret, retain: true, release: true);
  }

  /// setWithObjects:
  static NSMutableSet setWithObjects(objc.ObjCObjectBase firstObj) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableSet,
      _sel_setWithObjects_,
      firstObj.ref.pointer,
    );
    return NSMutableSet.castFromPointer($ret, retain: true, release: true);
  }

  /// setWithObjects:count:
  static NSMutableSet setWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required int count,
  }) {
    final $ret = _objc_msgSend_zmbtbd(
      _class_NSMutableSet,
      _sel_setWithObjects_count_,
      objects,
      count,
    );
    return NSMutableSet.castFromPointer($ret, retain: true, release: true);
  }

  /// setWithSet:
  static NSMutableSet setWithSet(NSSet set) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableSet,
      _sel_setWithSet_,
      set.ref.pointer,
    );
    return NSMutableSet.castFromPointer($ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSMutableSet, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSMutableSet constructed with the default `new` method.
  NSMutableSet() : this.castFrom(new$()._$);
}

extension NSMutableSet$Methods on NSMutableSet {
  /// addObject:
  void addObject(objc.ObjCObjectBase object) {
    _objc_msgSend_xtuoz7(_$.ref.pointer, _sel_addObject_, object.ref.pointer);
  }

  /// init
  NSMutableSet init() {
    objc.checkOsVersionInternal(
      'NSMutableSet.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSMutableSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithArray:
  NSMutableSet initWithArray(NSArray array) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithArray_,
      array.ref.pointer,
    );
    return NSMutableSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCapacity:
  NSMutableSet initWithCapacity(int numItems) {
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCapacity_,
      numItems,
    );
    return NSMutableSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSMutableSet? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSMutableSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObjects:
  NSMutableSet initWithObjects(objc.ObjCObjectBase firstObj) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_,
      firstObj.ref.pointer,
    );
    return NSMutableSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObjects:count:
  NSMutableSet initWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required int count,
  }) {
    final $ret = _objc_msgSend_zmbtbd(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_count_,
      objects,
      count,
    );
    return NSMutableSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithSet:
  NSMutableSet initWithSet(NSSet set) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithSet_,
      set.ref.pointer,
    );
    return NSMutableSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithSet:copyItems:
  NSMutableSet initWithSet$1(NSSet set, {required bool copyItems}) {
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithSet_copyItems_,
      set.ref.pointer,
      copyItems,
    );
    return NSMutableSet.castFromPointer($ret, retain: false, release: true);
  }

  /// removeObject:
  void removeObject(objc.ObjCObjectBase object) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_removeObject_,
      object.ref.pointer,
    );
  }
}

/// NSMutableString
extension type NSMutableString.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSString {
  /// Constructs a [NSMutableString] that wraps the given raw object pointer.
  NSMutableString.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSMutableString].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSMutableString,
    );
  }

  /// alloc
  static NSMutableString alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableString, _sel_alloc);
    return NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSMutableString allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSMutableString,
      _sel_allocWithZone_,
      zone,
    );
    return NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// localizedStringWithFormat:
  static NSMutableString localizedStringWithFormat(NSString format) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableString,
      _sel_localizedStringWithFormat_,
      format.ref.pointer,
    );
    return NSMutableString.castFromPointer($ret, retain: true, release: true);
  }

  /// localizedStringWithValidatedFormat:validFormatSpecifiers:error:
  static NSMutableString? localizedStringWithValidatedFormat(
    NSString format, {
    required NSString validFormatSpecifiers,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableString.localizedStringWithValidatedFormat:validFormatSpecifiers:error:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_1pnyuds(
      _class_NSMutableString,
      _sel_localizedStringWithValidatedFormat_validFormatSpecifiers_error_,
      format.ref.pointer,
      validFormatSpecifiers.ref.pointer,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSMutableString new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableString, _sel_new);
    return NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// string
  static NSMutableString string() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableString, _sel_string);
    return NSMutableString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithCString:encoding:
  static NSMutableString? stringWithCString(
    ffi.Pointer<ffi.Char> cString, {
    required int encoding,
  }) {
    final $ret = _objc_msgSend_erqryg(
      _class_NSMutableString,
      _sel_stringWithCString_encoding_,
      cString,
      encoding,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithCharacters:length:
  static NSMutableString stringWithCharacters(
    ffi.Pointer<ffi.UnsignedShort> characters, {
    required int length,
  }) {
    final $ret = _objc_msgSend_9x4k8x(
      _class_NSMutableString,
      _sel_stringWithCharacters_length_,
      characters,
      length,
    );
    return NSMutableString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithContentsOfFile:encoding:error:
  static NSMutableString? stringWithContentsOfFile(
    NSString path, {
    required int encoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1nomli1(
      _class_NSMutableString,
      _sel_stringWithContentsOfFile_encoding_error_,
      path.ref.pointer,
      encoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithContentsOfFile:usedEncoding:error:
  static NSMutableString? stringWithContentsOfFile$1(
    NSString path, {
    required ffi.Pointer<ffi.UnsignedLong> usedEncoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1alewu7(
      _class_NSMutableString,
      _sel_stringWithContentsOfFile_usedEncoding_error_,
      path.ref.pointer,
      usedEncoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithContentsOfURL:encoding:error:
  static NSMutableString? stringWithContentsOfURL(
    NSURL url, {
    required int encoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1nomli1(
      _class_NSMutableString,
      _sel_stringWithContentsOfURL_encoding_error_,
      url.ref.pointer,
      encoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithContentsOfURL:usedEncoding:error:
  static NSMutableString? stringWithContentsOfURL$1(
    NSURL url, {
    required ffi.Pointer<ffi.UnsignedLong> usedEncoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1alewu7(
      _class_NSMutableString,
      _sel_stringWithContentsOfURL_usedEncoding_error_,
      url.ref.pointer,
      usedEncoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithFormat:
  static NSMutableString stringWithFormat(NSString format) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableString,
      _sel_stringWithFormat_,
      format.ref.pointer,
    );
    return NSMutableString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithString:
  static NSMutableString stringWithString(NSString string) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableString,
      _sel_stringWithString_,
      string.ref.pointer,
    );
    return NSMutableString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithUTF8String:
  static NSMutableString? stringWithUTF8String(
    ffi.Pointer<ffi.Char> nullTerminatedCString,
  ) {
    final $ret = _objc_msgSend_56zxyn(
      _class_NSMutableString,
      _sel_stringWithUTF8String_,
      nullTerminatedCString,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithValidatedFormat:validFormatSpecifiers:error:
  static NSMutableString? stringWithValidatedFormat(
    NSString format, {
    required NSString validFormatSpecifiers,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableString.stringWithValidatedFormat:validFormatSpecifiers:error:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_1pnyuds(
      _class_NSMutableString,
      _sel_stringWithValidatedFormat_validFormatSpecifiers_error_,
      format.ref.pointer,
      validFormatSpecifiers.ref.pointer,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_NSMutableString,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of NSMutableString constructed with the default `new` method.
  NSMutableString() : this.castFrom(new$()._$);
}

extension NSMutableString$Methods on NSMutableString {
  /// init
  NSMutableString init() {
    objc.checkOsVersionInternal(
      'NSMutableString.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytes:length:encoding:
  NSMutableString? initWithBytes(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
    required int encoding,
  }) {
    final $ret = _objc_msgSend_9b3h4v(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytes_length_encoding_,
      bytes,
      length,
      encoding,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytesNoCopy:length:encoding:deallocator:
  NSMutableString? initWithBytesNoCopy(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
    required int encoding,
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>?
    deallocator,
  }) {
    final $ret = _objc_msgSend_1lbgrac(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytesNoCopy_length_encoding_deallocator_,
      bytes,
      length,
      encoding,
      deallocator?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytesNoCopy:length:encoding:freeWhenDone:
  NSMutableString? initWithBytesNoCopy$1(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
    required int encoding,
    required bool freeWhenDone,
  }) {
    final $ret = _objc_msgSend_k4j8m3(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytesNoCopy_length_encoding_freeWhenDone_,
      bytes,
      length,
      encoding,
      freeWhenDone,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCString:encoding:
  NSMutableString? initWithCString(
    ffi.Pointer<ffi.Char> nullTerminatedCString, {
    required int encoding,
  }) {
    final $ret = _objc_msgSend_erqryg(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCString_encoding_,
      nullTerminatedCString,
      encoding,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCharacters:length:
  NSMutableString initWithCharacters(
    ffi.Pointer<ffi.UnsignedShort> characters, {
    required int length,
  }) {
    final $ret = _objc_msgSend_9x4k8x(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCharacters_length_,
      characters,
      length,
    );
    return NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCharactersNoCopy:length:deallocator:
  NSMutableString initWithCharactersNoCopy(
    ffi.Pointer<ffi.UnsignedShort> chars, {
    required int length,
    objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)
    >?
    deallocator,
  }) {
    final $ret = _objc_msgSend_talwei(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCharactersNoCopy_length_deallocator_,
      chars,
      length,
      deallocator?.ref.pointer ?? ffi.nullptr,
    );
    return NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCharactersNoCopy:length:freeWhenDone:
  NSMutableString initWithCharactersNoCopy$1(
    ffi.Pointer<ffi.UnsignedShort> characters, {
    required int length,
    required bool freeWhenDone,
  }) {
    final $ret = _objc_msgSend_lh0jh5(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCharactersNoCopy_length_freeWhenDone_,
      characters,
      length,
      freeWhenDone,
    );
    return NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSMutableString? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfFile:encoding:error:
  NSMutableString? initWithContentsOfFile(
    NSString path, {
    required int encoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1nomli1(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfFile_encoding_error_,
      path.ref.pointer,
      encoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfFile:usedEncoding:error:
  NSMutableString? initWithContentsOfFile$1(
    NSString path, {
    required ffi.Pointer<ffi.UnsignedLong> usedEncoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1alewu7(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfFile_usedEncoding_error_,
      path.ref.pointer,
      usedEncoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:encoding:error:
  NSMutableString? initWithContentsOfURL(
    NSURL url, {
    required int encoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1nomli1(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfURL_encoding_error_,
      url.ref.pointer,
      encoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:usedEncoding:error:
  NSMutableString? initWithContentsOfURL$1(
    NSURL url, {
    required ffi.Pointer<ffi.UnsignedLong> usedEncoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1alewu7(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfURL_usedEncoding_error_,
      url.ref.pointer,
      usedEncoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithData:encoding:
  NSMutableString? initWithData(NSData data, {required int encoding}) {
    final $ret = _objc_msgSend_1k4kd9s(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithData_encoding_,
      data.ref.pointer,
      encoding,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFormat:
  NSMutableString initWithFormat(NSString format) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithFormat_,
      format.ref.pointer,
    );
    return NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFormat:locale:
  NSMutableString initWithFormat$1(
    NSString format, {
    objc.ObjCObjectBase? locale,
  }) {
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithFormat_locale_,
      format.ref.pointer,
      locale?.ref.pointer ?? ffi.nullptr,
    );
    return NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithString:
  NSMutableString initWithString(NSString aString) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithString_,
      aString.ref.pointer,
    );
    return NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithUTF8String:
  NSMutableString? initWithUTF8String(
    ffi.Pointer<ffi.Char> nullTerminatedCString,
  ) {
    final $ret = _objc_msgSend_56zxyn(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithUTF8String_,
      nullTerminatedCString,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithValidatedFormat:validFormatSpecifiers:error:
  ///
  /// iOS: introduced 16.0.0
  /// macOS: introduced 13.0.0
  NSMutableString? initWithValidatedFormat(
    NSString format, {
    required NSString validFormatSpecifiers,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableString.initWithValidatedFormat:validFormatSpecifiers:error:',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_1pnyuds(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithValidatedFormat_validFormatSpecifiers_error_,
      format.ref.pointer,
      validFormatSpecifiers.ref.pointer,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithValidatedFormat:validFormatSpecifiers:locale:error:
  ///
  /// iOS: introduced 16.0.0
  /// macOS: introduced 13.0.0
  NSMutableString? initWithValidatedFormat$1(
    NSString format, {
    required NSString validFormatSpecifiers,
    objc.ObjCObjectBase? locale,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableString.initWithValidatedFormat:validFormatSpecifiers:locale:error:',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_1k0ezzm(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithValidatedFormat_validFormatSpecifiers_locale_error_,
      format.ref.pointer,
      validFormatSpecifiers.ref.pointer,
      locale?.ref.pointer ?? ffi.nullptr,
      error,
    );
    return $ret.address == 0
        ? null
        : NSMutableString.castFromPointer($ret, retain: false, release: true);
  }

  /// replaceCharactersInRange:withString:
  void replaceCharactersInRange(NSRange range, {required NSString withString}) {
    _objc_msgSend_1tv4uax(
      _$.ref.pointer,
      _sel_replaceCharactersInRange_withString_,
      range,
      withString.ref.pointer,
    );
  }
}

/// NSNotification
extension type NSNotification.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject, NSCopying, NSCoding {
  /// Constructs a [NSNotification] that wraps the given raw object pointer.
  NSNotification.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSNotification].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSNotification,
    );
  }

  /// alloc
  static NSNotification alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSNotification, _sel_alloc);
    return NSNotification.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSNotification allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSNotification,
      _sel_allocWithZone_,
      zone,
    );
    return NSNotification.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSNotification new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSNotification, _sel_new);
    return NSNotification.castFromPointer($ret, retain: false, release: true);
  }

  /// notificationWithName:object:
  static NSNotification notificationWithName(
    NSString aName, {
    objc.ObjCObjectBase? object,
  }) {
    final $ret = _objc_msgSend_15qeuct(
      _class_NSNotification,
      _sel_notificationWithName_object_,
      aName.ref.pointer,
      object?.ref.pointer ?? ffi.nullptr,
    );
    return NSNotification.castFromPointer($ret, retain: true, release: true);
  }

  /// notificationWithName:object:userInfo:
  static NSNotification notificationWithName$1(
    NSString aName, {
    objc.ObjCObjectBase? object,
    NSDictionary? userInfo,
  }) {
    final $ret = _objc_msgSend_11spmsz(
      _class_NSNotification,
      _sel_notificationWithName_object_userInfo_,
      aName.ref.pointer,
      object?.ref.pointer ?? ffi.nullptr,
      userInfo?.ref.pointer ?? ffi.nullptr,
    );
    return NSNotification.castFromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of NSNotification constructed with the default `new` method.
  NSNotification() : this.castFrom(new$()._$);
}

extension NSNotification$Methods on NSNotification {
  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  NSNotification init() {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSNotification.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSNotification? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSNotification.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithName:object:userInfo:
  NSNotification initWithName(
    NSString name, {
    objc.ObjCObjectBase? object,
    NSDictionary? userInfo,
  }) {
    objc.checkOsVersionInternal(
      'NSNotification.initWithName:object:userInfo:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithName_object_userInfo_,
      name.ref.pointer,
      object?.ref.pointer ?? ffi.nullptr,
      userInfo?.ref.pointer ?? ffi.nullptr,
    );
    return NSNotification.castFromPointer($ret, retain: false, release: true);
  }

  /// name
  NSString get name {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_name);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// object
  objc.ObjCObjectBase? get object {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_object);
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// userInfo
  NSDictionary? get userInfo {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_userInfo);
    return $ret.address == 0
        ? null
        : NSDictionary.castFromPointer($ret, retain: true, release: true);
  }
}

/// NSNull
extension type NSNull.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject, NSCopying, NSSecureCoding {
  /// Constructs a [NSNull] that wraps the given raw object pointer.
  NSNull.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSNull].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSNull,
    );
  }

  /// alloc
  static NSNull alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSNull, _sel_alloc);
    return NSNull.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSNull allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSNull,
      _sel_allocWithZone_,
      zone,
    );
    return NSNull.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSNull new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSNull, _sel_new);
    return NSNull.castFromPointer($ret, retain: false, release: true);
  }

  /// null
  static NSNull null$() {
    final $ret = _objc_msgSend_151sglz(_class_NSNull, _sel_null);
    return NSNull.castFromPointer($ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSNull, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSNull constructed with the default `new` method.
  NSNull() : this.castFrom(new$()._$);
}

extension NSNull$Methods on NSNull {
  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  NSNull init() {
    objc.checkOsVersionInternal(
      'NSNull.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSNull.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSNull? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSNull.castFromPointer($ret, retain: false, release: true);
  }
}

/// NSNumber
extension type NSNumber.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSValue {
  /// Constructs a [NSNumber] that wraps the given raw object pointer.
  NSNumber.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSNumber].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSNumber,
    );
  }

  /// alloc
  static NSNumber alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSNumber, _sel_alloc);
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSNumber allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSNumber,
      _sel_allocWithZone_,
      zone,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSNumber new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSNumber, _sel_new);
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSNumber, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSNumber constructed with the default `new` method.
  NSNumber() : this.castFrom(new$()._$);
}

extension NSNumber$Methods on NSNumber {
  /// boolValue
  bool get boolValue {
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_boolValue);
  }

  /// charValue
  int get charValue {
    return _objc_msgSend_xmlz1t(_$.ref.pointer, _sel_charValue);
  }

  /// compare:
  NSComparisonResult compare(NSNumber otherNumber) {
    final $ret = _objc_msgSend_1ym6zyw(
      _$.ref.pointer,
      _sel_compare_,
      otherNumber.ref.pointer,
    );
    return NSComparisonResult.fromValue($ret);
  }

  /// descriptionWithLocale:
  NSString descriptionWithLocale(objc.ObjCObjectBase? locale) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_descriptionWithLocale_,
      locale?.ref.pointer ?? ffi.nullptr,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// doubleValue
  double get doubleValue {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_$.ref.pointer, _sel_doubleValue)
        : _objc_msgSend_1ukqyt8(_$.ref.pointer, _sel_doubleValue);
  }

  /// floatValue
  double get floatValue {
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(_$.ref.pointer, _sel_floatValue)
        : _objc_msgSend_2cgrxl(_$.ref.pointer, _sel_floatValue);
  }

  /// init
  NSNumber init() {
    objc.checkOsVersionInternal(
      'NSNumber.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBool:
  NSNumber initWithBool(bool value) {
    final $ret = _objc_msgSend_1t6aok9(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBool_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytes:objCType:
  NSNumber initWithBytes(
    ffi.Pointer<ffi.Void> value, {
    required ffi.Pointer<ffi.Char> objCType,
  }) {
    final $ret = _objc_msgSend_e9mncn(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytes_objCType_,
      value,
      objCType,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithChar:
  NSNumber initWithChar(int value) {
    final $ret = _objc_msgSend_13mclwd(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithChar_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSNumber? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithDouble:
  NSNumber initWithDouble(double value) {
    final $ret = _objc_msgSend_oa8mke(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithDouble_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFloat:
  NSNumber initWithFloat(double value) {
    final $ret = _objc_msgSend_et8cuh(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithFloat_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithInt:
  NSNumber initWithInt(int value) {
    final $ret = _objc_msgSend_14hvw5k(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithInt_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithInteger:
  NSNumber initWithInteger(int value) {
    objc.checkOsVersionInternal(
      'NSNumber.initWithInteger:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_qugqlf(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithInteger_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithLong:
  NSNumber initWithLong(int value) {
    final $ret = _objc_msgSend_qugqlf(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithLong_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithLongLong:
  NSNumber initWithLongLong(int value) {
    final $ret = _objc_msgSend_16f0drb(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithLongLong_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithShort:
  NSNumber initWithShort(int value) {
    final $ret = _objc_msgSend_68x6r1(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithShort_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithUnsignedChar:
  NSNumber initWithUnsignedChar(int value) {
    final $ret = _objc_msgSend_7uautw(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithUnsignedChar_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithUnsignedInt:
  NSNumber initWithUnsignedInt(int value) {
    final $ret = _objc_msgSend_degb40(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithUnsignedInt_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithUnsignedInteger:
  NSNumber initWithUnsignedInteger(int value) {
    objc.checkOsVersionInternal(
      'NSNumber.initWithUnsignedInteger:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithUnsignedInteger_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithUnsignedLong:
  NSNumber initWithUnsignedLong(int value) {
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithUnsignedLong_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithUnsignedLongLong:
  NSNumber initWithUnsignedLongLong(int value) {
    final $ret = _objc_msgSend_1x2hskc(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithUnsignedLongLong_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithUnsignedShort:
  NSNumber initWithUnsignedShort(int value) {
    final $ret = _objc_msgSend_1njucl2(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithUnsignedShort_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: false, release: true);
  }

  /// intValue
  int get intValue {
    return _objc_msgSend_13yqbb6(_$.ref.pointer, _sel_intValue);
  }

  /// integerValue
  int get integerValue {
    objc.checkOsVersionInternal(
      'NSNumber.integerValue',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_1hz7y9r(_$.ref.pointer, _sel_integerValue);
  }

  /// isEqualToNumber:
  bool isEqualToNumber(NSNumber number) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isEqualToNumber_,
      number.ref.pointer,
    );
  }

  /// longLongValue
  int get longLongValue {
    return _objc_msgSend_1k101e3(_$.ref.pointer, _sel_longLongValue);
  }

  /// longValue
  int get longValue {
    return _objc_msgSend_1hz7y9r(_$.ref.pointer, _sel_longValue);
  }

  /// shortValue
  int get shortValue {
    return _objc_msgSend_1jwityx(_$.ref.pointer, _sel_shortValue);
  }

  /// stringValue
  NSString get stringValue {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_stringValue);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// unsignedCharValue
  int get unsignedCharValue {
    return _objc_msgSend_1ko4qka(_$.ref.pointer, _sel_unsignedCharValue);
  }

  /// unsignedIntValue
  int get unsignedIntValue {
    return _objc_msgSend_3pyzne(_$.ref.pointer, _sel_unsignedIntValue);
  }

  /// unsignedIntegerValue
  int get unsignedIntegerValue {
    objc.checkOsVersionInternal(
      'NSNumber.unsignedIntegerValue',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_unsignedIntegerValue);
  }

  /// unsignedLongLongValue
  int get unsignedLongLongValue {
    return _objc_msgSend_1p4gbjy(_$.ref.pointer, _sel_unsignedLongLongValue);
  }

  /// unsignedLongValue
  int get unsignedLongValue {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_unsignedLongValue);
  }

  /// unsignedShortValue
  int get unsignedShortValue {
    return _objc_msgSend_ud8gg(_$.ref.pointer, _sel_unsignedShortValue);
  }
}

/// NSNumberCreation
extension NSNumberCreation on NSNumber {
  /// numberWithBool:
  static NSNumber numberWithBool(bool value) {
    final $ret = _objc_msgSend_1t6aok9(
      _class_NSNumber,
      _sel_numberWithBool_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// numberWithChar:
  static NSNumber numberWithChar(int value) {
    final $ret = _objc_msgSend_13mclwd(
      _class_NSNumber,
      _sel_numberWithChar_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// numberWithDouble:
  static NSNumber numberWithDouble(double value) {
    final $ret = _objc_msgSend_oa8mke(
      _class_NSNumber,
      _sel_numberWithDouble_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// numberWithFloat:
  static NSNumber numberWithFloat(double value) {
    final $ret = _objc_msgSend_et8cuh(
      _class_NSNumber,
      _sel_numberWithFloat_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// numberWithInt:
  static NSNumber numberWithInt(int value) {
    final $ret = _objc_msgSend_14hvw5k(
      _class_NSNumber,
      _sel_numberWithInt_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// numberWithInteger:
  static NSNumber numberWithInteger(int value) {
    objc.checkOsVersionInternal(
      'NSNumber.numberWithInteger:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_qugqlf(
      _class_NSNumber,
      _sel_numberWithInteger_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// numberWithLong:
  static NSNumber numberWithLong(int value) {
    final $ret = _objc_msgSend_qugqlf(
      _class_NSNumber,
      _sel_numberWithLong_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// numberWithLongLong:
  static NSNumber numberWithLongLong(int value) {
    final $ret = _objc_msgSend_16f0drb(
      _class_NSNumber,
      _sel_numberWithLongLong_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// numberWithShort:
  static NSNumber numberWithShort(int value) {
    final $ret = _objc_msgSend_68x6r1(
      _class_NSNumber,
      _sel_numberWithShort_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// numberWithUnsignedChar:
  static NSNumber numberWithUnsignedChar(int value) {
    final $ret = _objc_msgSend_7uautw(
      _class_NSNumber,
      _sel_numberWithUnsignedChar_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// numberWithUnsignedInt:
  static NSNumber numberWithUnsignedInt(int value) {
    final $ret = _objc_msgSend_degb40(
      _class_NSNumber,
      _sel_numberWithUnsignedInt_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// numberWithUnsignedInteger:
  static NSNumber numberWithUnsignedInteger(int value) {
    objc.checkOsVersionInternal(
      'NSNumber.numberWithUnsignedInteger:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_14hpxwa(
      _class_NSNumber,
      _sel_numberWithUnsignedInteger_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// numberWithUnsignedLong:
  static NSNumber numberWithUnsignedLong(int value) {
    final $ret = _objc_msgSend_14hpxwa(
      _class_NSNumber,
      _sel_numberWithUnsignedLong_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// numberWithUnsignedLongLong:
  static NSNumber numberWithUnsignedLongLong(int value) {
    final $ret = _objc_msgSend_1x2hskc(
      _class_NSNumber,
      _sel_numberWithUnsignedLongLong_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// numberWithUnsignedShort:
  static NSNumber numberWithUnsignedShort(int value) {
    final $ret = _objc_msgSend_1njucl2(
      _class_NSNumber,
      _sel_numberWithUnsignedShort_,
      value,
    );
    return NSNumber.castFromPointer($ret, retain: true, release: true);
  }
}

/// NSNumberIsFloat
extension NSNumberIsFloat on NSNumber {
  /// isFloat
  bool get isFloat {
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isFloat);
  }
}

/// NSObject
extension type NSObject.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObjectProtocol {
  /// Constructs a [NSObject] that wraps the given raw object pointer.
  NSObject.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSObject].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSObject,
    );
  }

  /// alloc
  static NSObject alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSObject, _sel_alloc);
    return NSObject.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSObject allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSObject,
      _sel_allocWithZone_,
      zone,
    );
    return NSObject.castFromPointer($ret, retain: false, release: true);
  }

  /// class
  static objc.ObjCObjectBase class$() {
    final $ret = _objc_msgSend_151sglz(_class_NSObject, _sel_class);
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// conformsToProtocol:
  static bool conformsToProtocol(Protocol protocol) {
    objc.checkOsVersionInternal(
      'NSObject.conformsToProtocol:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      _class_NSObject,
      _sel_conformsToProtocol_,
      protocol.ref.pointer,
    );
  }

  /// copyWithZone:
  static objc.ObjCObjectBase copyWithZone(ffi.Pointer<NSZone> zone) {
    objc.checkOsVersionInternal(
      'NSObject.copyWithZone:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1cwp428(
      _class_NSObject,
      _sel_copyWithZone_,
      zone,
    );
    return objc.ObjCObjectBase($ret, retain: false, release: true);
  }

  /// debugDescription
  static NSString debugDescription() {
    objc.checkOsVersionInternal(
      'NSObject.debugDescription',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_NSObject, _sel_debugDescription);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// description
  static NSString description() {
    objc.checkOsVersionInternal(
      'NSObject.description',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_NSObject, _sel_description);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// hash
  static int hash() {
    objc.checkOsVersionInternal(
      'NSObject.hash',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_xw2lbc(_class_NSObject, _sel_hash);
  }

  /// initialize
  static void initialize() {
    objc.checkOsVersionInternal(
      'NSObject.initialize',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(_class_NSObject, _sel_initialize);
  }

  /// instanceMethodForSelector:
  static ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>
  instanceMethodForSelector(ffi.Pointer<objc.ObjCSelector> aSelector) {
    objc.checkOsVersionInternal(
      'NSObject.instanceMethodForSelector:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_1pa9f4m(
      _class_NSObject,
      _sel_instanceMethodForSelector_,
      aSelector,
    );
  }

  /// instanceMethodSignatureForSelector:
  static NSMethodSignature instanceMethodSignatureForSelector(
    ffi.Pointer<objc.ObjCSelector> aSelector,
  ) {
    final $ret = _objc_msgSend_3ctkt6(
      _class_NSObject,
      _sel_instanceMethodSignatureForSelector_,
      aSelector,
    );
    return NSMethodSignature.castFromPointer($ret, retain: true, release: true);
  }

  /// instancesRespondToSelector:
  static bool instancesRespondToSelector(
    ffi.Pointer<objc.ObjCSelector> aSelector,
  ) {
    objc.checkOsVersionInternal(
      'NSObject.instancesRespondToSelector:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_1srf6wk(
      _class_NSObject,
      _sel_instancesRespondToSelector_,
      aSelector,
    );
  }

  /// isSubclassOfClass:
  static bool isSubclassOfClass(objc.ObjCObjectBase aClass) {
    objc.checkOsVersionInternal(
      'NSObject.isSubclassOfClass:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      _class_NSObject,
      _sel_isSubclassOfClass_,
      aClass.ref.pointer,
    );
  }

  /// load
  static void load() {
    objc.checkOsVersionInternal(
      'NSObject.load',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(_class_NSObject, _sel_load);
  }

  /// mutableCopyWithZone:
  static objc.ObjCObjectBase mutableCopyWithZone(ffi.Pointer<NSZone> zone) {
    objc.checkOsVersionInternal(
      'NSObject.mutableCopyWithZone:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1cwp428(
      _class_NSObject,
      _sel_mutableCopyWithZone_,
      zone,
    );
    return objc.ObjCObjectBase($ret, retain: false, release: true);
  }

  /// new
  static NSObject new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSObject, _sel_new);
    return NSObject.castFromPointer($ret, retain: false, release: true);
  }

  /// resolveClassMethod:
  static bool resolveClassMethod(ffi.Pointer<objc.ObjCSelector> sel) {
    objc.checkOsVersionInternal(
      'NSObject.resolveClassMethod:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_1srf6wk(
      _class_NSObject,
      _sel_resolveClassMethod_,
      sel,
    );
  }

  /// resolveInstanceMethod:
  static bool resolveInstanceMethod(ffi.Pointer<objc.ObjCSelector> sel) {
    objc.checkOsVersionInternal(
      'NSObject.resolveInstanceMethod:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_1srf6wk(
      _class_NSObject,
      _sel_resolveInstanceMethod_,
      sel,
    );
  }

  /// superclass
  static objc.ObjCObjectBase superclass() {
    objc.checkOsVersionInternal(
      'NSObject.superclass',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_NSObject, _sel_superclass);
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// Returns a new instance of NSObject constructed with the default `new` method.
  NSObject() : this.castFrom(new$()._$);
}

extension NSObject$Methods on NSObject {
  /// copy
  objc.ObjCObjectBase copy() {
    objc.checkOsVersionInternal(
      'NSObject.copy',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_copy);
    return objc.ObjCObjectBase($ret, retain: false, release: true);
  }

  /// dealloc
  void dealloc() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_dealloc);
  }

  /// doesNotRecognizeSelector:
  void doesNotRecognizeSelector(ffi.Pointer<objc.ObjCSelector> aSelector) {
    objc.checkOsVersionInternal(
      'NSObject.doesNotRecognizeSelector:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_1d9e4oe(
      _$.ref.pointer,
      _sel_doesNotRecognizeSelector_,
      aSelector,
    );
  }

  /// forwardInvocation:
  void forwardInvocation(NSInvocation anInvocation) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_forwardInvocation_,
      anInvocation.ref.pointer,
    );
  }

  /// forwardingTargetForSelector:
  objc.ObjCObjectBase forwardingTargetForSelector(
    ffi.Pointer<objc.ObjCSelector> aSelector,
  ) {
    objc.checkOsVersionInternal(
      'NSObject.forwardingTargetForSelector:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_3ctkt6(
      _$.ref.pointer,
      _sel_forwardingTargetForSelector_,
      aSelector,
    );
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// init
  NSObject init() {
    objc.checkOsVersionInternal(
      'NSObject.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSObject.castFromPointer($ret, retain: false, release: true);
  }

  /// isEqual:
  bool isEqual(objc.ObjCObjectBase object) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isEqual_,
      object.ref.pointer,
    );
  }

  /// isKindOfClass:
  bool isKindOfClass(objc.ObjCObjectBase aClass) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isKindOfClass_,
      aClass.ref.pointer,
    );
  }

  /// isMemberOfClass:
  bool isMemberOfClass(objc.ObjCObjectBase aClass) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isMemberOfClass_,
      aClass.ref.pointer,
    );
  }

  /// isProxy
  bool get isProxy {
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isProxy);
  }

  /// methodForSelector:
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> methodForSelector(
    ffi.Pointer<objc.ObjCSelector> aSelector,
  ) {
    objc.checkOsVersionInternal(
      'NSObject.methodForSelector:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_1pa9f4m(
      _$.ref.pointer,
      _sel_methodForSelector_,
      aSelector,
    );
  }

  /// methodSignatureForSelector:
  NSMethodSignature methodSignatureForSelector(
    ffi.Pointer<objc.ObjCSelector> aSelector,
  ) {
    final $ret = _objc_msgSend_3ctkt6(
      _$.ref.pointer,
      _sel_methodSignatureForSelector_,
      aSelector,
    );
    return NSMethodSignature.castFromPointer($ret, retain: true, release: true);
  }

  /// mutableCopy
  objc.ObjCObjectBase mutableCopy() {
    objc.checkOsVersionInternal(
      'NSObject.mutableCopy',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_mutableCopy);
    return objc.ObjCObjectBase($ret, retain: false, release: true);
  }

  /// performSelector:
  objc.ObjCObjectBase performSelector(
    ffi.Pointer<objc.ObjCSelector> aSelector,
  ) {
    final $ret = _objc_msgSend_3ctkt6(
      _$.ref.pointer,
      _sel_performSelector_,
      aSelector,
    );
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// performSelector:withObject:
  objc.ObjCObjectBase performSelector$1(
    ffi.Pointer<objc.ObjCSelector> aSelector, {
    required objc.ObjCObjectBase withObject,
  }) {
    final $ret = _objc_msgSend_gx50so(
      _$.ref.pointer,
      _sel_performSelector_withObject_,
      aSelector,
      withObject.ref.pointer,
    );
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// performSelector:withObject:withObject:
  objc.ObjCObjectBase performSelector$2(
    ffi.Pointer<objc.ObjCSelector> aSelector, {
    required objc.ObjCObjectBase withObject,
    required objc.ObjCObjectBase withObject$1,
  }) {
    final $ret = _objc_msgSend_cfx8ce(
      _$.ref.pointer,
      _sel_performSelector_withObject_withObject_,
      aSelector,
      withObject.ref.pointer,
      withObject$1.ref.pointer,
    );
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// zone
  ffi.Pointer<NSZone> zone() {
    return _objc_msgSend_sz90oi(_$.ref.pointer, _sel_zone);
  }
}

/// NSObject
extension type NSObjectProtocol.castFrom(objc.ObjCProtocolBase _$)
    implements objc.ObjCProtocolBase {
  /// Constructs a [NSObjectProtocol] that wraps the given raw object pointer.
  NSObjectProtocol.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCProtocolBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSObjectProtocol].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_NSObject,
    );
  }
}

extension NSObjectProtocol$Methods on NSObjectProtocol {
  /// autorelease
  NSObjectProtocol autorelease() {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_autorelease);
    return NSObjectProtocol.castFromPointer($ret, retain: true, release: true);
  }

  /// class
  objc.ObjCObjectBase class$() {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_class);
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// conformsToProtocol:
  bool conformsToProtocol(Protocol aProtocol) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_conformsToProtocol_,
      aProtocol.ref.pointer,
    );
  }

  /// debugDescription
  NSString get debugDescription {
    if (!objc.respondsToSelector(_$.ref.pointer, _sel_debugDescription)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSObject',
        'debugDescription',
      );
    }
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_debugDescription);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// description
  NSString get description {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_description);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// hash
  int get hash {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_hash);
  }

  /// isEqual:
  bool isEqual(objc.ObjCObjectBase object) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isEqual_,
      object.ref.pointer,
    );
  }

  /// isKindOfClass:
  bool isKindOfClass(objc.ObjCObjectBase aClass) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isKindOfClass_,
      aClass.ref.pointer,
    );
  }

  /// isMemberOfClass:
  bool isMemberOfClass(objc.ObjCObjectBase aClass) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isMemberOfClass_,
      aClass.ref.pointer,
    );
  }

  /// isProxy
  bool get isProxy {
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isProxy);
  }

  /// performSelector:
  objc.ObjCObjectBase performSelector(
    ffi.Pointer<objc.ObjCSelector> aSelector,
  ) {
    final $ret = _objc_msgSend_3ctkt6(
      _$.ref.pointer,
      _sel_performSelector_,
      aSelector,
    );
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// performSelector:withObject:
  objc.ObjCObjectBase performSelector$1(
    ffi.Pointer<objc.ObjCSelector> aSelector, {
    required objc.ObjCObjectBase withObject,
  }) {
    final $ret = _objc_msgSend_gx50so(
      _$.ref.pointer,
      _sel_performSelector_withObject_,
      aSelector,
      withObject.ref.pointer,
    );
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// performSelector:withObject:withObject:
  objc.ObjCObjectBase performSelector$2(
    ffi.Pointer<objc.ObjCSelector> aSelector, {
    required objc.ObjCObjectBase withObject,
    required objc.ObjCObjectBase withObject$1,
  }) {
    final $ret = _objc_msgSend_cfx8ce(
      _$.ref.pointer,
      _sel_performSelector_withObject_withObject_,
      aSelector,
      withObject.ref.pointer,
      withObject$1.ref.pointer,
    );
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// release
  void release() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_release);
  }

  /// respondsToSelector:
  bool respondsToSelector(ffi.Pointer<objc.ObjCSelector> aSelector) {
    return _objc_msgSend_1srf6wk(
      _$.ref.pointer,
      _sel_respondsToSelector_,
      aSelector,
    );
  }

  /// retain
  NSObjectProtocol retain() {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_retain);
    return NSObjectProtocol.castFromPointer($ret, retain: true, release: true);
  }

  /// retainCount
  int retainCount() {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_retainCount);
  }

  /// self
  NSObjectProtocol self() {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_self);
    return NSObjectProtocol.castFromPointer($ret, retain: true, release: true);
  }

  /// superclass
  objc.ObjCObjectBase get superclass {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_superclass);
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// zone
  ffi.Pointer<NSZone> zone() {
    return _objc_msgSend_sz90oi(_$.ref.pointer, _sel_zone);
  }
}

interface class NSObjectProtocol$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_NSObject.cast());

  /// Builds an object that implements the NSObject protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSObjectProtocol implement({
    required objc.ObjCObjectBase Function() autorelease,
    required objc.ObjCObjectBase Function() class$,
    required bool Function(Protocol) conformsToProtocol_,
    NSString Function()? debugDescription,
    required NSString Function() description,
    required int Function() hash,
    required bool Function(objc.ObjCObjectBase) isEqual_,
    required bool Function(objc.ObjCObjectBase) isKindOfClass_,
    required bool Function(objc.ObjCObjectBase) isMemberOfClass_,
    required bool Function() isProxy,
    required objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>)
    performSelector_,
    required objc.ObjCObjectBase Function(
      ffi.Pointer<objc.ObjCSelector>,
      objc.ObjCObjectBase,
    )
    performSelector_withObject_,
    required objc.ObjCObjectBase Function(
      ffi.Pointer<objc.ObjCSelector>,
      objc.ObjCObjectBase,
      objc.ObjCObjectBase,
    )
    performSelector_withObject_withObject_,
    required void Function() release,
    required bool Function(ffi.Pointer<objc.ObjCSelector>) respondsToSelector_,
    required objc.ObjCObjectBase Function() retain,
    required int Function() retainCount,
    required objc.ObjCObjectBase Function() self,
    required objc.ObjCObjectBase Function() superclass,
    required ffi.Pointer<NSZone> Function() zone,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSObject');
    NSObjectProtocol$Builder.autorelease.implement(builder, autorelease);
    NSObjectProtocol$Builder.class$.implement(builder, class$);
    NSObjectProtocol$Builder.conformsToProtocol_.implement(
      builder,
      conformsToProtocol_,
    );
    NSObjectProtocol$Builder.debugDescription.implement(
      builder,
      debugDescription,
    );
    NSObjectProtocol$Builder.description.implement(builder, description);
    NSObjectProtocol$Builder.hash.implement(builder, hash);
    NSObjectProtocol$Builder.isEqual_.implement(builder, isEqual_);
    NSObjectProtocol$Builder.isKindOfClass_.implement(builder, isKindOfClass_);
    NSObjectProtocol$Builder.isMemberOfClass_.implement(
      builder,
      isMemberOfClass_,
    );
    NSObjectProtocol$Builder.isProxy.implement(builder, isProxy);
    NSObjectProtocol$Builder.performSelector_.implement(
      builder,
      performSelector_,
    );
    NSObjectProtocol$Builder.performSelector_withObject_.implement(
      builder,
      performSelector_withObject_,
    );
    NSObjectProtocol$Builder.performSelector_withObject_withObject_.implement(
      builder,
      performSelector_withObject_withObject_,
    );
    NSObjectProtocol$Builder.release.implement(builder, release);
    NSObjectProtocol$Builder.respondsToSelector_.implement(
      builder,
      respondsToSelector_,
    );
    NSObjectProtocol$Builder.retain.implement(builder, retain);
    NSObjectProtocol$Builder.retainCount.implement(builder, retainCount);
    NSObjectProtocol$Builder.self.implement(builder, self);
    NSObjectProtocol$Builder.superclass.implement(builder, superclass);
    NSObjectProtocol$Builder.zone.implement(builder, zone);
    builder.addProtocol($protocol);
    return NSObjectProtocol.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSObject protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    required objc.ObjCObjectBase Function() autorelease,
    required objc.ObjCObjectBase Function() class$,
    required bool Function(Protocol) conformsToProtocol_,
    NSString Function()? debugDescription,
    required NSString Function() description,
    required int Function() hash,
    required bool Function(objc.ObjCObjectBase) isEqual_,
    required bool Function(objc.ObjCObjectBase) isKindOfClass_,
    required bool Function(objc.ObjCObjectBase) isMemberOfClass_,
    required bool Function() isProxy,
    required objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>)
    performSelector_,
    required objc.ObjCObjectBase Function(
      ffi.Pointer<objc.ObjCSelector>,
      objc.ObjCObjectBase,
    )
    performSelector_withObject_,
    required objc.ObjCObjectBase Function(
      ffi.Pointer<objc.ObjCSelector>,
      objc.ObjCObjectBase,
      objc.ObjCObjectBase,
    )
    performSelector_withObject_withObject_,
    required void Function() release,
    required bool Function(ffi.Pointer<objc.ObjCSelector>) respondsToSelector_,
    required objc.ObjCObjectBase Function() retain,
    required int Function() retainCount,
    required objc.ObjCObjectBase Function() self,
    required objc.ObjCObjectBase Function() superclass,
    required ffi.Pointer<NSZone> Function() zone,
    bool $keepIsolateAlive = true,
  }) {
    NSObjectProtocol$Builder.autorelease.implement(builder, autorelease);
    NSObjectProtocol$Builder.class$.implement(builder, class$);
    NSObjectProtocol$Builder.conformsToProtocol_.implement(
      builder,
      conformsToProtocol_,
    );
    NSObjectProtocol$Builder.debugDescription.implement(
      builder,
      debugDescription,
    );
    NSObjectProtocol$Builder.description.implement(builder, description);
    NSObjectProtocol$Builder.hash.implement(builder, hash);
    NSObjectProtocol$Builder.isEqual_.implement(builder, isEqual_);
    NSObjectProtocol$Builder.isKindOfClass_.implement(builder, isKindOfClass_);
    NSObjectProtocol$Builder.isMemberOfClass_.implement(
      builder,
      isMemberOfClass_,
    );
    NSObjectProtocol$Builder.isProxy.implement(builder, isProxy);
    NSObjectProtocol$Builder.performSelector_.implement(
      builder,
      performSelector_,
    );
    NSObjectProtocol$Builder.performSelector_withObject_.implement(
      builder,
      performSelector_withObject_,
    );
    NSObjectProtocol$Builder.performSelector_withObject_withObject_.implement(
      builder,
      performSelector_withObject_withObject_,
    );
    NSObjectProtocol$Builder.release.implement(builder, release);
    NSObjectProtocol$Builder.respondsToSelector_.implement(
      builder,
      respondsToSelector_,
    );
    NSObjectProtocol$Builder.retain.implement(builder, retain);
    NSObjectProtocol$Builder.retainCount.implement(builder, retainCount);
    NSObjectProtocol$Builder.self.implement(builder, self);
    NSObjectProtocol$Builder.superclass.implement(builder, superclass);
    NSObjectProtocol$Builder.zone.implement(builder, zone);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSObject protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSObjectProtocol implementAsListener({
    required objc.ObjCObjectBase Function() autorelease,
    required objc.ObjCObjectBase Function() class$,
    required bool Function(Protocol) conformsToProtocol_,
    NSString Function()? debugDescription,
    required NSString Function() description,
    required int Function() hash,
    required bool Function(objc.ObjCObjectBase) isEqual_,
    required bool Function(objc.ObjCObjectBase) isKindOfClass_,
    required bool Function(objc.ObjCObjectBase) isMemberOfClass_,
    required bool Function() isProxy,
    required objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>)
    performSelector_,
    required objc.ObjCObjectBase Function(
      ffi.Pointer<objc.ObjCSelector>,
      objc.ObjCObjectBase,
    )
    performSelector_withObject_,
    required objc.ObjCObjectBase Function(
      ffi.Pointer<objc.ObjCSelector>,
      objc.ObjCObjectBase,
      objc.ObjCObjectBase,
    )
    performSelector_withObject_withObject_,
    required void Function() release,
    required bool Function(ffi.Pointer<objc.ObjCSelector>) respondsToSelector_,
    required objc.ObjCObjectBase Function() retain,
    required int Function() retainCount,
    required objc.ObjCObjectBase Function() self,
    required objc.ObjCObjectBase Function() superclass,
    required ffi.Pointer<NSZone> Function() zone,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSObject');
    NSObjectProtocol$Builder.autorelease.implement(builder, autorelease);
    NSObjectProtocol$Builder.class$.implement(builder, class$);
    NSObjectProtocol$Builder.conformsToProtocol_.implement(
      builder,
      conformsToProtocol_,
    );
    NSObjectProtocol$Builder.debugDescription.implement(
      builder,
      debugDescription,
    );
    NSObjectProtocol$Builder.description.implement(builder, description);
    NSObjectProtocol$Builder.hash.implement(builder, hash);
    NSObjectProtocol$Builder.isEqual_.implement(builder, isEqual_);
    NSObjectProtocol$Builder.isKindOfClass_.implement(builder, isKindOfClass_);
    NSObjectProtocol$Builder.isMemberOfClass_.implement(
      builder,
      isMemberOfClass_,
    );
    NSObjectProtocol$Builder.isProxy.implement(builder, isProxy);
    NSObjectProtocol$Builder.performSelector_.implement(
      builder,
      performSelector_,
    );
    NSObjectProtocol$Builder.performSelector_withObject_.implement(
      builder,
      performSelector_withObject_,
    );
    NSObjectProtocol$Builder.performSelector_withObject_withObject_.implement(
      builder,
      performSelector_withObject_withObject_,
    );
    NSObjectProtocol$Builder.release.implementAsListener(builder, release);
    NSObjectProtocol$Builder.respondsToSelector_.implement(
      builder,
      respondsToSelector_,
    );
    NSObjectProtocol$Builder.retain.implement(builder, retain);
    NSObjectProtocol$Builder.retainCount.implement(builder, retainCount);
    NSObjectProtocol$Builder.self.implement(builder, self);
    NSObjectProtocol$Builder.superclass.implement(builder, superclass);
    NSObjectProtocol$Builder.zone.implement(builder, zone);
    builder.addProtocol($protocol);
    return NSObjectProtocol.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSObject protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    required objc.ObjCObjectBase Function() autorelease,
    required objc.ObjCObjectBase Function() class$,
    required bool Function(Protocol) conformsToProtocol_,
    NSString Function()? debugDescription,
    required NSString Function() description,
    required int Function() hash,
    required bool Function(objc.ObjCObjectBase) isEqual_,
    required bool Function(objc.ObjCObjectBase) isKindOfClass_,
    required bool Function(objc.ObjCObjectBase) isMemberOfClass_,
    required bool Function() isProxy,
    required objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>)
    performSelector_,
    required objc.ObjCObjectBase Function(
      ffi.Pointer<objc.ObjCSelector>,
      objc.ObjCObjectBase,
    )
    performSelector_withObject_,
    required objc.ObjCObjectBase Function(
      ffi.Pointer<objc.ObjCSelector>,
      objc.ObjCObjectBase,
      objc.ObjCObjectBase,
    )
    performSelector_withObject_withObject_,
    required void Function() release,
    required bool Function(ffi.Pointer<objc.ObjCSelector>) respondsToSelector_,
    required objc.ObjCObjectBase Function() retain,
    required int Function() retainCount,
    required objc.ObjCObjectBase Function() self,
    required objc.ObjCObjectBase Function() superclass,
    required ffi.Pointer<NSZone> Function() zone,
    bool $keepIsolateAlive = true,
  }) {
    NSObjectProtocol$Builder.autorelease.implement(builder, autorelease);
    NSObjectProtocol$Builder.class$.implement(builder, class$);
    NSObjectProtocol$Builder.conformsToProtocol_.implement(
      builder,
      conformsToProtocol_,
    );
    NSObjectProtocol$Builder.debugDescription.implement(
      builder,
      debugDescription,
    );
    NSObjectProtocol$Builder.description.implement(builder, description);
    NSObjectProtocol$Builder.hash.implement(builder, hash);
    NSObjectProtocol$Builder.isEqual_.implement(builder, isEqual_);
    NSObjectProtocol$Builder.isKindOfClass_.implement(builder, isKindOfClass_);
    NSObjectProtocol$Builder.isMemberOfClass_.implement(
      builder,
      isMemberOfClass_,
    );
    NSObjectProtocol$Builder.isProxy.implement(builder, isProxy);
    NSObjectProtocol$Builder.performSelector_.implement(
      builder,
      performSelector_,
    );
    NSObjectProtocol$Builder.performSelector_withObject_.implement(
      builder,
      performSelector_withObject_,
    );
    NSObjectProtocol$Builder.performSelector_withObject_withObject_.implement(
      builder,
      performSelector_withObject_withObject_,
    );
    NSObjectProtocol$Builder.release.implementAsListener(builder, release);
    NSObjectProtocol$Builder.respondsToSelector_.implement(
      builder,
      respondsToSelector_,
    );
    NSObjectProtocol$Builder.retain.implement(builder, retain);
    NSObjectProtocol$Builder.retainCount.implement(builder, retainCount);
    NSObjectProtocol$Builder.self.implement(builder, self);
    NSObjectProtocol$Builder.superclass.implement(builder, superclass);
    NSObjectProtocol$Builder.zone.implement(builder, zone);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSObject protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSObjectProtocol implementAsBlocking({
    required objc.ObjCObjectBase Function() autorelease,
    required objc.ObjCObjectBase Function() class$,
    required bool Function(Protocol) conformsToProtocol_,
    NSString Function()? debugDescription,
    required NSString Function() description,
    required int Function() hash,
    required bool Function(objc.ObjCObjectBase) isEqual_,
    required bool Function(objc.ObjCObjectBase) isKindOfClass_,
    required bool Function(objc.ObjCObjectBase) isMemberOfClass_,
    required bool Function() isProxy,
    required objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>)
    performSelector_,
    required objc.ObjCObjectBase Function(
      ffi.Pointer<objc.ObjCSelector>,
      objc.ObjCObjectBase,
    )
    performSelector_withObject_,
    required objc.ObjCObjectBase Function(
      ffi.Pointer<objc.ObjCSelector>,
      objc.ObjCObjectBase,
      objc.ObjCObjectBase,
    )
    performSelector_withObject_withObject_,
    required void Function() release,
    required bool Function(ffi.Pointer<objc.ObjCSelector>) respondsToSelector_,
    required objc.ObjCObjectBase Function() retain,
    required int Function() retainCount,
    required objc.ObjCObjectBase Function() self,
    required objc.ObjCObjectBase Function() superclass,
    required ffi.Pointer<NSZone> Function() zone,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSObject');
    NSObjectProtocol$Builder.autorelease.implement(builder, autorelease);
    NSObjectProtocol$Builder.class$.implement(builder, class$);
    NSObjectProtocol$Builder.conformsToProtocol_.implement(
      builder,
      conformsToProtocol_,
    );
    NSObjectProtocol$Builder.debugDescription.implement(
      builder,
      debugDescription,
    );
    NSObjectProtocol$Builder.description.implement(builder, description);
    NSObjectProtocol$Builder.hash.implement(builder, hash);
    NSObjectProtocol$Builder.isEqual_.implement(builder, isEqual_);
    NSObjectProtocol$Builder.isKindOfClass_.implement(builder, isKindOfClass_);
    NSObjectProtocol$Builder.isMemberOfClass_.implement(
      builder,
      isMemberOfClass_,
    );
    NSObjectProtocol$Builder.isProxy.implement(builder, isProxy);
    NSObjectProtocol$Builder.performSelector_.implement(
      builder,
      performSelector_,
    );
    NSObjectProtocol$Builder.performSelector_withObject_.implement(
      builder,
      performSelector_withObject_,
    );
    NSObjectProtocol$Builder.performSelector_withObject_withObject_.implement(
      builder,
      performSelector_withObject_withObject_,
    );
    NSObjectProtocol$Builder.release.implementAsBlocking(builder, release);
    NSObjectProtocol$Builder.respondsToSelector_.implement(
      builder,
      respondsToSelector_,
    );
    NSObjectProtocol$Builder.retain.implement(builder, retain);
    NSObjectProtocol$Builder.retainCount.implement(builder, retainCount);
    NSObjectProtocol$Builder.self.implement(builder, self);
    NSObjectProtocol$Builder.superclass.implement(builder, superclass);
    NSObjectProtocol$Builder.zone.implement(builder, zone);
    builder.addProtocol($protocol);
    return NSObjectProtocol.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSObject protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    required objc.ObjCObjectBase Function() autorelease,
    required objc.ObjCObjectBase Function() class$,
    required bool Function(Protocol) conformsToProtocol_,
    NSString Function()? debugDescription,
    required NSString Function() description,
    required int Function() hash,
    required bool Function(objc.ObjCObjectBase) isEqual_,
    required bool Function(objc.ObjCObjectBase) isKindOfClass_,
    required bool Function(objc.ObjCObjectBase) isMemberOfClass_,
    required bool Function() isProxy,
    required objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>)
    performSelector_,
    required objc.ObjCObjectBase Function(
      ffi.Pointer<objc.ObjCSelector>,
      objc.ObjCObjectBase,
    )
    performSelector_withObject_,
    required objc.ObjCObjectBase Function(
      ffi.Pointer<objc.ObjCSelector>,
      objc.ObjCObjectBase,
      objc.ObjCObjectBase,
    )
    performSelector_withObject_withObject_,
    required void Function() release,
    required bool Function(ffi.Pointer<objc.ObjCSelector>) respondsToSelector_,
    required objc.ObjCObjectBase Function() retain,
    required int Function() retainCount,
    required objc.ObjCObjectBase Function() self,
    required objc.ObjCObjectBase Function() superclass,
    required ffi.Pointer<NSZone> Function() zone,
    bool $keepIsolateAlive = true,
  }) {
    NSObjectProtocol$Builder.autorelease.implement(builder, autorelease);
    NSObjectProtocol$Builder.class$.implement(builder, class$);
    NSObjectProtocol$Builder.conformsToProtocol_.implement(
      builder,
      conformsToProtocol_,
    );
    NSObjectProtocol$Builder.debugDescription.implement(
      builder,
      debugDescription,
    );
    NSObjectProtocol$Builder.description.implement(builder, description);
    NSObjectProtocol$Builder.hash.implement(builder, hash);
    NSObjectProtocol$Builder.isEqual_.implement(builder, isEqual_);
    NSObjectProtocol$Builder.isKindOfClass_.implement(builder, isKindOfClass_);
    NSObjectProtocol$Builder.isMemberOfClass_.implement(
      builder,
      isMemberOfClass_,
    );
    NSObjectProtocol$Builder.isProxy.implement(builder, isProxy);
    NSObjectProtocol$Builder.performSelector_.implement(
      builder,
      performSelector_,
    );
    NSObjectProtocol$Builder.performSelector_withObject_.implement(
      builder,
      performSelector_withObject_,
    );
    NSObjectProtocol$Builder.performSelector_withObject_withObject_.implement(
      builder,
      performSelector_withObject_withObject_,
    );
    NSObjectProtocol$Builder.release.implementAsBlocking(builder, release);
    NSObjectProtocol$Builder.respondsToSelector_.implement(
      builder,
      respondsToSelector_,
    );
    NSObjectProtocol$Builder.retain.implement(builder, retain);
    NSObjectProtocol$Builder.retainCount.implement(builder, retainCount);
    NSObjectProtocol$Builder.self.implement(builder, self);
    NSObjectProtocol$Builder.superclass.implement(builder, superclass);
    NSObjectProtocol$Builder.zone.implement(builder, zone);
    builder.addProtocol($protocol);
  }

  /// autorelease
  static final autorelease =
      objc.ObjCProtocolMethod<objc.ObjCObjectBase Function()>(
        _protocol_NSObject,
        _sel_autorelease,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_1mbt9g9)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSObject,
          _sel_autorelease,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (objc.ObjCObjectBase Function() func) =>
            ObjCBlock_objcObjCObject_ffiVoid.fromFunction(
              (ffi.Pointer<ffi.Void> _) => func(),
            ),
      );

  /// class
  static final class$ = objc.ObjCProtocolMethod<objc.ObjCObjectBase Function()>(
    _protocol_NSObject,
    _sel_class,
    ffi.Native.addressOf<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >(_ObjectiveCBindings_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_class,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase Function() func) =>
        ObjCBlock_objcObjCObject_ffiVoid.fromFunction(
          (ffi.Pointer<ffi.Void> _) => func(),
        ),
  );

  /// conformsToProtocol:
  static final conformsToProtocol_ =
      objc.ObjCProtocolMethod<bool Function(Protocol)>(
        _protocol_NSObject,
        _sel_conformsToProtocol_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Bool Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_3su7tt)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSObject,
          _sel_conformsToProtocol_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (bool Function(Protocol) func) =>
            ObjCBlock_bool_ffiVoid_Protocol.fromFunction(
              (ffi.Pointer<ffi.Void> _, Protocol arg1) => func(arg1),
            ),
      );

  /// debugDescription
  static final debugDescription = objc.ObjCProtocolMethod<NSString Function()>(
    _protocol_NSObject,
    _sel_debugDescription,
    ffi.Native.addressOf<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >(_ObjectiveCBindings_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_debugDescription,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (NSString Function() func) => ObjCBlock_NSString_ffiVoid.fromFunction(
      (ffi.Pointer<ffi.Void> _) => func(),
    ),
  );

  /// description
  static final description = objc.ObjCProtocolMethod<NSString Function()>(
    _protocol_NSObject,
    _sel_description,
    ffi.Native.addressOf<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >(_ObjectiveCBindings_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_description,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (NSString Function() func) => ObjCBlock_NSString_ffiVoid.fromFunction(
      (ffi.Pointer<ffi.Void> _) => func(),
    ),
  );

  /// hash
  static final hash = objc.ObjCProtocolMethod<int Function()>(
    _protocol_NSObject,
    _sel_hash,
    ffi.Native.addressOf<
          ffi.NativeFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >(_ObjectiveCBindings_protocolTrampoline_1ckyi24)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_hash,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (int Function() func) => ObjCBlock_NSUInteger_ffiVoid.fromFunction(
      (ffi.Pointer<ffi.Void> _) => func(),
    ),
  );

  /// isEqual:
  static final isEqual_ =
      objc.ObjCProtocolMethod<bool Function(objc.ObjCObjectBase)>(
        _protocol_NSObject,
        _sel_isEqual_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Bool Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_3su7tt)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSObject,
          _sel_isEqual_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (bool Function(objc.ObjCObjectBase) func) =>
            ObjCBlock_bool_ffiVoid_objcObjCObject.fromFunction(
              (ffi.Pointer<ffi.Void> _, objc.ObjCObjectBase arg1) => func(arg1),
            ),
      );

  /// isKindOfClass:
  static final isKindOfClass_ =
      objc.ObjCProtocolMethod<bool Function(objc.ObjCObjectBase)>(
        _protocol_NSObject,
        _sel_isKindOfClass_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Bool Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_3su7tt)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSObject,
          _sel_isKindOfClass_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (bool Function(objc.ObjCObjectBase) func) =>
            ObjCBlock_bool_ffiVoid_objcObjCObject.fromFunction(
              (ffi.Pointer<ffi.Void> _, objc.ObjCObjectBase arg1) => func(arg1),
            ),
      );

  /// isMemberOfClass:
  static final isMemberOfClass_ =
      objc.ObjCProtocolMethod<bool Function(objc.ObjCObjectBase)>(
        _protocol_NSObject,
        _sel_isMemberOfClass_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Bool Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_3su7tt)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSObject,
          _sel_isMemberOfClass_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (bool Function(objc.ObjCObjectBase) func) =>
            ObjCBlock_bool_ffiVoid_objcObjCObject.fromFunction(
              (ffi.Pointer<ffi.Void> _, objc.ObjCObjectBase arg1) => func(arg1),
            ),
      );

  /// isProxy
  static final isProxy = objc.ObjCProtocolMethod<bool Function()>(
    _protocol_NSObject,
    _sel_isProxy,
    ffi.Native.addressOf<
          ffi.NativeFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >(_ObjectiveCBindings_protocolTrampoline_e3qsqz)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_isProxy,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (bool Function() func) => ObjCBlock_bool_ffiVoid.fromFunction(
      (ffi.Pointer<ffi.Void> _) => func(),
    ),
  );

  /// performSelector:
  static final performSelector_ =
      objc.ObjCProtocolMethod<
        objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>)
      >(
        _protocol_NSObject,
        _sel_performSelector_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCSelector>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_50as9u)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSObject,
          _sel_performSelector_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (objc.ObjCObjectBase Function(ffi.Pointer<objc.ObjCSelector>) func) =>
            ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector.fromFunction(
              (ffi.Pointer<ffi.Void> _, ffi.Pointer<objc.ObjCSelector> arg1) =>
                  func(arg1),
            ),
      );

  /// performSelector:withObject:
  static final performSelector_withObject_ =
      objc.ObjCProtocolMethod<
        objc.ObjCObjectBase Function(
          ffi.Pointer<objc.ObjCSelector>,
          objc.ObjCObjectBase,
        )
      >(
        _protocol_NSObject,
        _sel_performSelector_withObject_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCSelector>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_1mllhpc)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSObject,
          _sel_performSelector_withObject_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (
          objc.ObjCObjectBase Function(
            ffi.Pointer<objc.ObjCSelector>,
            objc.ObjCObjectBase,
          )
          func,
        ) =>
            ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                ffi.Pointer<objc.ObjCSelector> arg1,
                objc.ObjCObjectBase arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// performSelector:withObject:withObject:
  static final performSelector_withObject_withObject_ =
      objc.ObjCProtocolMethod<
        objc.ObjCObjectBase Function(
          ffi.Pointer<objc.ObjCSelector>,
          objc.ObjCObjectBase,
          objc.ObjCObjectBase,
        )
      >(
        _protocol_NSObject,
        _sel_performSelector_withObject_withObject_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCSelector>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_c7gk2u)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSObject,
          _sel_performSelector_withObject_withObject_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (
          objc.ObjCObjectBase Function(
            ffi.Pointer<objc.ObjCSelector>,
            objc.ObjCObjectBase,
            objc.ObjCObjectBase,
          )
          func,
        ) =>
            ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_objcObjCObject.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                ffi.Pointer<objc.ObjCSelector> arg1,
                objc.ObjCObjectBase arg2,
                objc.ObjCObjectBase arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// release
  static final release = objc.ObjCProtocolListenableMethod<void Function()>(
    _protocol_NSObject,
    _sel_release,
    ffi.Native.addressOf<
          ffi.NativeFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >(_ObjectiveCBindings_protocolTrampoline_ovsamd)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_release,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.fromFunction(
      (ffi.Pointer<ffi.Void> _) => func(),
    ),
    (void Function() func) =>
        ObjCBlock_ffiVoid_ffiVoid.listener((ffi.Pointer<ffi.Void> _) => func()),
    (void Function() func) =>
        ObjCBlock_ffiVoid_ffiVoid.blocking((ffi.Pointer<ffi.Void> _) => func()),
  );

  /// respondsToSelector:
  static final respondsToSelector_ =
      objc.ObjCProtocolMethod<bool Function(ffi.Pointer<objc.ObjCSelector>)>(
        _protocol_NSObject,
        _sel_respondsToSelector_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Bool Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCSelector>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_w1e3k0)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSObject,
          _sel_respondsToSelector_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (bool Function(ffi.Pointer<objc.ObjCSelector>) func) =>
            ObjCBlock_bool_ffiVoid_objcObjCSelector.fromFunction(
              (ffi.Pointer<ffi.Void> _, ffi.Pointer<objc.ObjCSelector> arg1) =>
                  func(arg1),
            ),
      );

  /// retain
  static final retain = objc.ObjCProtocolMethod<objc.ObjCObjectBase Function()>(
    _protocol_NSObject,
    _sel_retain,
    ffi.Native.addressOf<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >(_ObjectiveCBindings_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_retain,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase Function() func) =>
        ObjCBlock_objcObjCObject_ffiVoid.fromFunction(
          (ffi.Pointer<ffi.Void> _) => func(),
        ),
  );

  /// retainCount
  static final retainCount = objc.ObjCProtocolMethod<int Function()>(
    _protocol_NSObject,
    _sel_retainCount,
    ffi.Native.addressOf<
          ffi.NativeFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >(_ObjectiveCBindings_protocolTrampoline_1ckyi24)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_retainCount,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (int Function() func) => ObjCBlock_NSUInteger_ffiVoid.fromFunction(
      (ffi.Pointer<ffi.Void> _) => func(),
    ),
  );

  /// self
  static final self = objc.ObjCProtocolMethod<objc.ObjCObjectBase Function()>(
    _protocol_NSObject,
    _sel_self,
    ffi.Native.addressOf<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >(_ObjectiveCBindings_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_self,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (objc.ObjCObjectBase Function() func) =>
        ObjCBlock_objcObjCObject_ffiVoid.fromFunction(
          (ffi.Pointer<ffi.Void> _) => func(),
        ),
  );

  /// superclass
  static final superclass =
      objc.ObjCProtocolMethod<objc.ObjCObjectBase Function()>(
        _protocol_NSObject,
        _sel_superclass,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_1mbt9g9)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSObject,
          _sel_superclass,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (objc.ObjCObjectBase Function() func) =>
            ObjCBlock_objcObjCObject_ffiVoid.fromFunction(
              (ffi.Pointer<ffi.Void> _) => func(),
            ),
      );

  /// zone
  static final zone = objc.ObjCProtocolMethod<ffi.Pointer<NSZone> Function()>(
    _protocol_NSObject,
    _sel_zone,
    ffi.Native.addressOf<
          ffi.NativeFunction<
            ffi.Pointer<NSZone> Function(
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >(_ObjectiveCBindings_protocolTrampoline_1a8cl66)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSObject,
      _sel_zone,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (ffi.Pointer<NSZone> Function() func) =>
        ObjCBlock_NSZone_ffiVoid.fromFunction(
          (ffi.Pointer<ffi.Void> _) => func(),
        ),
  );
}

/// NSOrderedCollectionChange
///
/// iOS: introduced 13.0.0
/// macOS: introduced 10.15.0
extension type NSOrderedCollectionChange.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [NSOrderedCollectionChange] that wraps the given raw object pointer.
  NSOrderedCollectionChange.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSOrderedCollectionChange].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSOrderedCollectionChange,
    );
  }

  /// alloc
  static NSOrderedCollectionChange alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSOrderedCollectionChange,
      _sel_alloc,
    );
    return NSOrderedCollectionChange.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NSOrderedCollectionChange allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSOrderedCollectionChange,
      _sel_allocWithZone_,
      zone,
    );
    return NSOrderedCollectionChange.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// changeWithObject:type:index:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  static NSOrderedCollectionChange changeWithObject(
    objc.ObjCObjectBase? anObject, {
    required NSCollectionChangeType type,
    required int index,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionChange.changeWithObject:type:index:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_vbymrb(
      _class_NSOrderedCollectionChange,
      _sel_changeWithObject_type_index_,
      anObject?.ref.pointer ?? ffi.nullptr,
      type.value,
      index,
    );
    return NSOrderedCollectionChange.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// changeWithObject:type:index:associatedIndex:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  static NSOrderedCollectionChange changeWithObject$1(
    objc.ObjCObjectBase? anObject, {
    required NSCollectionChangeType type,
    required int index,
    required int associatedIndex,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionChange.changeWithObject:type:index:associatedIndex:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1egc1c(
      _class_NSOrderedCollectionChange,
      _sel_changeWithObject_type_index_associatedIndex_,
      anObject?.ref.pointer ?? ffi.nullptr,
      type.value,
      index,
      associatedIndex,
    );
    return NSOrderedCollectionChange.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// new
  static NSOrderedCollectionChange new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSOrderedCollectionChange,
      _sel_new,
    );
    return NSOrderedCollectionChange.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of NSOrderedCollectionChange constructed with the default `new` method.
  NSOrderedCollectionChange() : this.castFrom(new$()._$);
}

extension NSOrderedCollectionChange$Methods on NSOrderedCollectionChange {
  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  int get associatedIndex {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionChange.associatedIndex',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_associatedIndex);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  NSCollectionChangeType get changeType {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionChange.changeType',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_hc8exi(_$.ref.pointer, _sel_changeType);
    return NSCollectionChangeType.fromValue($ret);
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  int get index {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionChange.index',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_index);
  }

  /// init
  NSOrderedCollectionChange init() {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionChange.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSOrderedCollectionChange.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithObject:type:index:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  NSOrderedCollectionChange initWithObject(
    objc.ObjCObjectBase? anObject, {
    required NSCollectionChangeType type,
    required int index,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionChange.initWithObject:type:index:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_vbymrb(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObject_type_index_,
      anObject?.ref.pointer ?? ffi.nullptr,
      type.value,
      index,
    );
    return NSOrderedCollectionChange.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithObject:type:index:associatedIndex:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  NSOrderedCollectionChange initWithObject$1(
    objc.ObjCObjectBase? anObject, {
    required NSCollectionChangeType type,
    required int index,
    required int associatedIndex,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionChange.initWithObject:type:index:associatedIndex:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1egc1c(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObject_type_index_associatedIndex_,
      anObject?.ref.pointer ?? ffi.nullptr,
      type.value,
      index,
      associatedIndex,
    );
    return NSOrderedCollectionChange.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  objc.ObjCObjectBase? get object {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionChange.object',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_object);
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }
}

/// NSOrderedCollectionDifference
///
/// iOS: introduced 13.0.0
/// macOS: introduced 10.15.0
extension type NSOrderedCollectionDifference.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject, NSFastEnumeration {
  /// Constructs a [NSOrderedCollectionDifference] that wraps the given raw object pointer.
  NSOrderedCollectionDifference.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSOrderedCollectionDifference].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSOrderedCollectionDifference,
    );
  }

  /// alloc
  static NSOrderedCollectionDifference alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSOrderedCollectionDifference,
      _sel_alloc,
    );
    return NSOrderedCollectionDifference.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NSOrderedCollectionDifference allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSOrderedCollectionDifference,
      _sel_allocWithZone_,
      zone,
    );
    return NSOrderedCollectionDifference.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static NSOrderedCollectionDifference new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSOrderedCollectionDifference,
      _sel_new,
    );
    return NSOrderedCollectionDifference.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of NSOrderedCollectionDifference constructed with the default `new` method.
  NSOrderedCollectionDifference() : this.castFrom(new$()._$);
}

extension NSOrderedCollectionDifference$Methods
    on NSOrderedCollectionDifference {
  /// countByEnumeratingWithState:objects:count:
  int countByEnumeratingWithState(
    ffi.Pointer<NSFastEnumerationState> state, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects,
    required int count,
  }) {
    return _objc_msgSend_1b5ysjl(
      _$.ref.pointer,
      _sel_countByEnumeratingWithState_objects_count_,
      state,
      objects,
      count,
    );
  }

  /// differenceByTransformingChangesWithBlock:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  NSOrderedCollectionDifference differenceByTransformingChangesWithBlock(
    objc.ObjCBlock<
      NSOrderedCollectionChange Function(NSOrderedCollectionChange)
    >
    block,
  ) {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionDifference.differenceByTransformingChangesWithBlock:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_nnxkei(
      _$.ref.pointer,
      _sel_differenceByTransformingChangesWithBlock_,
      block.ref.pointer,
    );
    return NSOrderedCollectionDifference.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  bool get hasChanges {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionDifference.hasChanges',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_hasChanges);
  }

  /// init
  NSOrderedCollectionDifference init() {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionDifference.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSOrderedCollectionDifference.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithChanges:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  NSOrderedCollectionDifference initWithChanges(NSArray changes) {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionDifference.initWithChanges:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithChanges_,
      changes.ref.pointer,
    );
    return NSOrderedCollectionDifference.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithInsertIndexes:insertedObjects:removeIndexes:removedObjects:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  NSOrderedCollectionDifference initWithInsertIndexes(
    NSIndexSet inserts, {
    NSArray? insertedObjects,
    required NSIndexSet removeIndexes,
    NSArray? removedObjects,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionDifference.initWithInsertIndexes:insertedObjects:removeIndexes:removedObjects:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_s92gih(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithInsertIndexes_insertedObjects_removeIndexes_removedObjects_,
      inserts.ref.pointer,
      insertedObjects?.ref.pointer ?? ffi.nullptr,
      removeIndexes.ref.pointer,
      removedObjects?.ref.pointer ?? ffi.nullptr,
    );
    return NSOrderedCollectionDifference.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithInsertIndexes:insertedObjects:removeIndexes:removedObjects:additionalChanges:
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  NSOrderedCollectionDifference initWithInsertIndexes$1(
    NSIndexSet inserts, {
    NSArray? insertedObjects,
    required NSIndexSet removeIndexes,
    NSArray? removedObjects,
    required NSArray additionalChanges,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionDifference.initWithInsertIndexes:insertedObjects:removeIndexes:removedObjects:additionalChanges:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_3cbdpb(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithInsertIndexes_insertedObjects_removeIndexes_removedObjects_additionalChanges_,
      inserts.ref.pointer,
      insertedObjects?.ref.pointer ?? ffi.nullptr,
      removeIndexes.ref.pointer,
      removedObjects?.ref.pointer ?? ffi.nullptr,
      additionalChanges.ref.pointer,
    );
    return NSOrderedCollectionDifference.castFromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  NSArray get insertions {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionDifference.insertions',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_insertions);
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// inverseDifference
  ///
  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  NSOrderedCollectionDifference inverseDifference() {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionDifference.inverseDifference',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_inverseDifference);
    return NSOrderedCollectionDifference.castFromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// iOS: introduced 13.0.0
  /// macOS: introduced 10.15.0
  NSArray get removals {
    objc.checkOsVersionInternal(
      'NSOrderedCollectionDifference.removals',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_removals);
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }
}

/// iOS: introduced 13.0.0
/// macOS: introduced 10.15.0
sealed class NSOrderedCollectionDifferenceCalculationOptions {
  static const NSOrderedCollectionDifferenceCalculationOmitInsertedObjects = 1;
  static const NSOrderedCollectionDifferenceCalculationOmitRemovedObjects = 2;
  static const NSOrderedCollectionDifferenceCalculationInferMoves = 4;
}

/// NSOrderedSet
extension type NSOrderedSet.castFrom(objc.ObjCObjectBase _$)
    implements
        objc.ObjCObjectBase,
        NSObject,
        NSCopying,
        NSMutableCopying,
        NSSecureCoding,
        NSFastEnumeration {
  /// Constructs a [NSOrderedSet] that wraps the given raw object pointer.
  NSOrderedSet.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSOrderedSet].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSOrderedSet,
    );
  }

  /// alloc
  static NSOrderedSet alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSOrderedSet, _sel_alloc);
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSOrderedSet allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSOrderedSet,
      _sel_allocWithZone_,
      zone,
    );
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSOrderedSet new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSOrderedSet, _sel_new);
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// orderedSet
  static NSOrderedSet orderedSet() {
    objc.checkOsVersionInternal(
      'NSOrderedSet.orderedSet',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_NSOrderedSet, _sel_orderedSet);
    return NSOrderedSet.castFromPointer($ret, retain: true, release: true);
  }

  /// orderedSetWithArray:
  static NSOrderedSet orderedSetWithArray(NSArray array) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.orderedSetWithArray:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSOrderedSet,
      _sel_orderedSetWithArray_,
      array.ref.pointer,
    );
    return NSOrderedSet.castFromPointer($ret, retain: true, release: true);
  }

  /// orderedSetWithArray:range:copyItems:
  static NSOrderedSet orderedSetWithArray$1(
    NSArray array, {
    required NSRange range,
    required bool copyItems,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.orderedSetWithArray:range:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_w9bq5x(
      _class_NSOrderedSet,
      _sel_orderedSetWithArray_range_copyItems_,
      array.ref.pointer,
      range,
      copyItems,
    );
    return NSOrderedSet.castFromPointer($ret, retain: true, release: true);
  }

  /// orderedSetWithObject:
  static NSOrderedSet orderedSetWithObject(objc.ObjCObjectBase object) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.orderedSetWithObject:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSOrderedSet,
      _sel_orderedSetWithObject_,
      object.ref.pointer,
    );
    return NSOrderedSet.castFromPointer($ret, retain: true, release: true);
  }

  /// orderedSetWithObjects:
  static NSOrderedSet orderedSetWithObjects(objc.ObjCObjectBase firstObj) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.orderedSetWithObjects:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSOrderedSet,
      _sel_orderedSetWithObjects_,
      firstObj.ref.pointer,
    );
    return NSOrderedSet.castFromPointer($ret, retain: true, release: true);
  }

  /// orderedSetWithObjects:count:
  static NSOrderedSet orderedSetWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required int count,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.orderedSetWithObjects:count:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_zmbtbd(
      _class_NSOrderedSet,
      _sel_orderedSetWithObjects_count_,
      objects,
      count,
    );
    return NSOrderedSet.castFromPointer($ret, retain: true, release: true);
  }

  /// orderedSetWithOrderedSet:
  static NSOrderedSet orderedSetWithOrderedSet(NSOrderedSet set) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.orderedSetWithOrderedSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSOrderedSet,
      _sel_orderedSetWithOrderedSet_,
      set.ref.pointer,
    );
    return NSOrderedSet.castFromPointer($ret, retain: true, release: true);
  }

  /// orderedSetWithOrderedSet:range:copyItems:
  static NSOrderedSet orderedSetWithOrderedSet$1(
    NSOrderedSet set, {
    required NSRange range,
    required bool copyItems,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.orderedSetWithOrderedSet:range:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_w9bq5x(
      _class_NSOrderedSet,
      _sel_orderedSetWithOrderedSet_range_copyItems_,
      set.ref.pointer,
      range,
      copyItems,
    );
    return NSOrderedSet.castFromPointer($ret, retain: true, release: true);
  }

  /// orderedSetWithSet:
  static NSOrderedSet orderedSetWithSet(NSSet set) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.orderedSetWithSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSOrderedSet,
      _sel_orderedSetWithSet_,
      set.ref.pointer,
    );
    return NSOrderedSet.castFromPointer($ret, retain: true, release: true);
  }

  /// orderedSetWithSet:copyItems:
  static NSOrderedSet orderedSetWithSet$1(
    NSSet set, {
    required bool copyItems,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.orderedSetWithSet:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _class_NSOrderedSet,
      _sel_orderedSetWithSet_copyItems_,
      set.ref.pointer,
      copyItems,
    );
    return NSOrderedSet.castFromPointer($ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSOrderedSet, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSOrderedSet constructed with the default `new` method.
  NSOrderedSet() : this.castFrom(new$()._$);
}

extension NSOrderedSet$Methods on NSOrderedSet {
  /// count
  int get count {
    objc.checkOsVersionInternal(
      'NSOrderedSet.count',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_count);
  }

  /// countByEnumeratingWithState:objects:count:
  int countByEnumeratingWithState(
    ffi.Pointer<NSFastEnumerationState> state, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects,
    required int count,
  }) {
    return _objc_msgSend_1b5ysjl(
      _$.ref.pointer,
      _sel_countByEnumeratingWithState_objects_count_,
      state,
      objects,
      count,
    );
  }

  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// indexOfObject:
  int indexOfObject(objc.ObjCObjectBase object) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.indexOfObject:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_1vd1c5m(
      _$.ref.pointer,
      _sel_indexOfObject_,
      object.ref.pointer,
    );
  }

  /// init
  NSOrderedSet init() {
    objc.checkOsVersionInternal(
      'NSOrderedSet.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithArray:
  NSOrderedSet initWithArray(NSArray array) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.initWithArray:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithArray_,
      array.ref.pointer,
    );
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithArray:copyItems:
  NSOrderedSet initWithArray$1(NSArray set, {required bool copyItems}) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.initWithArray:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithArray_copyItems_,
      set.ref.pointer,
      copyItems,
    );
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithArray:range:copyItems:
  NSOrderedSet initWithArray$2(
    NSArray set, {
    required NSRange range,
    required bool copyItems,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.initWithArray:range:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_w9bq5x(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithArray_range_copyItems_,
      set.ref.pointer,
      range,
      copyItems,
    );
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSOrderedSet? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObject:
  NSOrderedSet initWithObject(objc.ObjCObjectBase object) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.initWithObject:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObject_,
      object.ref.pointer,
    );
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObjects:
  NSOrderedSet initWithObjects(objc.ObjCObjectBase firstObj) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.initWithObjects:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_,
      firstObj.ref.pointer,
    );
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObjects:count:
  NSOrderedSet initWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required int count,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.initWithObjects:count:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_zmbtbd(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_count_,
      objects,
      count,
    );
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithOrderedSet:
  NSOrderedSet initWithOrderedSet(NSOrderedSet set) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.initWithOrderedSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithOrderedSet_,
      set.ref.pointer,
    );
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithOrderedSet:copyItems:
  NSOrderedSet initWithOrderedSet$1(
    NSOrderedSet set, {
    required bool copyItems,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.initWithOrderedSet:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithOrderedSet_copyItems_,
      set.ref.pointer,
      copyItems,
    );
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithOrderedSet:range:copyItems:
  NSOrderedSet initWithOrderedSet$2(
    NSOrderedSet set, {
    required NSRange range,
    required bool copyItems,
  }) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.initWithOrderedSet:range:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_w9bq5x(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithOrderedSet_range_copyItems_,
      set.ref.pointer,
      range,
      copyItems,
    );
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithSet:
  NSOrderedSet initWithSet(NSSet set) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.initWithSet:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithSet_,
      set.ref.pointer,
    );
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithSet:copyItems:
  NSOrderedSet initWithSet$1(NSSet set, {required bool copyItems}) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.initWithSet:copyItems:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithSet_copyItems_,
      set.ref.pointer,
      copyItems,
    );
    return NSOrderedSet.castFromPointer($ret, retain: false, release: true);
  }

  /// objectAtIndex:
  objc.ObjCObjectBase objectAtIndex(int idx) {
    objc.checkOsVersionInternal(
      'NSOrderedSet.objectAtIndex:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.pointer,
      _sel_objectAtIndex_,
      idx,
    );
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }
}

/// NSOutputStream
extension type NSOutputStream.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSStream {
  /// Constructs a [NSOutputStream] that wraps the given raw object pointer.
  NSOutputStream.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSOutputStream].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSOutputStream,
    );
  }

  /// alloc
  static NSOutputStream alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSOutputStream, _sel_alloc);
    return NSOutputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSOutputStream allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSOutputStream,
      _sel_allocWithZone_,
      zone,
    );
    return NSOutputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSOutputStream new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSOutputStream, _sel_new);
    return NSOutputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// outputStreamToBuffer:capacity:
  static NSOutputStream outputStreamToBuffer(
    ffi.Pointer<ffi.Uint8> buffer, {
    required int capacity,
  }) {
    final $ret = _objc_msgSend_158ju31(
      _class_NSOutputStream,
      _sel_outputStreamToBuffer_capacity_,
      buffer,
      capacity,
    );
    return NSOutputStream.castFromPointer($ret, retain: true, release: true);
  }

  /// outputStreamToFileAtPath:append:
  static NSOutputStream outputStreamToFileAtPath(
    NSString path, {
    required bool append,
  }) {
    final $ret = _objc_msgSend_17amj0z(
      _class_NSOutputStream,
      _sel_outputStreamToFileAtPath_append_,
      path.ref.pointer,
      append,
    );
    return NSOutputStream.castFromPointer($ret, retain: true, release: true);
  }

  /// outputStreamToMemory
  static NSOutputStream outputStreamToMemory() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSOutputStream,
      _sel_outputStreamToMemory,
    );
    return NSOutputStream.castFromPointer($ret, retain: true, release: true);
  }

  /// outputStreamWithURL:append:
  static NSOutputStream? outputStreamWithURL(
    NSURL url, {
    required bool append,
  }) {
    objc.checkOsVersionInternal(
      'NSOutputStream.outputStreamWithURL:append:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _class_NSOutputStream,
      _sel_outputStreamWithURL_append_,
      url.ref.pointer,
      append,
    );
    return $ret.address == 0
        ? null
        : NSOutputStream.castFromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of NSOutputStream constructed with the default `new` method.
  NSOutputStream() : this.castFrom(new$()._$);
}

extension NSOutputStream$Methods on NSOutputStream {
  /// hasSpaceAvailable
  bool get hasSpaceAvailable {
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_hasSpaceAvailable);
  }

  /// init
  NSOutputStream init() {
    objc.checkOsVersionInternal(
      'NSOutputStream.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSOutputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// initToBuffer:capacity:
  NSOutputStream initToBuffer(
    ffi.Pointer<ffi.Uint8> buffer, {
    required int capacity,
  }) {
    final $ret = _objc_msgSend_158ju31(
      _$.ref.retainAndReturnPointer(),
      _sel_initToBuffer_capacity_,
      buffer,
      capacity,
    );
    return NSOutputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// initToFileAtPath:append:
  NSOutputStream? initToFileAtPath(NSString path, {required bool append}) {
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initToFileAtPath_append_,
      path.ref.pointer,
      append,
    );
    return $ret.address == 0
        ? null
        : NSOutputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// initToMemory
  NSOutputStream initToMemory() {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_initToMemory,
    );
    return NSOutputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithURL:append:
  NSOutputStream? initWithURL(NSURL url, {required bool append}) {
    objc.checkOsVersionInternal(
      'NSOutputStream.initWithURL:append:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithURL_append_,
      url.ref.pointer,
      append,
    );
    return $ret.address == 0
        ? null
        : NSOutputStream.castFromPointer($ret, retain: false, release: true);
  }

  /// write:maxLength:
  int write(ffi.Pointer<ffi.Uint8> buffer, {required int maxLength}) {
    return _objc_msgSend_11e9f5x(
      _$.ref.pointer,
      _sel_write_maxLength_,
      buffer,
      maxLength,
    );
  }
}

/// NSPort
extension type NSPort.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject, NSCopying, NSCoding {
  /// Constructs a [NSPort] that wraps the given raw object pointer.
  NSPort.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSPort].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSPort,
    );
  }

  /// alloc
  static NSPort alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSPort, _sel_alloc);
    return NSPort.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSPort allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSPort,
      _sel_allocWithZone_,
      zone,
    );
    return NSPort.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSPort new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSPort, _sel_new);
    return NSPort.castFromPointer($ret, retain: false, release: true);
  }

  /// port
  static NSPort port() {
    final $ret = _objc_msgSend_151sglz(_class_NSPort, _sel_port);
    return NSPort.castFromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of NSPort constructed with the default `new` method.
  NSPort() : this.castFrom(new$()._$);
}

extension NSPort$Methods on NSPort {
  /// delegate
  NSPortDelegate? delegate() {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_delegate);
    return $ret.address == 0
        ? null
        : NSPortDelegate.castFromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  NSPort init() {
    objc.checkOsVersionInternal(
      'NSPort.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSPort.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSPort? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSPort.castFromPointer($ret, retain: false, release: true);
  }

  /// invalidate
  void invalidate() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_invalidate);
  }

  /// isValid
  bool get isValid {
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isValid);
  }

  /// removeFromRunLoop:forMode:
  void removeFromRunLoop(NSRunLoop runLoop, {required NSString forMode}) {
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_removeFromRunLoop_forMode_,
      runLoop.ref.pointer,
      forMode.ref.pointer,
    );
  }

  /// reservedSpaceLength
  int get reservedSpaceLength {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_reservedSpaceLength);
  }

  /// scheduleInRunLoop:forMode:
  void scheduleInRunLoop(NSRunLoop runLoop, {required NSString forMode}) {
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_scheduleInRunLoop_forMode_,
      runLoop.ref.pointer,
      forMode.ref.pointer,
    );
  }

  /// sendBeforeDate:components:from:reserved:
  bool sendBeforeDate(
    NSDate limitDate, {
    NSMutableArray? components,
    NSPort? from,
    required int reserved,
  }) {
    return _objc_msgSend_1frfu5e(
      _$.ref.pointer,
      _sel_sendBeforeDate_components_from_reserved_,
      limitDate.ref.pointer,
      components?.ref.pointer ?? ffi.nullptr,
      from?.ref.pointer ?? ffi.nullptr,
      reserved,
    );
  }

  /// sendBeforeDate:msgid:components:from:reserved:
  bool sendBeforeDate$1(
    NSDate limitDate, {
    required int msgid,
    NSMutableArray? components,
    NSPort? from,
    required int reserved,
  }) {
    return _objc_msgSend_gupwtj(
      _$.ref.pointer,
      _sel_sendBeforeDate_msgid_components_from_reserved_,
      limitDate.ref.pointer,
      msgid,
      components?.ref.pointer ?? ffi.nullptr,
      from?.ref.pointer ?? ffi.nullptr,
      reserved,
    );
  }

  /// setDelegate:
  void setDelegate(NSPortDelegate? anObject) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setDelegate_,
      anObject?.ref.pointer ?? ffi.nullptr,
    );
  }
}

/// NSPortDelegate
extension type NSPortDelegate.castFrom(objc.ObjCProtocolBase _$)
    implements objc.ObjCProtocolBase, NSObjectProtocol {
  /// Constructs a [NSPortDelegate] that wraps the given raw object pointer.
  NSPortDelegate.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCProtocolBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSPortDelegate].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_NSPortDelegate,
    );
  }
}

extension NSPortDelegate$Methods on NSPortDelegate {
  /// handlePortMessage:
  void handlePortMessage(NSPortMessage message) {
    if (!objc.respondsToSelector(_$.ref.pointer, _sel_handlePortMessage_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSPortDelegate',
        'handlePortMessage:',
      );
    }
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_handlePortMessage_,
      message.ref.pointer,
    );
  }
}

interface class NSPortDelegate$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_NSPortDelegate.cast());

  /// Builds an object that implements the NSPortDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSPortDelegate implement({
    void Function(NSPortMessage)? handlePortMessage_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSPortDelegate');
    NSPortDelegate$Builder.handlePortMessage_.implement(
      builder,
      handlePortMessage_,
    );
    builder.addProtocol($protocol);
    return NSPortDelegate.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSPortDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSPortMessage)? handlePortMessage_,
    bool $keepIsolateAlive = true,
  }) {
    NSPortDelegate$Builder.handlePortMessage_.implement(
      builder,
      handlePortMessage_,
    );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSPortDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSPortDelegate implementAsListener({
    void Function(NSPortMessage)? handlePortMessage_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSPortDelegate');
    NSPortDelegate$Builder.handlePortMessage_.implementAsListener(
      builder,
      handlePortMessage_,
    );
    builder.addProtocol($protocol);
    return NSPortDelegate.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSPortDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSPortMessage)? handlePortMessage_,
    bool $keepIsolateAlive = true,
  }) {
    NSPortDelegate$Builder.handlePortMessage_.implementAsListener(
      builder,
      handlePortMessage_,
    );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSPortDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSPortDelegate implementAsBlocking({
    void Function(NSPortMessage)? handlePortMessage_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSPortDelegate');
    NSPortDelegate$Builder.handlePortMessage_.implementAsBlocking(
      builder,
      handlePortMessage_,
    );
    builder.addProtocol($protocol);
    return NSPortDelegate.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSPortDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSPortMessage)? handlePortMessage_,
    bool $keepIsolateAlive = true,
  }) {
    NSPortDelegate$Builder.handlePortMessage_.implementAsBlocking(
      builder,
      handlePortMessage_,
    );
    builder.addProtocol($protocol);
  }

  /// handlePortMessage:
  static final handlePortMessage_ =
      objc.ObjCProtocolListenableMethod<void Function(NSPortMessage)>(
        _protocol_NSPortDelegate,
        _sel_handlePortMessage_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_18v1jvf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSPortDelegate,
          _sel_handlePortMessage_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSPortMessage) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSPortMessage.fromFunction(
              (ffi.Pointer<ffi.Void> _, NSPortMessage arg1) => func(arg1),
            ),
        (void Function(NSPortMessage) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSPortMessage.listener(
              (ffi.Pointer<ffi.Void> _, NSPortMessage arg1) => func(arg1),
            ),
        (void Function(NSPortMessage) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSPortMessage.blocking(
              (ffi.Pointer<ffi.Void> _, NSPortMessage arg1) => func(arg1),
            ),
      );
}

/// NSPortMessage
extension type NSPortMessage.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [NSPortMessage] that wraps the given raw object pointer.
  NSPortMessage.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSPortMessage].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSPortMessage,
    );
  }

  /// alloc
  static NSPortMessage alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSPortMessage, _sel_alloc);
    return NSPortMessage.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSPortMessage allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSPortMessage,
      _sel_allocWithZone_,
      zone,
    );
    return NSPortMessage.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSPortMessage new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSPortMessage, _sel_new);
    return NSPortMessage.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSPortMessage constructed with the default `new` method.
  NSPortMessage() : this.castFrom(new$()._$);
}

extension NSPortMessage$Methods on NSPortMessage {
  /// components
  NSArray? get components {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_components);
    return $ret.address == 0
        ? null
        : NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  NSPortMessage init() {
    objc.checkOsVersionInternal(
      'NSPortMessage.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSPortMessage.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithSendPort:receivePort:components:
  NSPortMessage initWithSendPort(
    NSPort? sendPort, {
    NSPort? receivePort,
    NSArray? components,
  }) {
    final $ret = _objc_msgSend_11spmsz(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithSendPort_receivePort_components_,
      sendPort?.ref.pointer ?? ffi.nullptr,
      receivePort?.ref.pointer ?? ffi.nullptr,
      components?.ref.pointer ?? ffi.nullptr,
    );
    return NSPortMessage.castFromPointer($ret, retain: false, release: true);
  }

  /// msgid
  int get msgid {
    return _objc_msgSend_usggvf(_$.ref.pointer, _sel_msgid);
  }

  /// receivePort
  NSPort? get receivePort {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_receivePort);
    return $ret.address == 0
        ? null
        : NSPort.castFromPointer($ret, retain: true, release: true);
  }

  /// sendBeforeDate:
  bool sendBeforeDate(NSDate date) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_sendBeforeDate_,
      date.ref.pointer,
    );
  }

  /// sendPort
  NSPort? get sendPort {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_sendPort);
    return $ret.address == 0
        ? null
        : NSPort.castFromPointer($ret, retain: true, release: true);
  }

  /// setMsgid:
  set msgid(int value) {
    _objc_msgSend_1xpk2hb(_$.ref.pointer, _sel_setMsgid_, value);
  }
}

/// NSProgress
extension type NSProgress.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [NSProgress] that wraps the given raw object pointer.
  NSProgress.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSProgress].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSProgress,
    );
  }

  /// addSubscriberForFileURL:withPublishingHandler:
  ///
  /// iOS: unavailable
  /// macOS: introduced 10.9.0
  static objc.ObjCObjectBase addSubscriberForFileURL(
    NSURL url, {
    required objc.ObjCBlock<
      objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)
    >
    withPublishingHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSProgress.addSubscriberForFileURL:withPublishingHandler:',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_r0bo0s(
      _class_NSProgress,
      _sel_addSubscriberForFileURL_withPublishingHandler_,
      url.ref.pointer,
      withPublishingHandler.ref.pointer,
    );
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// alloc
  static NSProgress alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSProgress, _sel_alloc);
    return NSProgress.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSProgress allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSProgress,
      _sel_allocWithZone_,
      zone,
    );
    return NSProgress.castFromPointer($ret, retain: false, release: true);
  }

  /// currentProgress
  static NSProgress? currentProgress() {
    objc.checkOsVersionInternal(
      'NSProgress.currentProgress',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_NSProgress, _sel_currentProgress);
    return $ret.address == 0
        ? null
        : NSProgress.castFromPointer($ret, retain: true, release: true);
  }

  /// discreteProgressWithTotalUnitCount:
  static NSProgress discreteProgressWithTotalUnitCount(int unitCount) {
    objc.checkOsVersionInternal(
      'NSProgress.discreteProgressWithTotalUnitCount:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_1ya1kjn(
      _class_NSProgress,
      _sel_discreteProgressWithTotalUnitCount_,
      unitCount,
    );
    return NSProgress.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSProgress new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSProgress, _sel_new);
    return NSProgress.castFromPointer($ret, retain: false, release: true);
  }

  /// progressWithTotalUnitCount:
  static NSProgress progressWithTotalUnitCount(int unitCount) {
    objc.checkOsVersionInternal(
      'NSProgress.progressWithTotalUnitCount:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_1ya1kjn(
      _class_NSProgress,
      _sel_progressWithTotalUnitCount_,
      unitCount,
    );
    return NSProgress.castFromPointer($ret, retain: true, release: true);
  }

  /// progressWithTotalUnitCount:parent:pendingUnitCount:
  static NSProgress progressWithTotalUnitCount$1(
    int unitCount, {
    required NSProgress parent,
    required int pendingUnitCount,
  }) {
    objc.checkOsVersionInternal(
      'NSProgress.progressWithTotalUnitCount:parent:pendingUnitCount:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_553v(
      _class_NSProgress,
      _sel_progressWithTotalUnitCount_parent_pendingUnitCount_,
      unitCount,
      parent.ref.pointer,
      pendingUnitCount,
    );
    return NSProgress.castFromPointer($ret, retain: true, release: true);
  }

  /// removeSubscriber:
  ///
  /// iOS: unavailable
  /// macOS: introduced 10.9.0
  static void removeSubscriber(objc.ObjCObjectBase subscriber) {
    objc.checkOsVersionInternal(
      'NSProgress.removeSubscriber:',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_xtuoz7(
      _class_NSProgress,
      _sel_removeSubscriber_,
      subscriber.ref.pointer,
    );
  }

  /// Returns a new instance of NSProgress constructed with the default `new` method.
  NSProgress() : this.castFrom(new$()._$);
}

extension NSProgress$Methods on NSProgress {
  /// addChild:withPendingUnitCount:
  void addChild(NSProgress child, {required int withPendingUnitCount}) {
    objc.checkOsVersionInternal(
      'NSProgress.addChild:withPendingUnitCount:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_1m7prh1(
      _$.ref.pointer,
      _sel_addChild_withPendingUnitCount_,
      child.ref.pointer,
      withPendingUnitCount,
    );
  }

  /// becomeCurrentWithPendingUnitCount:
  void becomeCurrentWithPendingUnitCount(int unitCount) {
    objc.checkOsVersionInternal(
      'NSProgress.becomeCurrentWithPendingUnitCount:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_17gvxvj(
      _$.ref.pointer,
      _sel_becomeCurrentWithPendingUnitCount_,
      unitCount,
    );
  }

  /// cancel
  void cancel() {
    objc.checkOsVersionInternal(
      'NSProgress.cancel',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_cancel);
  }

  /// cancellationHandler
  objc.ObjCBlock<ffi.Void Function()>? get cancellationHandler {
    objc.checkOsVersionInternal(
      'NSProgress.cancellationHandler',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_uwvaik(_$.ref.pointer, _sel_cancellationHandler);
    return $ret.address == 0
        ? null
        : ObjCBlock_ffiVoid.castFromPointer($ret, retain: true, release: true);
  }

  /// completedUnitCount
  int get completedUnitCount {
    objc.checkOsVersionInternal(
      'NSProgress.completedUnitCount',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_pysgoz(_$.ref.pointer, _sel_completedUnitCount);
  }

  /// estimatedTimeRemaining
  NSNumber? get estimatedTimeRemaining {
    objc.checkOsVersionInternal(
      'NSProgress.estimatedTimeRemaining',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_estimatedTimeRemaining,
    );
    return $ret.address == 0
        ? null
        : NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// fileCompletedCount
  NSNumber? get fileCompletedCount {
    objc.checkOsVersionInternal(
      'NSProgress.fileCompletedCount',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_fileCompletedCount);
    return $ret.address == 0
        ? null
        : NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// fileOperationKind
  NSString? get fileOperationKind {
    objc.checkOsVersionInternal(
      'NSProgress.fileOperationKind',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_fileOperationKind);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// fileTotalCount
  NSNumber? get fileTotalCount {
    objc.checkOsVersionInternal(
      'NSProgress.fileTotalCount',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_fileTotalCount);
    return $ret.address == 0
        ? null
        : NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// fileURL
  NSURL? get fileURL {
    objc.checkOsVersionInternal(
      'NSProgress.fileURL',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_fileURL);
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// fractionCompleted
  double get fractionCompleted {
    objc.checkOsVersionInternal(
      'NSProgress.fractionCompleted',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_$.ref.pointer, _sel_fractionCompleted)
        : _objc_msgSend_1ukqyt8(_$.ref.pointer, _sel_fractionCompleted);
  }

  /// init
  NSProgress init() {
    objc.checkOsVersionInternal(
      'NSProgress.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSProgress.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithParent:userInfo:
  NSProgress initWithParent(
    NSProgress? parentProgressOrNil, {
    NSDictionary? userInfo,
  }) {
    objc.checkOsVersionInternal(
      'NSProgress.initWithParent:userInfo:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithParent_userInfo_,
      parentProgressOrNil?.ref.pointer ?? ffi.nullptr,
      userInfo?.ref.pointer ?? ffi.nullptr,
    );
    return NSProgress.castFromPointer($ret, retain: false, release: true);
  }

  /// isCancellable
  bool get isCancellable {
    objc.checkOsVersionInternal(
      'NSProgress.isCancellable',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isCancellable);
  }

  /// isCancelled
  bool get isCancelled {
    objc.checkOsVersionInternal(
      'NSProgress.isCancelled',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isCancelled);
  }

  /// isFinished
  bool get isFinished {
    objc.checkOsVersionInternal(
      'NSProgress.isFinished',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isFinished);
  }

  /// isIndeterminate
  bool get isIndeterminate {
    objc.checkOsVersionInternal(
      'NSProgress.isIndeterminate',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isIndeterminate);
  }

  /// iOS: unavailable
  /// macOS: introduced 10.9.0
  bool get isOld {
    objc.checkOsVersionInternal(
      'NSProgress.isOld',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isOld);
  }

  /// isPausable
  bool get isPausable {
    objc.checkOsVersionInternal(
      'NSProgress.isPausable',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isPausable);
  }

  /// isPaused
  bool get isPaused {
    objc.checkOsVersionInternal(
      'NSProgress.isPaused',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isPaused);
  }

  /// kind
  NSString? get kind {
    objc.checkOsVersionInternal(
      'NSProgress.kind',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_kind);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// localizedAdditionalDescription
  NSString get localizedAdditionalDescription {
    objc.checkOsVersionInternal(
      'NSProgress.localizedAdditionalDescription',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_localizedAdditionalDescription,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// localizedDescription
  NSString get localizedDescription {
    objc.checkOsVersionInternal(
      'NSProgress.localizedDescription',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_localizedDescription,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// pause
  void pause() {
    objc.checkOsVersionInternal(
      'NSProgress.pause',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_pause);
  }

  /// pausingHandler
  objc.ObjCBlock<ffi.Void Function()>? get pausingHandler {
    objc.checkOsVersionInternal(
      'NSProgress.pausingHandler',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_uwvaik(_$.ref.pointer, _sel_pausingHandler);
    return $ret.address == 0
        ? null
        : ObjCBlock_ffiVoid.castFromPointer($ret, retain: true, release: true);
  }

  /// performAsCurrentWithPendingUnitCount:usingBlock:
  void performAsCurrentWithPendingUnitCount(
    int unitCount, {
    required objc.ObjCBlock<ffi.Void Function()> usingBlock,
  }) {
    objc.checkOsVersionInternal(
      'NSProgress.performAsCurrentWithPendingUnitCount:usingBlock:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_1i0cxyc(
      _$.ref.pointer,
      _sel_performAsCurrentWithPendingUnitCount_usingBlock_,
      unitCount,
      usingBlock.ref.pointer,
    );
  }

  /// publish
  ///
  /// iOS: unavailable
  /// macOS: introduced 10.9.0
  void publish() {
    objc.checkOsVersionInternal(
      'NSProgress.publish',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_publish);
  }

  /// resignCurrent
  void resignCurrent() {
    objc.checkOsVersionInternal(
      'NSProgress.resignCurrent',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_resignCurrent);
  }

  /// resume
  void resume() {
    objc.checkOsVersionInternal(
      'NSProgress.resume',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_resume);
  }

  /// resumingHandler
  objc.ObjCBlock<ffi.Void Function()>? get resumingHandler {
    objc.checkOsVersionInternal(
      'NSProgress.resumingHandler',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_uwvaik(_$.ref.pointer, _sel_resumingHandler);
    return $ret.address == 0
        ? null
        : ObjCBlock_ffiVoid.castFromPointer($ret, retain: true, release: true);
  }

  /// setCancellable:
  set isCancellable(bool value) {
    objc.checkOsVersionInternal(
      'NSProgress.setCancellable:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1s56lr9(_$.ref.pointer, _sel_setCancellable_, value);
  }

  /// setCancellationHandler:
  set cancellationHandler(objc.ObjCBlock<ffi.Void Function()>? value) {
    objc.checkOsVersionInternal(
      'NSProgress.setCancellationHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_f167m6(
      _$.ref.pointer,
      _sel_setCancellationHandler_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setCompletedUnitCount:
  set completedUnitCount(int value) {
    objc.checkOsVersionInternal(
      'NSProgress.setCompletedUnitCount:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_17gvxvj(_$.ref.pointer, _sel_setCompletedUnitCount_, value);
  }

  /// setEstimatedTimeRemaining:
  set estimatedTimeRemaining(NSNumber? value) {
    objc.checkOsVersionInternal(
      'NSProgress.setEstimatedTimeRemaining:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setEstimatedTimeRemaining_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setFileCompletedCount:
  set fileCompletedCount(NSNumber? value) {
    objc.checkOsVersionInternal(
      'NSProgress.setFileCompletedCount:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setFileCompletedCount_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setFileOperationKind:
  set fileOperationKind(NSString? value) {
    objc.checkOsVersionInternal(
      'NSProgress.setFileOperationKind:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setFileOperationKind_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setFileTotalCount:
  set fileTotalCount(NSNumber? value) {
    objc.checkOsVersionInternal(
      'NSProgress.setFileTotalCount:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setFileTotalCount_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setFileURL:
  set fileURL(NSURL? value) {
    objc.checkOsVersionInternal(
      'NSProgress.setFileURL:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setFileURL_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setKind:
  set kind(NSString? value) {
    objc.checkOsVersionInternal(
      'NSProgress.setKind:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setKind_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setLocalizedAdditionalDescription:
  set localizedAdditionalDescription(NSString value) {
    objc.checkOsVersionInternal(
      'NSProgress.setLocalizedAdditionalDescription:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setLocalizedAdditionalDescription_,
      value.ref.pointer,
    );
  }

  /// setLocalizedDescription:
  set localizedDescription(NSString value) {
    objc.checkOsVersionInternal(
      'NSProgress.setLocalizedDescription:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setLocalizedDescription_,
      value.ref.pointer,
    );
  }

  /// setPausable:
  set isPausable(bool value) {
    objc.checkOsVersionInternal(
      'NSProgress.setPausable:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1s56lr9(_$.ref.pointer, _sel_setPausable_, value);
  }

  /// setPausingHandler:
  set pausingHandler(objc.ObjCBlock<ffi.Void Function()>? value) {
    objc.checkOsVersionInternal(
      'NSProgress.setPausingHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_f167m6(
      _$.ref.pointer,
      _sel_setPausingHandler_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setResumingHandler:
  set resumingHandler(objc.ObjCBlock<ffi.Void Function()>? value) {
    objc.checkOsVersionInternal(
      'NSProgress.setResumingHandler:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_f167m6(
      _$.ref.pointer,
      _sel_setResumingHandler_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setThroughput:
  set throughput(NSNumber? value) {
    objc.checkOsVersionInternal(
      'NSProgress.setThroughput:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setThroughput_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setTotalUnitCount:
  set totalUnitCount(int value) {
    objc.checkOsVersionInternal(
      'NSProgress.setTotalUnitCount:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_17gvxvj(_$.ref.pointer, _sel_setTotalUnitCount_, value);
  }

  /// setUserInfoObject:forKey:
  void setUserInfoObject(
    objc.ObjCObjectBase? objectOrNil, {
    required NSString forKey,
  }) {
    objc.checkOsVersionInternal(
      'NSProgress.setUserInfoObject:forKey:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_setUserInfoObject_forKey_,
      objectOrNil?.ref.pointer ?? ffi.nullptr,
      forKey.ref.pointer,
    );
  }

  /// throughput
  NSNumber? get throughput {
    objc.checkOsVersionInternal(
      'NSProgress.throughput',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_throughput);
    return $ret.address == 0
        ? null
        : NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// totalUnitCount
  int get totalUnitCount {
    objc.checkOsVersionInternal(
      'NSProgress.totalUnitCount',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_pysgoz(_$.ref.pointer, _sel_totalUnitCount);
  }

  /// unpublish
  ///
  /// iOS: unavailable
  /// macOS: introduced 10.9.0
  void unpublish() {
    objc.checkOsVersionInternal(
      'NSProgress.unpublish',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_unpublish);
  }

  /// userInfo
  NSDictionary get userInfo {
    objc.checkOsVersionInternal(
      'NSProgress.userInfo',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_userInfo);
    return NSDictionary.castFromPointer($ret, retain: true, release: true);
  }
}

enum NSPropertyListFormat {
  NSPropertyListOpenStepFormat(1),
  NSPropertyListXMLFormat_v1_0(100),
  NSPropertyListBinaryFormat_v1_0(200);

  final int value;
  const NSPropertyListFormat(this.value);

  static NSPropertyListFormat fromValue(int value) => switch (value) {
    1 => NSPropertyListOpenStepFormat,
    100 => NSPropertyListXMLFormat_v1_0,
    200 => NSPropertyListBinaryFormat_v1_0,
    _ => throw ArgumentError('Unknown value for NSPropertyListFormat: $value'),
  };
}

enum NSQualityOfService {
  NSQualityOfServiceUserInteractive(33),
  NSQualityOfServiceUserInitiated(25),
  NSQualityOfServiceUtility(17),
  NSQualityOfServiceBackground(9),
  NSQualityOfServiceDefault(-1);

  final int value;
  const NSQualityOfService(this.value);

  static NSQualityOfService fromValue(int value) => switch (value) {
    33 => NSQualityOfServiceUserInteractive,
    25 => NSQualityOfServiceUserInitiated,
    17 => NSQualityOfServiceUtility,
    9 => NSQualityOfServiceBackground,
    -1 => NSQualityOfServiceDefault,
    _ => throw ArgumentError('Unknown value for NSQualityOfService: $value'),
  };
}

final class NSRange extends ffi.Struct {
  @ffi.UnsignedLong()
  external int location;

  @ffi.UnsignedLong()
  external int length;
}

/// NSRunLoop
extension type NSRunLoop.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [NSRunLoop] that wraps the given raw object pointer.
  NSRunLoop.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSRunLoop].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSRunLoop,
    );
  }

  /// alloc
  static NSRunLoop alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSRunLoop, _sel_alloc);
    return NSRunLoop.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSRunLoop allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSRunLoop,
      _sel_allocWithZone_,
      zone,
    );
    return NSRunLoop.castFromPointer($ret, retain: false, release: true);
  }

  /// currentRunLoop
  static NSRunLoop getCurrentRunLoop() {
    final $ret = _objc_msgSend_151sglz(_class_NSRunLoop, _sel_currentRunLoop);
    return NSRunLoop.castFromPointer($ret, retain: true, release: true);
  }

  /// mainRunLoop
  static NSRunLoop getMainRunLoop() {
    objc.checkOsVersionInternal(
      'NSRunLoop.mainRunLoop',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_NSRunLoop, _sel_mainRunLoop);
    return NSRunLoop.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSRunLoop new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSRunLoop, _sel_new);
    return NSRunLoop.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSRunLoop constructed with the default `new` method.
  NSRunLoop() : this.castFrom(new$()._$);
}

extension NSRunLoop$Methods on NSRunLoop {
  /// acceptInputForMode:beforeDate:
  void acceptInputForMode(NSString mode, {required NSDate beforeDate}) {
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_acceptInputForMode_beforeDate_,
      mode.ref.pointer,
      beforeDate.ref.pointer,
    );
  }

  /// addPort:forMode:
  void addPort(NSPort aPort, {required NSString forMode}) {
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_addPort_forMode_,
      aPort.ref.pointer,
      forMode.ref.pointer,
    );
  }

  /// addTimer:forMode:
  void addTimer(NSTimer timer, {required NSString forMode}) {
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_addTimer_forMode_,
      timer.ref.pointer,
      forMode.ref.pointer,
    );
  }

  /// currentMode
  NSString? get currentMode {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_currentMode);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// getCFRunLoop
  ffi.Pointer<CFRunLoop> getCFRunLoop() {
    return _objc_msgSend_1bbja28(_$.ref.pointer, _sel_getCFRunLoop);
  }

  /// init
  NSRunLoop init() {
    objc.checkOsVersionInternal(
      'NSRunLoop.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSRunLoop.castFromPointer($ret, retain: false, release: true);
  }

  /// limitDateForMode:
  NSDate? limitDateForMode(NSString mode) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_limitDateForMode_,
      mode.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSDate.castFromPointer($ret, retain: true, release: true);
  }

  /// removePort:forMode:
  void removePort(NSPort aPort, {required NSString forMode}) {
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_removePort_forMode_,
      aPort.ref.pointer,
      forMode.ref.pointer,
    );
  }
}

/// NSSecureCoding
extension type NSSecureCoding.castFrom(objc.ObjCProtocolBase _$)
    implements objc.ObjCProtocolBase, NSCoding {
  /// Constructs a [NSSecureCoding] that wraps the given raw object pointer.
  NSSecureCoding.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCProtocolBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSSecureCoding].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_NSSecureCoding,
    );
  }
}

extension NSSecureCoding$Methods on NSSecureCoding {
  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// initWithCoder:
  NSSecureCoding? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSSecureCoding.castFromPointer($ret, retain: false, release: true);
  }
}

interface class NSSecureCoding$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_NSSecureCoding.cast());

  /// Builds an object that implements the NSSecureCoding protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSSecureCoding implement({
    required void Function(NSCoder) encodeWithCoder_,
    required Dartinstancetype? Function(NSCoder) initWithCoder_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSSecureCoding');
    NSSecureCoding$Builder.encodeWithCoder_.implement(
      builder,
      encodeWithCoder_,
    );
    NSSecureCoding$Builder.initWithCoder_.implement(builder, initWithCoder_);
    builder.addProtocol($protocol);
    return NSSecureCoding.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSSecureCoding protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    required void Function(NSCoder) encodeWithCoder_,
    required Dartinstancetype? Function(NSCoder) initWithCoder_,
    bool $keepIsolateAlive = true,
  }) {
    NSSecureCoding$Builder.encodeWithCoder_.implement(
      builder,
      encodeWithCoder_,
    );
    NSSecureCoding$Builder.initWithCoder_.implement(builder, initWithCoder_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSSecureCoding protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSSecureCoding implementAsListener({
    required void Function(NSCoder) encodeWithCoder_,
    required Dartinstancetype? Function(NSCoder) initWithCoder_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSSecureCoding');
    NSSecureCoding$Builder.encodeWithCoder_.implementAsListener(
      builder,
      encodeWithCoder_,
    );
    NSSecureCoding$Builder.initWithCoder_.implement(builder, initWithCoder_);
    builder.addProtocol($protocol);
    return NSSecureCoding.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSSecureCoding protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    required void Function(NSCoder) encodeWithCoder_,
    required Dartinstancetype? Function(NSCoder) initWithCoder_,
    bool $keepIsolateAlive = true,
  }) {
    NSSecureCoding$Builder.encodeWithCoder_.implementAsListener(
      builder,
      encodeWithCoder_,
    );
    NSSecureCoding$Builder.initWithCoder_.implement(builder, initWithCoder_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSSecureCoding protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSSecureCoding implementAsBlocking({
    required void Function(NSCoder) encodeWithCoder_,
    required Dartinstancetype? Function(NSCoder) initWithCoder_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSSecureCoding');
    NSSecureCoding$Builder.encodeWithCoder_.implementAsBlocking(
      builder,
      encodeWithCoder_,
    );
    NSSecureCoding$Builder.initWithCoder_.implement(builder, initWithCoder_);
    builder.addProtocol($protocol);
    return NSSecureCoding.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSSecureCoding protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    required void Function(NSCoder) encodeWithCoder_,
    required Dartinstancetype? Function(NSCoder) initWithCoder_,
    bool $keepIsolateAlive = true,
  }) {
    NSSecureCoding$Builder.encodeWithCoder_.implementAsBlocking(
      builder,
      encodeWithCoder_,
    );
    NSSecureCoding$Builder.initWithCoder_.implement(builder, initWithCoder_);
    builder.addProtocol($protocol);
  }

  /// encodeWithCoder:
  static final encodeWithCoder_ =
      objc.ObjCProtocolListenableMethod<void Function(NSCoder)>(
        _protocol_NSSecureCoding,
        _sel_encodeWithCoder_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_18v1jvf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSSecureCoding,
          _sel_encodeWithCoder_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (void Function(NSCoder) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSCoder.fromFunction(
              (ffi.Pointer<ffi.Void> _, NSCoder arg1) => func(arg1),
            ),
        (void Function(NSCoder) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSCoder.listener(
              (ffi.Pointer<ffi.Void> _, NSCoder arg1) => func(arg1),
            ),
        (void Function(NSCoder) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSCoder.blocking(
              (ffi.Pointer<ffi.Void> _, NSCoder arg1) => func(arg1),
            ),
      );

  /// initWithCoder:
  static final initWithCoder_ =
      objc.ObjCProtocolMethod<Dartinstancetype? Function(NSCoder)>(
        _protocol_NSSecureCoding,
        _sel_initWithCoder_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_xr62hr)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSSecureCoding,
          _sel_initWithCoder_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (Dartinstancetype? Function(NSCoder) func) =>
            ObjCBlock_instancetype_ffiVoid_NSCoder.fromFunction(
              (ffi.Pointer<ffi.Void> _, NSCoder arg1) => func(arg1),
            ),
      );
}

/// NSSet
extension type NSSet.castFrom(objc.ObjCObjectBase _$)
    implements
        objc.ObjCObjectBase,
        NSObject,
        NSCopying,
        NSMutableCopying,
        NSSecureCoding,
        NSFastEnumeration {
  /// Constructs a [NSSet] that wraps the given raw object pointer.
  NSSet.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSSet].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSSet,
    );
  }

  /// alloc
  static NSSet alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSSet, _sel_alloc);
    return NSSet.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSSet allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_NSSet, _sel_allocWithZone_, zone);
    return NSSet.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSSet new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSSet, _sel_new);
    return NSSet.castFromPointer($ret, retain: false, release: true);
  }

  /// set
  static NSSet set() {
    final $ret = _objc_msgSend_151sglz(_class_NSSet, _sel_set);
    return NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// setWithArray:
  static NSSet setWithArray(NSArray array) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSSet,
      _sel_setWithArray_,
      array.ref.pointer,
    );
    return NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// setWithObject:
  static NSSet setWithObject(objc.ObjCObjectBase object) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSSet,
      _sel_setWithObject_,
      object.ref.pointer,
    );
    return NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// setWithObjects:
  static NSSet setWithObjects(objc.ObjCObjectBase firstObj) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSSet,
      _sel_setWithObjects_,
      firstObj.ref.pointer,
    );
    return NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// setWithObjects:count:
  static NSSet setWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required int count,
  }) {
    final $ret = _objc_msgSend_zmbtbd(
      _class_NSSet,
      _sel_setWithObjects_count_,
      objects,
      count,
    );
    return NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// setWithSet:
  static NSSet setWithSet(NSSet set) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSSet,
      _sel_setWithSet_,
      set.ref.pointer,
    );
    return NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSSet, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSSet constructed with the default `new` method.
  NSSet() : this.castFrom(new$()._$);
}

extension NSSet$Methods on NSSet {
  /// count
  int get count {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_count);
  }

  /// countByEnumeratingWithState:objects:count:
  int countByEnumeratingWithState(
    ffi.Pointer<NSFastEnumerationState> state, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects,
    required int count,
  }) {
    return _objc_msgSend_1b5ysjl(
      _$.ref.pointer,
      _sel_countByEnumeratingWithState_objects_count_,
      state,
      objects,
      count,
    );
  }

  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  NSSet init() {
    objc.checkOsVersionInternal(
      'NSSet.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithArray:
  NSSet initWithArray(NSArray array) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithArray_,
      array.ref.pointer,
    );
    return NSSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSSet? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObjects:
  NSSet initWithObjects(objc.ObjCObjectBase firstObj) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_,
      firstObj.ref.pointer,
    );
    return NSSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithObjects:count:
  NSSet initWithObjects$1(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, {
    required int count,
  }) {
    final $ret = _objc_msgSend_zmbtbd(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_count_,
      objects,
      count,
    );
    return NSSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithSet:
  NSSet initWithSet(NSSet set) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithSet_,
      set.ref.pointer,
    );
    return NSSet.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithSet:copyItems:
  NSSet initWithSet$1(NSSet set, {required bool copyItems}) {
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithSet_copyItems_,
      set.ref.pointer,
      copyItems,
    );
    return NSSet.castFromPointer($ret, retain: false, release: true);
  }

  /// member:
  objc.ObjCObjectBase? member(objc.ObjCObjectBase object) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_member_,
      object.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// objectEnumerator
  NSEnumerator objectEnumerator() {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_objectEnumerator);
    return NSEnumerator.castFromPointer($ret, retain: true, release: true);
  }
}

sealed class NSSortOptions {
  static const NSSortConcurrent = 1;
  static const NSSortStable = 16;
}

/// NSStream
extension type NSStream.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [NSStream] that wraps the given raw object pointer.
  NSStream.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSStream].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSStream,
    );
  }

  /// alloc
  static NSStream alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSStream, _sel_alloc);
    return NSStream.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSStream allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSStream,
      _sel_allocWithZone_,
      zone,
    );
    return NSStream.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSStream new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSStream, _sel_new);
    return NSStream.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSStream constructed with the default `new` method.
  NSStream() : this.castFrom(new$()._$);
}

extension NSStream$Methods on NSStream {
  /// close
  void close() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_close);
  }

  /// delegate
  NSStreamDelegate? get delegate {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_delegate);
    return $ret.address == 0
        ? null
        : NSStreamDelegate.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  NSStream init() {
    objc.checkOsVersionInternal(
      'NSStream.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSStream.castFromPointer($ret, retain: false, release: true);
  }

  /// open
  void open() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_open);
  }

  /// propertyForKey:
  objc.ObjCObjectBase? propertyForKey(NSString key) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_propertyForKey_,
      key.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// removeFromRunLoop:forMode:
  void removeFromRunLoop(NSRunLoop aRunLoop, {required NSString forMode}) {
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_removeFromRunLoop_forMode_,
      aRunLoop.ref.pointer,
      forMode.ref.pointer,
    );
  }

  /// scheduleInRunLoop:forMode:
  void scheduleInRunLoop(NSRunLoop aRunLoop, {required NSString forMode}) {
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_scheduleInRunLoop_forMode_,
      aRunLoop.ref.pointer,
      forMode.ref.pointer,
    );
  }

  /// setDelegate:
  set delegate(NSStreamDelegate? value) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_setDelegate_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setProperty:forKey:
  bool setProperty(objc.ObjCObjectBase? property, {required NSString forKey}) {
    return _objc_msgSend_1lsax7n(
      _$.ref.pointer,
      _sel_setProperty_forKey_,
      property?.ref.pointer ?? ffi.nullptr,
      forKey.ref.pointer,
    );
  }

  /// streamError
  NSError? get streamError {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_streamError);
    return $ret.address == 0
        ? null
        : NSError.castFromPointer($ret, retain: true, release: true);
  }

  /// streamStatus
  NSStreamStatus get streamStatus {
    final $ret = _objc_msgSend_1efxbd8(_$.ref.pointer, _sel_streamStatus);
    return NSStreamStatus.fromValue($ret);
  }
}

/// NSStreamDelegate
extension type NSStreamDelegate.castFrom(objc.ObjCProtocolBase _$)
    implements objc.ObjCProtocolBase, NSObjectProtocol {
  /// Constructs a [NSStreamDelegate] that wraps the given raw object pointer.
  NSStreamDelegate.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCProtocolBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSStreamDelegate].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_NSStreamDelegate,
    );
  }
}

extension NSStreamDelegate$Methods on NSStreamDelegate {
  /// stream:handleEvent:
  void stream(NSStream aStream, {required int handleEvent}) {
    if (!objc.respondsToSelector(_$.ref.pointer, _sel_stream_handleEvent_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSStreamDelegate',
        'stream:handleEvent:',
      );
    }
    _objc_msgSend_3l8zum(
      _$.ref.pointer,
      _sel_stream_handleEvent_,
      aStream.ref.pointer,
      handleEvent,
    );
  }
}

interface class NSStreamDelegate$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_NSStreamDelegate.cast());

  /// Builds an object that implements the NSStreamDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSStreamDelegate implement({
    void Function(NSStream, int)? stream_handleEvent_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSStreamDelegate');
    NSStreamDelegate$Builder.stream_handleEvent_.implement(
      builder,
      stream_handleEvent_,
    );
    builder.addProtocol($protocol);
    return NSStreamDelegate.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSStreamDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSStream, int)? stream_handleEvent_,
    bool $keepIsolateAlive = true,
  }) {
    NSStreamDelegate$Builder.stream_handleEvent_.implement(
      builder,
      stream_handleEvent_,
    );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSStreamDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSStreamDelegate implementAsListener({
    void Function(NSStream, int)? stream_handleEvent_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSStreamDelegate');
    NSStreamDelegate$Builder.stream_handleEvent_.implementAsListener(
      builder,
      stream_handleEvent_,
    );
    builder.addProtocol($protocol);
    return NSStreamDelegate.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSStreamDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSStream, int)? stream_handleEvent_,
    bool $keepIsolateAlive = true,
  }) {
    NSStreamDelegate$Builder.stream_handleEvent_.implementAsListener(
      builder,
      stream_handleEvent_,
    );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSStreamDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSStreamDelegate implementAsBlocking({
    void Function(NSStream, int)? stream_handleEvent_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSStreamDelegate');
    NSStreamDelegate$Builder.stream_handleEvent_.implementAsBlocking(
      builder,
      stream_handleEvent_,
    );
    builder.addProtocol($protocol);
    return NSStreamDelegate.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSStreamDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSStream, int)? stream_handleEvent_,
    bool $keepIsolateAlive = true,
  }) {
    NSStreamDelegate$Builder.stream_handleEvent_.implementAsBlocking(
      builder,
      stream_handleEvent_,
    );
    builder.addProtocol($protocol);
  }

  /// stream:handleEvent:
  static final stream_handleEvent_ =
      objc.ObjCProtocolListenableMethod<void Function(NSStream, int)>(
        _protocol_NSStreamDelegate,
        _sel_stream_handleEvent_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.UnsignedLong,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_hoampi)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSStreamDelegate,
          _sel_stream_handleEvent_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSStream, int) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSStream_NSStreamEvent.fromFunction(
              (ffi.Pointer<ffi.Void> _, NSStream arg1, int arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(NSStream, int) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSStream_NSStreamEvent.listener(
              (ffi.Pointer<ffi.Void> _, NSStream arg1, int arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(NSStream, int) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSStream_NSStreamEvent.blocking(
              (ffi.Pointer<ffi.Void> _, NSStream arg1, int arg2) =>
                  func(arg1, arg2),
            ),
      );
}

sealed class NSStreamEvent {
  static const NSStreamEventNone = 0;
  static const NSStreamEventOpenCompleted = 1;
  static const NSStreamEventHasBytesAvailable = 2;
  static const NSStreamEventHasSpaceAvailable = 4;
  static const NSStreamEventErrorOccurred = 8;
  static const NSStreamEventEndEncountered = 16;
}

enum NSStreamStatus {
  NSStreamStatusNotOpen(0),
  NSStreamStatusOpening(1),
  NSStreamStatusOpen(2),
  NSStreamStatusReading(3),
  NSStreamStatusWriting(4),
  NSStreamStatusAtEnd(5),
  NSStreamStatusClosed(6),
  NSStreamStatusError(7);

  final int value;
  const NSStreamStatus(this.value);

  static NSStreamStatus fromValue(int value) => switch (value) {
    0 => NSStreamStatusNotOpen,
    1 => NSStreamStatusOpening,
    2 => NSStreamStatusOpen,
    3 => NSStreamStatusReading,
    4 => NSStreamStatusWriting,
    5 => NSStreamStatusAtEnd,
    6 => NSStreamStatusClosed,
    7 => NSStreamStatusError,
    _ => throw ArgumentError('Unknown value for NSStreamStatus: $value'),
  };
}

/// NSString
extension type NSString.castFrom(objc.ObjCObjectBase _$)
    implements
        objc.ObjCObjectBase,
        NSObject,
        NSCopying,
        NSMutableCopying,
        NSSecureCoding {
  NSString(String str) : this.castFrom(_stringToNSString$(str));

  static NSString _stringToNSString$(String str) {
    final cstr = str.toNativeUtf16();
    final nsstr = stringWithCharacters(cstr.cast(), length: str.length);
    pkg_ffi.calloc.free(cstr);
    return nsstr;
  }

  /// Constructs a [NSString] that wraps the given raw object pointer.
  NSString.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSString].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSString,
    );
  }

  /// alloc
  static NSString alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSString, _sel_alloc);
    return NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSString allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSString,
      _sel_allocWithZone_,
      zone,
    );
    return NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// localizedStringWithFormat:
  static NSString localizedStringWithFormat(NSString format) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSString,
      _sel_localizedStringWithFormat_,
      format.ref.pointer,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// localizedStringWithValidatedFormat:validFormatSpecifiers:error:
  static NSString? localizedStringWithValidatedFormat(
    NSString format, {
    required NSString validFormatSpecifiers,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSString.localizedStringWithValidatedFormat:validFormatSpecifiers:error:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_1pnyuds(
      _class_NSString,
      _sel_localizedStringWithValidatedFormat_validFormatSpecifiers_error_,
      format.ref.pointer,
      validFormatSpecifiers.ref.pointer,
      error,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSString new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSString, _sel_new);
    return NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// string
  static NSString string() {
    final $ret = _objc_msgSend_151sglz(_class_NSString, _sel_string);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithCString:encoding:
  static NSString? stringWithCString(
    ffi.Pointer<ffi.Char> cString, {
    required int encoding,
  }) {
    final $ret = _objc_msgSend_erqryg(
      _class_NSString,
      _sel_stringWithCString_encoding_,
      cString,
      encoding,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithCharacters:length:
  static NSString stringWithCharacters(
    ffi.Pointer<ffi.UnsignedShort> characters, {
    required int length,
  }) {
    final $ret = _objc_msgSend_9x4k8x(
      _class_NSString,
      _sel_stringWithCharacters_length_,
      characters,
      length,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithContentsOfFile:encoding:error:
  static NSString? stringWithContentsOfFile(
    NSString path, {
    required int encoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1nomli1(
      _class_NSString,
      _sel_stringWithContentsOfFile_encoding_error_,
      path.ref.pointer,
      encoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithContentsOfFile:usedEncoding:error:
  static NSString? stringWithContentsOfFile$1(
    NSString path, {
    required ffi.Pointer<ffi.UnsignedLong> usedEncoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1alewu7(
      _class_NSString,
      _sel_stringWithContentsOfFile_usedEncoding_error_,
      path.ref.pointer,
      usedEncoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithContentsOfURL:encoding:error:
  static NSString? stringWithContentsOfURL(
    NSURL url, {
    required int encoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1nomli1(
      _class_NSString,
      _sel_stringWithContentsOfURL_encoding_error_,
      url.ref.pointer,
      encoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithContentsOfURL:usedEncoding:error:
  static NSString? stringWithContentsOfURL$1(
    NSURL url, {
    required ffi.Pointer<ffi.UnsignedLong> usedEncoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1alewu7(
      _class_NSString,
      _sel_stringWithContentsOfURL_usedEncoding_error_,
      url.ref.pointer,
      usedEncoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithFormat:
  static NSString stringWithFormat(NSString format) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSString,
      _sel_stringWithFormat_,
      format.ref.pointer,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithString:
  static NSString stringWithString(NSString string) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSString,
      _sel_stringWithString_,
      string.ref.pointer,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithUTF8String:
  static NSString? stringWithUTF8String(
    ffi.Pointer<ffi.Char> nullTerminatedCString,
  ) {
    final $ret = _objc_msgSend_56zxyn(
      _class_NSString,
      _sel_stringWithUTF8String_,
      nullTerminatedCString,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringWithValidatedFormat:validFormatSpecifiers:error:
  static NSString? stringWithValidatedFormat(
    NSString format, {
    required NSString validFormatSpecifiers,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSString.stringWithValidatedFormat:validFormatSpecifiers:error:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_1pnyuds(
      _class_NSString,
      _sel_stringWithValidatedFormat_validFormatSpecifiers_error_,
      format.ref.pointer,
      validFormatSpecifiers.ref.pointer,
      error,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSString, _sel_supportsSecureCoding);
  }
}

extension NSString$Methods on NSString {
  /// characterAtIndex:
  int characterAtIndex(int index) {
    return _objc_msgSend_1deg8x(_$.ref.pointer, _sel_characterAtIndex_, index);
  }

  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  NSString init() {
    objc.checkOsVersionInternal(
      'NSString.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytes:length:encoding:
  NSString? initWithBytes(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
    required int encoding,
  }) {
    final $ret = _objc_msgSend_9b3h4v(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytes_length_encoding_,
      bytes,
      length,
      encoding,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytesNoCopy:length:encoding:deallocator:
  NSString? initWithBytesNoCopy(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
    required int encoding,
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>?
    deallocator,
  }) {
    final $ret = _objc_msgSend_1lbgrac(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytesNoCopy_length_encoding_deallocator_,
      bytes,
      length,
      encoding,
      deallocator?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytesNoCopy:length:encoding:freeWhenDone:
  NSString? initWithBytesNoCopy$1(
    ffi.Pointer<ffi.Void> bytes, {
    required int length,
    required int encoding,
    required bool freeWhenDone,
  }) {
    final $ret = _objc_msgSend_k4j8m3(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytesNoCopy_length_encoding_freeWhenDone_,
      bytes,
      length,
      encoding,
      freeWhenDone,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCString:encoding:
  NSString? initWithCString(
    ffi.Pointer<ffi.Char> nullTerminatedCString, {
    required int encoding,
  }) {
    final $ret = _objc_msgSend_erqryg(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCString_encoding_,
      nullTerminatedCString,
      encoding,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCharacters:length:
  NSString initWithCharacters(
    ffi.Pointer<ffi.UnsignedShort> characters, {
    required int length,
  }) {
    final $ret = _objc_msgSend_9x4k8x(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCharacters_length_,
      characters,
      length,
    );
    return NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCharactersNoCopy:length:deallocator:
  NSString initWithCharactersNoCopy(
    ffi.Pointer<ffi.UnsignedShort> chars, {
    required int length,
    objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)
    >?
    deallocator,
  }) {
    final $ret = _objc_msgSend_talwei(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCharactersNoCopy_length_deallocator_,
      chars,
      length,
      deallocator?.ref.pointer ?? ffi.nullptr,
    );
    return NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCharactersNoCopy:length:freeWhenDone:
  NSString initWithCharactersNoCopy$1(
    ffi.Pointer<ffi.UnsignedShort> characters, {
    required int length,
    required bool freeWhenDone,
  }) {
    final $ret = _objc_msgSend_lh0jh5(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCharactersNoCopy_length_freeWhenDone_,
      characters,
      length,
      freeWhenDone,
    );
    return NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSString? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfFile:encoding:error:
  NSString? initWithContentsOfFile(
    NSString path, {
    required int encoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1nomli1(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfFile_encoding_error_,
      path.ref.pointer,
      encoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfFile:usedEncoding:error:
  NSString? initWithContentsOfFile$1(
    NSString path, {
    required ffi.Pointer<ffi.UnsignedLong> usedEncoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1alewu7(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfFile_usedEncoding_error_,
      path.ref.pointer,
      usedEncoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:encoding:error:
  NSString? initWithContentsOfURL(
    NSURL url, {
    required int encoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1nomli1(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfURL_encoding_error_,
      url.ref.pointer,
      encoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:usedEncoding:error:
  NSString? initWithContentsOfURL$1(
    NSURL url, {
    required ffi.Pointer<ffi.UnsignedLong> usedEncoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    final $ret = _objc_msgSend_1alewu7(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfURL_usedEncoding_error_,
      url.ref.pointer,
      usedEncoding,
      error,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithData:encoding:
  NSString? initWithData(NSData data, {required int encoding}) {
    final $ret = _objc_msgSend_1k4kd9s(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithData_encoding_,
      data.ref.pointer,
      encoding,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFormat:
  NSString initWithFormat(NSString format) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithFormat_,
      format.ref.pointer,
    );
    return NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFormat:locale:
  NSString initWithFormat$1(NSString format, {objc.ObjCObjectBase? locale}) {
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithFormat_locale_,
      format.ref.pointer,
      locale?.ref.pointer ?? ffi.nullptr,
    );
    return NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithString:
  NSString initWithString(NSString aString) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithString_,
      aString.ref.pointer,
    );
    return NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithUTF8String:
  NSString? initWithUTF8String(ffi.Pointer<ffi.Char> nullTerminatedCString) {
    final $ret = _objc_msgSend_56zxyn(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithUTF8String_,
      nullTerminatedCString,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithValidatedFormat:validFormatSpecifiers:error:
  ///
  /// iOS: introduced 16.0.0
  /// macOS: introduced 13.0.0
  NSString? initWithValidatedFormat(
    NSString format, {
    required NSString validFormatSpecifiers,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSString.initWithValidatedFormat:validFormatSpecifiers:error:',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_1pnyuds(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithValidatedFormat_validFormatSpecifiers_error_,
      format.ref.pointer,
      validFormatSpecifiers.ref.pointer,
      error,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithValidatedFormat:validFormatSpecifiers:locale:error:
  ///
  /// iOS: introduced 16.0.0
  /// macOS: introduced 13.0.0
  NSString? initWithValidatedFormat$1(
    NSString format, {
    required NSString validFormatSpecifiers,
    objc.ObjCObjectBase? locale,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSString.initWithValidatedFormat:validFormatSpecifiers:locale:error:',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_1k0ezzm(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithValidatedFormat_validFormatSpecifiers_locale_error_,
      format.ref.pointer,
      validFormatSpecifiers.ref.pointer,
      locale?.ref.pointer ?? ffi.nullptr,
      error,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: false, release: true);
  }

  /// length
  int get length {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_length);
  }
}

sealed class NSStringCompareOptions {
  static const NSCaseInsensitiveSearch = 1;
  static const NSLiteralSearch = 2;
  static const NSBackwardsSearch = 4;
  static const NSAnchoredSearch = 8;
  static const NSNumericSearch = 64;
  static const NSDiacriticInsensitiveSearch = 128;
  static const NSWidthInsensitiveSearch = 256;
  static const NSForcedOrderingSearch = 512;
  static const NSRegularExpressionSearch = 1024;
}

sealed class NSStringEncodingConversionOptions {
  static const NSStringEncodingConversionAllowLossy = 1;
  static const NSStringEncodingConversionExternalRepresentation = 2;
}

sealed class NSStringEnumerationOptions {
  static const NSStringEnumerationByLines = 0;
  static const NSStringEnumerationByParagraphs = 1;
  static const NSStringEnumerationByComposedCharacterSequences = 2;
  static const NSStringEnumerationByWords = 3;
  static const NSStringEnumerationBySentences = 4;
  static const NSStringEnumerationByCaretPositions = 5;
  static const NSStringEnumerationByDeletionClusters = 6;
  static const NSStringEnumerationReverse = 256;
  static const NSStringEnumerationSubstringNotRequired = 512;
  static const NSStringEnumerationLocalized = 1024;
}

/// NSStringExtensionMethods
extension NSStringExtensionMethods on NSString {
  /// UTF8String
  ffi.Pointer<ffi.Char> get UTF8String {
    return _objc_msgSend_1fuqfwb(_$.ref.pointer, _sel_UTF8String);
  }

  /// boolValue
  bool get boolValue {
    objc.checkOsVersionInternal(
      'NSString.boolValue',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_boolValue);
  }

  /// cStringUsingEncoding:
  ffi.Pointer<ffi.Char> cStringUsingEncoding(int encoding) {
    return _objc_msgSend_1jtxufi(
      _$.ref.pointer,
      _sel_cStringUsingEncoding_,
      encoding,
    );
  }

  /// canBeConvertedToEncoding:
  bool canBeConvertedToEncoding(int encoding) {
    return _objc_msgSend_6peh6o(
      _$.ref.pointer,
      _sel_canBeConvertedToEncoding_,
      encoding,
    );
  }

  /// capitalizedString
  NSString get capitalizedString {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_capitalizedString);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// capitalizedStringWithLocale:
  NSString capitalizedStringWithLocale(NSLocale? locale) {
    objc.checkOsVersionInternal(
      'NSString.capitalizedStringWithLocale:',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_capitalizedStringWithLocale_,
      locale?.ref.pointer ?? ffi.nullptr,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// caseInsensitiveCompare:
  NSComparisonResult caseInsensitiveCompare(NSString string) {
    final $ret = _objc_msgSend_1ym6zyw(
      _$.ref.pointer,
      _sel_caseInsensitiveCompare_,
      string.ref.pointer,
    );
    return NSComparisonResult.fromValue($ret);
  }

  /// commonPrefixWithString:options:
  NSString commonPrefixWithString(NSString str, {required int options}) {
    final $ret = _objc_msgSend_diypgk(
      _$.ref.pointer,
      _sel_commonPrefixWithString_options_,
      str.ref.pointer,
      options,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// compare:
  NSComparisonResult compare(NSString string) {
    final $ret = _objc_msgSend_1ym6zyw(
      _$.ref.pointer,
      _sel_compare_,
      string.ref.pointer,
    );
    return NSComparisonResult.fromValue($ret);
  }

  /// compare:options:
  NSComparisonResult compare$1(NSString string, {required int options}) {
    final $ret = _objc_msgSend_pg1fnv(
      _$.ref.pointer,
      _sel_compare_options_,
      string.ref.pointer,
      options,
    );
    return NSComparisonResult.fromValue($ret);
  }

  /// compare:options:range:
  NSComparisonResult compare$2(
    NSString string, {
    required int options,
    required NSRange range,
  }) {
    final $ret = _objc_msgSend_xrqic1(
      _$.ref.pointer,
      _sel_compare_options_range_,
      string.ref.pointer,
      options,
      range,
    );
    return NSComparisonResult.fromValue($ret);
  }

  /// compare:options:range:locale:
  NSComparisonResult compare$3(
    NSString string, {
    required int options,
    required NSRange range,
    objc.ObjCObjectBase? locale,
  }) {
    final $ret = _objc_msgSend_1895u4n(
      _$.ref.pointer,
      _sel_compare_options_range_locale_,
      string.ref.pointer,
      options,
      range,
      locale?.ref.pointer ?? ffi.nullptr,
    );
    return NSComparisonResult.fromValue($ret);
  }

  /// componentsSeparatedByCharactersInSet:
  NSArray componentsSeparatedByCharactersInSet(NSCharacterSet separator) {
    objc.checkOsVersionInternal(
      'NSString.componentsSeparatedByCharactersInSet:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_componentsSeparatedByCharactersInSet_,
      separator.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// componentsSeparatedByString:
  NSArray componentsSeparatedByString(NSString separator) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_componentsSeparatedByString_,
      separator.ref.pointer,
    );
    return NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// containsString:
  bool containsString(NSString str) {
    objc.checkOsVersionInternal(
      'NSString.containsString:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_containsString_,
      str.ref.pointer,
    );
  }

  /// dataUsingEncoding:
  NSData? dataUsingEncoding(int encoding) {
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.pointer,
      _sel_dataUsingEncoding_,
      encoding,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataUsingEncoding:allowLossyConversion:
  NSData? dataUsingEncoding$1(
    int encoding, {
    required bool allowLossyConversion,
  }) {
    final $ret = _objc_msgSend_hiwitm(
      _$.ref.pointer,
      _sel_dataUsingEncoding_allowLossyConversion_,
      encoding,
      allowLossyConversion,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// decomposedStringWithCanonicalMapping
  NSString get decomposedStringWithCanonicalMapping {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_decomposedStringWithCanonicalMapping,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// decomposedStringWithCompatibilityMapping
  NSString get decomposedStringWithCompatibilityMapping {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_decomposedStringWithCompatibilityMapping,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// description
  NSString get description$1 {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_description);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// doubleValue
  double get doubleValue {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_$.ref.pointer, _sel_doubleValue)
        : _objc_msgSend_1ukqyt8(_$.ref.pointer, _sel_doubleValue);
  }

  /// enumerateLinesUsingBlock:
  void enumerateLinesUsingBlock(
    objc.ObjCBlock<ffi.Void Function(NSString, ffi.Pointer<ffi.Bool>)> block,
  ) {
    objc.checkOsVersionInternal(
      'NSString.enumerateLinesUsingBlock:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_f167m6(
      _$.ref.pointer,
      _sel_enumerateLinesUsingBlock_,
      block.ref.pointer,
    );
  }

  /// enumerateSubstringsInRange:options:usingBlock:
  void enumerateSubstringsInRange(
    NSRange range, {
    required int options,
    required objc.ObjCBlock<
      ffi.Void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
    >
    usingBlock,
  }) {
    objc.checkOsVersionInternal(
      'NSString.enumerateSubstringsInRange:options:usingBlock:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_14ew8zr(
      _$.ref.pointer,
      _sel_enumerateSubstringsInRange_options_usingBlock_,
      range,
      options,
      usingBlock.ref.pointer,
    );
  }

  /// fastestEncoding
  int get fastestEncoding {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_fastestEncoding);
  }

  /// floatValue
  double get floatValue {
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(_$.ref.pointer, _sel_floatValue)
        : _objc_msgSend_2cgrxl(_$.ref.pointer, _sel_floatValue);
  }

  /// getBytes:maxLength:usedLength:encoding:options:range:remainingRange:
  bool getBytes(
    ffi.Pointer<ffi.Void> buffer, {
    required int maxLength,
    required ffi.Pointer<ffi.UnsignedLong> usedLength,
    required int encoding,
    required int options,
    required NSRange range,
    required ffi.Pointer<NSRange> remainingRange,
  }) {
    return _objc_msgSend_i30zh3(
      _$.ref.pointer,
      _sel_getBytes_maxLength_usedLength_encoding_options_range_remainingRange_,
      buffer,
      maxLength,
      usedLength,
      encoding,
      options,
      range,
      remainingRange,
    );
  }

  /// getCString:maxLength:encoding:
  bool getCString(
    ffi.Pointer<ffi.Char> buffer, {
    required int maxLength,
    required int encoding,
  }) {
    return _objc_msgSend_1lv8yz3(
      _$.ref.pointer,
      _sel_getCString_maxLength_encoding_,
      buffer,
      maxLength,
      encoding,
    );
  }

  /// getCharacters:range:
  void getCharacters(
    ffi.Pointer<ffi.UnsignedShort> buffer, {
    required NSRange range,
  }) {
    _objc_msgSend_898fog(
      _$.ref.pointer,
      _sel_getCharacters_range_,
      buffer,
      range,
    );
  }

  /// getLineStart:end:contentsEnd:forRange:
  void getLineStart(
    ffi.Pointer<ffi.UnsignedLong> startPtr, {
    required ffi.Pointer<ffi.UnsignedLong> end,
    required ffi.Pointer<ffi.UnsignedLong> contentsEnd,
    required NSRange forRange,
  }) {
    _objc_msgSend_ourvf2(
      _$.ref.pointer,
      _sel_getLineStart_end_contentsEnd_forRange_,
      startPtr,
      end,
      contentsEnd,
      forRange,
    );
  }

  /// getParagraphStart:end:contentsEnd:forRange:
  void getParagraphStart(
    ffi.Pointer<ffi.UnsignedLong> startPtr, {
    required ffi.Pointer<ffi.UnsignedLong> end,
    required ffi.Pointer<ffi.UnsignedLong> contentsEnd,
    required NSRange forRange,
  }) {
    _objc_msgSend_ourvf2(
      _$.ref.pointer,
      _sel_getParagraphStart_end_contentsEnd_forRange_,
      startPtr,
      end,
      contentsEnd,
      forRange,
    );
  }

  /// hasPrefix:
  bool hasPrefix(NSString str) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_hasPrefix_,
      str.ref.pointer,
    );
  }

  /// hasSuffix:
  bool hasSuffix(NSString str) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_hasSuffix_,
      str.ref.pointer,
    );
  }

  /// hash
  int get hash$1 {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_hash);
  }

  /// intValue
  int get intValue {
    return _objc_msgSend_13yqbb6(_$.ref.pointer, _sel_intValue);
  }

  /// integerValue
  int get integerValue {
    objc.checkOsVersionInternal(
      'NSString.integerValue',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_1hz7y9r(_$.ref.pointer, _sel_integerValue);
  }

  /// isEqualToString:
  bool isEqualToString(NSString aString) {
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_isEqualToString_,
      aString.ref.pointer,
    );
  }

  /// lengthOfBytesUsingEncoding:
  int lengthOfBytesUsingEncoding(int enc) {
    return _objc_msgSend_12py2ux(
      _$.ref.pointer,
      _sel_lengthOfBytesUsingEncoding_,
      enc,
    );
  }

  /// lineRangeForRange:
  NSRange lineRangeForRange(NSRange range) {
    final $ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_uimyc7Stret(
            $ptr,
            _$.ref.pointer,
            _sel_lineRangeForRange_,
            range,
          )
        : $ptr.ref = _objc_msgSend_uimyc7(
            _$.ref.pointer,
            _sel_lineRangeForRange_,
            range,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSRange>($finalizable);
  }

  /// localizedCapitalizedString
  NSString get localizedCapitalizedString {
    objc.checkOsVersionInternal(
      'NSString.localizedCapitalizedString',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_localizedCapitalizedString,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// localizedCaseInsensitiveCompare:
  NSComparisonResult localizedCaseInsensitiveCompare(NSString string) {
    final $ret = _objc_msgSend_1ym6zyw(
      _$.ref.pointer,
      _sel_localizedCaseInsensitiveCompare_,
      string.ref.pointer,
    );
    return NSComparisonResult.fromValue($ret);
  }

  /// localizedCaseInsensitiveContainsString:
  bool localizedCaseInsensitiveContainsString(NSString str) {
    objc.checkOsVersionInternal(
      'NSString.localizedCaseInsensitiveContainsString:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_localizedCaseInsensitiveContainsString_,
      str.ref.pointer,
    );
  }

  /// localizedCompare:
  NSComparisonResult localizedCompare(NSString string) {
    final $ret = _objc_msgSend_1ym6zyw(
      _$.ref.pointer,
      _sel_localizedCompare_,
      string.ref.pointer,
    );
    return NSComparisonResult.fromValue($ret);
  }

  /// localizedLowercaseString
  NSString get localizedLowercaseString {
    objc.checkOsVersionInternal(
      'NSString.localizedLowercaseString',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_localizedLowercaseString,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// localizedStandardCompare:
  NSComparisonResult localizedStandardCompare(NSString string) {
    objc.checkOsVersionInternal(
      'NSString.localizedStandardCompare:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1ym6zyw(
      _$.ref.pointer,
      _sel_localizedStandardCompare_,
      string.ref.pointer,
    );
    return NSComparisonResult.fromValue($ret);
  }

  /// localizedStandardContainsString:
  bool localizedStandardContainsString(NSString str) {
    objc.checkOsVersionInternal(
      'NSString.localizedStandardContainsString:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    return _objc_msgSend_19nvye5(
      _$.ref.pointer,
      _sel_localizedStandardContainsString_,
      str.ref.pointer,
    );
  }

  /// localizedStandardRangeOfString:
  NSRange localizedStandardRangeOfString(NSString str) {
    objc.checkOsVersionInternal(
      'NSString.localizedStandardRangeOfString:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_182fzonStret(
            $ptr,
            _$.ref.pointer,
            _sel_localizedStandardRangeOfString_,
            str.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_182fzon(
            _$.ref.pointer,
            _sel_localizedStandardRangeOfString_,
            str.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSRange>($finalizable);
  }

  /// localizedUppercaseString
  NSString get localizedUppercaseString {
    objc.checkOsVersionInternal(
      'NSString.localizedUppercaseString',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_localizedUppercaseString,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// longLongValue
  int get longLongValue {
    objc.checkOsVersionInternal(
      'NSString.longLongValue',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_1k101e3(_$.ref.pointer, _sel_longLongValue);
  }

  /// lowercaseString
  NSString get lowercaseString {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_lowercaseString);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// lowercaseStringWithLocale:
  NSString lowercaseStringWithLocale(NSLocale? locale) {
    objc.checkOsVersionInternal(
      'NSString.lowercaseStringWithLocale:',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_lowercaseStringWithLocale_,
      locale?.ref.pointer ?? ffi.nullptr,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// maximumLengthOfBytesUsingEncoding:
  int maximumLengthOfBytesUsingEncoding(int enc) {
    return _objc_msgSend_12py2ux(
      _$.ref.pointer,
      _sel_maximumLengthOfBytesUsingEncoding_,
      enc,
    );
  }

  /// paragraphRangeForRange:
  NSRange paragraphRangeForRange(NSRange range) {
    final $ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_uimyc7Stret(
            $ptr,
            _$.ref.pointer,
            _sel_paragraphRangeForRange_,
            range,
          )
        : $ptr.ref = _objc_msgSend_uimyc7(
            _$.ref.pointer,
            _sel_paragraphRangeForRange_,
            range,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSRange>($finalizable);
  }

  /// precomposedStringWithCanonicalMapping
  NSString get precomposedStringWithCanonicalMapping {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_precomposedStringWithCanonicalMapping,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// precomposedStringWithCompatibilityMapping
  NSString get precomposedStringWithCompatibilityMapping {
    final $ret = _objc_msgSend_151sglz(
      _$.ref.pointer,
      _sel_precomposedStringWithCompatibilityMapping,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// rangeOfCharacterFromSet:
  NSRange rangeOfCharacterFromSet(NSCharacterSet searchSet) {
    final $ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_182fzonStret(
            $ptr,
            _$.ref.pointer,
            _sel_rangeOfCharacterFromSet_,
            searchSet.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_182fzon(
            _$.ref.pointer,
            _sel_rangeOfCharacterFromSet_,
            searchSet.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSRange>($finalizable);
  }

  /// rangeOfCharacterFromSet:options:
  NSRange rangeOfCharacterFromSet$1(
    NSCharacterSet searchSet, {
    required int options,
  }) {
    final $ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_102xxo4Stret(
            $ptr,
            _$.ref.pointer,
            _sel_rangeOfCharacterFromSet_options_,
            searchSet.ref.pointer,
            options,
          )
        : $ptr.ref = _objc_msgSend_102xxo4(
            _$.ref.pointer,
            _sel_rangeOfCharacterFromSet_options_,
            searchSet.ref.pointer,
            options,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSRange>($finalizable);
  }

  /// rangeOfCharacterFromSet:options:range:
  NSRange rangeOfCharacterFromSet$2(
    NSCharacterSet searchSet, {
    required int options,
    required NSRange range,
  }) {
    final $ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1nmlvqcStret(
            $ptr,
            _$.ref.pointer,
            _sel_rangeOfCharacterFromSet_options_range_,
            searchSet.ref.pointer,
            options,
            range,
          )
        : $ptr.ref = _objc_msgSend_1nmlvqc(
            _$.ref.pointer,
            _sel_rangeOfCharacterFromSet_options_range_,
            searchSet.ref.pointer,
            options,
            range,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSRange>($finalizable);
  }

  /// rangeOfComposedCharacterSequenceAtIndex:
  NSRange rangeOfComposedCharacterSequenceAtIndex(int index) {
    final $ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_d3i1uyStret(
            $ptr,
            _$.ref.pointer,
            _sel_rangeOfComposedCharacterSequenceAtIndex_,
            index,
          )
        : $ptr.ref = _objc_msgSend_d3i1uy(
            _$.ref.pointer,
            _sel_rangeOfComposedCharacterSequenceAtIndex_,
            index,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSRange>($finalizable);
  }

  /// rangeOfComposedCharacterSequencesForRange:
  NSRange rangeOfComposedCharacterSequencesForRange(NSRange range) {
    objc.checkOsVersionInternal(
      'NSString.rangeOfComposedCharacterSequencesForRange:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_uimyc7Stret(
            $ptr,
            _$.ref.pointer,
            _sel_rangeOfComposedCharacterSequencesForRange_,
            range,
          )
        : $ptr.ref = _objc_msgSend_uimyc7(
            _$.ref.pointer,
            _sel_rangeOfComposedCharacterSequencesForRange_,
            range,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSRange>($finalizable);
  }

  /// rangeOfString:
  NSRange rangeOfString(NSString searchString) {
    final $ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_182fzonStret(
            $ptr,
            _$.ref.pointer,
            _sel_rangeOfString_,
            searchString.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_182fzon(
            _$.ref.pointer,
            _sel_rangeOfString_,
            searchString.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSRange>($finalizable);
  }

  /// rangeOfString:options:
  NSRange rangeOfString$1(NSString searchString, {required int options}) {
    final $ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_102xxo4Stret(
            $ptr,
            _$.ref.pointer,
            _sel_rangeOfString_options_,
            searchString.ref.pointer,
            options,
          )
        : $ptr.ref = _objc_msgSend_102xxo4(
            _$.ref.pointer,
            _sel_rangeOfString_options_,
            searchString.ref.pointer,
            options,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSRange>($finalizable);
  }

  /// rangeOfString:options:range:
  NSRange rangeOfString$2(
    NSString searchString, {
    required int options,
    required NSRange range,
  }) {
    final $ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1nmlvqcStret(
            $ptr,
            _$.ref.pointer,
            _sel_rangeOfString_options_range_,
            searchString.ref.pointer,
            options,
            range,
          )
        : $ptr.ref = _objc_msgSend_1nmlvqc(
            _$.ref.pointer,
            _sel_rangeOfString_options_range_,
            searchString.ref.pointer,
            options,
            range,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSRange>($finalizable);
  }

  /// rangeOfString:options:range:locale:
  NSRange rangeOfString$3(
    NSString searchString, {
    required int options,
    required NSRange range,
    NSLocale? locale,
  }) {
    objc.checkOsVersionInternal(
      'NSString.rangeOfString:options:range:locale:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_gg0462Stret(
            $ptr,
            _$.ref.pointer,
            _sel_rangeOfString_options_range_locale_,
            searchString.ref.pointer,
            options,
            range,
            locale?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_gg0462(
            _$.ref.pointer,
            _sel_rangeOfString_options_range_locale_,
            searchString.ref.pointer,
            options,
            range,
            locale?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSRange>($finalizable);
  }

  /// smallestEncoding
  int get smallestEncoding {
    return _objc_msgSend_xw2lbc(_$.ref.pointer, _sel_smallestEncoding);
  }

  /// stringByAppendingFormat:
  NSString stringByAppendingFormat(NSString format) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_stringByAppendingFormat_,
      format.ref.pointer,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringByAppendingString:
  NSString stringByAppendingString(NSString aString) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_stringByAppendingString_,
      aString.ref.pointer,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringByApplyingTransform:reverse:
  NSString? stringByApplyingTransform(
    NSString transform, {
    required bool reverse,
  }) {
    objc.checkOsVersionInternal(
      'NSString.stringByApplyingTransform:reverse:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.pointer,
      _sel_stringByApplyingTransform_reverse_,
      transform.ref.pointer,
      reverse,
    );
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringByFoldingWithOptions:locale:
  NSString stringByFoldingWithOptions(int options, {NSLocale? locale}) {
    objc.checkOsVersionInternal(
      'NSString.stringByFoldingWithOptions:locale:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_11cbyu0(
      _$.ref.pointer,
      _sel_stringByFoldingWithOptions_locale_,
      options,
      locale?.ref.pointer ?? ffi.nullptr,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringByPaddingToLength:withString:startingAtIndex:
  NSString stringByPaddingToLength(
    int newLength, {
    required NSString withString,
    required int startingAtIndex,
  }) {
    final $ret = _objc_msgSend_1tfztp(
      _$.ref.pointer,
      _sel_stringByPaddingToLength_withString_startingAtIndex_,
      newLength,
      withString.ref.pointer,
      startingAtIndex,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringByReplacingCharactersInRange:withString:
  NSString stringByReplacingCharactersInRange(
    NSRange range, {
    required NSString withString,
  }) {
    objc.checkOsVersionInternal(
      'NSString.stringByReplacingCharactersInRange:withString:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_bstjp9(
      _$.ref.pointer,
      _sel_stringByReplacingCharactersInRange_withString_,
      range,
      withString.ref.pointer,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringByReplacingOccurrencesOfString:withString:
  NSString stringByReplacingOccurrencesOfString(
    NSString target, {
    required NSString withString,
  }) {
    objc.checkOsVersionInternal(
      'NSString.stringByReplacingOccurrencesOfString:withString:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.pointer,
      _sel_stringByReplacingOccurrencesOfString_withString_,
      target.ref.pointer,
      withString.ref.pointer,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringByReplacingOccurrencesOfString:withString:options:range:
  NSString stringByReplacingOccurrencesOfString$1(
    NSString target, {
    required NSString withString,
    required int options,
    required NSRange range,
  }) {
    objc.checkOsVersionInternal(
      'NSString.stringByReplacingOccurrencesOfString:withString:options:range:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_2u4jm6(
      _$.ref.pointer,
      _sel_stringByReplacingOccurrencesOfString_withString_options_range_,
      target.ref.pointer,
      withString.ref.pointer,
      options,
      range,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// stringByTrimmingCharactersInSet:
  NSString stringByTrimmingCharactersInSet(NSCharacterSet set) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_stringByTrimmingCharactersInSet_,
      set.ref.pointer,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// substringFromIndex:
  NSString substringFromIndex(int from) {
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.pointer,
      _sel_substringFromIndex_,
      from,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// substringToIndex:
  NSString substringToIndex(int to) {
    final $ret = _objc_msgSend_14hpxwa(
      _$.ref.pointer,
      _sel_substringToIndex_,
      to,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// substringWithRange:
  NSString substringWithRange(NSRange range) {
    final $ret = _objc_msgSend_1k1o1s7(
      _$.ref.pointer,
      _sel_substringWithRange_,
      range,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// uppercaseString
  NSString get uppercaseString {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_uppercaseString);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// uppercaseStringWithLocale:
  NSString uppercaseStringWithLocale(NSLocale? locale) {
    objc.checkOsVersionInternal(
      'NSString.uppercaseStringWithLocale:',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.pointer,
      _sel_uppercaseStringWithLocale_,
      locale?.ref.pointer ?? ffi.nullptr,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// writeToFile:atomically:encoding:error:
  bool writeToFile(
    NSString path, {
    required bool atomically,
    required int encoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    return _objc_msgSend_dv3z6r(
      _$.ref.pointer,
      _sel_writeToFile_atomically_encoding_error_,
      path.ref.pointer,
      atomically,
      encoding,
      error,
    );
  }

  /// writeToURL:atomically:encoding:error:
  bool writeToURL(
    NSURL url, {
    required bool atomically,
    required int encoding,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    return _objc_msgSend_dv3z6r(
      _$.ref.pointer,
      _sel_writeToURL_atomically_encoding_error_,
      url.ref.pointer,
      atomically,
      encoding,
      error,
    );
  }

  /// availableStringEncodings
  static ffi.Pointer<ffi.UnsignedLong> getAvailableStringEncodings() {
    return _objc_msgSend_1h2q612(
      _class_NSString,
      _sel_availableStringEncodings,
    );
  }

  /// defaultCStringEncoding
  static int getDefaultCStringEncoding() {
    return _objc_msgSend_xw2lbc(_class_NSString, _sel_defaultCStringEncoding);
  }

  /// localizedNameOfStringEncoding:
  static NSString localizedNameOfStringEncoding(int encoding) {
    final $ret = _objc_msgSend_14hpxwa(
      _class_NSString,
      _sel_localizedNameOfStringEncoding_,
      encoding,
    );
    return NSString.castFromPointer($ret, retain: true, release: true);
  }
}

/// NSTimer
extension type NSTimer.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [NSTimer] that wraps the given raw object pointer.
  NSTimer.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSTimer].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSTimer,
    );
  }

  /// alloc
  static NSTimer alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSTimer, _sel_alloc);
    return NSTimer.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSTimer allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSTimer,
      _sel_allocWithZone_,
      zone,
    );
    return NSTimer.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSTimer new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSTimer, _sel_new);
    return NSTimer.castFromPointer($ret, retain: false, release: true);
  }

  /// scheduledTimerWithTimeInterval:invocation:repeats:
  static NSTimer scheduledTimerWithTimeInterval(
    double ti, {
    required NSInvocation invocation,
    required bool repeats,
  }) {
    final $ret = _objc_msgSend_r49ehc(
      _class_NSTimer,
      _sel_scheduledTimerWithTimeInterval_invocation_repeats_,
      ti,
      invocation.ref.pointer,
      repeats,
    );
    return NSTimer.castFromPointer($ret, retain: true, release: true);
  }

  /// scheduledTimerWithTimeInterval:repeats:block:
  static NSTimer scheduledTimerWithTimeInterval$1(
    double interval, {
    required bool repeats,
    required objc.ObjCBlock<ffi.Void Function(NSTimer)> block,
  }) {
    objc.checkOsVersionInternal(
      'NSTimer.scheduledTimerWithTimeInterval:repeats:block:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    final $ret = _objc_msgSend_9a64f1(
      _class_NSTimer,
      _sel_scheduledTimerWithTimeInterval_repeats_block_,
      interval,
      repeats,
      block.ref.pointer,
    );
    return NSTimer.castFromPointer($ret, retain: true, release: true);
  }

  /// scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:
  static NSTimer scheduledTimerWithTimeInterval$2(
    double ti, {
    required objc.ObjCObjectBase target,
    required ffi.Pointer<objc.ObjCSelector> selector,
    objc.ObjCObjectBase? userInfo,
    required bool repeats,
  }) {
    final $ret = _objc_msgSend_ot6jdx(
      _class_NSTimer,
      _sel_scheduledTimerWithTimeInterval_target_selector_userInfo_repeats_,
      ti,
      target.ref.pointer,
      selector,
      userInfo?.ref.pointer ?? ffi.nullptr,
      repeats,
    );
    return NSTimer.castFromPointer($ret, retain: true, release: true);
  }

  /// timerWithTimeInterval:invocation:repeats:
  static NSTimer timerWithTimeInterval(
    double ti, {
    required NSInvocation invocation,
    required bool repeats,
  }) {
    final $ret = _objc_msgSend_r49ehc(
      _class_NSTimer,
      _sel_timerWithTimeInterval_invocation_repeats_,
      ti,
      invocation.ref.pointer,
      repeats,
    );
    return NSTimer.castFromPointer($ret, retain: true, release: true);
  }

  /// timerWithTimeInterval:repeats:block:
  static NSTimer timerWithTimeInterval$1(
    double interval, {
    required bool repeats,
    required objc.ObjCBlock<ffi.Void Function(NSTimer)> block,
  }) {
    objc.checkOsVersionInternal(
      'NSTimer.timerWithTimeInterval:repeats:block:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    final $ret = _objc_msgSend_9a64f1(
      _class_NSTimer,
      _sel_timerWithTimeInterval_repeats_block_,
      interval,
      repeats,
      block.ref.pointer,
    );
    return NSTimer.castFromPointer($ret, retain: true, release: true);
  }

  /// timerWithTimeInterval:target:selector:userInfo:repeats:
  static NSTimer timerWithTimeInterval$2(
    double ti, {
    required objc.ObjCObjectBase target,
    required ffi.Pointer<objc.ObjCSelector> selector,
    objc.ObjCObjectBase? userInfo,
    required bool repeats,
  }) {
    final $ret = _objc_msgSend_ot6jdx(
      _class_NSTimer,
      _sel_timerWithTimeInterval_target_selector_userInfo_repeats_,
      ti,
      target.ref.pointer,
      selector,
      userInfo?.ref.pointer ?? ffi.nullptr,
      repeats,
    );
    return NSTimer.castFromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of NSTimer constructed with the default `new` method.
  NSTimer() : this.castFrom(new$()._$);
}

extension NSTimer$Methods on NSTimer {
  /// fire
  void fire() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_fire);
  }

  /// fireDate
  NSDate get fireDate {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_fireDate);
    return NSDate.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  NSTimer init() {
    objc.checkOsVersionInternal(
      'NSTimer.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSTimer.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFireDate:interval:repeats:block:
  NSTimer initWithFireDate(
    NSDate date, {
    required double interval,
    required bool repeats,
    required objc.ObjCBlock<ffi.Void Function(NSTimer)> block,
  }) {
    objc.checkOsVersionInternal(
      'NSTimer.initWithFireDate:interval:repeats:block:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    final $ret = _objc_msgSend_1s0rfm3(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithFireDate_interval_repeats_block_,
      date.ref.pointer,
      interval,
      repeats,
      block.ref.pointer,
    );
    return NSTimer.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFireDate:interval:target:selector:userInfo:repeats:
  NSTimer initWithFireDate$1(
    NSDate date, {
    required double interval,
    required objc.ObjCObjectBase target,
    required ffi.Pointer<objc.ObjCSelector> selector,
    objc.ObjCObjectBase? userInfo,
    required bool repeats,
  }) {
    final $ret = _objc_msgSend_14wwtbv(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithFireDate_interval_target_selector_userInfo_repeats_,
      date.ref.pointer,
      interval,
      target.ref.pointer,
      selector,
      userInfo?.ref.pointer ?? ffi.nullptr,
      repeats,
    );
    return NSTimer.castFromPointer($ret, retain: false, release: true);
  }

  /// invalidate
  void invalidate() {
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_invalidate);
  }

  /// isValid
  bool get isValid {
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isValid);
  }

  /// setFireDate:
  set fireDate(NSDate value) {
    _objc_msgSend_xtuoz7(_$.ref.pointer, _sel_setFireDate_, value.ref.pointer);
  }

  /// setTolerance:
  set tolerance(double value) {
    objc.checkOsVersionInternal(
      'NSTimer.setTolerance:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_hwm8nu(_$.ref.pointer, _sel_setTolerance_, value);
  }

  /// timeInterval
  double get timeInterval {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_$.ref.pointer, _sel_timeInterval)
        : _objc_msgSend_1ukqyt8(_$.ref.pointer, _sel_timeInterval);
  }

  /// tolerance
  double get tolerance {
    objc.checkOsVersionInternal(
      'NSTimer.tolerance',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_$.ref.pointer, _sel_tolerance)
        : _objc_msgSend_1ukqyt8(_$.ref.pointer, _sel_tolerance);
  }

  /// userInfo
  objc.ObjCObjectBase? get userInfo {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_userInfo);
    return $ret.address == 0
        ? null
        : objc.ObjCObjectBase($ret, retain: true, release: true);
  }
}

/// NSURL
extension type NSURL.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject, NSSecureCoding, NSCopying {
  /// Constructs a [NSURL] that wraps the given raw object pointer.
  NSURL.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSURL].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSURL,
    );
  }

  /// URLByResolvingAliasFileAtURL:options:error:
  static NSURL? URLByResolvingAliasFileAtURL(
    NSURL url, {
    required int options,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.URLByResolvingAliasFileAtURL:options:error:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_1tiux5i(
      _class_NSURL,
      _sel_URLByResolvingAliasFileAtURL_options_error_,
      url.ref.pointer,
      options,
      error,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// URLByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:
  static NSURL? URLByResolvingBookmarkData(
    NSData bookmarkData, {
    required int options,
    NSURL? relativeToURL,
    required ffi.Pointer<ffi.Bool> bookmarkDataIsStale,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.URLByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1ceswyu(
      _class_NSURL,
      _sel_URLByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_,
      bookmarkData.ref.pointer,
      options,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
      bookmarkDataIsStale,
      error,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// URLWithDataRepresentation:relativeToURL:
  static NSURL URLWithDataRepresentation(NSData data, {NSURL? relativeToURL}) {
    objc.checkOsVersionInternal(
      'NSURL.URLWithDataRepresentation:relativeToURL:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_NSURL,
      _sel_URLWithDataRepresentation_relativeToURL_,
      data.ref.pointer,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
    );
    return NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// URLWithString:
  static NSURL? URLWithString(NSString URLString) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSURL,
      _sel_URLWithString_,
      URLString.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// URLWithString:encodingInvalidCharacters:
  ///
  /// iOS: introduced 17.0.0
  /// macOS: introduced 14.0.0
  static NSURL? URLWithString$1(
    NSString URLString, {
    required bool encodingInvalidCharacters,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.URLWithString:encodingInvalidCharacters:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _class_NSURL,
      _sel_URLWithString_encodingInvalidCharacters_,
      URLString.ref.pointer,
      encodingInvalidCharacters,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// URLWithString:relativeToURL:
  static NSURL? URLWithString$2(NSString URLString, {NSURL? relativeToURL}) {
    final $ret = _objc_msgSend_15qeuct(
      _class_NSURL,
      _sel_URLWithString_relativeToURL_,
      URLString.ref.pointer,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// absoluteURLWithDataRepresentation:relativeToURL:
  static NSURL absoluteURLWithDataRepresentation(
    NSData data, {
    NSURL? relativeToURL,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.absoluteURLWithDataRepresentation:relativeToURL:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_NSURL,
      _sel_absoluteURLWithDataRepresentation_relativeToURL_,
      data.ref.pointer,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
    );
    return NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// alloc
  static NSURL alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSURL, _sel_alloc);
    return NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSURL allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_NSURL, _sel_allocWithZone_, zone);
    return NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// bookmarkDataWithContentsOfURL:error:
  static NSData? bookmarkDataWithContentsOfURL(
    NSURL bookmarkFileURL, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.bookmarkDataWithContentsOfURL:error:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1lhpu4m(
      _class_NSURL,
      _sel_bookmarkDataWithContentsOfURL_error_,
      bookmarkFileURL.ref.pointer,
      error,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// fileURLWithFileSystemRepresentation:isDirectory:relativeToURL:
  static NSURL fileURLWithFileSystemRepresentation(
    ffi.Pointer<ffi.Char> path, {
    required bool isDirectory,
    NSURL? relativeToURL,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.fileURLWithFileSystemRepresentation:isDirectory:relativeToURL:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_1n40f6p(
      _class_NSURL,
      _sel_fileURLWithFileSystemRepresentation_isDirectory_relativeToURL_,
      path,
      isDirectory,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
    );
    return NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// fileURLWithPath:
  static NSURL fileURLWithPath(NSString path) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSURL,
      _sel_fileURLWithPath_,
      path.ref.pointer,
    );
    return NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// fileURLWithPath:isDirectory:
  static NSURL fileURLWithPath$1(NSString path, {required bool isDirectory}) {
    objc.checkOsVersionInternal(
      'NSURL.fileURLWithPath:isDirectory:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _class_NSURL,
      _sel_fileURLWithPath_isDirectory_,
      path.ref.pointer,
      isDirectory,
    );
    return NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// fileURLWithPath:isDirectory:relativeToURL:
  static NSURL fileURLWithPath$2(
    NSString path, {
    required bool isDirectory,
    NSURL? relativeToURL,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.fileURLWithPath:isDirectory:relativeToURL:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_1ged0jd(
      _class_NSURL,
      _sel_fileURLWithPath_isDirectory_relativeToURL_,
      path.ref.pointer,
      isDirectory,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
    );
    return NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// fileURLWithPath:relativeToURL:
  static NSURL fileURLWithPath$3(NSString path, {NSURL? relativeToURL}) {
    objc.checkOsVersionInternal(
      'NSURL.fileURLWithPath:relativeToURL:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_NSURL,
      _sel_fileURLWithPath_relativeToURL_,
      path.ref.pointer,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
    );
    return NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSURL new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSURL, _sel_new);
    return NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// resourceValuesForKeys:fromBookmarkData:
  static NSDictionary? resourceValuesForKeys$1(
    NSArray keys, {
    required NSData fromBookmarkData,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.resourceValuesForKeys:fromBookmarkData:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_NSURL,
      _sel_resourceValuesForKeys_fromBookmarkData_,
      keys.ref.pointer,
      fromBookmarkData.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSDictionary.castFromPointer($ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSURL, _sel_supportsSecureCoding);
  }

  /// writeBookmarkData:toURL:options:error:
  static bool writeBookmarkData(
    NSData bookmarkData, {
    required NSURL toURL,
    required int options,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.writeBookmarkData:toURL:options:error:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_1vxoo9h(
      _class_NSURL,
      _sel_writeBookmarkData_toURL_options_error_,
      bookmarkData.ref.pointer,
      toURL.ref.pointer,
      options,
      error,
    );
  }

  /// Returns a new instance of NSURL constructed with the default `new` method.
  NSURL() : this.castFrom(new$()._$);
}

extension NSURL$Methods on NSURL {
  /// absoluteString
  NSString? get absoluteString {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_absoluteString);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// absoluteURL
  NSURL? get absoluteURL {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_absoluteURL);
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// baseURL
  NSURL? get baseURL {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_baseURL);
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// bookmarkDataWithOptions:includingResourceValuesForKeys:relativeToURL:error:
  NSData? bookmarkDataWithOptions(
    int options, {
    NSArray? includingResourceValuesForKeys,
    NSURL? relativeToURL,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.bookmarkDataWithOptions:includingResourceValuesForKeys:relativeToURL:error:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1wt9a7r(
      _$.ref.pointer,
      _sel_bookmarkDataWithOptions_includingResourceValuesForKeys_relativeToURL_error_,
      options,
      includingResourceValuesForKeys?.ref.pointer ?? ffi.nullptr,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
      error,
    );
    return $ret.address == 0
        ? null
        : NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// dataRepresentation
  NSData get dataRepresentation {
    objc.checkOsVersionInternal(
      'NSURL.dataRepresentation',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_dataRepresentation);
    return NSData.castFromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// filePathURL
  NSURL? get filePathURL {
    objc.checkOsVersionInternal(
      'NSURL.filePathURL',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_filePathURL);
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// fileReferenceURL
  NSURL? fileReferenceURL() {
    objc.checkOsVersionInternal(
      'NSURL.fileReferenceURL',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_fileReferenceURL);
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// fileSystemRepresentation
  ffi.Pointer<ffi.Char> get fileSystemRepresentation {
    objc.checkOsVersionInternal(
      'NSURL.fileSystemRepresentation',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_1fuqfwb(_$.ref.pointer, _sel_fileSystemRepresentation);
  }

  /// fragment
  NSString? get fragment {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_fragment);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// getFileSystemRepresentation:maxLength:
  bool getFileSystemRepresentation(
    ffi.Pointer<ffi.Char> buffer, {
    required int maxLength,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.getFileSystemRepresentation:maxLength:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_8cymbm(
      _$.ref.pointer,
      _sel_getFileSystemRepresentation_maxLength_,
      buffer,
      maxLength,
    );
  }

  /// getResourceValue:forKey:error:
  bool getResourceValue(
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> value, {
    required NSString forKey,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.getResourceValue:forKey:error:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_1j9bhml(
      _$.ref.pointer,
      _sel_getResourceValue_forKey_error_,
      value,
      forKey.ref.pointer,
      error,
    );
  }

  /// hasDirectoryPath
  bool get hasDirectoryPath {
    objc.checkOsVersionInternal(
      'NSURL.hasDirectoryPath',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_hasDirectoryPath);
  }

  /// host
  NSString? get host {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_host);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  NSURL init() {
    objc.checkOsVersionInternal(
      'NSURL.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// initAbsoluteURLWithDataRepresentation:relativeToURL:
  NSURL initAbsoluteURLWithDataRepresentation(
    NSData data, {
    NSURL? relativeToURL,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.initAbsoluteURLWithDataRepresentation:relativeToURL:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.retainAndReturnPointer(),
      _sel_initAbsoluteURLWithDataRepresentation_relativeToURL_,
      data.ref.pointer,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
    );
    return NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// initByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:
  NSURL? initByResolvingBookmarkData(
    NSData bookmarkData, {
    required int options,
    NSURL? relativeToURL,
    required ffi.Pointer<ffi.Bool> bookmarkDataIsStale,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.initByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1ceswyu(
      _$.ref.retainAndReturnPointer(),
      _sel_initByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_,
      bookmarkData.ref.pointer,
      options,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
      bookmarkDataIsStale,
      error,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// initFileURLWithFileSystemRepresentation:isDirectory:relativeToURL:
  NSURL initFileURLWithFileSystemRepresentation(
    ffi.Pointer<ffi.Char> path, {
    required bool isDirectory,
    NSURL? relativeToURL,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.initFileURLWithFileSystemRepresentation:isDirectory:relativeToURL:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_1n40f6p(
      _$.ref.retainAndReturnPointer(),
      _sel_initFileURLWithFileSystemRepresentation_isDirectory_relativeToURL_,
      path,
      isDirectory,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
    );
    return NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// initFileURLWithPath:
  NSURL initFileURLWithPath(NSString path) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initFileURLWithPath_,
      path.ref.pointer,
    );
    return NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// initFileURLWithPath:isDirectory:
  NSURL initFileURLWithPath$1(NSString path, {required bool isDirectory}) {
    objc.checkOsVersionInternal(
      'NSURL.initFileURLWithPath:isDirectory:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initFileURLWithPath_isDirectory_,
      path.ref.pointer,
      isDirectory,
    );
    return NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// initFileURLWithPath:isDirectory:relativeToURL:
  NSURL initFileURLWithPath$2(
    NSString path, {
    required bool isDirectory,
    NSURL? relativeToURL,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.initFileURLWithPath:isDirectory:relativeToURL:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_1ged0jd(
      _$.ref.retainAndReturnPointer(),
      _sel_initFileURLWithPath_isDirectory_relativeToURL_,
      path.ref.pointer,
      isDirectory,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
    );
    return NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// initFileURLWithPath:relativeToURL:
  NSURL initFileURLWithPath$3(NSString path, {NSURL? relativeToURL}) {
    objc.checkOsVersionInternal(
      'NSURL.initFileURLWithPath:relativeToURL:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.retainAndReturnPointer(),
      _sel_initFileURLWithPath_relativeToURL_,
      path.ref.pointer,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
    );
    return NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSURL? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithDataRepresentation:relativeToURL:
  NSURL initWithDataRepresentation(NSData data, {NSURL? relativeToURL}) {
    objc.checkOsVersionInternal(
      'NSURL.initWithDataRepresentation:relativeToURL:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithDataRepresentation_relativeToURL_,
      data.ref.pointer,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
    );
    return NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithString:
  NSURL? initWithString(NSString URLString) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithString_,
      URLString.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithString:encodingInvalidCharacters:
  ///
  /// iOS: introduced 17.0.0
  /// macOS: introduced 14.0.0
  NSURL? initWithString$1(
    NSString URLString, {
    required bool encodingInvalidCharacters,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.initWithString:encodingInvalidCharacters:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_17amj0z(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithString_encodingInvalidCharacters_,
      URLString.ref.pointer,
      encodingInvalidCharacters,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithString:relativeToURL:
  NSURL? initWithString$2(NSString URLString, {NSURL? relativeToURL}) {
    final $ret = _objc_msgSend_15qeuct(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithString_relativeToURL_,
      URLString.ref.pointer,
      relativeToURL?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: false, release: true);
  }

  /// isFileReferenceURL
  bool isFileReferenceURL() {
    objc.checkOsVersionInternal(
      'NSURL.isFileReferenceURL',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isFileReferenceURL);
  }

  /// isFileURL
  bool get isFileURL {
    return _objc_msgSend_91o635(_$.ref.pointer, _sel_isFileURL);
  }

  /// iOS: introduced 2.0.0, deprecated 13.0.0
  /// macOS: introduced 10.2.0, deprecated 10.15.0
  NSString? get parameterString {
    objc.checkOsVersionInternal(
      'NSURL.parameterString',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_parameterString);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// password
  NSString? get password {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_password);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// path
  NSString? get path {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_path);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// port
  NSNumber? get port {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_port);
    return $ret.address == 0
        ? null
        : NSNumber.castFromPointer($ret, retain: true, release: true);
  }

  /// query
  NSString? get query {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_query);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// relativePath
  NSString? get relativePath {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_relativePath);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// relativeString
  NSString get relativeString {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_relativeString);
    return NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// removeAllCachedResourceValues
  void removeAllCachedResourceValues() {
    objc.checkOsVersionInternal(
      'NSURL.removeAllCachedResourceValues',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1pl9qdv(_$.ref.pointer, _sel_removeAllCachedResourceValues);
  }

  /// removeCachedResourceValueForKey:
  void removeCachedResourceValueForKey(NSString key) {
    objc.checkOsVersionInternal(
      'NSURL.removeCachedResourceValueForKey:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_removeCachedResourceValueForKey_,
      key.ref.pointer,
    );
  }

  /// resourceSpecifier
  NSString? get resourceSpecifier {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_resourceSpecifier);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// resourceValuesForKeys:error:
  NSDictionary? resourceValuesForKeys(
    NSArray keys, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.resourceValuesForKeys:error:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1lhpu4m(
      _$.ref.pointer,
      _sel_resourceValuesForKeys_error_,
      keys.ref.pointer,
      error,
    );
    return $ret.address == 0
        ? null
        : NSDictionary.castFromPointer($ret, retain: true, release: true);
  }

  /// scheme
  NSString? get scheme {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_scheme);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// setResourceValue:forKey:error:
  bool setResourceValue(
    objc.ObjCObjectBase? value, {
    required NSString forKey,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.setResourceValue:forKey:error:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_6z4k82(
      _$.ref.pointer,
      _sel_setResourceValue_forKey_error_,
      value?.ref.pointer ?? ffi.nullptr,
      forKey.ref.pointer,
      error,
    );
  }

  /// setResourceValues:error:
  bool setResourceValues(
    NSDictionary keyedValues, {
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.setResourceValues:error:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_l9p60w(
      _$.ref.pointer,
      _sel_setResourceValues_error_,
      keyedValues.ref.pointer,
      error,
    );
  }

  /// setTemporaryResourceValue:forKey:
  void setTemporaryResourceValue(
    objc.ObjCObjectBase? value, {
    required NSString forKey,
  }) {
    objc.checkOsVersionInternal(
      'NSURL.setTemporaryResourceValue:forKey:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_pfv6jd(
      _$.ref.pointer,
      _sel_setTemporaryResourceValue_forKey_,
      value?.ref.pointer ?? ffi.nullptr,
      forKey.ref.pointer,
    );
  }

  /// standardizedURL
  NSURL? get standardizedURL {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_standardizedURL);
    return $ret.address == 0
        ? null
        : NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// startAccessingSecurityScopedResource
  bool startAccessingSecurityScopedResource() {
    objc.checkOsVersionInternal(
      'NSURL.startAccessingSecurityScopedResource',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_91o635(
      _$.ref.pointer,
      _sel_startAccessingSecurityScopedResource,
    );
  }

  /// stopAccessingSecurityScopedResource
  void stopAccessingSecurityScopedResource() {
    objc.checkOsVersionInternal(
      'NSURL.stopAccessingSecurityScopedResource',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1pl9qdv(
      _$.ref.pointer,
      _sel_stopAccessingSecurityScopedResource,
    );
  }

  /// user
  NSString? get user {
    final $ret = _objc_msgSend_151sglz(_$.ref.pointer, _sel_user);
    return $ret.address == 0
        ? null
        : NSString.castFromPointer($ret, retain: true, release: true);
  }
}

sealed class NSURLBookmarkCreationOptions {
  static const NSURLBookmarkCreationPreferFileIDResolution = 256;
  static const NSURLBookmarkCreationMinimalBookmark = 512;
  static const NSURLBookmarkCreationSuitableForBookmarkFile = 1024;
  static const NSURLBookmarkCreationWithSecurityScope = 2048;
  static const NSURLBookmarkCreationSecurityScopeAllowOnlyReadAccess = 4096;
  static const NSURLBookmarkCreationWithoutImplicitSecurityScope = 536870912;
}

sealed class NSURLBookmarkResolutionOptions {
  static const NSURLBookmarkResolutionWithoutUI = 256;
  static const NSURLBookmarkResolutionWithoutMounting = 512;
  static const NSURLBookmarkResolutionWithSecurityScope = 1024;
  static const NSURLBookmarkResolutionWithoutImplicitStartAccessing = 32768;
}

/// NSURLHandle
extension type NSURLHandle.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject {
  /// Constructs a [NSURLHandle] that wraps the given raw object pointer.
  NSURLHandle.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSURLHandle].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSURLHandle,
    );
  }

  /// alloc
  static NSURLHandle alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLHandle, _sel_alloc);
    return NSURLHandle.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLHandle allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSURLHandle,
      _sel_allocWithZone_,
      zone,
    );
    return NSURLHandle.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSURLHandle new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLHandle, _sel_new);
    return NSURLHandle.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSURLHandle constructed with the default `new` method.
  NSURLHandle() : this.castFrom(new$()._$);
}

extension NSURLHandle$Methods on NSURLHandle {
  /// init
  NSURLHandle init() {
    objc.checkOsVersionInternal(
      'NSURLHandle.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSURLHandle.castFromPointer($ret, retain: false, release: true);
  }
}

enum NSURLHandleStatus {
  NSURLHandleNotLoaded(0),
  NSURLHandleLoadSucceeded(1),
  NSURLHandleLoadInProgress(2),
  NSURLHandleLoadFailed(3);

  final int value;
  const NSURLHandleStatus(this.value);

  static NSURLHandleStatus fromValue(int value) => switch (value) {
    0 => NSURLHandleNotLoaded,
    1 => NSURLHandleLoadSucceeded,
    2 => NSURLHandleLoadInProgress,
    3 => NSURLHandleLoadFailed,
    _ => throw ArgumentError('Unknown value for NSURLHandleStatus: $value'),
  };
}

/// NSValue
extension type NSValue.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase, NSObject, NSCopying, NSSecureCoding {
  /// Constructs a [NSValue] that wraps the given raw object pointer.
  NSValue.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [NSValue].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_NSValue,
    );
  }

  /// alloc
  static NSValue alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSValue, _sel_alloc);
    return NSValue.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSValue allocWithZone(ffi.Pointer<NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSValue,
      _sel_allocWithZone_,
      zone,
    );
    return NSValue.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSValue new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSValue, _sel_new);
    return NSValue.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSValue, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSValue constructed with the default `new` method.
  NSValue() : this.castFrom(new$()._$);
}

extension NSValue$Methods on NSValue {
  /// encodeWithCoder:
  void encodeWithCoder(NSCoder coder) {
    _objc_msgSend_xtuoz7(
      _$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// getValue:size:
  void getValue(ffi.Pointer<ffi.Void> value, {required int size}) {
    objc.checkOsVersionInternal(
      'NSValue.getValue:size:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_zuf90e(_$.ref.pointer, _sel_getValue_size_, value, size);
  }

  /// init
  NSValue init() {
    objc.checkOsVersionInternal(
      'NSValue.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSValue.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBytes:objCType:
  NSValue initWithBytes(
    ffi.Pointer<ffi.Void> value, {
    required ffi.Pointer<ffi.Char> objCType,
  }) {
    final $ret = _objc_msgSend_e9mncn(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithBytes_objCType_,
      value,
      objCType,
    );
    return NSValue.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSValue? initWithCoder(NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      _$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSValue.castFromPointer($ret, retain: false, release: true);
  }

  /// objCType
  ffi.Pointer<ffi.Char> get objCType {
    return _objc_msgSend_1fuqfwb(_$.ref.pointer, _sel_objCType);
  }
}

final class NSZone extends ffi.Opaque {}

/// Construction methods for `objc.ObjCBlock<NSArray Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSArray_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<NSArray Function(ffi.Pointer<ffi.Void>)>
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<NSArray Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSArray Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<NSArray Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<NSArray Function(ffi.Pointer<ffi.Void>)> fromFunction(
    NSArray Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<NSArray Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<NSArray Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSArray_ffiVoid$CallExtension
    on objc.ObjCBlock<NSArray Function(ffi.Pointer<ffi.Void>)> {
  NSArray call(ffi.Pointer<ffi.Void> arg0) => NSArray.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_NSComparisonResult_objcObjCObject_objcObjCObject {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Long Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Long Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Long Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  fromFunction(
    NSComparisonResult Function(objc.ObjCObjectBase, objc.ObjCObjectBase) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          ) => fn(
            objc.ObjCObjectBase(arg0, retain: true, release: true),
            objc.ObjCObjectBase(arg1, retain: true, release: true),
          ).value,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Long Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_NSComparisonResult_objcObjCObject_objcObjCObject$CallExtension
    on
        objc.ObjCBlock<
          ffi.Long Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        > {
  NSComparisonResult call(objc.ObjCObjectBase arg0, objc.ObjCObjectBase arg1) =>
      NSComparisonResult.fromValue(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Long Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<objc.ObjCObject> arg0,
                  ffi.Pointer<objc.ObjCObject> arg1,
                )
              >
            >()
            .asFunction<
              int Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
              )
            >()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer),
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, NSString)>`.
abstract final class ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, NSString)>
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, NSString)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, NSString)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, NSString)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, NSString)>
  fromFunction(
    NSItemProviderRepresentationVisibility Function(
      ffi.Pointer<ffi.Void>,
      NSString,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, NSString)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0,
        NSString.castFromPointer(arg1, retain: true, release: true),
      ).value,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Long Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, NSString)>`.
extension ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString$CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, NSString)> {
  NSItemProviderRepresentationVisibility call(
    ffi.Pointer<ffi.Void> arg0,
    NSString arg1,
  ) => NSItemProviderRepresentationVisibility.fromValue(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObject> arg1,
            )
          >
        >()
        .asFunction<
          int Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >()(ref.pointer, arg0, arg1.ref.pointer),
  );
}

/// Construction methods for `objc.ObjCBlock<NSOrderedCollectionChange Function(NSOrderedCollectionChange)>`.
abstract final class ObjCBlock_NSOrderedCollectionChange_NSOrderedCollectionChange {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    NSOrderedCollectionChange Function(NSOrderedCollectionChange)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        NSOrderedCollectionChange Function(NSOrderedCollectionChange)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    NSOrderedCollectionChange Function(NSOrderedCollectionChange)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        NSOrderedCollectionChange Function(NSOrderedCollectionChange)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    NSOrderedCollectionChange Function(NSOrderedCollectionChange)
  >
  fromFunction(
    NSOrderedCollectionChange Function(NSOrderedCollectionChange) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        NSOrderedCollectionChange Function(NSOrderedCollectionChange)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<objc.ObjCObject> arg0) => fn(
            NSOrderedCollectionChange.castFromPointer(
              arg0,
              retain: true,
              release: true,
            ),
          ).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject> arg0,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<NSOrderedCollectionChange Function(NSOrderedCollectionChange)>`.
extension ObjCBlock_NSOrderedCollectionChange_NSOrderedCollectionChange$CallExtension
    on
        objc.ObjCBlock<
          NSOrderedCollectionChange Function(NSOrderedCollectionChange)
        > {
  NSOrderedCollectionChange call(NSOrderedCollectionChange arg0) =>
      NSOrderedCollectionChange.castFromPointer(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<objc.ObjCObject> arg0,
                )
              >
            >()
            .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
              )
            >()(ref.pointer, arg0.ref.pointer),
        retain: true,
        release: true,
      );
}

/// Construction methods for `objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>`.
abstract final class ObjCBlock_NSProgressUnpublishingHandler_NSProgress {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
          ffi.Pointer<objc.ObjCObject> arg0,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)
  >
  fromFunction(
    objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<objc.ObjCObject> arg0) =>
              fn(
                NSProgress.castFromPointer(arg0, retain: true, release: true),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCBlockImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCObject> arg0,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCObject>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCBlockImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCBlockImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCBlockImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>`.
extension ObjCBlock_NSProgressUnpublishingHandler_NSProgress$CallExtension
    on
        objc.ObjCBlock<
          objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)
        > {
  objc.ObjCBlock<ffi.Void Function()>? call(NSProgress arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCBlockImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCObject> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCBlockImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : ObjCBlock_ffiVoid.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCBlockImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCObject> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCBlockImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true,
        );
}

/// Construction methods for `objc.ObjCBlock<NSProgress? Function(objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoidNSDataNSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    NSProgress? Function(objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        NSProgress? Function(
          objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    NSProgress? Function(objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCBlockImpl> arg0,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        NSProgress? Function(
          objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    NSProgress? Function(objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>)
  >
  fromFunction(
    NSProgress? Function(objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>)
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        NSProgress? Function(
          objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<objc.ObjCBlockImpl> arg0) =>
              fn(
                ObjCBlock_ffiVoid_NSData_NSError.castFromPointer(
                  arg0,
                  retain: true,
                  release: true,
                ),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl> arg0,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<NSProgress? Function(objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>)>`.
extension ObjCBlock_NSProgress_ffiVoidNSDataNSError$CallExtension
    on
        objc.ObjCBlock<
          NSProgress? Function(
            objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
          )
        > {
  NSProgress? call(objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCBlockImpl> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : NSProgress.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCBlockImpl> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true,
        );
}

/// Construction methods for `objc.ObjCBlock<NSProgress? Function(objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoidNSURLboolNSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    NSProgress? Function(
      objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        NSProgress? Function(
          objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    NSProgress? Function(
      objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCBlockImpl> arg0,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        NSProgress? Function(
          objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    NSProgress? Function(
      objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>,
    )
  >
  fromFunction(
    NSProgress? Function(
      objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        NSProgress? Function(
          objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<objc.ObjCBlockImpl> arg0) =>
              fn(
                ObjCBlock_ffiVoid_NSURL_bool_NSError.castFromPointer(
                  arg0,
                  retain: true,
                  release: true,
                ),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl> arg0,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<NSProgress? Function(objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>)>`.
extension ObjCBlock_NSProgress_ffiVoidNSURLboolNSError$CallExtension
    on
        objc.ObjCBlock<
          NSProgress? Function(
            objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>,
          )
        > {
  NSProgress? call(
    objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)> arg0,
  ) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCBlockImpl> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : NSProgress.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCBlockImpl> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true,
        );
}

/// Construction methods for `objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, NSString, objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      NSString,
      objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        NSProgress? Function(
          ffi.Pointer<ffi.Void>,
          NSString,
          objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      NSString,
      objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCBlockImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        NSProgress? Function(
          ffi.Pointer<ffi.Void>,
          NSString,
          objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      NSString,
      objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
    )
  >
  fromFunction(
    NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      NSString,
      objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        NSProgress? Function(
          ffi.Pointer<ffi.Void>,
          NSString,
          objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCBlockImpl> arg2,
          ) =>
              fn(
                arg0,
                NSString.castFromPointer(arg1, retain: true, release: true),
                ObjCBlock_ffiVoid_NSData_NSError.castFromPointer(
                  arg2,
                  retain: true,
                  release: true,
                ),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCBlockImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCBlockImpl> arg2,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCBlockImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, NSString, objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>)>`.
extension ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError$CallExtension
    on
        objc.ObjCBlock<
          NSProgress? Function(
            ffi.Pointer<ffi.Void>,
            NSString,
            objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>,
          )
        > {
  NSProgress? call(
    ffi.Pointer<ffi.Void> arg0,
    NSString arg1,
    objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)> arg2,
  ) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCBlockImpl> arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer)
              .address ==
          0
      ? null
      : NSProgress.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCBlockImpl> arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
          retain: true,
          release: true,
        );
}

/// Construction methods for `objc.ObjCBlock<NSProgress? Function(objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoididNSItemProviderWritingNSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    NSProgress? Function(
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
      >,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        NSProgress? Function(
          objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
          >,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    NSProgress? Function(
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
      >,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCBlockImpl> arg0,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        NSProgress? Function(
          objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
          >,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    NSProgress? Function(
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
      >,
    )
  >
  fromFunction(
    NSProgress? Function(
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
      >,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        NSProgress? Function(
          objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
          >,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<objc.ObjCBlockImpl> arg0) =>
              fn(
                ObjCBlock_ffiVoid_idNSItemProviderWriting_NSError.castFromPointer(
                  arg0,
                  retain: true,
                  release: true,
                ),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl> arg0,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<NSProgress? Function(objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)>)>`.
extension ObjCBlock_NSProgress_ffiVoididNSItemProviderWritingNSError$CallExtension
    on
        objc.ObjCBlock<
          NSProgress? Function(
            objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
            >,
          )
        > {
  NSProgress? call(
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)>
    arg0,
  ) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCBlockImpl> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : NSProgress.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCBlockImpl> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true,
        );
}

/// Construction methods for `objc.ObjCBlock<NSString Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSString_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<NSString Function(ffi.Pointer<ffi.Void>)>
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<NSString Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSString Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<NSString Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<NSString Function(ffi.Pointer<ffi.Void>)> fromFunction(
    NSString Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<NSString Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<NSString Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSString_ffiVoid$CallExtension
    on objc.ObjCBlock<NSString Function(ffi.Pointer<ffi.Void>)> {
  NSString call(ffi.Pointer<ffi.Void> arg0) => NSString.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSUInteger_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    int Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSUInteger_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Pointer<NSFastEnumerationState>, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>, ffi.UnsignedLong)>`.
abstract final class ObjCBlock_NSUInteger_ffiVoid_NSFastEnumerationState_objcObjCObject_NSUInteger {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.UnsignedLong Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<NSFastEnumerationState>,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      ffi.UnsignedLong,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.UnsignedLong Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<NSFastEnumerationState>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          ffi.UnsignedLong,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.UnsignedLong Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<NSFastEnumerationState>,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      ffi.UnsignedLong,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<NSFastEnumerationState> arg1,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2,
          ffi.UnsignedLong arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.UnsignedLong Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<NSFastEnumerationState>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          ffi.UnsignedLong,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.UnsignedLong Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<NSFastEnumerationState>,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      ffi.UnsignedLong,
    )
  >
  fromFunction(
    int Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<NSFastEnumerationState>,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      int,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.UnsignedLong Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<NSFastEnumerationState>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          ffi.UnsignedLong,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<NSFastEnumerationState> arg1,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2,
            int arg3,
          ) => fn(arg0, arg1, arg2, arg3),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<NSFastEnumerationState> arg1,
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2,
    int arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<NSFastEnumerationState> arg1,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2,
            ffi.UnsignedLong arg3,
          )
        >
      >()
      .asFunction<
        int Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<NSFastEnumerationState>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          int,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<NSFastEnumerationState>,
              ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
              ffi.UnsignedLong,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<NSFastEnumerationState> arg1,
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2,
    int arg3,
  ) =>
      (objc.getBlockClosure(block)
          as int Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<NSFastEnumerationState>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            int,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<NSFastEnumerationState>,
              ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
              ffi.UnsignedLong,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Pointer<NSFastEnumerationState>, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>, ffi.UnsignedLong)>`.
extension ObjCBlock_NSUInteger_ffiVoid_NSFastEnumerationState_objcObjCObject_NSUInteger$CallExtension
    on
        objc.ObjCBlock<
          ffi.UnsignedLong Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<NSFastEnumerationState>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            ffi.UnsignedLong,
          )
        > {
  int call(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<NSFastEnumerationState> arg1,
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2,
    int arg3,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<NSFastEnumerationState> arg1,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2,
            ffi.UnsignedLong arg3,
          )
        >
      >()
      .asFunction<
        int Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<NSFastEnumerationState>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          int,
        )
      >()(ref.pointer, arg0, arg1, arg2, arg3);
}

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSZone_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void>)>
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<NSZone> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<NSZone> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<NSZone> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<NSZone> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSZone_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void>)> {
  ffi.Pointer<NSZone> call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<NSZone> Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<NSZone> Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >()(ref.pointer, arg0);
}

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_bool_KeyType_ObjectType_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<ffi.Bool> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromFunction(
    bool Function(
      objc.ObjCObjectBase,
      objc.ObjCObjectBase,
      ffi.Pointer<ffi.Bool>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<ffi.Bool> arg2,
          ) => fn(
            objc.ObjCObjectBase(arg0, retain: true, release: true),
            objc.ObjCObjectBase(arg1, retain: true, release: true),
            arg2,
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<ffi.Bool> arg2,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Bool>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Bool>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_bool_KeyType_ObjectType_bool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          )
        > {
  bool call(
    objc.ObjCObjectBase arg0,
    objc.ObjCObjectBase arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<ffi.Bool> arg2,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer, arg2);
}

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_bool_NSUInteger_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(ffi.UnsignedLong arg0, ffi.Pointer<ffi.Bool> arg1)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
  >
  fromFunction(
    bool Function(int, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (int arg0, ffi.Pointer<ffi.Bool> arg1) => fn(arg0, arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(ffi.UnsignedLong arg0, ffi.Pointer<ffi.Bool> arg1)
        >
      >()
      .asFunction<bool Function(int, ffi.Pointer<ffi.Bool>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Bool>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(int, ffi.Pointer<ffi.Bool>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Bool>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_bool_NSUInteger_bool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
        > {
  bool call(int arg0, ffi.Pointer<ffi.Bool> arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.UnsignedLong arg0,
            ffi.Pointer<ffi.Bool> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          int,
          ffi.Pointer<ffi.Bool>,
        )
      >()(ref.pointer, arg0, arg1);
}

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_bool_ObjectType_NSUInteger_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.UnsignedLong arg1,
          ffi.Pointer<ffi.Bool> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromFunction(
    bool Function(objc.ObjCObjectBase, int, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObject> arg0,
            int arg1,
            ffi.Pointer<ffi.Bool> arg2,
          ) => fn(
            objc.ObjCObjectBase(arg0, retain: true, release: true),
            arg1,
            arg2,
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    int arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.UnsignedLong arg1,
            ffi.Pointer<ffi.Bool> arg2,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>, int, ffi.Pointer<ffi.Bool>)
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Bool>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    int arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Bool>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_bool_ObjectType_NSUInteger_bool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        > {
  bool call(objc.ObjCObjectBase arg0, int arg1, ffi.Pointer<ffi.Bool> arg2) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Bool Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObject> arg0,
                ffi.UnsignedLong arg1,
                ffi.Pointer<ffi.Bool> arg2,
              )
            >
          >()
          .asFunction<
            bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              int,
              ffi.Pointer<ffi.Bool>,
            )
          >()(ref.pointer, arg0.ref.pointer, arg1, arg2);
}

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_bool_ObjectType_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<ffi.Bool> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
  >
  fromFunction(
    bool Function(objc.ObjCObjectBase, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) =>
              fn(objc.ObjCObjectBase(arg0, retain: true, release: true), arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<ffi.Bool> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Bool>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Bool>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_bool_ObjectType_bool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
        > {
  bool call(objc.ObjCObjectBase arg0, ffi.Pointer<ffi.Bool> arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<ffi.Bool> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1);
}

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
    bool Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, Protocol)>`.
abstract final class ObjCBlock_bool_ffiVoid_Protocol {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, Protocol)>
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, Protocol)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, Protocol)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, Protocol)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, Protocol)>
  fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, Protocol) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, Protocol)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, Protocol.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, Protocol)>`.
extension ObjCBlock_bool_ffiVoid_Protocol$CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, Protocol)> {
  bool call(ffi.Pointer<ffi.Void> arg0, Protocol arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_bool_ffiVoid_objcObjCObject {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
              fn(arg0, objc.ObjCObjectBase(arg1, retain: true, release: true)),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_bool_ffiVoid_objcObjCObject$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        > {
  bool call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObjectBase arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)>`.
abstract final class ObjCBlock_bool_ffiVoid_objcObjCSelector {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCSelector> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
  >
  fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1) =>
              fn(arg0, arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCSelector> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)>`.
extension ObjCBlock_bool_ffiVoid_objcObjCSelector$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
          )
        > {
  bool call(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Bool Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCSelector> arg1,
              )
            >
          >()
          .asFunction<
            bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
            )
          >()(ref.pointer, arg0, arg1);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function()>`.
abstract final class ObjCBlock_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function()> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function()>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> fromFunction(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newClosureBlock(_closureCallable, () => fn(), keepIsolateAlive),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> listener(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_1pl9qdv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function()>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function()> blocking(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_1pl9qdv(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function()>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) {
    (objc.getBlockClosure(block) as void Function())();
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function())();
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) => block
      .ref
      .target
      .cast<ffi.NativeFunction<ffi.Void Function()>>()
      .asFunction<void Function()>()();
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) =>
      (objc.getBlockClosure(block) as void Function())();
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function()>`.
extension ObjCBlock_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Void Function()> {
  void call() =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block)
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
        ref.pointer,
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_KeyType_ObjectType_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<ffi.Bool> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromFunction(
    void Function(
      objc.ObjCObjectBase,
      objc.ObjCObjectBase,
      ffi.Pointer<ffi.Bool>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<ffi.Bool> arg2,
          ) => fn(
            objc.ObjCObjectBase(arg0, retain: true, release: true),
            objc.ObjCObjectBase(arg1, retain: true, release: true),
            arg2,
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  listener(
    void Function(
      objc.ObjCObjectBase,
      objc.ObjCObjectBase,
      ffi.Pointer<ffi.Bool>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<ffi.Bool> arg2,
      ) => fn(
        objc.ObjCObjectBase(arg0, retain: false, release: true),
        objc.ObjCObjectBase(arg1, retain: false, release: true),
        arg2,
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_1o83rbn(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Bool>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  blocking(
    void Function(
      objc.ObjCObjectBase,
      objc.ObjCObjectBase,
      ffi.Pointer<ffi.Bool>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<ffi.Bool> arg2,
      ) => fn(
        objc.ObjCObjectBase(arg0, retain: false, release: true),
        objc.ObjCObjectBase(arg1, retain: false, release: true),
        arg2,
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<ffi.Bool> arg2,
      ) => fn(
        objc.ObjCObjectBase(arg0, retain: false, release: true),
        objc.ObjCObjectBase(arg1, retain: false, release: true),
        arg2,
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_1o83rbn(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Bool>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<ffi.Bool> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Bool>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Bool>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_KeyType_ObjectType_bool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          )
        > {
  void call(
    objc.ObjCObjectBase arg0,
    objc.ObjCObjectBase arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<ffi.Bool> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer, arg2);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSData_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)> fromFunction(
    void Function(NSData?, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSData.castFromPointer(arg0, retain: true, release: true),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: true, release: true),
          ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)> listener(
    void Function(NSData?, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSData.castFromPointer(arg0, retain: false, release: true),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)> blocking(
    void Function(NSData?, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSData.castFromPointer(arg0, retain: false, release: true),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSData.castFromPointer(arg0, retain: false, release: true),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)>`.
extension ObjCBlock_ffiVoid_NSData_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSData?, NSError?)> {
  void call(NSData? arg0, NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>, ffi.Pointer<objc.ObjCObject>, NSDictionary)>`.
abstract final class ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>,
      ffi.Pointer<objc.ObjCObject>,
      NSDictionary,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
          >,
          ffi.Pointer<objc.ObjCObject>,
          NSDictionary,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>,
      ffi.Pointer<objc.ObjCObject>,
      NSDictionary,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
          >,
          ffi.Pointer<objc.ObjCObject>,
          NSDictionary,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>,
      ffi.Pointer<objc.ObjCObject>,
      NSDictionary,
    )
  >
  fromFunction(
    void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>,
      objc.ObjCObjectBase,
      NSDictionary,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
          >,
          ffi.Pointer<objc.ObjCObject>,
          NSDictionary,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCBlockImpl> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          ) => fn(
            ObjCBlock_ffiVoid_idNSSecureCoding_NSError.castFromPointer(
              arg0,
              retain: true,
              release: true,
            ),
            objc.ObjCObjectBase(arg1, retain: true, release: true),
            NSDictionary.castFromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>,
      ffi.Pointer<objc.ObjCObject>,
      NSDictionary,
    )
  >
  listener(
    void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>,
      objc.ObjCObjectBase,
      NSDictionary,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCBlockImpl> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        ObjCBlock_ffiVoid_idNSSecureCoding_NSError.castFromPointer(
          arg0,
          retain: false,
          release: true,
        ),
        objc.ObjCObjectBase(arg1, retain: false, release: true),
        NSDictionary.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_1b3bb6a(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
        >,
        ffi.Pointer<objc.ObjCObject>,
        NSDictionary,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>,
      ffi.Pointer<objc.ObjCObject>,
      NSDictionary,
    )
  >
  blocking(
    void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>,
      objc.ObjCObjectBase,
      NSDictionary,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCBlockImpl> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        ObjCBlock_ffiVoid_idNSSecureCoding_NSError.castFromPointer(
          arg0,
          retain: false,
          release: true,
        ),
        objc.ObjCObjectBase(arg1, retain: false, release: true),
        NSDictionary.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCBlockImpl> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        ObjCBlock_ffiVoid_idNSSecureCoding_NSError.castFromPointer(
          arg0,
          retain: false,
          release: true,
        ),
        objc.ObjCObjectBase(arg1, retain: false, release: true),
        NSDictionary.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_1b3bb6a(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
        >,
        ffi.Pointer<objc.ObjCObject>,
        NSDictionary,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>, ffi.Pointer<objc.ObjCObject>, NSDictionary)>`.
extension ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
            >,
            ffi.Pointer<objc.ObjCObject>,
            NSDictionary,
          )
        > {
  void call(
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>
    arg0,
    objc.ObjCObjectBase arg1,
    NSDictionary arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCBlockImpl> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer, arg2.ref.pointer);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_NSRange_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)>
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(NSRange arg0, ffi.Pointer<ffi.Bool> arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)>
  fromFunction(
    void Function(NSRange, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)>(
    objc.newClosureBlock(
      _closureCallable,
      (NSRange arg0, ffi.Pointer<ffi.Bool> arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)>
  listener(
    void Function(NSRange, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (NSRange arg0, ffi.Pointer<ffi.Bool> arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_zkjmn1(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)>
  blocking(
    void Function(NSRange, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (NSRange arg0, ffi.Pointer<ffi.Bool> arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (NSRange arg0, ffi.Pointer<ffi.Bool> arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_zkjmn1(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    NSRange arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(NSRange, ffi.Pointer<ffi.Bool>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      NSRange,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            NSRange,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    NSRange arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(NSRange, ffi.Pointer<ffi.Bool>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      NSRange,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            NSRange,
            ffi.Pointer<ffi.Bool>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      NSRange,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            NSRange,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    NSRange arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(NSRange arg0, ffi.Pointer<ffi.Bool> arg1)
        >
      >()
      .asFunction<void Function(NSRange, ffi.Pointer<ffi.Bool>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              NSRange,
              ffi.Pointer<ffi.Bool>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    NSRange arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(NSRange, ffi.Pointer<ffi.Bool>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              NSRange,
              ffi.Pointer<ffi.Bool>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_NSRange_bool$CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSRange, ffi.Pointer<ffi.Bool>)> {
  void call(NSRange arg0, ffi.Pointer<ffi.Bool> arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            NSRange arg0,
            ffi.Pointer<ffi.Bool> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          NSRange,
          ffi.Pointer<ffi.Bool>,
        )
      >()(ref.pointer, arg0, arg1);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          NSRange arg1,
          NSRange arg2,
          ffi.Pointer<ffi.Bool> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
  >
  fromFunction(
    void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObject> arg0,
            NSRange arg1,
            NSRange arg2,
            ffi.Pointer<ffi.Bool> arg3,
          ) => fn(
            arg0.address == 0
                ? null
                : NSString.castFromPointer(arg0, retain: true, release: true),
            arg1,
            arg2,
            arg3,
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
  >
  listener(
    void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        NSRange arg1,
        NSRange arg2,
        ffi.Pointer<ffi.Bool> arg3,
      ) => fn(
        arg0.address == 0
            ? null
            : NSString.castFromPointer(arg0, retain: false, release: true),
        arg1,
        arg2,
        arg3,
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_lmc3p5(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
  >
  blocking(
    void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        NSRange arg1,
        NSRange arg2,
        ffi.Pointer<ffi.Bool> arg3,
      ) => fn(
        arg0.address == 0
            ? null
            : NSString.castFromPointer(arg0, retain: false, release: true),
        arg1,
        arg2,
        arg3,
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        NSRange arg1,
        NSRange arg2,
        ffi.Pointer<ffi.Bool> arg3,
      ) => fn(
        arg0.address == 0
            ? null
            : NSString.castFromPointer(arg0, retain: false, release: true),
        arg1,
        arg2,
        arg3,
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_lmc3p5(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    NSRange arg1,
    NSRange arg2,
    ffi.Pointer<ffi.Bool> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObject>,
          NSRange,
          NSRange,
          ffi.Pointer<ffi.Bool>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      NSRange,
      NSRange,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            NSRange,
            NSRange,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    NSRange arg1,
    NSRange arg2,
    ffi.Pointer<ffi.Bool> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            NSRange,
            NSRange,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      NSRange,
      NSRange,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            NSRange,
            NSRange,
            ffi.Pointer<ffi.Bool>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      NSRange,
      NSRange,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            NSRange,
            NSRange,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    NSRange arg1,
    NSRange arg2,
    ffi.Pointer<ffi.Bool> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            NSRange arg1,
            NSRange arg2,
            ffi.Pointer<ffi.Bool> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObject>,
          NSRange,
          NSRange,
          ffi.Pointer<ffi.Bool>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              NSRange,
              NSRange,
              ffi.Pointer<ffi.Bool>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    NSRange arg1,
    NSRange arg2,
    ffi.Pointer<ffi.Bool> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            NSRange,
            NSRange,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              NSRange,
              NSRange,
              ffi.Pointer<ffi.Bool>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
        > {
  void call(
    NSString? arg0,
    NSRange arg1,
    NSRange arg2,
    ffi.Pointer<ffi.Bool> arg3,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            NSRange arg1,
            NSRange arg2,
            ffi.Pointer<ffi.Bool> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
          NSRange,
          NSRange,
          ffi.Pointer<ffi.Bool>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1, arg2, arg3);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSString, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_NSString_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSString, ffi.Pointer<ffi.Bool>)>
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(NSString, ffi.Pointer<ffi.Bool>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSString, ffi.Pointer<ffi.Bool>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<ffi.Bool> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(NSString, ffi.Pointer<ffi.Bool>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSString, ffi.Pointer<ffi.Bool>)>
  fromFunction(
    void Function(NSString, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(NSString, ffi.Pointer<ffi.Bool>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) =>
          fn(NSString.castFromPointer(arg0, retain: true, release: true), arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSString, ffi.Pointer<ffi.Bool>)>
  listener(
    void Function(NSString, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
        NSString.castFromPointer(arg0, retain: false, release: true),
        arg1,
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_t8l8el(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSString, ffi.Pointer<ffi.Bool>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSString, ffi.Pointer<ffi.Bool>)>
  blocking(
    void Function(NSString, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
        NSString.castFromPointer(arg0, retain: false, release: true),
        arg1,
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
        NSString.castFromPointer(arg0, retain: false, release: true),
        arg1,
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_t8l8el(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSString, ffi.Pointer<ffi.Bool>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<ffi.Bool> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Bool>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Bool>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSString, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_NSString_bool$CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSString, ffi.Pointer<ffi.Bool>)> {
  void call(NSString arg0, ffi.Pointer<ffi.Bool> arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<ffi.Bool> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSTimer)>`.
abstract final class ObjCBlock_ffiVoid_NSTimer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSTimer)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(NSTimer)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSTimer)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(NSTimer)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSTimer)> fromFunction(
    void Function(NSTimer) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(NSTimer)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(NSTimer.castFromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSTimer)> listener(
    void Function(NSTimer) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(NSTimer.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSTimer)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSTimer)> blocking(
    void Function(NSTimer) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(NSTimer.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(NSTimer.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSTimer)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSTimer)>`.
extension ObjCBlock_ffiVoid_NSTimer$CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSTimer)> {
  void call(NSTimer arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0.ref.pointer);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_NSUInteger_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.UnsignedLong arg0, ffi.Pointer<ffi.Bool> arg1)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
  >
  fromFunction(
    void Function(int, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (int arg0, ffi.Pointer<ffi.Bool> arg1) => fn(arg0, arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
  >
  listener(
    void Function(int, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<ffi.Bool> arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_q5jeyk(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
  >
  blocking(
    void Function(int, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<ffi.Bool> arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<ffi.Bool> arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_q5jeyk(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(int, ffi.Pointer<ffi.Bool>))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<ffi.Bool>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.UnsignedLong arg0, ffi.Pointer<ffi.Bool> arg1)
        >
      >()
      .asFunction<void Function(int, ffi.Pointer<ffi.Bool>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Bool>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<ffi.Bool>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Bool>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_NSUInteger_bool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)
        > {
  void call(int arg0, ffi.Pointer<ffi.Bool> arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.UnsignedLong arg0,
            ffi.Pointer<ffi.Bool> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          int,
          ffi.Pointer<ffi.Bool>,
        )
      >()(ref.pointer, arg0, arg1);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSURL?, NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSURL_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSURL?, NSError?)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(NSURL?, NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSURL?, NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(NSURL?, NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSURL?, NSError?)> fromFunction(
    void Function(NSURL?, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(NSURL?, NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSURL.castFromPointer(arg0, retain: true, release: true),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: true, release: true),
          ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSURL?, NSError?)> listener(
    void Function(NSURL?, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSURL.castFromPointer(arg0, retain: false, release: true),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSURL?, NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSURL?, NSError?)> blocking(
    void Function(NSURL?, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSURL.castFromPointer(arg0, retain: false, release: true),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSURL.castFromPointer(arg0, retain: false, release: true),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSURL?, NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSURL?, NSError?)>`.
extension ObjCBlock_ffiVoid_NSURL_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSURL?, NSError?)> {
  void call(NSURL? arg0, NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSURL_bool_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Bool arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>
  fromFunction(
    void Function(NSURL?, bool, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        bool arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        arg0.address == 0
            ? null
            : NSURL.castFromPointer(arg0, retain: true, release: true),
        arg1,
        arg2.address == 0
            ? null
            : NSError.castFromPointer(arg2, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)> listener(
    void Function(NSURL?, bool, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        bool arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        arg0.address == 0
            ? null
            : NSURL.castFromPointer(arg0, retain: false, release: true),
        arg1,
        arg2.address == 0
            ? null
            : NSError.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_rnu2c5(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)> blocking(
    void Function(NSURL?, bool, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        bool arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        arg0.address == 0
            ? null
            : NSURL.castFromPointer(arg0, retain: false, release: true),
        arg1,
        arg2.address == 0
            ? null
            : NSError.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        bool arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        arg0.address == 0
            ? null
            : NSURL.castFromPointer(arg0, retain: false, release: true),
        arg1,
        arg2.address == 0
            ? null
            : NSError.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_rnu2c5(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    bool arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObject>,
          bool,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Bool,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    bool arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            bool,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Bool,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Bool,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    bool arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Bool arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObject>,
          bool,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Bool,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    bool arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            bool,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Bool,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)>`.
extension ObjCBlock_ffiVoid_NSURL_bool_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSURL?, ffi.Bool, NSError?)> {
  void call(NSURL? arg0, bool arg1, NSError? arg2) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Bool arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              bool,
              ffi.Pointer<objc.ObjCObject>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1,
        arg2?.ref.pointer ?? ffi.nullptr,
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_ObjectType_NSUInteger_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.UnsignedLong arg1,
          ffi.Pointer<ffi.Bool> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromFunction(
    void Function(objc.ObjCObjectBase, int, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObject> arg0,
            int arg1,
            ffi.Pointer<ffi.Bool> arg2,
          ) => fn(
            objc.ObjCObjectBase(arg0, retain: true, release: true),
            arg1,
            arg2,
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  listener(
    void Function(objc.ObjCObjectBase, int, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        int arg1,
        ffi.Pointer<ffi.Bool> arg2,
      ) => fn(
        objc.ObjCObjectBase(arg0, retain: false, release: true),
        arg1,
        arg2,
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_1p9ui4q(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  blocking(
    void Function(objc.ObjCObjectBase, int, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        int arg1,
        ffi.Pointer<ffi.Bool> arg2,
      ) => fn(
        objc.ObjCObjectBase(arg0, retain: false, release: true),
        arg1,
        arg2,
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        int arg1,
        ffi.Pointer<ffi.Bool> arg2,
      ) => fn(
        objc.ObjCObjectBase(arg0, retain: false, release: true),
        arg1,
        arg2,
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_1p9ui4q(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    int arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObject>,
          int,
          ffi.Pointer<ffi.Bool>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    int arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    int arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.UnsignedLong arg1,
            ffi.Pointer<ffi.Bool> arg2,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>, int, ffi.Pointer<ffi.Bool>)
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Bool>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    int arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Bool>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_ObjectType_NSUInteger_bool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        > {
  void call(objc.ObjCObjectBase arg0, int arg1, ffi.Pointer<ffi.Bool> arg2) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObject> arg0,
                ffi.UnsignedLong arg1,
                ffi.Pointer<ffi.Bool> arg2,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              int,
              ffi.Pointer<ffi.Bool>,
            )
          >()(ref.pointer, arg0.ref.pointer, arg1, arg2);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_ObjectType_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<ffi.Bool> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
  >
  fromFunction(
    void Function(objc.ObjCObjectBase, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) =>
              fn(objc.ObjCObjectBase(arg0, retain: true, release: true), arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
  >
  listener(
    void Function(objc.ObjCObjectBase, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) =>
          fn(objc.ObjCObjectBase(arg0, retain: false, release: true), arg1),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_t8l8el(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
  >
  blocking(
    void Function(objc.ObjCObjectBase, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) =>
          fn(objc.ObjCObjectBase(arg0, retain: false, release: true), arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) =>
          fn(objc.ObjCObjectBase(arg0, retain: false, release: true), arg1),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_t8l8el(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<ffi.Bool> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Bool>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<ffi.Bool> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Bool>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_ObjectType_bool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)
        > {
  void call(objc.ObjCObjectBase arg0, ffi.Pointer<ffi.Bool> arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<ffi.Bool> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> listener(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_ovsamd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> blocking(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_ovsamd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiVoid_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> {
  void call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSCoder)>
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSCoder)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSCoder)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSCoder)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSCoder)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSCoder)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSCoder.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSCoder)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSCoder.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSCoder)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSCoder)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSCoder.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSCoder.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSCoder)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSCoder arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSPortMessage)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSPortMessage {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSPortMessage)>
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSPortMessage)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSPortMessage)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSPortMessage)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSPortMessage)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSPortMessage) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSPortMessage)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0,
        NSPortMessage.castFromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSPortMessage)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSPortMessage) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0,
        NSPortMessage.castFromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSPortMessage)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSPortMessage)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSPortMessage) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0,
        NSPortMessage.castFromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0,
        NSPortMessage.castFromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSPortMessage)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSPortMessage)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSPortMessage$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSPortMessage)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSPortMessage arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSRange_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          NSRange arg1,
          ffi.Pointer<ffi.Bool> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            NSRange arg1,
            ffi.Pointer<ffi.Bool> arg2,
          ) => fn(arg0, arg1, arg2),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>
          fn(arg0, arg1, arg2),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_1q8ia8l(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>
          fn(arg0, arg1, arg2),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, NSRange arg1, ffi.Pointer<ffi.Bool> arg2) =>
          fn(arg0, arg1, arg2),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_1q8ia8l(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    NSRange arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          NSRange,
          ffi.Pointer<ffi.Bool>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      NSRange,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            NSRange,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    NSRange arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            NSRange,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      NSRange,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            NSRange,
            ffi.Pointer<ffi.Bool>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      NSRange,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            NSRange,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    NSRange arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            NSRange arg1,
            ffi.Pointer<ffi.Bool> arg2,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>)
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              NSRange,
              ffi.Pointer<ffi.Bool>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    NSRange arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            NSRange,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              NSRange,
              ffi.Pointer<ffi.Bool>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSRange, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSRange_bool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSRange,
            ffi.Pointer<ffi.Bool>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSRange arg1,
    ffi.Pointer<ffi.Bool> arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            NSRange arg1,
            ffi.Pointer<ffi.Bool> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          NSRange,
          ffi.Pointer<ffi.Bool>,
        )
      >()(ref.pointer, arg0, arg1, arg2);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSStream, ffi.UnsignedLong)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSStream_NSStreamEvent {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSStream, ffi.UnsignedLong)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSStream, ffi.UnsignedLong)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSStream, ffi.UnsignedLong)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.UnsignedLong arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSStream, ffi.UnsignedLong)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSStream, ffi.UnsignedLong)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSStream, int) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSStream, ffi.UnsignedLong)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            int arg2,
          ) => fn(
            arg0,
            NSStream.castFromPointer(arg1, retain: true, release: true),
            arg2,
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSStream, ffi.UnsignedLong)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSStream, int) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        int arg2,
      ) => fn(
        arg0,
        NSStream.castFromPointer(arg1, retain: false, release: true),
        arg2,
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_hoampi(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSStream, ffi.UnsignedLong)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSStream, ffi.UnsignedLong)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSStream, int) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        int arg2,
      ) => fn(
        arg0,
        NSStream.castFromPointer(arg1, retain: false, release: true),
        arg2,
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        int arg2,
      ) => fn(
        arg0,
        NSStream.castFromPointer(arg1, retain: false, release: true),
        arg2,
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_hoampi(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSStream, ffi.UnsignedLong)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    int arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          int,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.UnsignedLong,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.UnsignedLong,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    int arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            int,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.UnsignedLong,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.UnsignedLong,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.UnsignedLong,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.UnsignedLong,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    int arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.UnsignedLong arg2,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, int)
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.UnsignedLong,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    int arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            int,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.UnsignedLong,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSStream, ffi.UnsignedLong)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSStream_NSStreamEvent$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSStream, ffi.UnsignedLong)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, NSStream arg1, int arg2) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.UnsignedLong arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          int,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSString, ffi.Pointer<objc.ObjCObject>, NSDictionary, ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSString_objcObjCObject_NSDictionary_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSString,
      ffi.Pointer<objc.ObjCObject>,
      NSDictionary,
      ffi.Pointer<ffi.Void>,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSString,
          ffi.Pointer<objc.ObjCObject>,
          NSDictionary,
          ffi.Pointer<ffi.Void>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSString,
      ffi.Pointer<objc.ObjCObject>,
      NSDictionary,
      ffi.Pointer<ffi.Void>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
          ffi.Pointer<objc.ObjCObject> arg3,
          ffi.Pointer<ffi.Void> arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSString,
          ffi.Pointer<objc.ObjCObject>,
          NSDictionary,
          ffi.Pointer<ffi.Void>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSString,
      ffi.Pointer<objc.ObjCObject>,
      NSDictionary,
      ffi.Pointer<ffi.Void>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSString,
      objc.ObjCObjectBase,
      NSDictionary,
      ffi.Pointer<ffi.Void>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSString,
          ffi.Pointer<objc.ObjCObject>,
          NSDictionary,
          ffi.Pointer<ffi.Void>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
            ffi.Pointer<ffi.Void> arg4,
          ) => fn(
            arg0,
            NSString.castFromPointer(arg1, retain: true, release: true),
            objc.ObjCObjectBase(arg2, retain: true, release: true),
            NSDictionary.castFromPointer(arg3, retain: true, release: true),
            arg4,
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSString,
      ffi.Pointer<objc.ObjCObject>,
      NSDictionary,
      ffi.Pointer<ffi.Void>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSString,
      objc.ObjCObjectBase,
      NSDictionary,
      ffi.Pointer<ffi.Void>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<ffi.Void> arg4,
      ) => fn(
        arg0,
        NSString.castFromPointer(arg1, retain: false, release: true),
        objc.ObjCObjectBase(arg2, retain: false, release: true),
        NSDictionary.castFromPointer(arg3, retain: false, release: true),
        arg4,
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_1sr3ozv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSString,
        ffi.Pointer<objc.ObjCObject>,
        NSDictionary,
        ffi.Pointer<ffi.Void>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSString,
      ffi.Pointer<objc.ObjCObject>,
      NSDictionary,
      ffi.Pointer<ffi.Void>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSString,
      objc.ObjCObjectBase,
      NSDictionary,
      ffi.Pointer<ffi.Void>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<ffi.Void> arg4,
      ) => fn(
        arg0,
        NSString.castFromPointer(arg1, retain: false, release: true),
        objc.ObjCObjectBase(arg2, retain: false, release: true),
        NSDictionary.castFromPointer(arg3, retain: false, release: true),
        arg4,
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<ffi.Void> arg4,
      ) => fn(
        arg0,
        NSString.castFromPointer(arg1, retain: false, release: true),
        objc.ObjCObjectBase(arg2, retain: false, release: true),
        NSDictionary.castFromPointer(arg3, retain: false, release: true),
        arg4,
      ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_1sr3ozv(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSString,
        ffi.Pointer<objc.ObjCObject>,
        NSDictionary,
        ffi.Pointer<ffi.Void>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
    ffi.Pointer<objc.ObjCObject> arg3,
    ffi.Pointer<ffi.Void> arg4,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Void>,
        ))(arg0, arg1, arg2, arg3, arg4);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Void>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
    ffi.Pointer<objc.ObjCObject> arg3,
    ffi.Pointer<ffi.Void> arg4,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Void>,
          ))(arg0, arg1, arg2, arg3, arg4);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Void>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Void>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<ffi.Void>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
    ffi.Pointer<objc.ObjCObject> arg3,
    ffi.Pointer<ffi.Void> arg4,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
            ffi.Pointer<ffi.Void> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Void>,
        )
      >()(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
    ffi.Pointer<objc.ObjCObject> arg3,
    ffi.Pointer<ffi.Void> arg4,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Void>,
          ))(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSString, ffi.Pointer<objc.ObjCObject>, NSDictionary, ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSString_objcObjCObject_NSDictionary_ffiVoid$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSString,
            ffi.Pointer<objc.ObjCObject>,
            NSDictionary,
            ffi.Pointer<ffi.Void>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSString arg1,
    objc.ObjCObjectBase arg2,
    NSDictionary arg3,
    ffi.Pointer<ffi.Void> arg4,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<ffi.Void> arg4,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
        arg4,
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSUInteger {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.UnsignedLong arg1)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, int) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, int) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_zuf90e(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, int) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_zuf90e(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.UnsignedLong,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.UnsignedLong,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.UnsignedLong,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.UnsignedLong,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.UnsignedLong,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.UnsignedLong,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.UnsignedLong arg1)
        >
      >()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSUInteger$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, int arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.UnsignedLong arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          int,
        )
      >()(ref.pointer, arg0, arg1);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)>`.
abstract final class ObjCBlock_ffiVoid_idNSItemProviderReading_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
  >
  fromFunction(
    void Function(NSItemProviderReading?, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          ) => fn(
            arg0.address == 0
                ? null
                : NSItemProviderReading.castFromPointer(
                    arg0,
                    retain: true,
                    release: true,
                  ),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
  >
  listener(
    void Function(NSItemProviderReading?, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSItemProviderReading.castFromPointer(
                    arg0,
                    retain: false,
                    release: true,
                  ),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
  >
  blocking(
    void Function(NSItemProviderReading?, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSItemProviderReading.castFromPointer(
                    arg0,
                    retain: false,
                    release: true,
                  ),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSItemProviderReading.castFromPointer(
                    arg0,
                    retain: false,
                    release: true,
                  ),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)>`.
extension ObjCBlock_ffiVoid_idNSItemProviderReading_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
        > {
  void call(NSItemProviderReading? arg0, NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)>`.
abstract final class ObjCBlock_ffiVoid_idNSItemProviderWriting_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
  >
  fromFunction(
    void Function(NSItemProviderWriting?, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          ) => fn(
            arg0.address == 0
                ? null
                : NSItemProviderWriting.castFromPointer(
                    arg0,
                    retain: true,
                    release: true,
                  ),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
  >
  listener(
    void Function(NSItemProviderWriting?, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSItemProviderWriting.castFromPointer(
                    arg0,
                    retain: false,
                    release: true,
                  ),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
  >
  blocking(
    void Function(NSItemProviderWriting?, NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSItemProviderWriting.castFromPointer(
                    arg0,
                    retain: false,
                    release: true,
                  ),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSItemProviderWriting.castFromPointer(
                    arg0,
                    retain: false,
                    release: true,
                  ),
            arg1.address == 0
                ? null
                : NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)>`.
extension ObjCBlock_ffiVoid_idNSItemProviderWriting_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError?)
        > {
  void call(NSItemProviderWriting? arg0, NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>`.
abstract final class ObjCBlock_ffiVoid_idNSSecureCoding_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
  >
  fromFunction(
    void Function(NSSecureCoding?, NSError) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          ) => fn(
            arg0.address == 0
                ? null
                : NSSecureCoding.castFromPointer(
                    arg0,
                    retain: true,
                    release: true,
                  ),
            NSError.castFromPointer(arg1, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
  >
  listener(
    void Function(NSSecureCoding?, NSError) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSSecureCoding.castFromPointer(
                    arg0,
                    retain: false,
                    release: true,
                  ),
            NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
  >
  blocking(
    void Function(NSSecureCoding?, NSError) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSSecureCoding.castFromPointer(
                    arg0,
                    retain: false,
                    release: true,
                  ),
            NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0.address == 0
                ? null
                : NSSecureCoding.castFromPointer(
                    arg0,
                    retain: false,
                    release: true,
                  ),
            NSError.castFromPointer(arg1, retain: false, release: true),
          ),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)>`.
extension ObjCBlock_ffiVoid_idNSSecureCoding_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, NSError)
        > {
  void call(NSSecureCoding? arg0, NSError arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1.ref.pointer);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)>`.
abstract final class ObjCBlock_ffiVoid_unichar_NSUInteger {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.UnsignedShort> arg0,
          ffi.UnsignedLong arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.UnsignedShort>, int) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.UnsignedShort> arg0, int arg1) => fn(arg0, arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)
  >
  listener(
    void Function(ffi.Pointer<ffi.UnsignedShort>, int) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.UnsignedShort> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapListenerBlock_vhbh5h(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)
  >
  blocking(
    void Function(ffi.Pointer<ffi.UnsignedShort>, int) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.UnsignedShort> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.UnsignedShort> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _ObjectiveCBindings_wrapBlockingBlock_vhbh5h(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.UnsignedShort> arg0,
    int arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.UnsignedShort>, int))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.UnsignedShort>,
      ffi.UnsignedLong,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.UnsignedShort>,
            ffi.UnsignedLong,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.UnsignedShort> arg0,
    int arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.UnsignedShort>, int))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.UnsignedShort>,
      ffi.UnsignedLong,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.UnsignedShort>,
            ffi.UnsignedLong,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.UnsignedShort>,
      ffi.UnsignedLong,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.UnsignedShort>,
            ffi.UnsignedLong,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.UnsignedShort> arg0,
    int arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<ffi.UnsignedShort> arg0,
                ffi.UnsignedLong arg1,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>, int)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.UnsignedLong,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.UnsignedShort> arg0,
    int arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.UnsignedShort>, int))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.UnsignedLong,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)>`.
extension ObjCBlock_ffiVoid_unichar_NSUInteger$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>, ffi.UnsignedLong)
        > {
  void call(ffi.Pointer<ffi.UnsignedShort> arg0, int arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.UnsignedShort> arg0,
            ffi.UnsignedLong arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.UnsignedShort>,
          int,
        )
      >()(ref.pointer, arg0, arg1);
}

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
      ffi.Pointer<ffi.Void>,
      NSCoder,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
          ffi.Pointer<ffi.Void>,
          NSCoder,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
      ffi.Pointer<ffi.Void>,
      NSCoder,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
          ffi.Pointer<ffi.Void>,
          NSCoder,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
      ffi.Pointer<ffi.Void>,
      NSCoder,
    )
  >
  fromFunction(
    Dartinstancetype? Function(ffi.Pointer<ffi.Void>, NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
          ffi.Pointer<ffi.Void>,
          NSCoder,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
              fn(
                arg0,
                NSCoder.castFromPointer(arg1, retain: true, release: true),
              )?.ref.retainAndReturnPointer() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder$CallExtension
    on
        objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
            ffi.Pointer<ffi.Void>,
            NSCoder,
          )
        > {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, NSCoder arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer),
          retain: false,
          release: true,
        );
}

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(NSError, NSString)>`.
abstract final class ObjCBlock_objcObjCObject_NSError_NSErrorUserInfoKey {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject>? Function(NSError, NSString)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(NSError, NSString)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject>? Function(NSError, NSString)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(NSError, NSString)>(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject>? Function(NSError, NSString)
  >
  fromFunction(
    objc.ObjCObjectBase? Function(NSError, NSString) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(NSError, NSString)>(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          ) =>
              fn(
                NSError.castFromPointer(arg0, retain: true, release: true),
                NSString.castFromPointer(arg1, retain: true, release: true),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(NSError, NSString)>`.
extension ObjCBlock_objcObjCObject_NSError_NSErrorUserInfoKey$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(NSError, NSString)
        > {
  objc.ObjCObjectBase? call(NSError arg0, NSString arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer),
          retain: true,
          release: true,
        );
}

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
  >
  fromFunction(
    objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
        > {
  objc.ObjCObjectBase call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<NSZone>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid_NSZone {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<NSZone>,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<NSZone>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<NSZone>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<NSZone> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<NSZone>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<NSZone>,
    )
  >
  fromFunction(
    objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>, ffi.Pointer<NSZone>)
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<NSZone>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<NSZone> arg1) =>
              fn(arg0, arg1).ref.retainAndReturnPointer(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<NSZone> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<NSZone> arg1,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<NSZone>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<NSZone>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<NSZone> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<NSZone>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<NSZone>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<NSZone>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_NSZone$CallExtension
    on
        objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<NSZone>,
          )
        > {
  objc.ObjCObjectBase call(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<NSZone> arg1,
  ) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<NSZone> arg1,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<NSZone>,
          )
        >()(ref.pointer, arg0, arg1),
    retain: false,
    release: true,
  );
}

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCSelector> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
    )
  >
  fromFunction(
    objc.ObjCObjectBase Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1) =>
              fn(arg0, arg1).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCSelector> arg1,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
          )
        > {
  objc.ObjCObjectBase call(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
  ) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCSelector> arg1,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
          )
        >()(ref.pointer, arg0, arg1),
    retain: true,
    release: true,
  );
}

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCSelector> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  fromFunction(
    objc.ObjCObjectBase Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
      objc.ObjCObjectBase,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCSelector> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          ) => fn(
            arg0,
            arg1,
            objc.ObjCObjectBase(arg2, retain: true, release: true),
          ).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCSelector> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
          )
        > {
  objc.ObjCObjectBase call(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
    objc.ObjCObjectBase arg2,
  ) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCSelector> arg1,
              ffi.Pointer<objc.ObjCObject> arg2,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >()(ref.pointer, arg0, arg1, arg2.ref.pointer),
    retain: true,
    release: true,
  );
}

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_objcObjCObject {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCSelector> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
          ffi.Pointer<objc.ObjCObject> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  fromFunction(
    objc.ObjCObjectBase Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
      objc.ObjCObjectBase,
      objc.ObjCObjectBase,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCSelector> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
          ) => fn(
            arg0,
            arg1,
            objc.ObjCObjectBase(arg2, retain: true, release: true),
            objc.ObjCObjectBase(arg3, retain: true, release: true),
          ).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
    ffi.Pointer<objc.ObjCObject> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCSelector> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
    ffi.Pointer<objc.ObjCObject> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_objcObjCSelector_objcObjCObject_objcObjCObject$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        > {
  objc.ObjCObjectBase call(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
    objc.ObjCObjectBase arg2,
    objc.ObjCObjectBase arg3,
  ) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCSelector> arg1,
              ffi.Pointer<objc.ObjCObject> arg2,
              ffi.Pointer<objc.ObjCObject> arg3,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >()(ref.pointer, arg0, arg1, arg2.ref.pointer, arg3.ref.pointer),
    retain: true,
    release: true,
  );
}

/// Protocol for observing changes to values of objects.
extension type Observer.castFrom(objc.ObjCProtocolBase _$)
    implements objc.ObjCProtocolBase, NSObjectProtocol {
  /// Constructs a [Observer] that wraps the given raw object pointer.
  Observer.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCProtocolBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [Observer].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_Observer,
    );
  }
}

extension Observer$Methods on Observer {
  /// observeValueForKeyPath:ofObject:change:context:
  void observeValueForKeyPath(
    NSString keyPath, {
    required objc.ObjCObjectBase ofObject,
    required NSDictionary change,
    required ffi.Pointer<ffi.Void> context,
  }) {
    _objc_msgSend_1pl4k3n(
      _$.ref.pointer,
      _sel_observeValueForKeyPath_ofObject_change_context_,
      keyPath.ref.pointer,
      ofObject.ref.pointer,
      change.ref.pointer,
      context,
    );
  }
}

interface class Observer$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_Observer.cast());

  /// Builds an object that implements the Observer protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static Observer implement({
    required void Function(
      NSString,
      objc.ObjCObjectBase,
      NSDictionary,
      ffi.Pointer<ffi.Void>,
    )
    observeValueForKeyPath_ofObject_change_context_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'Observer');
    Observer$Builder.observeValueForKeyPath_ofObject_change_context_.implement(
      builder,
      observeValueForKeyPath_ofObject_change_context_,
    );
    builder.addProtocol($protocol);
    return Observer.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the Observer protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    required void Function(
      NSString,
      objc.ObjCObjectBase,
      NSDictionary,
      ffi.Pointer<ffi.Void>,
    )
    observeValueForKeyPath_ofObject_change_context_,
    bool $keepIsolateAlive = true,
  }) {
    Observer$Builder.observeValueForKeyPath_ofObject_change_context_.implement(
      builder,
      observeValueForKeyPath_ofObject_change_context_,
    );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the Observer protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static Observer implementAsListener({
    required void Function(
      NSString,
      objc.ObjCObjectBase,
      NSDictionary,
      ffi.Pointer<ffi.Void>,
    )
    observeValueForKeyPath_ofObject_change_context_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'Observer');
    Observer$Builder.observeValueForKeyPath_ofObject_change_context_
        .implementAsListener(
          builder,
          observeValueForKeyPath_ofObject_change_context_,
        );
    builder.addProtocol($protocol);
    return Observer.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the Observer protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    required void Function(
      NSString,
      objc.ObjCObjectBase,
      NSDictionary,
      ffi.Pointer<ffi.Void>,
    )
    observeValueForKeyPath_ofObject_change_context_,
    bool $keepIsolateAlive = true,
  }) {
    Observer$Builder.observeValueForKeyPath_ofObject_change_context_
        .implementAsListener(
          builder,
          observeValueForKeyPath_ofObject_change_context_,
        );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the Observer protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static Observer implementAsBlocking({
    required void Function(
      NSString,
      objc.ObjCObjectBase,
      NSDictionary,
      ffi.Pointer<ffi.Void>,
    )
    observeValueForKeyPath_ofObject_change_context_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'Observer');
    Observer$Builder.observeValueForKeyPath_ofObject_change_context_
        .implementAsBlocking(
          builder,
          observeValueForKeyPath_ofObject_change_context_,
        );
    builder.addProtocol($protocol);
    return Observer.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the Observer protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    required void Function(
      NSString,
      objc.ObjCObjectBase,
      NSDictionary,
      ffi.Pointer<ffi.Void>,
    )
    observeValueForKeyPath_ofObject_change_context_,
    bool $keepIsolateAlive = true,
  }) {
    Observer$Builder.observeValueForKeyPath_ofObject_change_context_
        .implementAsBlocking(
          builder,
          observeValueForKeyPath_ofObject_change_context_,
        );
    builder.addProtocol($protocol);
  }

  /// observeValueForKeyPath:ofObject:change:context:
  static final observeValueForKeyPath_ofObject_change_context_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSString,
          objc.ObjCObjectBase,
          NSDictionary,
          ffi.Pointer<ffi.Void>,
        )
      >(
        _protocol_Observer,
        _sel_observeValueForKeyPath_ofObject_change_context_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                )
              >
            >(_ObjectiveCBindings_protocolTrampoline_1sr3ozv)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_Observer,
          _sel_observeValueForKeyPath_ofObject_change_context_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSString,
            objc.ObjCObjectBase,
            NSDictionary,
            ffi.Pointer<ffi.Void>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSString_objcObjCObject_NSDictionary_ffiVoid.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSString arg1,
                objc.ObjCObjectBase arg2,
                NSDictionary arg3,
                ffi.Pointer<ffi.Void> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSString,
            objc.ObjCObjectBase,
            NSDictionary,
            ffi.Pointer<ffi.Void>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSString_objcObjCObject_NSDictionary_ffiVoid.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSString arg1,
                objc.ObjCObjectBase arg2,
                NSDictionary arg3,
                ffi.Pointer<ffi.Void> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSString,
            objc.ObjCObjectBase,
            NSDictionary,
            ffi.Pointer<ffi.Void>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSString_objcObjCObject_NSDictionary_ffiVoid.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSString arg1,
                objc.ObjCObjectBase arg2,
                NSDictionary arg3,
                ffi.Pointer<ffi.Void> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );
}

final class OpaqueAEDataStorageType extends ffi.Opaque {}

/// Protocol
extension type Protocol.castFrom(objc.ObjCObjectBase _$)
    implements objc.ObjCObjectBase {
  /// Constructs a [Protocol] that wraps the given raw object pointer.
  Protocol.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this.castFrom(
         objc.ObjCObjectBase(other, retain: retain, release: release),
       );

  /// Returns whether [obj] is an instance of [Protocol].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_Protocol,
    );
  }
}

extension Protocol$Methods on Protocol {}

late final _class_DOBJCDartInputStreamAdapter = objc.getClass(
  "DOBJCDartInputStreamAdapter",
);
late final _class_DOBJCDartInputStreamAdapterWeakHolder = objc.getClass(
  "DOBJCDartInputStreamAdapterWeakHolder",
);
late final _class_DOBJCDartProtocol = objc.getClass("DOBJCDartProtocol");
late final _class_DOBJCDartProtocolBuilder = objc.getClass(
  "DOBJCDartProtocolBuilder",
);
late final _class_DOBJCObservation = objc.getClass("DOBJCObservation");
late final _class_NSArray = objc.getClass("NSArray");
late final _class_NSAttributedString = objc.getClass("NSAttributedString");
late final _class_NSAttributedStringMarkdownParsingOptions = objc.getClass(
  "NSAttributedStringMarkdownParsingOptions",
);
late final _class_NSBundle = objc.getClass("NSBundle");
late final _class_NSCharacterSet = objc.getClass("NSCharacterSet");
late final _class_NSCoder = objc.getClass("NSCoder");
late final _class_NSData = objc.getClass("NSData");
late final _class_NSDate = objc.getClass("NSDate");
late final _class_NSDictionary = objc.getClass("NSDictionary");
late final _class_NSEnumerator = objc.getClass("NSEnumerator");
late final _class_NSError = objc.getClass("NSError");
late final _class_NSIndexSet = objc.getClass("NSIndexSet");
late final _class_NSInputStream = objc.getClass("NSInputStream");
late final _class_NSInvocation = objc.getClass("NSInvocation");
late final _class_NSItemProvider = objc.getClass("NSItemProvider");
late final _class_NSLocale = objc.getClass("NSLocale");
late final _class_NSMethodSignature = objc.getClass("NSMethodSignature");
late final _class_NSMutableArray = objc.getClass("NSMutableArray");
late final _class_NSMutableData = objc.getClass("NSMutableData");
late final _class_NSMutableDictionary = objc.getClass("NSMutableDictionary");
late final _class_NSMutableIndexSet = objc.getClass("NSMutableIndexSet");
late final _class_NSMutableOrderedSet = objc.getClass("NSMutableOrderedSet");
late final _class_NSMutableSet = objc.getClass("NSMutableSet");
late final _class_NSMutableString = objc.getClass("NSMutableString");
late final _class_NSNotification = objc.getClass("NSNotification");
late final _class_NSNull = objc.getClass("NSNull");
late final _class_NSNumber = objc.getClass("NSNumber");
late final _class_NSObject = objc.getClass("NSObject");
late final _class_NSOrderedCollectionChange = objc.getClass(
  "NSOrderedCollectionChange",
);
late final _class_NSOrderedCollectionDifference = objc.getClass(
  "NSOrderedCollectionDifference",
);
late final _class_NSOrderedSet = objc.getClass("NSOrderedSet");
late final _class_NSOutputStream = objc.getClass("NSOutputStream");
late final _class_NSPort = objc.getClass("NSPort");
late final _class_NSPortMessage = objc.getClass("NSPortMessage");
late final _class_NSProgress = objc.getClass("NSProgress");
late final _class_NSRunLoop = objc.getClass("NSRunLoop");
late final _class_NSSet = objc.getClass("NSSet");
late final _class_NSStream = objc.getClass("NSStream");
late final _class_NSString = objc.getClass("NSString");
late final _class_NSTimer = objc.getClass("NSTimer");
late final _class_NSURL = objc.getClass("NSURL");
late final _class_NSURLHandle = objc.getClass("NSURLHandle");
late final _class_NSValue = objc.getClass("NSValue");
late final _class_Protocol = objc.getClass("Protocol");
final _objc_msgSend_102xxo4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        NSRange Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      NSRange Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_102xxo4Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<NSRange>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<NSRange>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_10mlopr = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_11cbyu0 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_11e9f5x = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Uint8>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Uint8>,
        int,
      )
    >();
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_122v0cv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        int,
      )
    >();
final _objc_msgSend_12py2ux = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_134vhyh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_13mclwd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Char,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_13x5boi = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_13yqbb6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Int Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_14ew8zr = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_14hpxwa = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_14hvw5k = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_14wwtbv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Double,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        double,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        bool,
      )
    >();
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_158ju31 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Uint8>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Uint8>,
        int,
      )
    >();
final _objc_msgSend_15bolr3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
          ffi.Pointer<objc.ObjCObject>,
          NSRange,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
        ffi.Pointer<objc.ObjCObject>,
        NSRange,
      )
    >();
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_161ne8y = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
        int,
        bool,
      )
    >();
final _objc_msgSend_1698hqz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_16f0drb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.LongLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_16fy0up = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_1776v9k = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<NSRange>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<NSRange>,
      )
    >();
final _objc_msgSend_177cajs = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_17amj0z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        bool,
      )
    >();
final _objc_msgSend_17gvxvj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int64,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_182fzon = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        NSRange Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      NSRange Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_182fzonStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<NSRange>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<NSRange>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_187k8ck = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_1895u4n = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          NSRange,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        NSRange,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_18qun1e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_194u5n2 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_19lrthf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.UnsignedLong>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
        ffi.Pointer<ffi.UnsignedLong>,
      )
    >();
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_1alewu7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.UnsignedLong>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.UnsignedLong>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_1ay2tmt = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_1b5ysjl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<NSFastEnumerationState>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<NSFastEnumerationState>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        int,
      )
    >();
final _objc_msgSend_1bbja28 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<CFRunLoop> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<CFRunLoop> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1bvics1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<
            ffi.NativeFunction<
              ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Void>,
              )
            >
          >,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<
          ffi.NativeFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >,
        ffi.Pointer<ffi.Void>,
      )
    >();
final _objc_msgSend_1ceswyu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Bool>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Bool>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_1co9mn4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedShort,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<NSZone>,
      )
    >();
final _objc_msgSend_1d8s65w = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        NSRange Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          NSRange,
        )
      >
    >()
    .asFunction<
      NSRange Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        NSRange,
      )
    >();
final _objc_msgSend_1d8s65wStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<NSRange>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          NSRange,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<NSRange>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        NSRange,
      )
    >();
final _objc_msgSend_1d9e4oe = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1deg8x = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedShort Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_1dom33q = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_1dydpdi = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        int,
      )
    >();
final _objc_msgSend_1e3pm0z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
      )
    >();
final _objc_msgSend_1efxbd8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_1egc1c = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
          ffi.UnsignedLong,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        int,
        int,
      )
    >();
final _objc_msgSend_1ffoev1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<
            ffi.NativeFunction<
              ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Void>,
              )
            >
          >,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<
          ffi.NativeFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >,
        ffi.Pointer<ffi.Void>,
      )
    >();
final _objc_msgSend_1flkydz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Void>,
      )
    >();
final _objc_msgSend_1frfu5e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_1fuqfwb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1ged0jd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        bool,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_1gypgok = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_1h2q612 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<ffi.UnsignedLong> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<ffi.UnsignedLong> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_1i0cxyc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int64,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_1i2r70j = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<
            ffi.NativeFunction<
              ffi.Long Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Void>,
              )
            >
          >,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<
          ffi.NativeFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_1i9r4xy = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_1i9v144 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_1iyq28l = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        bool,
      )
    >();
final _objc_msgSend_1j9bhml = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_1jiinfj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<ffi.Void>,
      )
    >();
final _objc_msgSend_1jtxufi = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_1jwityx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Short Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_1k0ezzm = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_1k101e3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.LongLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_1k1o1s7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
      )
    >();
final _objc_msgSend_1k4kd9s = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_1k745tv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_1ko4qka = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedChar Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_1lbgrac = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
        int,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_1lhpu4m = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_1lsax7n = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_1lv8yz3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Char>,
          ffi.UnsignedLong,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Char>,
        int,
        int,
      )
    >();
final _objc_msgSend_1m7prh1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Int64,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_1n40f6p = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Char>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Char>,
        bool,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_1njucl2 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedShort,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_1nmlvqc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        NSRange Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          NSRange,
        )
      >
    >()
    .asFunction<
      NSRange Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        NSRange,
      )
    >();
final _objc_msgSend_1nmlvqcStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<NSRange>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          NSRange,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<NSRange>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        NSRange,
      )
    >();
final _objc_msgSend_1nomli1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_1oteutl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          NSRange,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        NSRange,
      )
    >();
final _objc_msgSend_1ovaulg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCSelector> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCSelector> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1ozwf6k = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_1p4gbjy = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLongLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_1pa9f4m = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1pl40xc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_1pl4k3n = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
      )
    >();
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1pnyuds = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_1q30cs4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_1qv0eq4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_1r6ymhb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_1s0rfm3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Double,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        double,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_1s2gdyk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Char>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Char>,
      )
    >();
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_1srf6wk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1t6aok9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();
final _objc_msgSend_1tfztp = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_1tiux5i = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_1tv4uax = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_1ukqyt8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1ukqyt8Fpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1vd1c5m = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_1vnlaqg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_1vxoo9h = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_1wdb8ji = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_1wt9a7r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_1x2hskc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLongLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_1x5ew3h = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_1xi08ar = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_1xpk2hb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Uint32,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_1ya1kjn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int64,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_1ym6zyw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_2cgrxl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_2cgrxlFpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_2u4jm6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          NSRange,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        NSRange,
      )
    >();
final _objc_msgSend_3cbdpb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_3ctkt6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_3fn4ca = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_3l8zum = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_3nbx5e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
        int,
      )
    >();
final _objc_msgSend_3pyzne = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedInt Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_553v = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int64,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Int64,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_56zxyn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Char>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Char>,
      )
    >();
final _objc_msgSend_68x6r1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Short,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_6ex6p5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_6jmuyz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_6peh6o = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_6z4k82 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_7g3u2y = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_7kpg7m = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_7uautw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedChar,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_8321cp = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_898fog = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.UnsignedShort>,
          NSRange,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.UnsignedShort>,
        NSRange,
      )
    >();
final _objc_msgSend_89xgla = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.UnsignedLong>,
          ffi.UnsignedLong,
          ffi.Pointer<NSRange>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.UnsignedLong>,
        int,
        ffi.Pointer<NSRange>,
      )
    >();
final _objc_msgSend_8cymbm = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Char>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Char>,
        int,
      )
    >();
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_9a64f1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_9b3h4v = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
        int,
        int,
      )
    >();
final _objc_msgSend_9x4k8x = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.UnsignedShort>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.UnsignedShort>,
        int,
      )
    >();
final _objc_msgSend_a3wp08 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_arew0j = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_bfp043 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        int,
      )
    >();
final _objc_msgSend_bstjp9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_c0vg4w = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
        ffi.Pointer<ffi.Void>,
        int,
      )
    >();
final _objc_msgSend_cfx8ce = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_cnxxyq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_d3i1uy = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        NSRange Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      NSRange Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_d3i1uyStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<NSRange>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<NSRange>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_dbvvll = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Int64,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_degb40 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedInt,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_diypgk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_djsa9o = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_dv3z6r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        bool,
        int,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_e3qsqz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCProtocol>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCProtocol>,
      )
    >();
final _objc_msgSend_e9mncn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Char>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Char>,
      )
    >();
final _objc_msgSend_eh32gn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
        ffi.Pointer<ffi.Void>,
      )
    >();
final _objc_msgSend_erqryg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Char>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Char>,
        int,
      )
    >();
final _objc_msgSend_et8cuh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Float,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
      )
    >();
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_gcjqkl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        int,
      )
    >();
final _objc_msgSend_gerswc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Uint8,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_gg0462 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        NSRange Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          NSRange,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      NSRange Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        NSRange,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_gg0462Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<NSRange>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          NSRange,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<NSRange>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        NSRange,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_gupwtj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_gx50so = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_h0o9ch = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_hc8exi = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_hiwitm = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        bool,
      )
    >();
final _objc_msgSend_hk6irj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>,
      )
    >();
final _objc_msgSend_hwm8nu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
      )
    >();
final _objc_msgSend_i30zh3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.UnsignedLong>,
          ffi.UnsignedLong,
          ffi.UnsignedLong,
          NSRange,
          ffi.Pointer<NSRange>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
        int,
        ffi.Pointer<ffi.UnsignedLong>,
        int,
        int,
        NSRange,
        ffi.Pointer<NSRange>,
      )
    >();
final _objc_msgSend_jjgvjt = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_jsclrq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedInt,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_k1x6mt = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_k4j8m3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
          ffi.UnsignedLong,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
        int,
        int,
        bool,
      )
    >();
final _objc_msgSend_kshx9d = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          NSRange,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        NSRange,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_l9p60w = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();
final _objc_msgSend_lh0jh5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.UnsignedShort>,
          ffi.UnsignedLong,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.UnsignedShort>,
        int,
        bool,
      )
    >();
final _objc_msgSend_mabicu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_mabicuFpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_mt0t38 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_n2svg2 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        int,
      )
    >();
final _objc_msgSend_nc6uds = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Void>,
        int,
      )
    >();
final _objc_msgSend_nnxkei = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_o16d3k = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          NSRange,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        NSRange,
      )
    >();
final _objc_msgSend_o762yo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_oa8mke = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
      )
    >();
final _objc_msgSend_ot6jdx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        bool,
      )
    >();
final _objc_msgSend_otx1t4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        int,
      )
    >();
final _objc_msgSend_ourvf2 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.UnsignedLong>,
          ffi.Pointer<ffi.UnsignedLong>,
          ffi.Pointer<ffi.UnsignedLong>,
          NSRange,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.UnsignedLong>,
        ffi.Pointer<ffi.UnsignedLong>,
        ffi.Pointer<ffi.UnsignedLong>,
        NSRange,
      )
    >();
final _objc_msgSend_ovsamd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
      )
    >();
final _objc_msgSend_p4nurx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
      )
    >();
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_pg1fnv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_pysgoz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Int64 Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_qm9f5w = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
      )
    >();
final _objc_msgSend_qugqlf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_r0bo0s = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_r49ehc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCObject>,
        bool,
      )
    >();
final _objc_msgSend_rc4ypv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_s058d2 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
final _objc_msgSend_s92gih = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_sz90oi = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<NSZone> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<NSZone> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_t7arir = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
          ffi.Long,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_talwei = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.UnsignedShort>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.UnsignedShort>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_ud8gg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedShort Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_uimyc7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        NSRange Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
        )
      >
    >()
    .asFunction<
      NSRange Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
      )
    >();
final _objc_msgSend_uimyc7Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<NSRange>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          NSRange,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<NSRange>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        NSRange,
      )
    >();
final _objc_msgSend_unr2j3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
        int,
      )
    >();
final _objc_msgSend_usggvf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Uint32 Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_uwvaik = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_vbymrb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        int,
      )
    >();
final _objc_msgSend_w9bq5x = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          NSRange,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        NSRange,
        bool,
      )
    >();
final _objc_msgSend_xmlz1t = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Char Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_xpqfd7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
          NSRange,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
        NSRange,
      )
    >();
final _objc_msgSend_xrqic1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          NSRange,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        NSRange,
      )
    >();
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
final _objc_msgSend_yx8yc6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_zmbtbd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        int,
      )
    >();
final _objc_msgSend_zuf90e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
        int,
      )
    >();
final _objc_msgSend_zug4wi = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          NSRange,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        NSRange,
      )
    >();
late final _protocol_NSCoding = objc.getProtocol("NSCoding");
late final _protocol_NSCopying = objc.getProtocol("NSCopying");
late final _protocol_NSFastEnumeration = objc.getProtocol("NSFastEnumeration");
late final _protocol_NSItemProviderReading = objc.getProtocol(
  "NSItemProviderReading",
);
late final _protocol_NSItemProviderWriting = objc.getProtocol(
  "NSItemProviderWriting",
);
late final _protocol_NSMutableCopying = objc.getProtocol("NSMutableCopying");
late final _protocol_NSObject = objc.getProtocol("NSObject");
late final _protocol_NSPortDelegate = objc.getProtocol("NSPortDelegate");
late final _protocol_NSSecureCoding = objc.getProtocol("NSSecureCoding");
late final _protocol_NSStreamDelegate = objc.getProtocol("NSStreamDelegate");
late final _protocol_Observer = objc.getProtocol("Observer");
late final _sel_URLByResolvingAliasFileAtURL_options_error_ = objc.registerName(
  "URLByResolvingAliasFileAtURL:options:error:",
);
late final _sel_URLByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_ =
    objc.registerName(
      "URLByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:",
    );
late final _sel_URLForAuxiliaryExecutable_ = objc.registerName(
  "URLForAuxiliaryExecutable:",
);
late final _sel_URLForResource_withExtension_ = objc.registerName(
  "URLForResource:withExtension:",
);
late final _sel_URLForResource_withExtension_subdirectory_ = objc.registerName(
  "URLForResource:withExtension:subdirectory:",
);
late final _sel_URLForResource_withExtension_subdirectory_inBundleWithURL_ =
    objc.registerName(
      "URLForResource:withExtension:subdirectory:inBundleWithURL:",
    );
late final _sel_URLForResource_withExtension_subdirectory_localization_ = objc
    .registerName("URLForResource:withExtension:subdirectory:localization:");
late final _sel_URLWithDataRepresentation_relativeToURL_ = objc.registerName(
  "URLWithDataRepresentation:relativeToURL:",
);
late final _sel_URLWithString_ = objc.registerName("URLWithString:");
late final _sel_URLWithString_encodingInvalidCharacters_ = objc.registerName(
  "URLWithString:encodingInvalidCharacters:",
);
late final _sel_URLWithString_relativeToURL_ = objc.registerName(
  "URLWithString:relativeToURL:",
);
late final _sel_URLsForResourcesWithExtension_subdirectory_ = objc.registerName(
  "URLsForResourcesWithExtension:subdirectory:",
);
late final _sel_URLsForResourcesWithExtension_subdirectory_inBundleWithURL_ =
    objc.registerName(
      "URLsForResourcesWithExtension:subdirectory:inBundleWithURL:",
    );
late final _sel_URLsForResourcesWithExtension_subdirectory_localization_ = objc
    .registerName("URLsForResourcesWithExtension:subdirectory:localization:");
late final _sel_UTF8String = objc.registerName("UTF8String");
late final _sel_absoluteString = objc.registerName("absoluteString");
late final _sel_absoluteURL = objc.registerName("absoluteURL");
late final _sel_absoluteURLWithDataRepresentation_relativeToURL_ = objc
    .registerName("absoluteURLWithDataRepresentation:relativeToURL:");
late final _sel_acceptInputForMode_beforeDate_ = objc.registerName(
  "acceptInputForMode:beforeDate:",
);
late final _sel_adapter = objc.registerName("adapter");
late final _sel_addChild_withPendingUnitCount_ = objc.registerName(
  "addChild:withPendingUnitCount:",
);
late final _sel_addData_ = objc.registerName("addData:");
late final _sel_addEntriesFromDictionary_ = objc.registerName(
  "addEntriesFromDictionary:",
);
late final _sel_addIndex_ = objc.registerName("addIndex:");
late final _sel_addIndexesInRange_ = objc.registerName("addIndexesInRange:");
late final _sel_addIndexes_ = objc.registerName("addIndexes:");
late final _sel_addObject_ = objc.registerName("addObject:");
late final _sel_addObjectsFromArray_ = objc.registerName(
  "addObjectsFromArray:",
);
late final _sel_addObjects_count_ = objc.registerName("addObjects:count:");
late final _sel_addPort_forMode_ = objc.registerName("addPort:forMode:");
late final _sel_addProtocol_ = objc.registerName("addProtocol:");
late final _sel_addSubscriberForFileURL_withPublishingHandler_ = objc
    .registerName("addSubscriberForFileURL:withPublishingHandler:");
late final _sel_addTimer_forMode_ = objc.registerName("addTimer:forMode:");
late final _sel_allBundles = objc.registerName("allBundles");
late final _sel_allFrameworks = objc.registerName("allFrameworks");
late final _sel_allKeys = objc.registerName("allKeys");
late final _sel_allKeysForObject_ = objc.registerName("allKeysForObject:");
late final _sel_allObjects = objc.registerName("allObjects");
late final _sel_allValues = objc.registerName("allValues");
late final _sel_alloc = objc.registerName("alloc");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
late final _sel_allowsExtendedAttributes = objc.registerName(
  "allowsExtendedAttributes",
);
late final _sel_alphanumericCharacterSet = objc.registerName(
  "alphanumericCharacterSet",
);
late final _sel_anyObject = objc.registerName("anyObject");
late final _sel_appStoreReceiptURL = objc.registerName("appStoreReceiptURL");
late final _sel_appendBytes_length_ = objc.registerName("appendBytes:length:");
late final _sel_appendData_ = objc.registerName("appendData:");
late final _sel_appliesSourcePositionAttributes = objc.registerName(
  "appliesSourcePositionAttributes",
);
late final _sel_argumentsRetained = objc.registerName("argumentsRetained");
late final _sel_array = objc.registerName("array");
late final _sel_arrayByAddingObject_ = objc.registerName(
  "arrayByAddingObject:",
);
late final _sel_arrayByAddingObjectsFromArray_ = objc.registerName(
  "arrayByAddingObjectsFromArray:",
);
late final _sel_arrayWithArray_ = objc.registerName("arrayWithArray:");
late final _sel_arrayWithCapacity_ = objc.registerName("arrayWithCapacity:");
late final _sel_arrayWithObject_ = objc.registerName("arrayWithObject:");
late final _sel_arrayWithObjects_ = objc.registerName("arrayWithObjects:");
late final _sel_arrayWithObjects_count_ = objc.registerName(
  "arrayWithObjects:count:",
);
late final _sel_associatedIndex = objc.registerName("associatedIndex");
late final _sel_attributesAtIndex_effectiveRange_ = objc.registerName(
  "attributesAtIndex:effectiveRange:",
);
late final _sel_autorelease = objc.registerName("autorelease");
late final _sel_availableStringEncodings = objc.registerName(
  "availableStringEncodings",
);
late final _sel_baseURL = objc.registerName("baseURL");
late final _sel_becomeCurrentWithPendingUnitCount_ = objc.registerName(
  "becomeCurrentWithPendingUnitCount:",
);
late final _sel_bitmapRepresentation = objc.registerName(
  "bitmapRepresentation",
);
late final _sel_bookmarkDataWithContentsOfURL_error_ = objc.registerName(
  "bookmarkDataWithContentsOfURL:error:",
);
late final _sel_bookmarkDataWithOptions_includingResourceValuesForKeys_relativeToURL_error_ =
    objc.registerName(
      "bookmarkDataWithOptions:includingResourceValuesForKeys:relativeToURL:error:",
    );
late final _sel_boolValue = objc.registerName("boolValue");
late final _sel_buildInstance_ = objc.registerName("buildInstance:");
late final _sel_builtInPlugInsPath = objc.registerName("builtInPlugInsPath");
late final _sel_builtInPlugInsURL = objc.registerName("builtInPlugInsURL");
late final _sel_bundleForClass_ = objc.registerName("bundleForClass:");
late final _sel_bundleIdentifier = objc.registerName("bundleIdentifier");
late final _sel_bundlePath = objc.registerName("bundlePath");
late final _sel_bundleURL = objc.registerName("bundleURL");
late final _sel_bundleWithIdentifier_ = objc.registerName(
  "bundleWithIdentifier:",
);
late final _sel_bundleWithPath_ = objc.registerName("bundleWithPath:");
late final _sel_bundleWithURL_ = objc.registerName("bundleWithURL:");
late final _sel_bytes = objc.registerName("bytes");
late final _sel_cStringUsingEncoding_ = objc.registerName(
  "cStringUsingEncoding:",
);
late final _sel_canBeConvertedToEncoding_ = objc.registerName(
  "canBeConvertedToEncoding:",
);
late final _sel_canLoadObjectOfClass_ = objc.registerName(
  "canLoadObjectOfClass:",
);
late final _sel_cancel = objc.registerName("cancel");
late final _sel_cancellationHandler = objc.registerName("cancellationHandler");
late final _sel_capitalizedLetterCharacterSet = objc.registerName(
  "capitalizedLetterCharacterSet",
);
late final _sel_capitalizedString = objc.registerName("capitalizedString");
late final _sel_capitalizedStringWithLocale_ = objc.registerName(
  "capitalizedStringWithLocale:",
);
late final _sel_caseInsensitiveCompare_ = objc.registerName(
  "caseInsensitiveCompare:",
);
late final _sel_changeType = objc.registerName("changeType");
late final _sel_changeWithObject_type_index_ = objc.registerName(
  "changeWithObject:type:index:",
);
late final _sel_changeWithObject_type_index_associatedIndex_ = objc
    .registerName("changeWithObject:type:index:associatedIndex:");
late final _sel_charValue = objc.registerName("charValue");
late final _sel_characterAtIndex_ = objc.registerName("characterAtIndex:");
late final _sel_characterIsMember_ = objc.registerName("characterIsMember:");
late final _sel_characterSetWithBitmapRepresentation_ = objc.registerName(
  "characterSetWithBitmapRepresentation:",
);
late final _sel_characterSetWithCharactersInString_ = objc.registerName(
  "characterSetWithCharactersInString:",
);
late final _sel_characterSetWithContentsOfFile_ = objc.registerName(
  "characterSetWithContentsOfFile:",
);
late final _sel_characterSetWithRange_ = objc.registerName(
  "characterSetWithRange:",
);
late final _sel_class = objc.registerName("class");
late final _sel_classNamed_ = objc.registerName("classNamed:");
late final _sel_close = objc.registerName("close");
late final _sel_code = objc.registerName("code");
late final _sel_commonPrefixWithString_options_ = objc.registerName(
  "commonPrefixWithString:options:",
);
late final _sel_compare_ = objc.registerName("compare:");
late final _sel_compare_options_ = objc.registerName("compare:options:");
late final _sel_compare_options_range_ = objc.registerName(
  "compare:options:range:",
);
late final _sel_compare_options_range_locale_ = objc.registerName(
  "compare:options:range:locale:",
);
late final _sel_completedUnitCount = objc.registerName("completedUnitCount");
late final _sel_components = objc.registerName("components");
late final _sel_componentsJoinedByString_ = objc.registerName(
  "componentsJoinedByString:",
);
late final _sel_componentsSeparatedByCharactersInSet_ = objc.registerName(
  "componentsSeparatedByCharactersInSet:",
);
late final _sel_componentsSeparatedByString_ = objc.registerName(
  "componentsSeparatedByString:",
);
late final _sel_compressedDataUsingAlgorithm_error_ = objc.registerName(
  "compressedDataUsingAlgorithm:error:",
);
late final _sel_conformsToProtocol_ = objc.registerName("conformsToProtocol:");
late final _sel_containsIndex_ = objc.registerName("containsIndex:");
late final _sel_containsIndexesInRange_ = objc.registerName(
  "containsIndexesInRange:",
);
late final _sel_containsIndexes_ = objc.registerName("containsIndexes:");
late final _sel_containsObject_ = objc.registerName("containsObject:");
late final _sel_containsString_ = objc.registerName("containsString:");
late final _sel_controlCharacterSet = objc.registerName("controlCharacterSet");
late final _sel_copy = objc.registerName("copy");
late final _sel_copyWithZone_ = objc.registerName("copyWithZone:");
late final _sel_count = objc.registerName("count");
late final _sel_countByEnumeratingWithState_objects_count_ = objc.registerName(
  "countByEnumeratingWithState:objects:count:",
);
late final _sel_countOfIndexesInRange_ = objc.registerName(
  "countOfIndexesInRange:",
);
late final _sel_currentMode = objc.registerName("currentMode");
late final _sel_currentProgress = objc.registerName("currentProgress");
late final _sel_currentRunLoop = objc.registerName("currentRunLoop");
late final _sel_data = objc.registerName("data");
late final _sel_dataRepresentation = objc.registerName("dataRepresentation");
late final _sel_dataUsingEncoding_ = objc.registerName("dataUsingEncoding:");
late final _sel_dataUsingEncoding_allowLossyConversion_ = objc.registerName(
  "dataUsingEncoding:allowLossyConversion:",
);
late final _sel_dataWithBytesNoCopy_length_ = objc.registerName(
  "dataWithBytesNoCopy:length:",
);
late final _sel_dataWithBytesNoCopy_length_freeWhenDone_ = objc.registerName(
  "dataWithBytesNoCopy:length:freeWhenDone:",
);
late final _sel_dataWithBytes_length_ = objc.registerName(
  "dataWithBytes:length:",
);
late final _sel_dataWithCapacity_ = objc.registerName("dataWithCapacity:");
late final _sel_dataWithContentsOfFile_ = objc.registerName(
  "dataWithContentsOfFile:",
);
late final _sel_dataWithContentsOfFile_options_error_ = objc.registerName(
  "dataWithContentsOfFile:options:error:",
);
late final _sel_dataWithContentsOfURL_ = objc.registerName(
  "dataWithContentsOfURL:",
);
late final _sel_dataWithContentsOfURL_options_error_ = objc.registerName(
  "dataWithContentsOfURL:options:error:",
);
late final _sel_dataWithData_ = objc.registerName("dataWithData:");
late final _sel_dataWithLength_ = objc.registerName("dataWithLength:");
late final _sel_date = objc.registerName("date");
late final _sel_dateByAddingTimeInterval_ = objc.registerName(
  "dateByAddingTimeInterval:",
);
late final _sel_dateWithTimeIntervalSince1970_ = objc.registerName(
  "dateWithTimeIntervalSince1970:",
);
late final _sel_dateWithTimeIntervalSinceNow_ = objc.registerName(
  "dateWithTimeIntervalSinceNow:",
);
late final _sel_dateWithTimeIntervalSinceReferenceDate_ = objc.registerName(
  "dateWithTimeIntervalSinceReferenceDate:",
);
late final _sel_dateWithTimeInterval_sinceDate_ = objc.registerName(
  "dateWithTimeInterval:sinceDate:",
);
late final _sel_dealloc = objc.registerName("dealloc");
late final _sel_debugDescription = objc.registerName("debugDescription");
late final _sel_debugObserver = objc.registerName("debugObserver");
late final _sel_decimalDigitCharacterSet = objc.registerName(
  "decimalDigitCharacterSet",
);
late final _sel_decodeDataObject = objc.registerName("decodeDataObject");
late final _sel_decodeValueOfObjCType_at_size_ = objc.registerName(
  "decodeValueOfObjCType:at:size:",
);
late final _sel_decomposableCharacterSet = objc.registerName(
  "decomposableCharacterSet",
);
late final _sel_decomposedStringWithCanonicalMapping = objc.registerName(
  "decomposedStringWithCanonicalMapping",
);
late final _sel_decomposedStringWithCompatibilityMapping = objc.registerName(
  "decomposedStringWithCompatibilityMapping",
);
late final _sel_decompressedDataUsingAlgorithm_error_ = objc.registerName(
  "decompressedDataUsingAlgorithm:error:",
);
late final _sel_defaultCStringEncoding = objc.registerName(
  "defaultCStringEncoding",
);
late final _sel_delegate = objc.registerName("delegate");
late final _sel_description = objc.registerName("description");
late final _sel_descriptionInStringsFileFormat = objc.registerName(
  "descriptionInStringsFileFormat",
);
late final _sel_descriptionWithLocale_ = objc.registerName(
  "descriptionWithLocale:",
);
late final _sel_descriptionWithLocale_indent_ = objc.registerName(
  "descriptionWithLocale:indent:",
);
late final _sel_developmentLocalization = objc.registerName(
  "developmentLocalization",
);
late final _sel_dictionary = objc.registerName("dictionary");
late final _sel_dictionaryWithCapacity_ = objc.registerName(
  "dictionaryWithCapacity:",
);
late final _sel_dictionaryWithDictionary_ = objc.registerName(
  "dictionaryWithDictionary:",
);
late final _sel_dictionaryWithObject_forKey_ = objc.registerName(
  "dictionaryWithObject:forKey:",
);
late final _sel_dictionaryWithObjectsAndKeys_ = objc.registerName(
  "dictionaryWithObjectsAndKeys:",
);
late final _sel_dictionaryWithObjects_forKeys_ = objc.registerName(
  "dictionaryWithObjects:forKeys:",
);
late final _sel_dictionaryWithObjects_forKeys_count_ = objc.registerName(
  "dictionaryWithObjects:forKeys:count:",
);
late final _sel_differenceByTransformingChangesWithBlock_ = objc.registerName(
  "differenceByTransformingChangesWithBlock:",
);
late final _sel_discreteProgressWithTotalUnitCount_ = objc.registerName(
  "discreteProgressWithTotalUnitCount:",
);
late final _sel_displayNameForKey_value_ = objc.registerName(
  "displayNameForKey:value:",
);
late final _sel_doesNotRecognizeSelector_ = objc.registerName(
  "doesNotRecognizeSelector:",
);
late final _sel_domain = objc.registerName("domain");
late final _sel_doubleValue = objc.registerName("doubleValue");
late final _sel_earlierDate_ = objc.registerName("earlierDate:");
late final _sel_encodeDataObject_ = objc.registerName("encodeDataObject:");
late final _sel_encodeValueOfObjCType_at_ = objc.registerName(
  "encodeValueOfObjCType:at:",
);
late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");
late final _sel_enumerateByteRangesUsingBlock_ = objc.registerName(
  "enumerateByteRangesUsingBlock:",
);
late final _sel_enumerateIndexesInRange_options_usingBlock_ = objc.registerName(
  "enumerateIndexesInRange:options:usingBlock:",
);
late final _sel_enumerateIndexesUsingBlock_ = objc.registerName(
  "enumerateIndexesUsingBlock:",
);
late final _sel_enumerateIndexesWithOptions_usingBlock_ = objc.registerName(
  "enumerateIndexesWithOptions:usingBlock:",
);
late final _sel_enumerateKeysAndObjectsUsingBlock_ = objc.registerName(
  "enumerateKeysAndObjectsUsingBlock:",
);
late final _sel_enumerateKeysAndObjectsWithOptions_usingBlock_ = objc
    .registerName("enumerateKeysAndObjectsWithOptions:usingBlock:");
late final _sel_enumerateLinesUsingBlock_ = objc.registerName(
  "enumerateLinesUsingBlock:",
);
late final _sel_enumerateObjectsAtIndexes_options_usingBlock_ = objc
    .registerName("enumerateObjectsAtIndexes:options:usingBlock:");
late final _sel_enumerateObjectsUsingBlock_ = objc.registerName(
  "enumerateObjectsUsingBlock:",
);
late final _sel_enumerateObjectsWithOptions_usingBlock_ = objc.registerName(
  "enumerateObjectsWithOptions:usingBlock:",
);
late final _sel_enumerateRangesInRange_options_usingBlock_ = objc.registerName(
  "enumerateRangesInRange:options:usingBlock:",
);
late final _sel_enumerateRangesUsingBlock_ = objc.registerName(
  "enumerateRangesUsingBlock:",
);
late final _sel_enumerateRangesWithOptions_usingBlock_ = objc.registerName(
  "enumerateRangesWithOptions:usingBlock:",
);
late final _sel_enumerateSubstringsInRange_options_usingBlock_ = objc
    .registerName("enumerateSubstringsInRange:options:usingBlock:");
late final _sel_errorWithDomain_code_userInfo_ = objc.registerName(
  "errorWithDomain:code:userInfo:",
);
late final _sel_estimatedTimeRemaining = objc.registerName(
  "estimatedTimeRemaining",
);
late final _sel_exchangeObjectAtIndex_withObjectAtIndex_ = objc.registerName(
  "exchangeObjectAtIndex:withObjectAtIndex:",
);
late final _sel_executableArchitectures = objc.registerName(
  "executableArchitectures",
);
late final _sel_executablePath = objc.registerName("executablePath");
late final _sel_executableURL = objc.registerName("executableURL");
late final _sel_failurePolicy = objc.registerName("failurePolicy");
late final _sel_fastestEncoding = objc.registerName("fastestEncoding");
late final _sel_fileCompletedCount = objc.registerName("fileCompletedCount");
late final _sel_fileOperationKind = objc.registerName("fileOperationKind");
late final _sel_filePathURL = objc.registerName("filePathURL");
late final _sel_fileReferenceURL = objc.registerName("fileReferenceURL");
late final _sel_fileSystemRepresentation = objc.registerName(
  "fileSystemRepresentation",
);
late final _sel_fileTotalCount = objc.registerName("fileTotalCount");
late final _sel_fileURL = objc.registerName("fileURL");
late final _sel_fileURLWithFileSystemRepresentation_isDirectory_relativeToURL_ =
    objc.registerName(
      "fileURLWithFileSystemRepresentation:isDirectory:relativeToURL:",
    );
late final _sel_fileURLWithPath_ = objc.registerName("fileURLWithPath:");
late final _sel_fileURLWithPath_isDirectory_ = objc.registerName(
  "fileURLWithPath:isDirectory:",
);
late final _sel_fileURLWithPath_isDirectory_relativeToURL_ = objc.registerName(
  "fileURLWithPath:isDirectory:relativeToURL:",
);
late final _sel_fileURLWithPath_relativeToURL_ = objc.registerName(
  "fileURLWithPath:relativeToURL:",
);
late final _sel_fire = objc.registerName("fire");
late final _sel_fireDate = objc.registerName("fireDate");
late final _sel_firstIndex = objc.registerName("firstIndex");
late final _sel_firstObject = objc.registerName("firstObject");
late final _sel_firstObjectCommonWithArray_ = objc.registerName(
  "firstObjectCommonWithArray:",
);
late final _sel_floatValue = objc.registerName("floatValue");
late final _sel_forwardInvocation_ = objc.registerName("forwardInvocation:");
late final _sel_forwardingTargetForSelector_ = objc.registerName(
  "forwardingTargetForSelector:",
);
late final _sel_fractionCompleted = objc.registerName("fractionCompleted");
late final _sel_fragment = objc.registerName("fragment");
late final _sel_frameLength = objc.registerName("frameLength");
late final _sel_getArgumentTypeAtIndex_ = objc.registerName(
  "getArgumentTypeAtIndex:",
);
late final _sel_getArgument_atIndex_ = objc.registerName(
  "getArgument:atIndex:",
);
late final _sel_getBuffer_length_ = objc.registerName("getBuffer:length:");
late final _sel_getBytes_length_ = objc.registerName("getBytes:length:");
late final _sel_getBytes_maxLength_usedLength_encoding_options_range_remainingRange_ =
    objc.registerName(
      "getBytes:maxLength:usedLength:encoding:options:range:remainingRange:",
    );
late final _sel_getBytes_range_ = objc.registerName("getBytes:range:");
late final _sel_getCFRunLoop = objc.registerName("getCFRunLoop");
late final _sel_getCString_maxLength_encoding_ = objc.registerName(
  "getCString:maxLength:encoding:",
);
late final _sel_getCharacters_range_ = objc.registerName(
  "getCharacters:range:",
);
late final _sel_getDOBJCDartProtocolMethodForSelector_ = objc.registerName(
  "getDOBJCDartProtocolMethodForSelector:",
);
late final _sel_getFileSystemRepresentation_maxLength_ = objc.registerName(
  "getFileSystemRepresentation:maxLength:",
);
late final _sel_getIndexes_maxCount_inIndexRange_ = objc.registerName(
  "getIndexes:maxCount:inIndexRange:",
);
late final _sel_getLineStart_end_contentsEnd_forRange_ = objc.registerName(
  "getLineStart:end:contentsEnd:forRange:",
);
late final _sel_getObjects_andKeys_count_ = objc.registerName(
  "getObjects:andKeys:count:",
);
late final _sel_getObjects_range_ = objc.registerName("getObjects:range:");
late final _sel_getParagraphStart_end_contentsEnd_forRange_ = objc.registerName(
  "getParagraphStart:end:contentsEnd:forRange:",
);
late final _sel_getResourceValue_forKey_error_ = objc.registerName(
  "getResourceValue:forKey:error:",
);
late final _sel_getReturnValue_ = objc.registerName("getReturnValue:");
late final _sel_getValue_size_ = objc.registerName("getValue:size:");
late final _sel_handlePortMessage_ = objc.registerName("handlePortMessage:");
late final _sel_hasBytesAvailable = objc.registerName("hasBytesAvailable");
late final _sel_hasChanges = objc.registerName("hasChanges");
late final _sel_hasDirectoryPath = objc.registerName("hasDirectoryPath");
late final _sel_hasItemConformingToTypeIdentifier_ = objc.registerName(
  "hasItemConformingToTypeIdentifier:",
);
late final _sel_hasMemberInPlane_ = objc.registerName("hasMemberInPlane:");
late final _sel_hasPrefix_ = objc.registerName("hasPrefix:");
late final _sel_hasRepresentationConformingToTypeIdentifier_fileOptions_ = objc
    .registerName("hasRepresentationConformingToTypeIdentifier:fileOptions:");
late final _sel_hasSpaceAvailable = objc.registerName("hasSpaceAvailable");
late final _sel_hasSuffix_ = objc.registerName("hasSuffix:");
late final _sel_hash = objc.registerName("hash");
late final _sel_helpAnchor = objc.registerName("helpAnchor");
late final _sel_holderWithInputStreamAdapter_ = objc.registerName(
  "holderWithInputStreamAdapter:",
);
late final _sel_host = objc.registerName("host");
late final _sel_illegalCharacterSet = objc.registerName("illegalCharacterSet");
late final _sel_implementMethod_withBlock_withTrampoline_withSignature_ = objc
    .registerName("implementMethod:withBlock:withTrampoline:withSignature:");
late final _sel_increaseLengthBy_ = objc.registerName("increaseLengthBy:");
late final _sel_index = objc.registerName("index");
late final _sel_indexGreaterThanIndex_ = objc.registerName(
  "indexGreaterThanIndex:",
);
late final _sel_indexGreaterThanOrEqualToIndex_ = objc.registerName(
  "indexGreaterThanOrEqualToIndex:",
);
late final _sel_indexInRange_options_passingTest_ = objc.registerName(
  "indexInRange:options:passingTest:",
);
late final _sel_indexLessThanIndex_ = objc.registerName("indexLessThanIndex:");
late final _sel_indexLessThanOrEqualToIndex_ = objc.registerName(
  "indexLessThanOrEqualToIndex:",
);
late final _sel_indexOfObjectAtIndexes_options_passingTest_ = objc.registerName(
  "indexOfObjectAtIndexes:options:passingTest:",
);
late final _sel_indexOfObjectIdenticalTo_ = objc.registerName(
  "indexOfObjectIdenticalTo:",
);
late final _sel_indexOfObjectIdenticalTo_inRange_ = objc.registerName(
  "indexOfObjectIdenticalTo:inRange:",
);
late final _sel_indexOfObjectPassingTest_ = objc.registerName(
  "indexOfObjectPassingTest:",
);
late final _sel_indexOfObjectWithOptions_passingTest_ = objc.registerName(
  "indexOfObjectWithOptions:passingTest:",
);
late final _sel_indexOfObject_ = objc.registerName("indexOfObject:");
late final _sel_indexOfObject_inRange_ = objc.registerName(
  "indexOfObject:inRange:",
);
late final _sel_indexOfObject_inSortedRange_options_usingComparator_ = objc
    .registerName("indexOfObject:inSortedRange:options:usingComparator:");
late final _sel_indexPassingTest_ = objc.registerName("indexPassingTest:");
late final _sel_indexSet = objc.registerName("indexSet");
late final _sel_indexSetWithIndex_ = objc.registerName("indexSetWithIndex:");
late final _sel_indexSetWithIndexesInRange_ = objc.registerName(
  "indexSetWithIndexesInRange:",
);
late final _sel_indexWithOptions_passingTest_ = objc.registerName(
  "indexWithOptions:passingTest:",
);
late final _sel_indexesInRange_options_passingTest_ = objc.registerName(
  "indexesInRange:options:passingTest:",
);
late final _sel_indexesOfObjectsAtIndexes_options_passingTest_ = objc
    .registerName("indexesOfObjectsAtIndexes:options:passingTest:");
late final _sel_indexesOfObjectsPassingTest_ = objc.registerName(
  "indexesOfObjectsPassingTest:",
);
late final _sel_indexesOfObjectsWithOptions_passingTest_ = objc.registerName(
  "indexesOfObjectsWithOptions:passingTest:",
);
late final _sel_indexesPassingTest_ = objc.registerName("indexesPassingTest:");
late final _sel_indexesWithOptions_passingTest_ = objc.registerName(
  "indexesWithOptions:passingTest:",
);
late final _sel_infoDictionary = objc.registerName("infoDictionary");
late final _sel_init = objc.registerName("init");
late final _sel_initAbsoluteURLWithDataRepresentation_relativeToURL_ = objc
    .registerName("initAbsoluteURLWithDataRepresentation:relativeToURL:");
late final _sel_initByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_ =
    objc.registerName(
      "initByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:",
    );
late final _sel_initDOBJCDartProtocolFromDartProtocolBuilder_withDisposePort_ =
    objc.registerName(
      "initDOBJCDartProtocolFromDartProtocolBuilder:withDisposePort:",
    );
late final _sel_initFileURLWithFileSystemRepresentation_isDirectory_relativeToURL_ =
    objc.registerName(
      "initFileURLWithFileSystemRepresentation:isDirectory:relativeToURL:",
    );
late final _sel_initFileURLWithPath_ = objc.registerName(
  "initFileURLWithPath:",
);
late final _sel_initFileURLWithPath_isDirectory_ = objc.registerName(
  "initFileURLWithPath:isDirectory:",
);
late final _sel_initFileURLWithPath_isDirectory_relativeToURL_ = objc
    .registerName("initFileURLWithPath:isDirectory:relativeToURL:");
late final _sel_initFileURLWithPath_relativeToURL_ = objc.registerName(
  "initFileURLWithPath:relativeToURL:",
);
late final _sel_initForKeyPath_ofObject_withObserver_options_context_ = objc
    .registerName("initForKeyPath:ofObject:withObserver:options:context:");
late final _sel_initToBuffer_capacity_ = objc.registerName(
  "initToBuffer:capacity:",
);
late final _sel_initToFileAtPath_append_ = objc.registerName(
  "initToFileAtPath:append:",
);
late final _sel_initToMemory = objc.registerName("initToMemory");
late final _sel_initWithArray_ = objc.registerName("initWithArray:");
late final _sel_initWithArray_copyItems_ = objc.registerName(
  "initWithArray:copyItems:",
);
late final _sel_initWithArray_range_copyItems_ = objc.registerName(
  "initWithArray:range:copyItems:",
);
late final _sel_initWithAttributedString_ = objc.registerName(
  "initWithAttributedString:",
);
late final _sel_initWithBase64EncodedData_options_ = objc.registerName(
  "initWithBase64EncodedData:options:",
);
late final _sel_initWithBase64EncodedString_options_ = objc.registerName(
  "initWithBase64EncodedString:options:",
);
late final _sel_initWithBool_ = objc.registerName("initWithBool:");
late final _sel_initWithBytesNoCopy_length_ = objc.registerName(
  "initWithBytesNoCopy:length:",
);
late final _sel_initWithBytesNoCopy_length_deallocator_ = objc.registerName(
  "initWithBytesNoCopy:length:deallocator:",
);
late final _sel_initWithBytesNoCopy_length_encoding_deallocator_ = objc
    .registerName("initWithBytesNoCopy:length:encoding:deallocator:");
late final _sel_initWithBytesNoCopy_length_encoding_freeWhenDone_ = objc
    .registerName("initWithBytesNoCopy:length:encoding:freeWhenDone:");
late final _sel_initWithBytesNoCopy_length_freeWhenDone_ = objc.registerName(
  "initWithBytesNoCopy:length:freeWhenDone:",
);
late final _sel_initWithBytes_length_ = objc.registerName(
  "initWithBytes:length:",
);
late final _sel_initWithBytes_length_encoding_ = objc.registerName(
  "initWithBytes:length:encoding:",
);
late final _sel_initWithBytes_objCType_ = objc.registerName(
  "initWithBytes:objCType:",
);
late final _sel_initWithCString_encoding_ = objc.registerName(
  "initWithCString:encoding:",
);
late final _sel_initWithCapacity_ = objc.registerName("initWithCapacity:");
late final _sel_initWithChanges_ = objc.registerName("initWithChanges:");
late final _sel_initWithChar_ = objc.registerName("initWithChar:");
late final _sel_initWithCharactersNoCopy_length_deallocator_ = objc
    .registerName("initWithCharactersNoCopy:length:deallocator:");
late final _sel_initWithCharactersNoCopy_length_freeWhenDone_ = objc
    .registerName("initWithCharactersNoCopy:length:freeWhenDone:");
late final _sel_initWithCharacters_length_ = objc.registerName(
  "initWithCharacters:length:",
);
late final _sel_initWithClassName_ = objc.registerName("initWithClassName:");
late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");
late final _sel_initWithContentsOfFile_ = objc.registerName(
  "initWithContentsOfFile:",
);
late final _sel_initWithContentsOfFile_encoding_error_ = objc.registerName(
  "initWithContentsOfFile:encoding:error:",
);
late final _sel_initWithContentsOfFile_options_error_ = objc.registerName(
  "initWithContentsOfFile:options:error:",
);
late final _sel_initWithContentsOfFile_usedEncoding_error_ = objc.registerName(
  "initWithContentsOfFile:usedEncoding:error:",
);
late final _sel_initWithContentsOfMarkdownFileAtURL_options_baseURL_error_ =
    objc.registerName(
      "initWithContentsOfMarkdownFileAtURL:options:baseURL:error:",
    );
late final _sel_initWithContentsOfURL_ = objc.registerName(
  "initWithContentsOfURL:",
);
late final _sel_initWithContentsOfURL_encoding_error_ = objc.registerName(
  "initWithContentsOfURL:encoding:error:",
);
late final _sel_initWithContentsOfURL_options_error_ = objc.registerName(
  "initWithContentsOfURL:options:error:",
);
late final _sel_initWithContentsOfURL_usedEncoding_error_ = objc.registerName(
  "initWithContentsOfURL:usedEncoding:error:",
);
late final _sel_initWithDataRepresentation_relativeToURL_ = objc.registerName(
  "initWithDataRepresentation:relativeToURL:",
);
late final _sel_initWithData_ = objc.registerName("initWithData:");
late final _sel_initWithData_encoding_ = objc.registerName(
  "initWithData:encoding:",
);
late final _sel_initWithDictionary_ = objc.registerName("initWithDictionary:");
late final _sel_initWithDictionary_copyItems_ = objc.registerName(
  "initWithDictionary:copyItems:",
);
late final _sel_initWithDomain_code_userInfo_ = objc.registerName(
  "initWithDomain:code:userInfo:",
);
late final _sel_initWithDouble_ = objc.registerName("initWithDouble:");
late final _sel_initWithFileAtPath_ = objc.registerName("initWithFileAtPath:");
late final _sel_initWithFireDate_interval_repeats_block_ = objc.registerName(
  "initWithFireDate:interval:repeats:block:",
);
late final _sel_initWithFireDate_interval_target_selector_userInfo_repeats_ =
    objc.registerName(
      "initWithFireDate:interval:target:selector:userInfo:repeats:",
    );
late final _sel_initWithFloat_ = objc.registerName("initWithFloat:");
late final _sel_initWithFormat_ = objc.registerName("initWithFormat:");
late final _sel_initWithFormat_locale_ = objc.registerName(
  "initWithFormat:locale:",
);
late final _sel_initWithFormat_options_locale_ = objc.registerName(
  "initWithFormat:options:locale:",
);
late final _sel_initWithFormat_options_locale_context_ = objc.registerName(
  "initWithFormat:options:locale:context:",
);
late final _sel_initWithIndexSet_ = objc.registerName("initWithIndexSet:");
late final _sel_initWithIndex_ = objc.registerName("initWithIndex:");
late final _sel_initWithIndexesInRange_ = objc.registerName(
  "initWithIndexesInRange:",
);
late final _sel_initWithInsertIndexes_insertedObjects_removeIndexes_removedObjects_ =
    objc.registerName(
      "initWithInsertIndexes:insertedObjects:removeIndexes:removedObjects:",
    );
late final _sel_initWithInsertIndexes_insertedObjects_removeIndexes_removedObjects_additionalChanges_ =
    objc.registerName(
      "initWithInsertIndexes:insertedObjects:removeIndexes:removedObjects:additionalChanges:",
    );
late final _sel_initWithInt_ = objc.registerName("initWithInt:");
late final _sel_initWithInteger_ = objc.registerName("initWithInteger:");
late final _sel_initWithItem_typeIdentifier_ = objc.registerName(
  "initWithItem:typeIdentifier:",
);
late final _sel_initWithLength_ = objc.registerName("initWithLength:");
late final _sel_initWithLocaleIdentifier_ = objc.registerName(
  "initWithLocaleIdentifier:",
);
late final _sel_initWithLongLong_ = objc.registerName("initWithLongLong:");
late final _sel_initWithLong_ = objc.registerName("initWithLong:");
late final _sel_initWithMarkdownString_options_baseURL_error_ = objc
    .registerName("initWithMarkdownString:options:baseURL:error:");
late final _sel_initWithMarkdown_options_baseURL_error_ = objc.registerName(
  "initWithMarkdown:options:baseURL:error:",
);
late final _sel_initWithName_object_userInfo_ = objc.registerName(
  "initWithName:object:userInfo:",
);
late final _sel_initWithObject_ = objc.registerName("initWithObject:");
late final _sel_initWithObject_type_index_ = objc.registerName(
  "initWithObject:type:index:",
);
late final _sel_initWithObject_type_index_associatedIndex_ = objc.registerName(
  "initWithObject:type:index:associatedIndex:",
);
late final _sel_initWithObjectsAndKeys_ = objc.registerName(
  "initWithObjectsAndKeys:",
);
late final _sel_initWithObjects_ = objc.registerName("initWithObjects:");
late final _sel_initWithObjects_count_ = objc.registerName(
  "initWithObjects:count:",
);
late final _sel_initWithObjects_forKeys_ = objc.registerName(
  "initWithObjects:forKeys:",
);
late final _sel_initWithObjects_forKeys_count_ = objc.registerName(
  "initWithObjects:forKeys:count:",
);
late final _sel_initWithOrderedSet_ = objc.registerName("initWithOrderedSet:");
late final _sel_initWithOrderedSet_copyItems_ = objc.registerName(
  "initWithOrderedSet:copyItems:",
);
late final _sel_initWithOrderedSet_range_copyItems_ = objc.registerName(
  "initWithOrderedSet:range:copyItems:",
);
late final _sel_initWithParent_userInfo_ = objc.registerName(
  "initWithParent:userInfo:",
);
late final _sel_initWithPath_ = objc.registerName("initWithPath:");
late final _sel_initWithSendPort_receivePort_components_ = objc.registerName(
  "initWithSendPort:receivePort:components:",
);
late final _sel_initWithSet_ = objc.registerName("initWithSet:");
late final _sel_initWithSet_copyItems_ = objc.registerName(
  "initWithSet:copyItems:",
);
late final _sel_initWithShort_ = objc.registerName("initWithShort:");
late final _sel_initWithString_ = objc.registerName("initWithString:");
late final _sel_initWithString_attributes_ = objc.registerName(
  "initWithString:attributes:",
);
late final _sel_initWithString_encodingInvalidCharacters_ = objc.registerName(
  "initWithString:encodingInvalidCharacters:",
);
late final _sel_initWithString_relativeToURL_ = objc.registerName(
  "initWithString:relativeToURL:",
);
late final _sel_initWithTimeIntervalSince1970_ = objc.registerName(
  "initWithTimeIntervalSince1970:",
);
late final _sel_initWithTimeIntervalSinceNow_ = objc.registerName(
  "initWithTimeIntervalSinceNow:",
);
late final _sel_initWithTimeIntervalSinceReferenceDate_ = objc.registerName(
  "initWithTimeIntervalSinceReferenceDate:",
);
late final _sel_initWithTimeInterval_sinceDate_ = objc.registerName(
  "initWithTimeInterval:sinceDate:",
);
late final _sel_initWithURL_ = objc.registerName("initWithURL:");
late final _sel_initWithURL_append_ = objc.registerName("initWithURL:append:");
late final _sel_initWithUTF8String_ = objc.registerName("initWithUTF8String:");
late final _sel_initWithUnsignedChar_ = objc.registerName(
  "initWithUnsignedChar:",
);
late final _sel_initWithUnsignedInt_ = objc.registerName(
  "initWithUnsignedInt:",
);
late final _sel_initWithUnsignedInteger_ = objc.registerName(
  "initWithUnsignedInteger:",
);
late final _sel_initWithUnsignedLongLong_ = objc.registerName(
  "initWithUnsignedLongLong:",
);
late final _sel_initWithUnsignedLong_ = objc.registerName(
  "initWithUnsignedLong:",
);
late final _sel_initWithUnsignedShort_ = objc.registerName(
  "initWithUnsignedShort:",
);
late final _sel_initWithValidatedFormat_validFormatSpecifiers_error_ = objc
    .registerName("initWithValidatedFormat:validFormatSpecifiers:error:");
late final _sel_initWithValidatedFormat_validFormatSpecifiers_locale_error_ =
    objc.registerName(
      "initWithValidatedFormat:validFormatSpecifiers:locale:error:",
    );
late final _sel_initialize = objc.registerName("initialize");
late final _sel_inputStreamWithData_ = objc.registerName(
  "inputStreamWithData:",
);
late final _sel_inputStreamWithFileAtPath_ = objc.registerName(
  "inputStreamWithFileAtPath:",
);
late final _sel_inputStreamWithPort_ = objc.registerName(
  "inputStreamWithPort:",
);
late final _sel_inputStreamWithURL_ = objc.registerName("inputStreamWithURL:");
late final _sel_insertObject_atIndex_ = objc.registerName(
  "insertObject:atIndex:",
);
late final _sel_insertObjects_atIndexes_ = objc.registerName(
  "insertObjects:atIndexes:",
);
late final _sel_insertions = objc.registerName("insertions");
late final _sel_instanceMethodForSelector_ = objc.registerName(
  "instanceMethodForSelector:",
);
late final _sel_instanceMethodSignatureForSelector_ = objc.registerName(
  "instanceMethodSignatureForSelector:",
);
late final _sel_instancesRespondToSelector_ = objc.registerName(
  "instancesRespondToSelector:",
);
late final _sel_intValue = objc.registerName("intValue");
late final _sel_integerValue = objc.registerName("integerValue");
late final _sel_interpretedSyntax = objc.registerName("interpretedSyntax");
late final _sel_intersectOrderedSet_ = objc.registerName(
  "intersectOrderedSet:",
);
late final _sel_intersectSet_ = objc.registerName("intersectSet:");
late final _sel_intersectsIndexesInRange_ = objc.registerName(
  "intersectsIndexesInRange:",
);
late final _sel_intersectsOrderedSet_ = objc.registerName(
  "intersectsOrderedSet:",
);
late final _sel_intersectsSet_ = objc.registerName("intersectsSet:");
late final _sel_invalidate = objc.registerName("invalidate");
late final _sel_inverseDifference = objc.registerName("inverseDifference");
late final _sel_invertedSet = objc.registerName("invertedSet");
late final _sel_invocationWithMethodSignature_ = objc.registerName(
  "invocationWithMethodSignature:",
);
late final _sel_invoke = objc.registerName("invoke");
late final _sel_invokeUsingIMP_ = objc.registerName("invokeUsingIMP:");
late final _sel_invokeWithTarget_ = objc.registerName("invokeWithTarget:");
late final _sel_isCancellable = objc.registerName("isCancellable");
late final _sel_isCancelled = objc.registerName("isCancelled");
late final _sel_isEqualToArray_ = objc.registerName("isEqualToArray:");
late final _sel_isEqualToData_ = objc.registerName("isEqualToData:");
late final _sel_isEqualToDate_ = objc.registerName("isEqualToDate:");
late final _sel_isEqualToDictionary_ = objc.registerName(
  "isEqualToDictionary:",
);
late final _sel_isEqualToIndexSet_ = objc.registerName("isEqualToIndexSet:");
late final _sel_isEqualToNumber_ = objc.registerName("isEqualToNumber:");
late final _sel_isEqualToOrderedSet_ = objc.registerName(
  "isEqualToOrderedSet:",
);
late final _sel_isEqualToSet_ = objc.registerName("isEqualToSet:");
late final _sel_isEqualToString_ = objc.registerName("isEqualToString:");
late final _sel_isEqual_ = objc.registerName("isEqual:");
late final _sel_isFileReferenceURL = objc.registerName("isFileReferenceURL");
late final _sel_isFileURL = objc.registerName("isFileURL");
late final _sel_isFinished = objc.registerName("isFinished");
late final _sel_isFloat = objc.registerName("isFloat");
late final _sel_isIndeterminate = objc.registerName("isIndeterminate");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
late final _sel_isLoaded = objc.registerName("isLoaded");
late final _sel_isMemberOfClass_ = objc.registerName("isMemberOfClass:");
late final _sel_isOld = objc.registerName("isOld");
late final _sel_isOneway = objc.registerName("isOneway");
late final _sel_isPausable = objc.registerName("isPausable");
late final _sel_isPaused = objc.registerName("isPaused");
late final _sel_isProxy = objc.registerName("isProxy");
late final _sel_isSubclassOfClass_ = objc.registerName("isSubclassOfClass:");
late final _sel_isSubsetOfOrderedSet_ = objc.registerName(
  "isSubsetOfOrderedSet:",
);
late final _sel_isSubsetOfSet_ = objc.registerName("isSubsetOfSet:");
late final _sel_isSupersetOfSet_ = objc.registerName("isSupersetOfSet:");
late final _sel_isValid = objc.registerName("isValid");
late final _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_ =
    objc.registerName(
      "itemProviderVisibilityForRepresentationWithTypeIdentifier:",
    );
late final _sel_keyEnumerator = objc.registerName("keyEnumerator");
late final _sel_keysOfEntriesPassingTest_ = objc.registerName(
  "keysOfEntriesPassingTest:",
);
late final _sel_keysOfEntriesWithOptions_passingTest_ = objc.registerName(
  "keysOfEntriesWithOptions:passingTest:",
);
late final _sel_keysSortedByValueUsingComparator_ = objc.registerName(
  "keysSortedByValueUsingComparator:",
);
late final _sel_keysSortedByValueUsingSelector_ = objc.registerName(
  "keysSortedByValueUsingSelector:",
);
late final _sel_keysSortedByValueWithOptions_usingComparator_ = objc
    .registerName("keysSortedByValueWithOptions:usingComparator:");
late final _sel_kind = objc.registerName("kind");
late final _sel_languageCode = objc.registerName("languageCode");
late final _sel_lastIndex = objc.registerName("lastIndex");
late final _sel_lastObject = objc.registerName("lastObject");
late final _sel_laterDate_ = objc.registerName("laterDate:");
late final _sel_length = objc.registerName("length");
late final _sel_lengthOfBytesUsingEncoding_ = objc.registerName(
  "lengthOfBytesUsingEncoding:",
);
late final _sel_letterCharacterSet = objc.registerName("letterCharacterSet");
late final _sel_limitDateForMode_ = objc.registerName("limitDateForMode:");
late final _sel_lineRangeForRange_ = objc.registerName("lineRangeForRange:");
late final _sel_load = objc.registerName("load");
late final _sel_loadAndReturnError_ = objc.registerName("loadAndReturnError:");
late final _sel_loadDataRepresentationForTypeIdentifier_completionHandler_ =
    objc.registerName(
      "loadDataRepresentationForTypeIdentifier:completionHandler:",
    );
late final _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_ =
    objc.registerName(
      "loadDataWithTypeIdentifier:forItemProviderCompletionHandler:",
    );
late final _sel_loadFileRepresentationForTypeIdentifier_completionHandler_ =
    objc.registerName(
      "loadFileRepresentationForTypeIdentifier:completionHandler:",
    );
late final _sel_loadInPlaceFileRepresentationForTypeIdentifier_completionHandler_ =
    objc.registerName(
      "loadInPlaceFileRepresentationForTypeIdentifier:completionHandler:",
    );
late final _sel_loadItemForTypeIdentifier_options_completionHandler_ = objc
    .registerName("loadItemForTypeIdentifier:options:completionHandler:");
late final _sel_loadObjectOfClass_completionHandler_ = objc.registerName(
  "loadObjectOfClass:completionHandler:",
);
late final _sel_localeWithLocaleIdentifier_ = objc.registerName(
  "localeWithLocaleIdentifier:",
);
late final _sel_localizations = objc.registerName("localizations");
late final _sel_localizedAdditionalDescription = objc.registerName(
  "localizedAdditionalDescription",
);
late final _sel_localizedAttributedStringForKey_value_table_ = objc
    .registerName("localizedAttributedStringForKey:value:table:");
late final _sel_localizedAttributedStringWithFormat_ = objc.registerName(
  "localizedAttributedStringWithFormat:",
);
late final _sel_localizedAttributedStringWithFormat_context_ = objc
    .registerName("localizedAttributedStringWithFormat:context:");
late final _sel_localizedAttributedStringWithFormat_options_ = objc
    .registerName("localizedAttributedStringWithFormat:options:");
late final _sel_localizedAttributedStringWithFormat_options_context_ = objc
    .registerName("localizedAttributedStringWithFormat:options:context:");
late final _sel_localizedCapitalizedString = objc.registerName(
  "localizedCapitalizedString",
);
late final _sel_localizedCaseInsensitiveCompare_ = objc.registerName(
  "localizedCaseInsensitiveCompare:",
);
late final _sel_localizedCaseInsensitiveContainsString_ = objc.registerName(
  "localizedCaseInsensitiveContainsString:",
);
late final _sel_localizedCompare_ = objc.registerName("localizedCompare:");
late final _sel_localizedDescription = objc.registerName(
  "localizedDescription",
);
late final _sel_localizedFailureReason = objc.registerName(
  "localizedFailureReason",
);
late final _sel_localizedInfoDictionary = objc.registerName(
  "localizedInfoDictionary",
);
late final _sel_localizedLowercaseString = objc.registerName(
  "localizedLowercaseString",
);
late final _sel_localizedNameOfStringEncoding_ = objc.registerName(
  "localizedNameOfStringEncoding:",
);
late final _sel_localizedRecoveryOptions = objc.registerName(
  "localizedRecoveryOptions",
);
late final _sel_localizedRecoverySuggestion = objc.registerName(
  "localizedRecoverySuggestion",
);
late final _sel_localizedStandardCompare_ = objc.registerName(
  "localizedStandardCompare:",
);
late final _sel_localizedStandardContainsString_ = objc.registerName(
  "localizedStandardContainsString:",
);
late final _sel_localizedStandardRangeOfString_ = objc.registerName(
  "localizedStandardRangeOfString:",
);
late final _sel_localizedStringForKey_value_table_ = objc.registerName(
  "localizedStringForKey:value:table:",
);
late final _sel_localizedStringWithFormat_ = objc.registerName(
  "localizedStringWithFormat:",
);
late final _sel_localizedStringWithValidatedFormat_validFormatSpecifiers_error_ =
    objc.registerName(
      "localizedStringWithValidatedFormat:validFormatSpecifiers:error:",
    );
late final _sel_localizedUppercaseString = objc.registerName(
  "localizedUppercaseString",
);
late final _sel_longCharacterIsMember_ = objc.registerName(
  "longCharacterIsMember:",
);
late final _sel_longLongValue = objc.registerName("longLongValue");
late final _sel_longValue = objc.registerName("longValue");
late final _sel_lowercaseLetterCharacterSet = objc.registerName(
  "lowercaseLetterCharacterSet",
);
late final _sel_lowercaseString = objc.registerName("lowercaseString");
late final _sel_lowercaseStringWithLocale_ = objc.registerName(
  "lowercaseStringWithLocale:",
);
late final _sel_mainBundle = objc.registerName("mainBundle");
late final _sel_mainRunLoop = objc.registerName("mainRunLoop");
late final _sel_makeObjectsPerformSelector_ = objc.registerName(
  "makeObjectsPerformSelector:",
);
late final _sel_makeObjectsPerformSelector_withObject_ = objc.registerName(
  "makeObjectsPerformSelector:withObject:",
);
late final _sel_maximumLengthOfBytesUsingEncoding_ = objc.registerName(
  "maximumLengthOfBytesUsingEncoding:",
);
late final _sel_member_ = objc.registerName("member:");
late final _sel_methodForSelector_ = objc.registerName("methodForSelector:");
late final _sel_methodReturnLength = objc.registerName("methodReturnLength");
late final _sel_methodReturnType = objc.registerName("methodReturnType");
late final _sel_methodSignature = objc.registerName("methodSignature");
late final _sel_methodSignatureForSelector_ = objc.registerName(
  "methodSignatureForSelector:",
);
late final _sel_minusOrderedSet_ = objc.registerName("minusOrderedSet:");
late final _sel_minusSet_ = objc.registerName("minusSet:");
late final _sel_moveObjectsAtIndexes_toIndex_ = objc.registerName(
  "moveObjectsAtIndexes:toIndex:",
);
late final _sel_msgid = objc.registerName("msgid");
late final _sel_mutableBytes = objc.registerName("mutableBytes");
late final _sel_mutableCopy = objc.registerName("mutableCopy");
late final _sel_mutableCopyWithZone_ = objc.registerName(
  "mutableCopyWithZone:",
);
late final _sel_name = objc.registerName("name");
late final _sel_new = objc.registerName("new");
late final _sel_newlineCharacterSet = objc.registerName("newlineCharacterSet");
late final _sel_nextObject = objc.registerName("nextObject");
late final _sel_nonBaseCharacterSet = objc.registerName("nonBaseCharacterSet");
late final _sel_notificationWithName_object_ = objc.registerName(
  "notificationWithName:object:",
);
late final _sel_notificationWithName_object_userInfo_ = objc.registerName(
  "notificationWithName:object:userInfo:",
);
late final _sel_null = objc.registerName("null");
late final _sel_numberOfArguments = objc.registerName("numberOfArguments");
late final _sel_numberWithBool_ = objc.registerName("numberWithBool:");
late final _sel_numberWithChar_ = objc.registerName("numberWithChar:");
late final _sel_numberWithDouble_ = objc.registerName("numberWithDouble:");
late final _sel_numberWithFloat_ = objc.registerName("numberWithFloat:");
late final _sel_numberWithInt_ = objc.registerName("numberWithInt:");
late final _sel_numberWithInteger_ = objc.registerName("numberWithInteger:");
late final _sel_numberWithLongLong_ = objc.registerName("numberWithLongLong:");
late final _sel_numberWithLong_ = objc.registerName("numberWithLong:");
late final _sel_numberWithShort_ = objc.registerName("numberWithShort:");
late final _sel_numberWithUnsignedChar_ = objc.registerName(
  "numberWithUnsignedChar:",
);
late final _sel_numberWithUnsignedInt_ = objc.registerName(
  "numberWithUnsignedInt:",
);
late final _sel_numberWithUnsignedInteger_ = objc.registerName(
  "numberWithUnsignedInteger:",
);
late final _sel_numberWithUnsignedLongLong_ = objc.registerName(
  "numberWithUnsignedLongLong:",
);
late final _sel_numberWithUnsignedLong_ = objc.registerName(
  "numberWithUnsignedLong:",
);
late final _sel_numberWithUnsignedShort_ = objc.registerName(
  "numberWithUnsignedShort:",
);
late final _sel_objCType = objc.registerName("objCType");
late final _sel_object = objc.registerName("object");
late final _sel_objectAtIndex_ = objc.registerName("objectAtIndex:");
late final _sel_objectAtIndexedSubscript_ = objc.registerName(
  "objectAtIndexedSubscript:",
);
late final _sel_objectEnumerator = objc.registerName("objectEnumerator");
late final _sel_objectForInfoDictionaryKey_ = objc.registerName(
  "objectForInfoDictionaryKey:",
);
late final _sel_objectForKey_ = objc.registerName("objectForKey:");
late final _sel_objectForKeyedSubscript_ = objc.registerName(
  "objectForKeyedSubscript:",
);
late final _sel_objectsAtIndexes_ = objc.registerName("objectsAtIndexes:");
late final _sel_objectsForKeys_notFoundMarker_ = objc.registerName(
  "objectsForKeys:notFoundMarker:",
);
late final _sel_objectsPassingTest_ = objc.registerName("objectsPassingTest:");
late final _sel_objectsWithOptions_passingTest_ = objc.registerName(
  "objectsWithOptions:passingTest:",
);
late final _sel_observeValueForKeyPath_ofObject_change_context_ = objc
    .registerName("observeValueForKeyPath:ofObject:change:context:");
late final _sel_open = objc.registerName("open");
late final _sel_orderedSet = objc.registerName("orderedSet");
late final _sel_orderedSetWithArray_ = objc.registerName(
  "orderedSetWithArray:",
);
late final _sel_orderedSetWithArray_range_copyItems_ = objc.registerName(
  "orderedSetWithArray:range:copyItems:",
);
late final _sel_orderedSetWithCapacity_ = objc.registerName(
  "orderedSetWithCapacity:",
);
late final _sel_orderedSetWithObject_ = objc.registerName(
  "orderedSetWithObject:",
);
late final _sel_orderedSetWithObjects_ = objc.registerName(
  "orderedSetWithObjects:",
);
late final _sel_orderedSetWithObjects_count_ = objc.registerName(
  "orderedSetWithObjects:count:",
);
late final _sel_orderedSetWithOrderedSet_ = objc.registerName(
  "orderedSetWithOrderedSet:",
);
late final _sel_orderedSetWithOrderedSet_range_copyItems_ = objc.registerName(
  "orderedSetWithOrderedSet:range:copyItems:",
);
late final _sel_orderedSetWithSet_ = objc.registerName("orderedSetWithSet:");
late final _sel_orderedSetWithSet_copyItems_ = objc.registerName(
  "orderedSetWithSet:copyItems:",
);
late final _sel_outputStreamToBuffer_capacity_ = objc.registerName(
  "outputStreamToBuffer:capacity:",
);
late final _sel_outputStreamToFileAtPath_append_ = objc.registerName(
  "outputStreamToFileAtPath:append:",
);
late final _sel_outputStreamToMemory = objc.registerName(
  "outputStreamToMemory",
);
late final _sel_outputStreamWithURL_append_ = objc.registerName(
  "outputStreamWithURL:append:",
);
late final _sel_paragraphRangeForRange_ = objc.registerName(
  "paragraphRangeForRange:",
);
late final _sel_parameterString = objc.registerName("parameterString");
late final _sel_password = objc.registerName("password");
late final _sel_path = objc.registerName("path");
late final _sel_pathForAuxiliaryExecutable_ = objc.registerName(
  "pathForAuxiliaryExecutable:",
);
late final _sel_pathForResource_ofType_ = objc.registerName(
  "pathForResource:ofType:",
);
late final _sel_pathForResource_ofType_inDirectory_ = objc.registerName(
  "pathForResource:ofType:inDirectory:",
);
late final _sel_pathForResource_ofType_inDirectory_forLocalization_ = objc
    .registerName("pathForResource:ofType:inDirectory:forLocalization:");
late final _sel_pathsForResourcesOfType_inDirectory_ = objc.registerName(
  "pathsForResourcesOfType:inDirectory:",
);
late final _sel_pathsForResourcesOfType_inDirectory_forLocalization_ = objc
    .registerName("pathsForResourcesOfType:inDirectory:forLocalization:");
late final _sel_pause = objc.registerName("pause");
late final _sel_pausingHandler = objc.registerName("pausingHandler");
late final _sel_performAsCurrentWithPendingUnitCount_usingBlock_ = objc
    .registerName("performAsCurrentWithPendingUnitCount:usingBlock:");
late final _sel_performSelector_ = objc.registerName("performSelector:");
late final _sel_performSelector_withObject_ = objc.registerName(
  "performSelector:withObject:",
);
late final _sel_performSelector_withObject_withObject_ = objc.registerName(
  "performSelector:withObject:withObject:",
);
late final _sel_port = objc.registerName("port");
late final _sel_precomposedStringWithCanonicalMapping = objc.registerName(
  "precomposedStringWithCanonicalMapping",
);
late final _sel_precomposedStringWithCompatibilityMapping = objc.registerName(
  "precomposedStringWithCompatibilityMapping",
);
late final _sel_preferredLocalizations = objc.registerName(
  "preferredLocalizations",
);
late final _sel_preferredLocalizationsFromArray_ = objc.registerName(
  "preferredLocalizationsFromArray:",
);
late final _sel_preferredLocalizationsFromArray_forPreferences_ = objc
    .registerName("preferredLocalizationsFromArray:forPreferences:");
late final _sel_preflightAndReturnError_ = objc.registerName(
  "preflightAndReturnError:",
);
late final _sel_principalClass = objc.registerName("principalClass");
late final _sel_privateFrameworksPath = objc.registerName(
  "privateFrameworksPath",
);
late final _sel_privateFrameworksURL = objc.registerName(
  "privateFrameworksURL",
);
late final _sel_progressWithTotalUnitCount_ = objc.registerName(
  "progressWithTotalUnitCount:",
);
late final _sel_progressWithTotalUnitCount_parent_pendingUnitCount_ = objc
    .registerName("progressWithTotalUnitCount:parent:pendingUnitCount:");
late final _sel_propertyForKey_ = objc.registerName("propertyForKey:");
late final _sel_publish = objc.registerName("publish");
late final _sel_punctuationCharacterSet = objc.registerName(
  "punctuationCharacterSet",
);
late final _sel_query = objc.registerName("query");
late final _sel_rangeOfCharacterFromSet_ = objc.registerName(
  "rangeOfCharacterFromSet:",
);
late final _sel_rangeOfCharacterFromSet_options_ = objc.registerName(
  "rangeOfCharacterFromSet:options:",
);
late final _sel_rangeOfCharacterFromSet_options_range_ = objc.registerName(
  "rangeOfCharacterFromSet:options:range:",
);
late final _sel_rangeOfComposedCharacterSequenceAtIndex_ = objc.registerName(
  "rangeOfComposedCharacterSequenceAtIndex:",
);
late final _sel_rangeOfComposedCharacterSequencesForRange_ = objc.registerName(
  "rangeOfComposedCharacterSequencesForRange:",
);
late final _sel_rangeOfData_options_range_ = objc.registerName(
  "rangeOfData:options:range:",
);
late final _sel_rangeOfString_ = objc.registerName("rangeOfString:");
late final _sel_rangeOfString_options_ = objc.registerName(
  "rangeOfString:options:",
);
late final _sel_rangeOfString_options_range_ = objc.registerName(
  "rangeOfString:options:range:",
);
late final _sel_rangeOfString_options_range_locale_ = objc.registerName(
  "rangeOfString:options:range:locale:",
);
late final _sel_read_maxLength_ = objc.registerName("read:maxLength:");
late final _sel_receivePort = objc.registerName("receivePort");
late final _sel_recoveryAttempter = objc.registerName("recoveryAttempter");
late final _sel_registerClass = objc.registerName("registerClass");
late final _sel_registerDataRepresentationForTypeIdentifier_visibility_loadHandler_ =
    objc.registerName(
      "registerDataRepresentationForTypeIdentifier:visibility:loadHandler:",
    );
late final _sel_registerFileRepresentationForTypeIdentifier_fileOptions_visibility_loadHandler_ =
    objc.registerName(
      "registerFileRepresentationForTypeIdentifier:fileOptions:visibility:loadHandler:",
    );
late final _sel_registerItemForTypeIdentifier_loadHandler_ = objc.registerName(
  "registerItemForTypeIdentifier:loadHandler:",
);
late final _sel_registerObjectOfClass_visibility_loadHandler_ = objc
    .registerName("registerObjectOfClass:visibility:loadHandler:");
late final _sel_registerObject_visibility_ = objc.registerName(
  "registerObject:visibility:",
);
late final _sel_registeredTypeIdentifiers = objc.registerName(
  "registeredTypeIdentifiers",
);
late final _sel_registeredTypeIdentifiersWithFileOptions_ = objc.registerName(
  "registeredTypeIdentifiersWithFileOptions:",
);
late final _sel_relativePath = objc.registerName("relativePath");
late final _sel_relativeString = objc.registerName("relativeString");
late final _sel_release = objc.registerName("release");
late final _sel_removals = objc.registerName("removals");
late final _sel_remove = objc.registerName("remove");
late final _sel_removeAllCachedResourceValues = objc.registerName(
  "removeAllCachedResourceValues",
);
late final _sel_removeAllIndexes = objc.registerName("removeAllIndexes");
late final _sel_removeAllObjects = objc.registerName("removeAllObjects");
late final _sel_removeCachedResourceValueForKey_ = objc.registerName(
  "removeCachedResourceValueForKey:",
);
late final _sel_removeFromRunLoop_forMode_ = objc.registerName(
  "removeFromRunLoop:forMode:",
);
late final _sel_removeIndex_ = objc.registerName("removeIndex:");
late final _sel_removeIndexesInRange_ = objc.registerName(
  "removeIndexesInRange:",
);
late final _sel_removeIndexes_ = objc.registerName("removeIndexes:");
late final _sel_removeLastObject = objc.registerName("removeLastObject");
late final _sel_removeObjectAtIndex_ = objc.registerName(
  "removeObjectAtIndex:",
);
late final _sel_removeObjectForKey_ = objc.registerName("removeObjectForKey:");
late final _sel_removeObjectIdenticalTo_ = objc.registerName(
  "removeObjectIdenticalTo:",
);
late final _sel_removeObjectIdenticalTo_inRange_ = objc.registerName(
  "removeObjectIdenticalTo:inRange:",
);
late final _sel_removeObject_ = objc.registerName("removeObject:");
late final _sel_removeObject_inRange_ = objc.registerName(
  "removeObject:inRange:",
);
late final _sel_removeObjectsAtIndexes_ = objc.registerName(
  "removeObjectsAtIndexes:",
);
late final _sel_removeObjectsForKeys_ = objc.registerName(
  "removeObjectsForKeys:",
);
late final _sel_removeObjectsInArray_ = objc.registerName(
  "removeObjectsInArray:",
);
late final _sel_removeObjectsInRange_ = objc.registerName(
  "removeObjectsInRange:",
);
late final _sel_removePort_forMode_ = objc.registerName("removePort:forMode:");
late final _sel_removeSubscriber_ = objc.registerName("removeSubscriber:");
late final _sel_replaceBytesInRange_withBytes_ = objc.registerName(
  "replaceBytesInRange:withBytes:",
);
late final _sel_replaceBytesInRange_withBytes_length_ = objc.registerName(
  "replaceBytesInRange:withBytes:length:",
);
late final _sel_replaceCharactersInRange_withString_ = objc.registerName(
  "replaceCharactersInRange:withString:",
);
late final _sel_replaceObjectAtIndex_withObject_ = objc.registerName(
  "replaceObjectAtIndex:withObject:",
);
late final _sel_replaceObjectsAtIndexes_withObjects_ = objc.registerName(
  "replaceObjectsAtIndexes:withObjects:",
);
late final _sel_replaceObjectsInRange_withObjectsFromArray_ = objc.registerName(
  "replaceObjectsInRange:withObjectsFromArray:",
);
late final _sel_replaceObjectsInRange_withObjectsFromArray_range_ = objc
    .registerName("replaceObjectsInRange:withObjectsFromArray:range:");
late final _sel_replaceObjectsInRange_withObjects_count_ = objc.registerName(
  "replaceObjectsInRange:withObjects:count:",
);
late final _sel_reservedSpaceLength = objc.registerName("reservedSpaceLength");
late final _sel_resetBytesInRange_ = objc.registerName("resetBytesInRange:");
late final _sel_resignCurrent = objc.registerName("resignCurrent");
late final _sel_resolveClassMethod_ = objc.registerName("resolveClassMethod:");
late final _sel_resolveInstanceMethod_ = objc.registerName(
  "resolveInstanceMethod:",
);
late final _sel_resourcePath = objc.registerName("resourcePath");
late final _sel_resourceSpecifier = objc.registerName("resourceSpecifier");
late final _sel_resourceURL = objc.registerName("resourceURL");
late final _sel_resourceValuesForKeys_error_ = objc.registerName(
  "resourceValuesForKeys:error:",
);
late final _sel_resourceValuesForKeys_fromBookmarkData_ = objc.registerName(
  "resourceValuesForKeys:fromBookmarkData:",
);
late final _sel_respondsToSelector_ = objc.registerName("respondsToSelector:");
late final _sel_resume = objc.registerName("resume");
late final _sel_resumingHandler = objc.registerName("resumingHandler");
late final _sel_retain = objc.registerName("retain");
late final _sel_retainArguments = objc.registerName("retainArguments");
late final _sel_retainCount = objc.registerName("retainCount");
late final _sel_reverseObjectEnumerator = objc.registerName(
  "reverseObjectEnumerator",
);
late final _sel_reversedOrderedSet = objc.registerName("reversedOrderedSet");
late final _sel_scheduleInRunLoop_forMode_ = objc.registerName(
  "scheduleInRunLoop:forMode:",
);
late final _sel_scheduledTimerWithTimeInterval_invocation_repeats_ = objc
    .registerName("scheduledTimerWithTimeInterval:invocation:repeats:");
late final _sel_scheduledTimerWithTimeInterval_repeats_block_ = objc
    .registerName("scheduledTimerWithTimeInterval:repeats:block:");
late final _sel_scheduledTimerWithTimeInterval_target_selector_userInfo_repeats_ =
    objc.registerName(
      "scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:",
    );
late final _sel_scheme = objc.registerName("scheme");
late final _sel_selector = objc.registerName("selector");
late final _sel_self = objc.registerName("self");
late final _sel_sendBeforeDate_ = objc.registerName("sendBeforeDate:");
late final _sel_sendBeforeDate_components_from_reserved_ = objc.registerName(
  "sendBeforeDate:components:from:reserved:",
);
late final _sel_sendBeforeDate_msgid_components_from_reserved_ = objc
    .registerName("sendBeforeDate:msgid:components:from:reserved:");
late final _sel_sendPort = objc.registerName("sendPort");
late final _sel_set = objc.registerName("set");
late final _sel_setAllowsExtendedAttributes_ = objc.registerName(
  "setAllowsExtendedAttributes:",
);
late final _sel_setAppliesSourcePositionAttributes_ = objc.registerName(
  "setAppliesSourcePositionAttributes:",
);
late final _sel_setArgument_atIndex_ = objc.registerName(
  "setArgument:atIndex:",
);
late final _sel_setArray_ = objc.registerName("setArray:");
late final _sel_setByAddingObject_ = objc.registerName("setByAddingObject:");
late final _sel_setByAddingObjectsFromArray_ = objc.registerName(
  "setByAddingObjectsFromArray:",
);
late final _sel_setByAddingObjectsFromSet_ = objc.registerName(
  "setByAddingObjectsFromSet:",
);
late final _sel_setCancellable_ = objc.registerName("setCancellable:");
late final _sel_setCancellationHandler_ = objc.registerName(
  "setCancellationHandler:",
);
late final _sel_setCompletedUnitCount_ = objc.registerName(
  "setCompletedUnitCount:",
);
late final _sel_setData_ = objc.registerName("setData:");
late final _sel_setDelegate_ = objc.registerName("setDelegate:");
late final _sel_setDictionary_ = objc.registerName("setDictionary:");
late final _sel_setDone = objc.registerName("setDone");
late final _sel_setError_ = objc.registerName("setError:");
late final _sel_setEstimatedTimeRemaining_ = objc.registerName(
  "setEstimatedTimeRemaining:",
);
late final _sel_setFailurePolicy_ = objc.registerName("setFailurePolicy:");
late final _sel_setFileCompletedCount_ = objc.registerName(
  "setFileCompletedCount:",
);
late final _sel_setFileOperationKind_ = objc.registerName(
  "setFileOperationKind:",
);
late final _sel_setFileTotalCount_ = objc.registerName("setFileTotalCount:");
late final _sel_setFileURL_ = objc.registerName("setFileURL:");
late final _sel_setFireDate_ = objc.registerName("setFireDate:");
late final _sel_setInterpretedSyntax_ = objc.registerName(
  "setInterpretedSyntax:",
);
late final _sel_setKind_ = objc.registerName("setKind:");
late final _sel_setLanguageCode_ = objc.registerName("setLanguageCode:");
late final _sel_setLength_ = objc.registerName("setLength:");
late final _sel_setLocalizedAdditionalDescription_ = objc.registerName(
  "setLocalizedAdditionalDescription:",
);
late final _sel_setLocalizedDescription_ = objc.registerName(
  "setLocalizedDescription:",
);
late final _sel_setMsgid_ = objc.registerName("setMsgid:");
late final _sel_setObject_atIndex_ = objc.registerName("setObject:atIndex:");
late final _sel_setObject_atIndexedSubscript_ = objc.registerName(
  "setObject:atIndexedSubscript:",
);
late final _sel_setObject_forKey_ = objc.registerName("setObject:forKey:");
late final _sel_setObject_forKeyedSubscript_ = objc.registerName(
  "setObject:forKeyedSubscript:",
);
late final _sel_setPausable_ = objc.registerName("setPausable:");
late final _sel_setPausingHandler_ = objc.registerName("setPausingHandler:");
late final _sel_setProperty_forKey_ = objc.registerName("setProperty:forKey:");
late final _sel_setResourceValue_forKey_error_ = objc.registerName(
  "setResourceValue:forKey:error:",
);
late final _sel_setResourceValues_error_ = objc.registerName(
  "setResourceValues:error:",
);
late final _sel_setResumingHandler_ = objc.registerName("setResumingHandler:");
late final _sel_setReturnValue_ = objc.registerName("setReturnValue:");
late final _sel_setSelector_ = objc.registerName("setSelector:");
late final _sel_setSet_ = objc.registerName("setSet:");
late final _sel_setSuggestedName_ = objc.registerName("setSuggestedName:");
late final _sel_setTarget_ = objc.registerName("setTarget:");
late final _sel_setTemporaryResourceValue_forKey_ = objc.registerName(
  "setTemporaryResourceValue:forKey:",
);
late final _sel_setThroughput_ = objc.registerName("setThroughput:");
late final _sel_setTolerance_ = objc.registerName("setTolerance:");
late final _sel_setTotalUnitCount_ = objc.registerName("setTotalUnitCount:");
late final _sel_setUserInfoObject_forKey_ = objc.registerName(
  "setUserInfoObject:forKey:",
);
late final _sel_setUserInfoValueProviderForDomain_provider_ = objc.registerName(
  "setUserInfoValueProviderForDomain:provider:",
);
late final _sel_setWithArray_ = objc.registerName("setWithArray:");
late final _sel_setWithCapacity_ = objc.registerName("setWithCapacity:");
late final _sel_setWithObject_ = objc.registerName("setWithObject:");
late final _sel_setWithObjects_ = objc.registerName("setWithObjects:");
late final _sel_setWithObjects_count_ = objc.registerName(
  "setWithObjects:count:",
);
late final _sel_setWithSet_ = objc.registerName("setWithSet:");
late final _sel_sharedFrameworksPath = objc.registerName(
  "sharedFrameworksPath",
);
late final _sel_sharedFrameworksURL = objc.registerName("sharedFrameworksURL");
late final _sel_sharedSupportPath = objc.registerName("sharedSupportPath");
late final _sel_sharedSupportURL = objc.registerName("sharedSupportURL");
late final _sel_shiftIndexesStartingAtIndex_by_ = objc.registerName(
  "shiftIndexesStartingAtIndex:by:",
);
late final _sel_shortValue = objc.registerName("shortValue");
late final _sel_signatureWithObjCTypes_ = objc.registerName(
  "signatureWithObjCTypes:",
);
late final _sel_smallestEncoding = objc.registerName("smallestEncoding");
late final _sel_sortRange_options_usingComparator_ = objc.registerName(
  "sortRange:options:usingComparator:",
);
late final _sel_sortUsingComparator_ = objc.registerName(
  "sortUsingComparator:",
);
late final _sel_sortUsingFunction_context_ = objc.registerName(
  "sortUsingFunction:context:",
);
late final _sel_sortUsingSelector_ = objc.registerName("sortUsingSelector:");
late final _sel_sortWithOptions_usingComparator_ = objc.registerName(
  "sortWithOptions:usingComparator:",
);
late final _sel_sortedArrayHint = objc.registerName("sortedArrayHint");
late final _sel_sortedArrayUsingComparator_ = objc.registerName(
  "sortedArrayUsingComparator:",
);
late final _sel_sortedArrayUsingFunction_context_ = objc.registerName(
  "sortedArrayUsingFunction:context:",
);
late final _sel_sortedArrayUsingFunction_context_hint_ = objc.registerName(
  "sortedArrayUsingFunction:context:hint:",
);
late final _sel_sortedArrayUsingSelector_ = objc.registerName(
  "sortedArrayUsingSelector:",
);
late final _sel_sortedArrayWithOptions_usingComparator_ = objc.registerName(
  "sortedArrayWithOptions:usingComparator:",
);
late final _sel_standardizedURL = objc.registerName("standardizedURL");
late final _sel_startAccessingSecurityScopedResource = objc.registerName(
  "startAccessingSecurityScopedResource",
);
late final _sel_stopAccessingSecurityScopedResource = objc.registerName(
  "stopAccessingSecurityScopedResource",
);
late final _sel_streamError = objc.registerName("streamError");
late final _sel_streamStatus = objc.registerName("streamStatus");
late final _sel_stream_handleEvent_ = objc.registerName("stream:handleEvent:");
late final _sel_string = objc.registerName("string");
late final _sel_stringByAppendingFormat_ = objc.registerName(
  "stringByAppendingFormat:",
);
late final _sel_stringByAppendingString_ = objc.registerName(
  "stringByAppendingString:",
);
late final _sel_stringByApplyingTransform_reverse_ = objc.registerName(
  "stringByApplyingTransform:reverse:",
);
late final _sel_stringByFoldingWithOptions_locale_ = objc.registerName(
  "stringByFoldingWithOptions:locale:",
);
late final _sel_stringByPaddingToLength_withString_startingAtIndex_ = objc
    .registerName("stringByPaddingToLength:withString:startingAtIndex:");
late final _sel_stringByReplacingCharactersInRange_withString_ = objc
    .registerName("stringByReplacingCharactersInRange:withString:");
late final _sel_stringByReplacingOccurrencesOfString_withString_ = objc
    .registerName("stringByReplacingOccurrencesOfString:withString:");
late final _sel_stringByReplacingOccurrencesOfString_withString_options_range_ =
    objc.registerName(
      "stringByReplacingOccurrencesOfString:withString:options:range:",
    );
late final _sel_stringByTrimmingCharactersInSet_ = objc.registerName(
  "stringByTrimmingCharactersInSet:",
);
late final _sel_stringValue = objc.registerName("stringValue");
late final _sel_stringWithCString_encoding_ = objc.registerName(
  "stringWithCString:encoding:",
);
late final _sel_stringWithCharacters_length_ = objc.registerName(
  "stringWithCharacters:length:",
);
late final _sel_stringWithContentsOfFile_encoding_error_ = objc.registerName(
  "stringWithContentsOfFile:encoding:error:",
);
late final _sel_stringWithContentsOfFile_usedEncoding_error_ = objc
    .registerName("stringWithContentsOfFile:usedEncoding:error:");
late final _sel_stringWithContentsOfURL_encoding_error_ = objc.registerName(
  "stringWithContentsOfURL:encoding:error:",
);
late final _sel_stringWithContentsOfURL_usedEncoding_error_ = objc.registerName(
  "stringWithContentsOfURL:usedEncoding:error:",
);
late final _sel_stringWithFormat_ = objc.registerName("stringWithFormat:");
late final _sel_stringWithString_ = objc.registerName("stringWithString:");
late final _sel_stringWithUTF8String_ = objc.registerName(
  "stringWithUTF8String:",
);
late final _sel_stringWithValidatedFormat_validFormatSpecifiers_error_ = objc
    .registerName("stringWithValidatedFormat:validFormatSpecifiers:error:");
late final _sel_subarrayWithRange_ = objc.registerName("subarrayWithRange:");
late final _sel_subdataWithRange_ = objc.registerName("subdataWithRange:");
late final _sel_substringFromIndex_ = objc.registerName("substringFromIndex:");
late final _sel_substringToIndex_ = objc.registerName("substringToIndex:");
late final _sel_substringWithRange_ = objc.registerName("substringWithRange:");
late final _sel_suggestedName = objc.registerName("suggestedName");
late final _sel_superclass = objc.registerName("superclass");
late final _sel_supportsSecureCoding = objc.registerName(
  "supportsSecureCoding",
);
late final _sel_symbolCharacterSet = objc.registerName("symbolCharacterSet");
late final _sel_target = objc.registerName("target");
late final _sel_throughput = objc.registerName("throughput");
late final _sel_timeInterval = objc.registerName("timeInterval");
late final _sel_timeIntervalSince1970 = objc.registerName(
  "timeIntervalSince1970",
);
late final _sel_timeIntervalSinceDate_ = objc.registerName(
  "timeIntervalSinceDate:",
);
late final _sel_timeIntervalSinceNow = objc.registerName(
  "timeIntervalSinceNow",
);
late final _sel_timeIntervalSinceReferenceDate = objc.registerName(
  "timeIntervalSinceReferenceDate",
);
late final _sel_timerWithTimeInterval_invocation_repeats_ = objc.registerName(
  "timerWithTimeInterval:invocation:repeats:",
);
late final _sel_timerWithTimeInterval_repeats_block_ = objc.registerName(
  "timerWithTimeInterval:repeats:block:",
);
late final _sel_timerWithTimeInterval_target_selector_userInfo_repeats_ = objc
    .registerName("timerWithTimeInterval:target:selector:userInfo:repeats:");
late final _sel_tolerance = objc.registerName("tolerance");
late final _sel_totalUnitCount = objc.registerName("totalUnitCount");
late final _sel_underlyingErrors = objc.registerName("underlyingErrors");
late final _sel_unionOrderedSet_ = objc.registerName("unionOrderedSet:");
late final _sel_unionSet_ = objc.registerName("unionSet:");
late final _sel_unload = objc.registerName("unload");
late final _sel_unpublish = objc.registerName("unpublish");
late final _sel_unsignedCharValue = objc.registerName("unsignedCharValue");
late final _sel_unsignedIntValue = objc.registerName("unsignedIntValue");
late final _sel_unsignedIntegerValue = objc.registerName(
  "unsignedIntegerValue",
);
late final _sel_unsignedLongLongValue = objc.registerName(
  "unsignedLongLongValue",
);
late final _sel_unsignedLongValue = objc.registerName("unsignedLongValue");
late final _sel_unsignedShortValue = objc.registerName("unsignedShortValue");
late final _sel_uppercaseLetterCharacterSet = objc.registerName(
  "uppercaseLetterCharacterSet",
);
late final _sel_uppercaseString = objc.registerName("uppercaseString");
late final _sel_uppercaseStringWithLocale_ = objc.registerName(
  "uppercaseStringWithLocale:",
);
late final _sel_user = objc.registerName("user");
late final _sel_userInfo = objc.registerName("userInfo");
late final _sel_userInfoValueProviderForDomain_ = objc.registerName(
  "userInfoValueProviderForDomain:",
);
late final _sel_versionForClassName_ = objc.registerName(
  "versionForClassName:",
);
late final _sel_whitespaceAndNewlineCharacterSet = objc.registerName(
  "whitespaceAndNewlineCharacterSet",
);
late final _sel_whitespaceCharacterSet = objc.registerName(
  "whitespaceCharacterSet",
);
late final _sel_writableTypeIdentifiersForItemProvider = objc.registerName(
  "writableTypeIdentifiersForItemProvider",
);
late final _sel_writeBookmarkData_toURL_options_error_ = objc.registerName(
  "writeBookmarkData:toURL:options:error:",
);
late final _sel_writeToFile_atomically_ = objc.registerName(
  "writeToFile:atomically:",
);
late final _sel_writeToFile_atomically_encoding_error_ = objc.registerName(
  "writeToFile:atomically:encoding:error:",
);
late final _sel_writeToFile_options_error_ = objc.registerName(
  "writeToFile:options:error:",
);
late final _sel_writeToURL_atomically_ = objc.registerName(
  "writeToURL:atomically:",
);
late final _sel_writeToURL_atomically_encoding_error_ = objc.registerName(
  "writeToURL:atomically:encoding:error:",
);
late final _sel_writeToURL_error_ = objc.registerName("writeToURL:error:");
late final _sel_writeToURL_options_error_ = objc.registerName(
  "writeToURL:options:error:",
);
late final _sel_write_maxLength_ = objc.registerName("write:maxLength:");
late final _sel_zone = objc.registerName("zone");
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
