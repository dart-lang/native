// Copyright (c) 2025, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// This file is generated, do not edit.
// File generated by pkg/record_use/tool/generate_syntax.dart.

// ignore_for_file: unused_element

import 'dart:io';

class Arguments {
  final Map<String, Object?> json;

  final List<Object> path;

  JsonReader get _reader => JsonReader(json, path);

  Arguments.fromJson(this.json, {this.path = const []});

  Arguments({required Constant? constant, required NonConstant? nonConstant})
    : json = {},
      path = const [] {
    _constant = constant;
    _nonConstant = nonConstant;
    json.sortOnKey();
  }

  Constant? get constant {
    final jsonValue = _reader.optionalMap('constant');
    if (jsonValue == null) return null;
    return Constant.fromJson(jsonValue, path: [...path, 'constant']);
  }

  set _constant(Constant? value) {
    json.setOrRemove('constant', value?.json);
  }

  List<String> _validateConstant() {
    final mapErrors = _reader.validate<Map<String, Object?>?>('constant');
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    return constant?.validate() ?? [];
  }

  NonConstant? get nonConstant {
    final jsonValue = _reader.optionalMap('nonConstant');
    if (jsonValue == null) return null;
    return NonConstant.fromJson(jsonValue, path: [...path, 'nonConstant']);
  }

  set _nonConstant(NonConstant? value) {
    json.setOrRemove('nonConstant', value?.json);
  }

  List<String> _validateNonConstant() {
    final mapErrors = _reader.validate<Map<String, Object?>?>('nonConstant');
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    return nonConstant?.validate() ?? [];
  }

  List<String> validate() => [
    ..._validateConstant(),
    ..._validateNonConstant(),
  ];

  @override
  String toString() => 'Arguments($json)';
}

class Call {
  final Map<String, Object?> json;

  final List<Object> path;

  JsonReader get _reader => JsonReader(json, path);

  Call.fromJson(this.json, {this.path = const []});

  Call({
    required Arguments? arguments,
    required Definition? definition,
    required String? loadingUnit,
    required List<Reference>? references,
  }) : json = {},
       path = const [] {
    _arguments = arguments;
    _definition = definition;
    _loadingUnit = loadingUnit;
    _references = references;
    json.sortOnKey();
  }

  Arguments? get arguments {
    final jsonValue = _reader.optionalMap('arguments');
    if (jsonValue == null) return null;
    return Arguments.fromJson(jsonValue, path: [...path, 'arguments']);
  }

  set _arguments(Arguments? value) {
    json.setOrRemove('arguments', value?.json);
  }

  List<String> _validateArguments() {
    final mapErrors = _reader.validate<Map<String, Object?>?>('arguments');
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    return arguments?.validate() ?? [];
  }

  Definition? get definition {
    final jsonValue = _reader.optionalMap('definition');
    if (jsonValue == null) return null;
    return Definition.fromJson(jsonValue, path: [...path, 'definition']);
  }

  set _definition(Definition? value) {
    json.setOrRemove('definition', value?.json);
  }

  List<String> _validateDefinition() {
    final mapErrors = _reader.validate<Map<String, Object?>?>('definition');
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    return definition?.validate() ?? [];
  }

  String? get loadingUnit => _reader.get<String?>('loadingUnit');

  set _loadingUnit(String? value) {
    json.setOrRemove('loadingUnit', value);
  }

  List<String> _validateLoadingUnit() =>
      _reader.validate<String?>('loadingUnit');

  List<Reference>? get references {
    final jsonValue = _reader.optionalList('references');
    if (jsonValue == null) return null;
    return [
      for (final (index, element) in jsonValue.indexed)
        Reference.fromJson(
          element as Map<String, Object?>,
          path: [...path, 'references', index],
        ),
    ];
  }

  set _references(List<Reference>? value) {
    if (value == null) {
      json.remove('references');
    } else {
      json['references'] = [for (final item in value) item.json];
    }
  }

  List<String> _validateReferences() {
    final listErrors = _reader.validateOptionalList<Map<String, Object?>>(
      'references',
    );
    if (listErrors.isNotEmpty) {
      return listErrors;
    }
    final elements = references;
    if (elements == null) {
      return [];
    }
    return [for (final element in elements) ...element.validate()];
  }

  List<String> validate() => [
    ..._validateArguments(),
    ..._validateDefinition(),
    ..._validateLoadingUnit(),
    ..._validateReferences(),
  ];

  @override
  String toString() => 'Call($json)';
}

class Constant {
  final Map<String, Object?> json;

  final List<Object> path;

  JsonReader get _reader => JsonReader(json, path);

  Constant.fromJson(this.json, {this.path = const []});

  Constant({
    required Map<String, Object?>? named,
    required Map<String, Object?>? positional,
  }) : json = {},
       path = const [] {
    _named = named;
    _positional = positional;
    json.sortOnKey();
  }

  Map<String, Object?>? get named => _reader.optionalMap('named');

  set _named(Map<String, Object?>? value) {
    json.setOrRemove('named', value);
  }

  List<String> _validateNamed() => _reader.validateOptionalMap('named');

  Map<String, Object?>? get positional => _reader.optionalMap('positional');

  set _positional(Map<String, Object?>? value) {
    json.setOrRemove('positional', value);
  }

  List<String> _validatePositional() =>
      _reader.validateOptionalMap('positional');

  List<String> validate() => [..._validateNamed(), ..._validatePositional()];

  @override
  String toString() => 'Constant($json)';
}

class Definition {
  final Map<String, Object?> json;

  final List<Object> path;

  JsonReader get _reader => JsonReader(json, path);

  Definition.fromJson(this.json, {this.path = const []});

  Definition({required int id, required String loadingUnit})
    : json = {},
      path = const [] {
    _id = id;
    _loadingUnit = loadingUnit;
    json.sortOnKey();
  }

  int get id => _reader.get<int>('id');

  set _id(int value) {
    json.setOrRemove('id', value);
  }

  List<String> _validateId() => _reader.validate<int>('id');

  String get loadingUnit => _reader.get<String>('loadingUnit');

  set _loadingUnit(String value) {
    json.setOrRemove('loadingUnit', value);
  }

  List<String> _validateLoadingUnit() =>
      _reader.validate<String>('loadingUnit');

  List<String> validate() => [..._validateId(), ..._validateLoadingUnit()];

  @override
  String toString() => 'Definition($json)';
}

class Identifier {
  final Map<String, Object?> json;

  final List<Object> path;

  JsonReader get _reader => JsonReader(json, path);

  Identifier.fromJson(this.json, {this.path = const []});

  Identifier({
    required String name,
    required String? parent,
    required String uri,
  }) : json = {},
       path = const [] {
    _name = name;
    _parent = parent;
    _uri = uri;
    json.sortOnKey();
  }

  String get name => _reader.get<String>('name');

  set _name(String value) {
    json.setOrRemove('name', value);
  }

  List<String> _validateName() => _reader.validate<String>('name');

  String? get parent => _reader.get<String?>('parent');

  set _parent(String? value) {
    json.setOrRemove('parent', value);
  }

  List<String> _validateParent() => _reader.validate<String?>('parent');

  String get uri => _reader.get<String>('uri');

  set _uri(String value) {
    json.setOrRemove('uri', value);
  }

  List<String> _validateUri() => _reader.validate<String>('uri');

  List<String> validate() => [
    ..._validateName(),
    ..._validateParent(),
    ..._validateUri(),
  ];

  @override
  String toString() => 'Identifier($json)';
}

class Instance {
  final Map<String, Object?> json;

  final List<Object> path;

  JsonReader get _reader => JsonReader(json, path);

  Instance.fromJson(this.json, {this.path = const []});

  Instance({required int instanceConstant, required String loadingUnit})
    : json = {},
      path = const [] {
    _instanceConstant = instanceConstant;
    _loadingUnit = loadingUnit;
    json.sortOnKey();
  }

  int get instanceConstant => _reader.get<int>('instanceConstant');

  set _instanceConstant(int value) {
    json.setOrRemove('instanceConstant', value);
  }

  List<String> _validateInstanceConstant() =>
      _reader.validate<int>('instanceConstant');

  String get loadingUnit => _reader.get<String>('loadingUnit');

  set _loadingUnit(String value) {
    json.setOrRemove('loadingUnit', value);
  }

  List<String> _validateLoadingUnit() =>
      _reader.validate<String>('loadingUnit');

  List<String> validate() => [
    ..._validateInstanceConstant(),
    ..._validateLoadingUnit(),
  ];

  @override
  String toString() => 'Instance($json)';
}

class Metadata {
  final Map<String, Object?> json;

  final List<Object> path;

  JsonReader get _reader => JsonReader(json, path);

  Metadata.fromJson(this.json, {this.path = const []});

  Metadata({required String comment, required String version})
    : json = {},
      path = const [] {
    _comment = comment;
    _version = version;
    json.sortOnKey();
  }

  String get comment => _reader.get<String>('comment');

  set _comment(String value) {
    json.setOrRemove('comment', value);
  }

  List<String> _validateComment() => _reader.validate<String>('comment');

  String get version => _reader.get<String>('version');

  set _version(String value) {
    json.setOrRemove('version', value);
  }

  List<String> _validateVersion() => _reader.validate<String>('version');

  List<String> validate() => [..._validateComment(), ..._validateVersion()];

  @override
  String toString() => 'Metadata($json)';
}

class NonConstant {
  final Map<String, Object?> json;

  final List<Object> path;

  JsonReader get _reader => JsonReader(json, path);

  NonConstant.fromJson(this.json, {this.path = const []});

  NonConstant({
    required List<Map<String, Object?>?>? named,
    required List<Map<String, Object?>?>? positional,
  }) : json = {},
       path = const [] {
    _named = named;
    _positional = positional;
    json.sortOnKey();
  }

  List<String> validate() => [..._validateNamed(), ..._validatePositional()];

  @override
  String toString() => 'NonConstant($json)';
}

class RecordedUses {
  final Map<String, Object?> json;

  final List<Object> path;

  JsonReader get _reader => JsonReader(json, path);

  RecordedUses.fromJson(this.json, {this.path = const []});

  RecordedUses({
    required List<Constant>? constants,
    required List<Identifier>? ids,
    required Metadata metadata,
    required List<Usage>? usages,
  }) : json = {},
       path = const [] {
    _constants = constants;
    _ids = ids;
    _metadata = metadata;
    _usages = usages;
    json.sortOnKey();
  }

  List<Constant>? get constants {
    final jsonValue = _reader.optionalList('constants');
    if (jsonValue == null) return null;
    return [
      for (final (index, element) in jsonValue.indexed)
        Constant.fromJson(
          element as Map<String, Object?>,
          path: [...path, 'constants', index],
        ),
    ];
  }

  set _constants(List<Constant>? value) {
    if (value == null) {
      json.remove('constants');
    } else {
      json['constants'] = [for (final item in value) item.json];
    }
  }

  List<String> _validateConstants() {
    final listErrors = _reader.validateOptionalList<Map<String, Object?>>(
      'constants',
    );
    if (listErrors.isNotEmpty) {
      return listErrors;
    }
    final elements = constants;
    if (elements == null) {
      return [];
    }
    return [for (final element in elements) ...element.validate()];
  }

  List<Identifier>? get ids {
    final jsonValue = _reader.optionalList('ids');
    if (jsonValue == null) return null;
    return [
      for (final (index, element) in jsonValue.indexed)
        Identifier.fromJson(
          element as Map<String, Object?>,
          path: [...path, 'ids', index],
        ),
    ];
  }

  set _ids(List<Identifier>? value) {
    if (value == null) {
      json.remove('ids');
    } else {
      json['ids'] = [for (final item in value) item.json];
    }
  }

  List<String> _validateIds() {
    final listErrors = _reader.validateOptionalList<Map<String, Object?>>(
      'ids',
    );
    if (listErrors.isNotEmpty) {
      return listErrors;
    }
    final elements = ids;
    if (elements == null) {
      return [];
    }
    return [for (final element in elements) ...element.validate()];
  }

  Metadata get metadata {
    final jsonValue = _reader.map$('metadata');
    return Metadata.fromJson(jsonValue, path: [...path, 'metadata']);
  }

  set _metadata(Metadata value) {
    json['metadata'] = value.json;
  }

  List<String> _validateMetadata() {
    final mapErrors = _reader.validate<Map<String, Object?>>('metadata');
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    return metadata.validate();
  }

  List<Usage>? get usages {
    final jsonValue = _reader.optionalList('usages');
    if (jsonValue == null) return null;
    return [
      for (final (index, element) in jsonValue.indexed)
        Usage.fromJson(
          element as Map<String, Object?>,
          path: [...path, 'usages', index],
        ),
    ];
  }

  set _usages(List<Usage>? value) {
    if (value == null) {
      json.remove('usages');
    } else {
      json['usages'] = [for (final item in value) item.json];
    }
  }

  List<String> _validateUsages() {
    final listErrors = _reader.validateOptionalList<Map<String, Object?>>(
      'usages',
    );
    if (listErrors.isNotEmpty) {
      return listErrors;
    }
    final elements = usages;
    if (elements == null) {
      return [];
    }
    return [for (final element in elements) ...element.validate()];
  }

  List<String> validate() => [
    ..._validateConstants(),
    ..._validateIds(),
    ..._validateMetadata(),
    ..._validateUsages(),
  ];

  @override
  String toString() => 'RecordedUses($json)';
}

class Reference {
  final Map<String, Object?> json;

  final List<Object> path;

  JsonReader get _reader => JsonReader(json, path);

  Reference.fromJson(this.json, {this.path = const []});

  Reference({required Arguments arguments, required String loadingUnit})
    : json = {},
      path = const [] {
    _arguments = arguments;
    _loadingUnit = loadingUnit;
    json.sortOnKey();
  }

  Arguments get arguments {
    final jsonValue = _reader.map$('arguments');
    return Arguments.fromJson(jsonValue, path: [...path, 'arguments']);
  }

  set _arguments(Arguments value) {
    json['arguments'] = value.json;
  }

  List<String> _validateArguments() {
    final mapErrors = _reader.validate<Map<String, Object?>>('arguments');
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    return arguments.validate();
  }

  String get loadingUnit => _reader.get<String>('loadingUnit');

  set _loadingUnit(String value) {
    json.setOrRemove('loadingUnit', value);
  }

  List<String> _validateLoadingUnit() =>
      _reader.validate<String>('loadingUnit');

  List<String> validate() => [
    ..._validateArguments(),
    ..._validateLoadingUnit(),
  ];

  @override
  String toString() => 'Reference($json)';
}

class Usage {
  final Map<String, Object?> json;

  final List<Object> path;

  JsonReader get _reader => JsonReader(json, path);

  Usage.fromJson(this.json, {this.path = const []});

  Usage({
    required List<Call>? calls,
    required int identifier,
    required List<Instance>? instances,
    required String? loadingUnit,
  }) : json = {},
       path = const [] {
    _calls = calls;
    _identifier = identifier;
    _instances = instances;
    _loadingUnit = loadingUnit;
    json.sortOnKey();
  }

  List<Call>? get calls {
    final jsonValue = _reader.optionalList('calls');
    if (jsonValue == null) return null;
    return [
      for (final (index, element) in jsonValue.indexed)
        Call.fromJson(
          element as Map<String, Object?>,
          path: [...path, 'calls', index],
        ),
    ];
  }

  set _calls(List<Call>? value) {
    if (value == null) {
      json.remove('calls');
    } else {
      json['calls'] = [for (final item in value) item.json];
    }
  }

  List<String> _validateCalls() {
    final listErrors = _reader.validateOptionalList<Map<String, Object?>>(
      'calls',
    );
    if (listErrors.isNotEmpty) {
      return listErrors;
    }
    final elements = calls;
    if (elements == null) {
      return [];
    }
    return [for (final element in elements) ...element.validate()];
  }

  int get identifier => _reader.get<int>('identifier');

  set _identifier(int value) {
    json.setOrRemove('identifier', value);
  }

  List<String> _validateIdentifier() => _reader.validate<int>('identifier');

  List<Instance>? get instances {
    final jsonValue = _reader.optionalList('instances');
    if (jsonValue == null) return null;
    return [
      for (final (index, element) in jsonValue.indexed)
        Instance.fromJson(
          element as Map<String, Object?>,
          path: [...path, 'instances', index],
        ),
    ];
  }

  set _instances(List<Instance>? value) {
    if (value == null) {
      json.remove('instances');
    } else {
      json['instances'] = [for (final item in value) item.json];
    }
  }

  List<String> _validateInstances() {
    final listErrors = _reader.validateOptionalList<Map<String, Object?>>(
      'instances',
    );
    if (listErrors.isNotEmpty) {
      return listErrors;
    }
    final elements = instances;
    if (elements == null) {
      return [];
    }
    return [for (final element in elements) ...element.validate()];
  }

  String? get loadingUnit => _reader.get<String?>('loadingUnit');

  set _loadingUnit(String? value) {
    json.setOrRemove('loadingUnit', value);
  }

  List<String> _validateLoadingUnit() =>
      _reader.validate<String?>('loadingUnit');

  List<String> validate() => [
    ..._validateCalls(),
    ..._validateIdentifier(),
    ..._validateInstances(),
    ..._validateLoadingUnit(),
  ];

  @override
  String toString() => 'Usage($json)';
}

class JsonReader {
  /// The JSON Object this reader is reading.
  final Map<String, Object?> json;

  /// The path traversed by readers of the surrounding JSON.
  ///
  /// Contains [String] property keys and [int] indices.
  ///
  /// This is used to give more precise error messages.
  final List<Object> path;

  JsonReader(this.json, this.path);

  T get<T extends Object?>(String key) {
    final value = json[key];
    if (value is T) return value;
    throwFormatException(value, T, [key]);
  }

  List<String> validate<T extends Object?>(String key) {
    final value = json[key];
    if (value is T) return [];
    return [
      errorString(value, T, [key]),
    ];
  }

  List<T> list<T extends Object?>(String key) =>
      _castList<T>(get<List<Object?>>(key), key);

  List<String> validateList<T extends Object?>(String key) {
    final listErrors = validate<List<Object?>>(key);
    if (listErrors.isNotEmpty) {
      return listErrors;
    }
    return _validateListElements(get<List<Object?>>(key), key);
  }

  List<T>? optionalList<T extends Object?>(String key) =>
      switch (get<List<Object?>?>(key)?.cast<T>()) {
        null => null,
        final l => _castList<T>(l, key),
      };

  List<String> validateOptionalList<T extends Object?>(String key) {
    final listErrors = validate<List<Object?>?>(key);
    if (listErrors.isNotEmpty) {
      return listErrors;
    }
    final list = get<List<Object?>?>(key);
    if (list == null) {
      return [];
    }
    return _validateListElements(list, key);
  }

  /// [List.cast] but with [FormatException]s.
  List<T> _castList<T extends Object?>(List<Object?> list, String key) {
    for (final (index, value) in list.indexed) {
      if (value is! T) {
        throwFormatException(value, T, [key, index]);
      }
    }
    return list.cast();
  }

  List<String> _validateListElements<T extends Object?>(
    List<Object?> list,
    String key,
  ) {
    final result = <String>[];
    for (final (index, value) in list.indexed) {
      if (value is! T) {
        result.add(errorString(value, T, [key, index]));
      }
    }
    return result;
  }

  Map<String, T> map$<T extends Object?>(String key) =>
      _castMap<T>(get<Map<String, Object?>>(key), key);

  List<String> validateMap<T extends Object?>(String key) {
    final mapErrors = validate<Map<String, Object?>>(key);
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    return _validateMapElements<T>(get<Map<String, Object?>>(key), key);
  }

  Map<String, T>? optionalMap<T extends Object?>(String key) =>
      switch (get<Map<String, Object?>?>(key)) {
        null => null,
        final m => _castMap<T>(m, key),
      };

  List<String> validateOptionalMap<T extends Object?>(String key) {
    final mapErrors = validate<Map<String, Object?>?>(key);
    if (mapErrors.isNotEmpty) {
      return mapErrors;
    }
    final map = get<Map<String, Object?>?>(key);
    if (map == null) {
      return [];
    }
    return _validateMapElements<T>(map, key);
  }

  /// [Map.cast] but with [FormatException]s.
  Map<String, T> _castMap<T extends Object?>(
    Map<String, Object?> map_,
    String parentKey,
  ) {
    for (final MapEntry(:key, :value) in map_.entries) {
      if (value is! T) {
        throwFormatException(value, T, [parentKey, key]);
      }
    }
    return map_.cast();
  }

  List<String> _validateMapElements<T extends Object?>(
    Map<String, Object?> map_,
    String parentKey,
  ) {
    final result = <String>[];
    for (final MapEntry(:key, :value) in map_.entries) {
      if (value is! T) {
        result.add(errorString(value, T, [parentKey, key]));
      }
    }
    return result;
  }

  List<String>? optionalStringList(String key) => optionalList<String>(key);

  List<String> validateOptionalStringList(String key) =>
      validateOptionalList<String>(key);

  List<String> stringList(String key) => list<String>(key);

  List<String> validateStringList(String key) => validateList<String>(key);

  Uri path$(String key) => _fileSystemPathToUri(get<String>(key));

  List<String> validatePath(String key) => validate<String>(key);

  Uri? optionalPath(String key) {
    final value = get<String?>(key);
    if (value == null) return null;
    return _fileSystemPathToUri(value);
  }

  List<String> validateOptionalPath(String key) => validate<String?>(key);

  List<Uri>? optionalPathList(String key) {
    final strings = optionalStringList(key);
    if (strings == null) {
      return null;
    }
    return [for (final string in strings) _fileSystemPathToUri(string)];
  }

  List<String> validateOptionalPathList(String key) =>
      validateOptionalStringList(key);

  static Uri _fileSystemPathToUri(String path) {
    if (path.endsWith(Platform.pathSeparator)) {
      return Uri.directory(path);
    }
    return Uri.file(path);
  }

  String _jsonPathToString(List<Object> pathEnding) =>
      [...path, ...pathEnding].join('.');

  Never throwFormatException(
    Object? value,
    Type expectedType,
    List<Object> pathExtension,
  ) {
    throw FormatException(errorString(value, expectedType, pathExtension));
  }

  String errorString(
    Object? value,
    Type expectedType,
    List<Object> pathExtension,
  ) {
    final pathString = _jsonPathToString(pathExtension);
    if (value == null) {
      return "No value was provided for '$pathString'."
          ' Expected a $expectedType.';
    }
    return "Unexpected value '$value' (${value.runtimeType}) for '$pathString'."
        ' Expected a $expectedType.';
  }

  /// Traverses a JSON path, returns `null` if the path cannot be traversed.
  Object? tryTraverse(List<String> path) {
    Object? json = this.json;
    for (final key in path) {
      if (json is! Map<String, Object?>) {
        return null;
      }
      json = json[key];
    }
    return json;
  }
}

extension on Map<String, Object?> {
  void setOrRemove(String key, Object? value) {
    if (value == null) {
      remove(key);
    } else {
      this[key] = value;
    }
  }
}

extension on List<Uri> {
  List<String> toJson() => [for (final uri in this) uri.toFilePath()];
}

extension<K extends Comparable<K>, V extends Object?> on Map<K, V> {
  void sortOnKey() {
    final result = <K, V>{};
    final keysSorted = keys.toList()..sort();
    for (final key in keysSorted) {
      result[key] = this[key] as V;
    }
    clear();
    addAll(result);
  }
}
