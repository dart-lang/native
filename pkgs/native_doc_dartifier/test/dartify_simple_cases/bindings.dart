// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `java.io.RandomAccessFile`
class RandomAccessFile extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<RandomAccessFile> $type;

  @jni$_.internal
  RandomAccessFile.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/RandomAccessFile');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $RandomAccessFile$NullableType();
  static const type = $RandomAccessFile$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory RandomAccessFile(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return RandomAccessFile.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/io/File;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory RandomAccessFile.new$1(File? file, jni$_.JString? string) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return RandomAccessFile.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_getFD = _class.instanceMethodId(
    r'getFD',
    r'()Ljava/io/FileDescriptor;',
  );

  static final _getFD =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.io.FileDescriptor getFD()`
  /// The returned object must be released after use, by calling the [release] method.
  FileDescriptor? getFD() => _getFD(
    reference.pointer,
    _id_getFD as jni$_.JMethodIDPtr,
  ).object<FileDescriptor?>(const $FileDescriptor$NullableType());

  static final _id_getChannel = _class.instanceMethodId(
    r'getChannel',
    r'()Ljava/nio/channels/FileChannel;',
  );

  static final _getChannel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.nio.channels.FileChannel getChannel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChannel() => _getChannel(
    reference.pointer,
    _id_getChannel as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() =>
      _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;

  static final _id_read$1 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read$1(
      reference.pointer,
      _id_read$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_read$2 = _class.instanceMethodId(r'read', r'([B)I');

  static final _read$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(byte[] bs)`
  int read$2(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read$2(
      reference.pointer,
      _id_read$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).integer;
  }

  static final _id_readFully = _class.instanceMethodId(r'readFully', r'([B)V');

  static final _readFully =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void readFully(byte[] bs)`
  void readFully(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully(
      reference.pointer,
      _id_readFully as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_readFully$1 = _class.instanceMethodId(
    r'readFully',
    r'([BII)V',
  );

  static final _readFully$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public final void readFully(byte[] bs, int i, int i1)`
  void readFully$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully$1(
      reference.pointer,
      _id_readFully$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_skipBytes = _class.instanceMethodId(r'skipBytes', r'(I)I');

  static final _skipBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int skipBytes(int i)`
  int skipBytes(int i) =>
      _skipBytes(
        reference.pointer,
        _id_skipBytes as jni$_.JMethodIDPtr,
        i,
      ).integer;

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write$1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(byte[] bs)`
  void write$1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$1(
      reference.pointer,
      _id_write$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_write$2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write$2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$2(
      reference.pointer,
      _id_write$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_getFilePointer = _class.instanceMethodId(
    r'getFilePointer',
    r'()J',
  );

  static final _getFilePointer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public native long getFilePointer()`
  int getFilePointer() =>
      _getFilePointer(
        reference.pointer,
        _id_getFilePointer as jni$_.JMethodIDPtr,
      ).long;

  static final _id_seek = _class.instanceMethodId(r'seek', r'(J)V');

  static final _seek =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void seek(long j)`
  void seek(int j) {
    _seek(reference.pointer, _id_seek as jni$_.JMethodIDPtr, j).check();
  }

  static final _id_length = _class.instanceMethodId(r'length', r'()J');

  static final _length =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public native long length()`
  int length() =>
      _length(reference.pointer, _id_length as jni$_.JMethodIDPtr).long;

  static final _id_setLength = _class.instanceMethodId(r'setLength', r'(J)V');

  static final _setLength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public native void setLength(long j)`
  void setLength(int j) {
    _setLength(
      reference.pointer,
      _id_setLength as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_readBoolean = _class.instanceMethodId(
    r'readBoolean',
    r'()Z',
  );

  static final _readBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean readBoolean()`
  bool readBoolean() =>
      _readBoolean(
        reference.pointer,
        _id_readBoolean as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_readByte = _class.instanceMethodId(r'readByte', r'()B');

  static final _readByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final byte readByte()`
  int readByte() =>
      _readByte(reference.pointer, _id_readByte as jni$_.JMethodIDPtr).byte;

  static final _id_readUnsignedByte = _class.instanceMethodId(
    r'readUnsignedByte',
    r'()I',
  );

  static final _readUnsignedByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int readUnsignedByte()`
  int readUnsignedByte() =>
      _readUnsignedByte(
        reference.pointer,
        _id_readUnsignedByte as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_readShort = _class.instanceMethodId(r'readShort', r'()S');

  static final _readShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final short readShort()`
  int readShort() =>
      _readShort(reference.pointer, _id_readShort as jni$_.JMethodIDPtr).short;

  static final _id_readUnsignedShort = _class.instanceMethodId(
    r'readUnsignedShort',
    r'()I',
  );

  static final _readUnsignedShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int readUnsignedShort()`
  int readUnsignedShort() =>
      _readUnsignedShort(
        reference.pointer,
        _id_readUnsignedShort as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_readChar = _class.instanceMethodId(r'readChar', r'()C');

  static final _readChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final char readChar()`
  int readChar() =>
      _readChar(reference.pointer, _id_readChar as jni$_.JMethodIDPtr).char;

  static final _id_readInt = _class.instanceMethodId(r'readInt', r'()I');

  static final _readInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int readInt()`
  int readInt() =>
      _readInt(reference.pointer, _id_readInt as jni$_.JMethodIDPtr).integer;

  static final _id_readLong = _class.instanceMethodId(r'readLong', r'()J');

  static final _readLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long readLong()`
  int readLong() =>
      _readLong(reference.pointer, _id_readLong as jni$_.JMethodIDPtr).long;

  static final _id_readFloat = _class.instanceMethodId(r'readFloat', r'()F');

  static final _readFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final float readFloat()`
  double readFloat() =>
      _readFloat(reference.pointer, _id_readFloat as jni$_.JMethodIDPtr).float;

  static final _id_readDouble = _class.instanceMethodId(r'readDouble', r'()D');

  static final _readDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final double readDouble()`
  double readDouble() =>
      _readDouble(
        reference.pointer,
        _id_readDouble as jni$_.JMethodIDPtr,
      ).doubleFloat;

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine() => _readLine(
    reference.pointer,
    _id_readLine as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_readUTF = _class.instanceMethodId(
    r'readUTF',
    r'()Ljava/lang/String;',
  );

  static final _readUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String readUTF()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readUTF() => _readUTF(
    reference.pointer,
    _id_readUTF as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_writeBoolean = _class.instanceMethodId(
    r'writeBoolean',
    r'(Z)V',
  );

  static final _writeBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeBoolean(boolean z)`
  void writeBoolean(bool z) {
    _writeBoolean(
      reference.pointer,
      _id_writeBoolean as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_writeByte = _class.instanceMethodId(r'writeByte', r'(I)V');

  static final _writeByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeByte(int i)`
  void writeByte(int i) {
    _writeByte(
      reference.pointer,
      _id_writeByte as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeShort = _class.instanceMethodId(r'writeShort', r'(I)V');

  static final _writeShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeShort(int i)`
  void writeShort(int i) {
    _writeShort(
      reference.pointer,
      _id_writeShort as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeChar = _class.instanceMethodId(r'writeChar', r'(I)V');

  static final _writeChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeChar(int i)`
  void writeChar(int i) {
    _writeChar(
      reference.pointer,
      _id_writeChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeInt = _class.instanceMethodId(r'writeInt', r'(I)V');

  static final _writeInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeInt(int i)`
  void writeInt(int i) {
    _writeInt(reference.pointer, _id_writeInt as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_writeLong = _class.instanceMethodId(r'writeLong', r'(J)V');

  static final _writeLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeLong(long j)`
  void writeLong(int j) {
    _writeLong(
      reference.pointer,
      _id_writeLong as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_writeFloat = _class.instanceMethodId(r'writeFloat', r'(F)V');

  static final _writeFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public final void writeFloat(float f)`
  void writeFloat(double f) {
    _writeFloat(
      reference.pointer,
      _id_writeFloat as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_writeDouble = _class.instanceMethodId(
    r'writeDouble',
    r'(D)V',
  );

  static final _writeDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public final void writeDouble(double d)`
  void writeDouble(double d) {
    _writeDouble(
      reference.pointer,
      _id_writeDouble as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'(Ljava/lang/String;)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void writeBytes(java.lang.String string)`
  void writeBytes(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeChars = _class.instanceMethodId(
    r'writeChars',
    r'(Ljava/lang/String;)V',
  );

  static final _writeChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void writeChars(java.lang.String string)`
  void writeChars(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeChars(
      reference.pointer,
      _id_writeChars as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeUTF = _class.instanceMethodId(
    r'writeUTF',
    r'(Ljava/lang/String;)V',
  );

  static final _writeUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void writeUTF(java.lang.String string)`
  void writeUTF(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeUTF(
      reference.pointer,
      _id_writeUTF as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }
}

final class $RandomAccessFile$NullableType
    extends jni$_.JObjType<RandomAccessFile?> {
  @jni$_.internal
  const $RandomAccessFile$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/RandomAccessFile;';

  @jni$_.internal
  @core$_.override
  RandomAccessFile? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : RandomAccessFile.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RandomAccessFile?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RandomAccessFile$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($RandomAccessFile$NullableType) &&
      other is $RandomAccessFile$NullableType;
}

final class $RandomAccessFile$Type extends jni$_.JObjType<RandomAccessFile> {
  @jni$_.internal
  const $RandomAccessFile$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/RandomAccessFile;';

  @jni$_.internal
  @core$_.override
  RandomAccessFile fromReference(jni$_.JReference reference) =>
      RandomAccessFile.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RandomAccessFile?> get nullableType =>
      const $RandomAccessFile$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RandomAccessFile$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($RandomAccessFile$Type) &&
      other is $RandomAccessFile$Type;
}

/// from: `java.io.BufferedInputStream`
class BufferedInputStream extends FilterInputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<BufferedInputStream> $type;

  @jni$_.internal
  BufferedInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/BufferedInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $BufferedInputStream$NullableType();
  static const type = $BufferedInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/InputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedInputStream(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return BufferedInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/InputStream;I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedInputStream.new$1(InputStream? inputStream, int i) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return BufferedInputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
        i,
      ).reference,
    );
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() =>
      _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() =>
      _available(
        reference.pointer,
        _id_available as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() =>
      _markSupported(
        reference.pointer,
        _id_markSupported as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $BufferedInputStream$NullableType
    extends jni$_.JObjType<BufferedInputStream?> {
  @jni$_.internal
  const $BufferedInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedInputStream;';

  @jni$_.internal
  @core$_.override
  BufferedInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : BufferedInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($BufferedInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($BufferedInputStream$NullableType) &&
      other is $BufferedInputStream$NullableType;
}

final class $BufferedInputStream$Type
    extends jni$_.JObjType<BufferedInputStream> {
  @jni$_.internal
  const $BufferedInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedInputStream;';

  @jni$_.internal
  @core$_.override
  BufferedInputStream fromReference(jni$_.JReference reference) =>
      BufferedInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedInputStream?> get nullableType =>
      const $BufferedInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($BufferedInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($BufferedInputStream$Type) &&
      other is $BufferedInputStream$Type;
}

/// from: `java.io.CharArrayReader`
class CharArrayReader extends Reader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CharArrayReader> $type;

  @jni$_.internal
  CharArrayReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/CharArrayReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CharArrayReader$NullableType();
  static const type = $CharArrayReader$Type();
  static final _id_new$ = _class.constructorId(r'([C)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(char[] cs)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CharArrayReader(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return CharArrayReader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$cs.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'([CII)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void <init>(char[] cs, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CharArrayReader.new$1(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return CharArrayReader.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$cs.pointer,
        i,
        i1,
      ).reference,
    );
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() =>
      _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_read = _class.instanceMethodId(
    r'read',
    r'(Ljava/nio/CharBuffer;)I',
  );

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(java.nio.CharBuffer charBuffer)`
  int read(jni$_.JObject? charBuffer) {
    final _$charBuffer = charBuffer?.reference ?? jni$_.jNullReference;
    return _read(
      reference.pointer,
      _id_read as jni$_.JMethodIDPtr,
      _$charBuffer.pointer,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() =>
      _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() =>
      _markSupported(
        reference.pointer,
        _id_markSupported as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $CharArrayReader$NullableType
    extends jni$_.JObjType<CharArrayReader?> {
  @jni$_.internal
  const $CharArrayReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/CharArrayReader;';

  @jni$_.internal
  @core$_.override
  CharArrayReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CharArrayReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CharArrayReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($CharArrayReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CharArrayReader$NullableType) &&
      other is $CharArrayReader$NullableType;
}

final class $CharArrayReader$Type extends jni$_.JObjType<CharArrayReader> {
  @jni$_.internal
  const $CharArrayReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/CharArrayReader;';

  @jni$_.internal
  @core$_.override
  CharArrayReader fromReference(jni$_.JReference reference) =>
      CharArrayReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CharArrayReader?> get nullableType =>
      const $CharArrayReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($CharArrayReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CharArrayReader$Type) &&
      other is $CharArrayReader$Type;
}

/// from: `java.io.ObjectOutputStream$PutField`
class ObjectOutputStream$PutField extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectOutputStream$PutField> $type;

  @jni$_.internal
  ObjectOutputStream$PutField.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/ObjectOutputStream$PutField',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectOutputStream$PutField$NullableType();
  static const type = $ObjectOutputStream$PutField$Type();
  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;Z)V',
  );

  static final _put =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, boolean z)`
  void put(jni$_.JString? string, bool z) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put(
      reference.pointer,
      _id_put as jni$_.JMethodIDPtr,
      _$string.pointer,
      z ? 1 : 0,
    ).check();
  }

  static final _id_put$1 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;B)V',
  );

  static final _put$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, byte b)`
  void put$1(jni$_.JString? string, int b) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put$1(
      reference.pointer,
      _id_put$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      b,
    ).check();
  }

  static final _id_put$2 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;C)V',
  );

  static final _put$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, char c)`
  void put$2(jni$_.JString? string, int c) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put$2(
      reference.pointer,
      _id_put$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      c,
    ).check();
  }

  static final _id_put$3 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;S)V',
  );

  static final _put$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, short s)`
  void put$3(jni$_.JString? string, int s) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put$3(
      reference.pointer,
      _id_put$3 as jni$_.JMethodIDPtr,
      _$string.pointer,
      s,
    ).check();
  }

  static final _id_put$4 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;I)V',
  );

  static final _put$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, int i)`
  void put$4(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put$4(
      reference.pointer,
      _id_put$4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
    ).check();
  }

  static final _id_put$5 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;J)V',
  );

  static final _put$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, long j)`
  void put$5(jni$_.JString? string, int j) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put$5(
      reference.pointer,
      _id_put$5 as jni$_.JMethodIDPtr,
      _$string.pointer,
      j,
    ).check();
  }

  static final _id_put$6 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;F)V',
  );

  static final _put$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Double)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              double,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, float f)`
  void put$6(jni$_.JString? string, double f) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put$6(
      reference.pointer,
      _id_put$6 as jni$_.JMethodIDPtr,
      _$string.pointer,
      f,
    ).check();
  }

  static final _id_put$7 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;D)V',
  );

  static final _put$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Double)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              double,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, double d)`
  void put$7(jni$_.JString? string, double d) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put$7(
      reference.pointer,
      _id_put$7 as jni$_.JMethodIDPtr,
      _$string.pointer,
      d,
    ).check();
  }

  static final _id_put$8 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;Ljava/lang/Object;)V',
  );

  static final _put$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, java.lang.Object object)`
  void put$8(jni$_.JString? string, jni$_.JObject? object) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _put$8(
      reference.pointer,
      _id_put$8 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$object.pointer,
    ).check();
  }

  static final _id_write = _class.instanceMethodId(
    r'write',
    r'(Ljava/io/ObjectOutput;)V',
  );

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void write(java.io.ObjectOutput objectOutput)`
  void write(ObjectOutput? objectOutput) {
    final _$objectOutput = objectOutput?.reference ?? jni$_.jNullReference;
    _write(
      reference.pointer,
      _id_write as jni$_.JMethodIDPtr,
      _$objectOutput.pointer,
    ).check();
  }
}

final class $ObjectOutputStream$PutField$NullableType
    extends jni$_.JObjType<ObjectOutputStream$PutField?> {
  @jni$_.internal
  const $ObjectOutputStream$PutField$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectOutputStream$PutField;';

  @jni$_.internal
  @core$_.override
  ObjectOutputStream$PutField? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ObjectOutputStream$PutField.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectOutputStream$PutField?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectOutputStream$PutField$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectOutputStream$PutField$NullableType) &&
      other is $ObjectOutputStream$PutField$NullableType;
}

final class $ObjectOutputStream$PutField$Type
    extends jni$_.JObjType<ObjectOutputStream$PutField> {
  @jni$_.internal
  const $ObjectOutputStream$PutField$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectOutputStream$PutField;';

  @jni$_.internal
  @core$_.override
  ObjectOutputStream$PutField fromReference(jni$_.JReference reference) =>
      ObjectOutputStream$PutField.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectOutputStream$PutField?> get nullableType =>
      const $ObjectOutputStream$PutField$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectOutputStream$PutField$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectOutputStream$PutField$Type) &&
      other is $ObjectOutputStream$PutField$Type;
}

/// from: `java.io.PushbackInputStream`
class PushbackInputStream extends FilterInputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PushbackInputStream> $type;

  @jni$_.internal
  PushbackInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PushbackInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PushbackInputStream$NullableType();
  static const type = $PushbackInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/InputStream;I)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PushbackInputStream(InputStream? inputStream, int i) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return PushbackInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/InputStream;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PushbackInputStream.new$1(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return PushbackInputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
      ).reference,
    );
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() =>
      _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_unread = _class.instanceMethodId(r'unread', r'(I)V');

  static final _unread =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void unread(int i)`
  void unread(int i) {
    _unread(reference.pointer, _id_unread as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_unread$1 = _class.instanceMethodId(r'unread', r'([BII)V');

  static final _unread$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void unread(byte[] bs, int i, int i1)`
  void unread$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _unread$1(
      reference.pointer,
      _id_unread$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_unread$2 = _class.instanceMethodId(r'unread', r'([B)V');

  static final _unread$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void unread(byte[] bs)`
  void unread$2(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _unread$2(
      reference.pointer,
      _id_unread$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() =>
      _available(
        reference.pointer,
        _id_available as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() =>
      _markSupported(
        reference.pointer,
        _id_markSupported as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $PushbackInputStream$NullableType
    extends jni$_.JObjType<PushbackInputStream?> {
  @jni$_.internal
  const $PushbackInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PushbackInputStream;';

  @jni$_.internal
  @core$_.override
  PushbackInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PushbackInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PushbackInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($PushbackInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PushbackInputStream$NullableType) &&
      other is $PushbackInputStream$NullableType;
}

final class $PushbackInputStream$Type
    extends jni$_.JObjType<PushbackInputStream> {
  @jni$_.internal
  const $PushbackInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PushbackInputStream;';

  @jni$_.internal
  @core$_.override
  PushbackInputStream fromReference(jni$_.JReference reference) =>
      PushbackInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PushbackInputStream?> get nullableType =>
      const $PushbackInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($PushbackInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PushbackInputStream$Type) &&
      other is $PushbackInputStream$Type;
}

/// from: `java.io.FilterReader`
class FilterReader extends Reader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FilterReader> $type;

  @jni$_.internal
  FilterReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FilterReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FilterReader$NullableType();
  static const type = $FilterReader$Type();
  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() =>
      _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() =>
      _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() =>
      _markSupported(
        reference.pointer,
        _id_markSupported as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $FilterReader$NullableType extends jni$_.JObjType<FilterReader?> {
  @jni$_.internal
  const $FilterReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterReader;';

  @jni$_.internal
  @core$_.override
  FilterReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FilterReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FilterReader$NullableType) &&
      other is $FilterReader$NullableType;
}

final class $FilterReader$Type extends jni$_.JObjType<FilterReader> {
  @jni$_.internal
  const $FilterReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterReader;';

  @jni$_.internal
  @core$_.override
  FilterReader fromReference(jni$_.JReference reference) =>
      FilterReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterReader?> get nullableType =>
      const $FilterReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FilterReader$Type) && other is $FilterReader$Type;
}

/// from: `java.io.DataOutputStream`
class DataOutputStream extends FilterOutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DataOutputStream> $type;

  @jni$_.internal
  DataOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/DataOutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DataOutputStream$NullableType();
  static const type = $DataOutputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DataOutputStream(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return DataOutputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_writeBoolean = _class.instanceMethodId(
    r'writeBoolean',
    r'(Z)V',
  );

  static final _writeBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeBoolean(boolean z)`
  void writeBoolean(bool z) {
    _writeBoolean(
      reference.pointer,
      _id_writeBoolean as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_writeByte = _class.instanceMethodId(r'writeByte', r'(I)V');

  static final _writeByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeByte(int i)`
  void writeByte(int i) {
    _writeByte(
      reference.pointer,
      _id_writeByte as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeShort = _class.instanceMethodId(r'writeShort', r'(I)V');

  static final _writeShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeShort(int i)`
  void writeShort(int i) {
    _writeShort(
      reference.pointer,
      _id_writeShort as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeChar = _class.instanceMethodId(r'writeChar', r'(I)V');

  static final _writeChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeChar(int i)`
  void writeChar(int i) {
    _writeChar(
      reference.pointer,
      _id_writeChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeInt = _class.instanceMethodId(r'writeInt', r'(I)V');

  static final _writeInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeInt(int i)`
  void writeInt(int i) {
    _writeInt(reference.pointer, _id_writeInt as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_writeLong = _class.instanceMethodId(r'writeLong', r'(J)V');

  static final _writeLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeLong(long j)`
  void writeLong(int j) {
    _writeLong(
      reference.pointer,
      _id_writeLong as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_writeFloat = _class.instanceMethodId(r'writeFloat', r'(F)V');

  static final _writeFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public final void writeFloat(float f)`
  void writeFloat(double f) {
    _writeFloat(
      reference.pointer,
      _id_writeFloat as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_writeDouble = _class.instanceMethodId(
    r'writeDouble',
    r'(D)V',
  );

  static final _writeDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public final void writeDouble(double d)`
  void writeDouble(double d) {
    _writeDouble(
      reference.pointer,
      _id_writeDouble as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'(Ljava/lang/String;)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void writeBytes(java.lang.String string)`
  void writeBytes(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeChars = _class.instanceMethodId(
    r'writeChars',
    r'(Ljava/lang/String;)V',
  );

  static final _writeChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void writeChars(java.lang.String string)`
  void writeChars(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeChars(
      reference.pointer,
      _id_writeChars as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeUTF = _class.instanceMethodId(
    r'writeUTF',
    r'(Ljava/lang/String;)V',
  );

  static final _writeUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void writeUTF(java.lang.String string)`
  void writeUTF(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeUTF(
      reference.pointer,
      _id_writeUTF as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_size = _class.instanceMethodId(r'size', r'()I');

  static final _size =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int size()`
  int size() =>
      _size(reference.pointer, _id_size as jni$_.JMethodIDPtr).integer;

  static final _id_write1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void write(byte[] bs)`
  void write1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write1(
      reference.pointer,
      _id_write1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }
}

final class $DataOutputStream$NullableType
    extends jni$_.JObjType<DataOutputStream?> {
  @jni$_.internal
  const $DataOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataOutputStream;';

  @jni$_.internal
  @core$_.override
  DataOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DataOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($DataOutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DataOutputStream$NullableType) &&
      other is $DataOutputStream$NullableType;
}

final class $DataOutputStream$Type extends jni$_.JObjType<DataOutputStream> {
  @jni$_.internal
  const $DataOutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataOutputStream;';

  @jni$_.internal
  @core$_.override
  DataOutputStream fromReference(jni$_.JReference reference) =>
      DataOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataOutputStream?> get nullableType =>
      const $DataOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($DataOutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DataOutputStream$Type) &&
      other is $DataOutputStream$Type;
}

/// from: `java.io.PipedInputStream`
class PipedInputStream extends InputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PipedInputStream> $type;

  @jni$_.internal
  PipedInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PipedInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PipedInputStream$NullableType();
  static const type = $PipedInputStream$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/io/PipedOutputStream;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.PipedOutputStream pipedOutputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedInputStream(PipedOutputStream? pipedOutputStream) {
    final _$pipedOutputStream =
        pipedOutputStream?.reference ?? jni$_.jNullReference;
    return PipedInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$pipedOutputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/io/PipedOutputStream;I)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.PipedOutputStream pipedOutputStream, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedInputStream.new$1(PipedOutputStream? pipedOutputStream, int i) {
    final _$pipedOutputStream =
        pipedOutputStream?.reference ?? jni$_.jNullReference;
    return PipedInputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$pipedOutputStream.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'()V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedInputStream.new$2() => PipedInputStream.fromReference(
    _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$3 = _class.constructorId(r'(I)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedInputStream.new$3(int i) => PipedInputStream.fromReference(
    _new$3(
      _class.reference.pointer,
      _id_new$3 as jni$_.JMethodIDPtr,
      i,
    ).reference,
  );

  static final _id_connect = _class.instanceMethodId(
    r'connect',
    r'(Ljava/io/PipedOutputStream;)V',
  );

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void connect(java.io.PipedOutputStream pipedOutputStream)`
  void connect(PipedOutputStream? pipedOutputStream) {
    final _$pipedOutputStream =
        pipedOutputStream?.reference ?? jni$_.jNullReference;
    _connect(
      reference.pointer,
      _id_connect as jni$_.JMethodIDPtr,
      _$pipedOutputStream.pointer,
    ).check();
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() =>
      _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() =>
      _available(
        reference.pointer,
        _id_available as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $PipedInputStream$NullableType
    extends jni$_.JObjType<PipedInputStream?> {
  @jni$_.internal
  const $PipedInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedInputStream;';

  @jni$_.internal
  @core$_.override
  PipedInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PipedInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PipedInputStream$NullableType) &&
      other is $PipedInputStream$NullableType;
}

final class $PipedInputStream$Type extends jni$_.JObjType<PipedInputStream> {
  @jni$_.internal
  const $PipedInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedInputStream;';

  @jni$_.internal
  @core$_.override
  PipedInputStream fromReference(jni$_.JReference reference) =>
      PipedInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedInputStream?> get nullableType =>
      const $PipedInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PipedInputStream$Type) &&
      other is $PipedInputStream$Type;
}

/// from: `java.io.FilePermission`
class FilePermission extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FilePermission> $type;

  @jni$_.internal
  FilePermission.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FilePermission');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FilePermission$NullableType();
  static const type = $FilePermission$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FilePermission(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return FilePermission.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_implies = _class.instanceMethodId(
    r'implies',
    r'(Ljava/security/Permission;)Z',
  );

  static final _implies =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean implies(java.security.Permission permission)`
  bool implies(jni$_.JObject? permission) {
    final _$permission = permission?.reference ?? jni$_.jNullReference;
    return _implies(
      reference.pointer,
      _id_implies as jni$_.JMethodIDPtr,
      _$permission.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getActions = _class.instanceMethodId(
    r'getActions',
    r'()Ljava/lang/String;',
  );

  static final _getActions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getActions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getActions() => _getActions(
    reference.pointer,
    _id_getActions as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_newPermissionCollection = _class.instanceMethodId(
    r'newPermissionCollection',
    r'()Ljava/security/PermissionCollection;',
  );

  static final _newPermissionCollection =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.security.PermissionCollection newPermissionCollection()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? newPermissionCollection() => _newPermissionCollection(
    reference.pointer,
    _id_newPermissionCollection as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
}

final class $FilePermission$NullableType
    extends jni$_.JObjType<FilePermission?> {
  @jni$_.internal
  const $FilePermission$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilePermission;';

  @jni$_.internal
  @core$_.override
  FilePermission? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FilePermission.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilePermission?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FilePermission$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FilePermission$NullableType) &&
      other is $FilePermission$NullableType;
}

final class $FilePermission$Type extends jni$_.JObjType<FilePermission> {
  @jni$_.internal
  const $FilePermission$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilePermission;';

  @jni$_.internal
  @core$_.override
  FilePermission fromReference(jni$_.JReference reference) =>
      FilePermission.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilePermission?> get nullableType =>
      const $FilePermission$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FilePermission$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FilePermission$Type) &&
      other is $FilePermission$Type;
}

/// from: `java.io.InvalidObjectException`
class InvalidObjectException extends ObjectStreamException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InvalidObjectException> $type;

  @jni$_.internal
  InvalidObjectException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/InvalidObjectException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InvalidObjectException$NullableType();
  static const type = $InvalidObjectException$Type();
  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InvalidObjectException.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return InvalidObjectException.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $InvalidObjectException$NullableType
    extends jni$_.JObjType<InvalidObjectException?> {
  @jni$_.internal
  const $InvalidObjectException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InvalidObjectException;';

  @jni$_.internal
  @core$_.override
  InvalidObjectException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InvalidObjectException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InvalidObjectException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($InvalidObjectException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InvalidObjectException$NullableType) &&
      other is $InvalidObjectException$NullableType;
}

final class $InvalidObjectException$Type
    extends jni$_.JObjType<InvalidObjectException> {
  @jni$_.internal
  const $InvalidObjectException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InvalidObjectException;';

  @jni$_.internal
  @core$_.override
  InvalidObjectException fromReference(jni$_.JReference reference) =>
      InvalidObjectException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InvalidObjectException?> get nullableType =>
      const $InvalidObjectException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($InvalidObjectException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InvalidObjectException$Type) &&
      other is $InvalidObjectException$Type;
}

/// from: `java.io.ObjectStreamField`
class ObjectStreamField extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectStreamField> $type;

  @jni$_.internal
  ObjectStreamField.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectStreamField');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectStreamField$NullableType();
  static const type = $ObjectStreamField$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/Class;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.Class<?> class)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ObjectStreamField(jni$_.JString? string, jni$_.JObject? class$) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    return ObjectStreamField.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$class$.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/Class;Z)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.Class<?> class, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ObjectStreamField.new$1(
    jni$_.JString? string,
    jni$_.JObject? class$,
    bool z,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    return ObjectStreamField.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$class$.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() => _getName(
    reference.pointer,
    _id_getName as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Ljava/lang/Class;',
  );

  static final _getType =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Class<?> getType()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getType() => _getType(
    reference.pointer,
    _id_getType as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getTypeCode = _class.instanceMethodId(
    r'getTypeCode',
    r'()C',
  );

  static final _getTypeCode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char getTypeCode()`
  int getTypeCode() =>
      _getTypeCode(
        reference.pointer,
        _id_getTypeCode as jni$_.JMethodIDPtr,
      ).char;

  static final _id_getTypeString = _class.instanceMethodId(
    r'getTypeString',
    r'()Ljava/lang/String;',
  );

  static final _getTypeString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getTypeString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getTypeString() => _getTypeString(
    reference.pointer,
    _id_getTypeString as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getOffset = _class.instanceMethodId(r'getOffset', r'()I');

  static final _getOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getOffset()`
  int getOffset() =>
      _getOffset(
        reference.pointer,
        _id_getOffset as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_isPrimitive = _class.instanceMethodId(
    r'isPrimitive',
    r'()Z',
  );

  static final _isPrimitive =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isPrimitive()`
  bool isPrimitive() =>
      _isPrimitive(
        reference.pointer,
        _id_isPrimitive as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isUnshared = _class.instanceMethodId(r'isUnshared', r'()Z');

  static final _isUnshared =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isUnshared()`
  bool isUnshared() =>
      _isUnshared(
        reference.pointer,
        _id_isUnshared as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/lang/Object;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.lang.Object object)`
  int compareTo(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $ObjectStreamField$NullableType
    extends jni$_.JObjType<ObjectStreamField?> {
  @jni$_.internal
  const $ObjectStreamField$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamField;';

  @jni$_.internal
  @core$_.override
  ObjectStreamField? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectStreamField.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamField?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectStreamField$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectStreamField$NullableType) &&
      other is $ObjectStreamField$NullableType;
}

final class $ObjectStreamField$Type extends jni$_.JObjType<ObjectStreamField> {
  @jni$_.internal
  const $ObjectStreamField$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamField;';

  @jni$_.internal
  @core$_.override
  ObjectStreamField fromReference(jni$_.JReference reference) =>
      ObjectStreamField.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamField?> get nullableType =>
      const $ObjectStreamField$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectStreamField$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectStreamField$Type) &&
      other is $ObjectStreamField$Type;
}

/// from: `java.io.PrintWriter`
class PrintWriter extends Writer {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PrintWriter> $type;

  @jni$_.internal
  PrintWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PrintWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PrintWriter$NullableType();
  static const type = $PrintWriter$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/Writer;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.Writer writer)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter(Writer? writer) {
    final _$writer = writer?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$writer.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/Writer;Z)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.Writer writer, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$1(Writer? writer, bool z) {
    final _$writer = writer?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$writer.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$2(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(Ljava/io/OutputStream;Z)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$3(OutputStream? outputStream, bool z) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(
    r'(Ljava/io/OutputStream;ZLjava/nio/charset/Charset;)V',
  );

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, boolean z, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$4(
    OutputStream? outputStream,
    bool z,
    jni$_.JObject? charset,
  ) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        z ? 1 : 0,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$5(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$6 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$6(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$6(
        _class.reference.pointer,
        _id_new$6 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_new$7 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;)V',
  );

  static final _new$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$7(jni$_.JString? string, jni$_.JObject? charset) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$7(
        _class.reference.pointer,
        _id_new$7 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$8 = _class.constructorId(r'(Ljava/io/File;)V');

  static final _new$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$8(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$8(
        _class.reference.pointer,
        _id_new$8 as jni$_.JMethodIDPtr,
        _$file.pointer,
      ).reference,
    );
  }

  static final _id_new$9 = _class.constructorId(
    r'(Ljava/io/File;Ljava/lang/String;)V',
  );

  static final _new$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$9(File? file, jni$_.JString? string) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$9(
        _class.reference.pointer,
        _id_new$9 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$10 = _class.constructorId(
    r'(Ljava/io/File;Ljava/nio/charset/Charset;)V',
  );

  static final _new$10 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$10(File? file, jni$_.JObject? charset) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$10(
        _class.reference.pointer,
        _id_new$10 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_checkError = _class.instanceMethodId(r'checkError', r'()Z');

  static final _checkError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean checkError()`
  bool checkError() =>
      _checkError(
        reference.pointer,
        _id_checkError as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(char[] cs, int i, int i1)`
  void write2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write1 = _class.instanceMethodId(r'write', r'([C)V');

  static final _write1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(char[] cs)`
  void write1(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write1(
      reference.pointer,
      _id_write1 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).check();
  }

  static final _id_write4 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;II)V',
  );

  static final _write4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(java.lang.String string, int i, int i1)`
  void write4(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write4(
      reference.pointer,
      _id_write4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write3 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;)V',
  );

  static final _write3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(java.lang.String string)`
  void write3(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write3(
      reference.pointer,
      _id_write3 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_print = _class.instanceMethodId(r'print', r'(Z)V');

  static final _print =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(boolean z)`
  void print(bool z) {
    _print(
      reference.pointer,
      _id_print as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_print$1 = _class.instanceMethodId(r'print', r'(C)V');

  static final _print$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(char c)`
  void print$1(int c) {
    _print$1(reference.pointer, _id_print$1 as jni$_.JMethodIDPtr, c).check();
  }

  static final _id_print$2 = _class.instanceMethodId(r'print', r'(I)V');

  static final _print$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(int i)`
  void print$2(int i) {
    _print$2(reference.pointer, _id_print$2 as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_print$3 = _class.instanceMethodId(r'print', r'(J)V');

  static final _print$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(long j)`
  void print$3(int j) {
    _print$3(reference.pointer, _id_print$3 as jni$_.JMethodIDPtr, j).check();
  }

  static final _id_print$4 = _class.instanceMethodId(r'print', r'(F)V');

  static final _print$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void print(float f)`
  void print$4(double f) {
    _print$4(reference.pointer, _id_print$4 as jni$_.JMethodIDPtr, f).check();
  }

  static final _id_print$5 = _class.instanceMethodId(r'print', r'(D)V');

  static final _print$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void print(double d)`
  void print$5(double d) {
    _print$5(reference.pointer, _id_print$5 as jni$_.JMethodIDPtr, d).check();
  }

  static final _id_print$6 = _class.instanceMethodId(r'print', r'([C)V');

  static final _print$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void print(char[] cs)`
  void print$6(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _print$6(
      reference.pointer,
      _id_print$6 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).check();
  }

  static final _id_print$7 = _class.instanceMethodId(
    r'print',
    r'(Ljava/lang/String;)V',
  );

  static final _print$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void print(java.lang.String string)`
  void print$7(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _print$7(
      reference.pointer,
      _id_print$7 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_print$8 = _class.instanceMethodId(
    r'print',
    r'(Ljava/lang/Object;)V',
  );

  static final _print$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void print(java.lang.Object object)`
  void print$8(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _print$8(
      reference.pointer,
      _id_print$8 as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_println = _class.instanceMethodId(r'println', r'()V');

  static final _println =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void println()`
  void println() {
    _println(reference.pointer, _id_println as jni$_.JMethodIDPtr).check();
  }

  static final _id_println$1 = _class.instanceMethodId(r'println', r'(Z)V');

  static final _println$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(boolean z)`
  void println$1(bool z) {
    _println$1(
      reference.pointer,
      _id_println$1 as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_println$2 = _class.instanceMethodId(r'println', r'(C)V');

  static final _println$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(char c)`
  void println$2(int c) {
    _println$2(
      reference.pointer,
      _id_println$2 as jni$_.JMethodIDPtr,
      c,
    ).check();
  }

  static final _id_println$3 = _class.instanceMethodId(r'println', r'(I)V');

  static final _println$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(int i)`
  void println$3(int i) {
    _println$3(
      reference.pointer,
      _id_println$3 as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_println$4 = _class.instanceMethodId(r'println', r'(J)V');

  static final _println$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(long j)`
  void println$4(int j) {
    _println$4(
      reference.pointer,
      _id_println$4 as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_println$5 = _class.instanceMethodId(r'println', r'(F)V');

  static final _println$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void println(float f)`
  void println$5(double f) {
    _println$5(
      reference.pointer,
      _id_println$5 as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_println$6 = _class.instanceMethodId(r'println', r'(D)V');

  static final _println$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void println(double d)`
  void println$6(double d) {
    _println$6(
      reference.pointer,
      _id_println$6 as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_println$7 = _class.instanceMethodId(r'println', r'([C)V');

  static final _println$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void println(char[] cs)`
  void println$7(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _println$7(
      reference.pointer,
      _id_println$7 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).check();
  }

  static final _id_println$8 = _class.instanceMethodId(
    r'println',
    r'(Ljava/lang/String;)V',
  );

  static final _println$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void println(java.lang.String string)`
  void println$8(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _println$8(
      reference.pointer,
      _id_println$8 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_println$9 = _class.instanceMethodId(
    r'println',
    r'(Ljava/lang/Object;)V',
  );

  static final _println$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void println(java.lang.Object object)`
  void println$9(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _println$9(
      reference.pointer,
      _id_println$9 as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_printf = _class.instanceMethodId(
    r'printf',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintWriter;',
  );

  static final _printf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintWriter printf(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? printf(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _printf(
      reference.pointer,
      _id_printf as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintWriter?>(const $PrintWriter$NullableType());
  }

  static final _id_printf$1 = _class.instanceMethodId(
    r'printf',
    r'(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintWriter;',
  );

  static final _printf$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintWriter printf(java.util.Locale locale, java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? printf$1(
    jni$_.JObject? locale,
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _printf$1(
      reference.pointer,
      _id_printf$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintWriter?>(const $PrintWriter$NullableType());
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintWriter;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintWriter format(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? format(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintWriter?>(const $PrintWriter$NullableType());
  }

  static final _id_format$1 = _class.instanceMethodId(
    r'format',
    r'(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintWriter;',
  );

  static final _format$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintWriter format(java.util.Locale locale, java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? format$1(
    jni$_.JObject? locale,
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _format$1(
      reference.pointer,
      _id_format$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintWriter?>(const $PrintWriter$NullableType());
  }

  static final _id_append$3 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;)Ljava/io/PrintWriter;',
  );

  static final _append$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintWriter append(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? append$3(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$3(
      reference.pointer,
      _id_append$3 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<PrintWriter?>(const $PrintWriter$NullableType());
  }

  static final _id_append$4 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;II)Ljava/io/PrintWriter;',
  );

  static final _append$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public java.io.PrintWriter append(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? append$4(jni$_.JObject? charSequence, int i, int i1) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$4(
      reference.pointer,
      _id_append$4 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
    ).object<PrintWriter?>(const $PrintWriter$NullableType());
  }

  static final _id_append$5 = _class.instanceMethodId(
    r'append',
    r'(C)Ljava/io/PrintWriter;',
  );

  static final _append$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.io.PrintWriter append(char c)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? append$5(int c) => _append$5(
    reference.pointer,
    _id_append$5 as jni$_.JMethodIDPtr,
    c,
  ).object<PrintWriter?>(const $PrintWriter$NullableType());
}

final class $PrintWriter$NullableType extends jni$_.JObjType<PrintWriter?> {
  @jni$_.internal
  const $PrintWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PrintWriter;';

  @jni$_.internal
  @core$_.override
  PrintWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PrintWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PrintWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PrintWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PrintWriter$NullableType) &&
      other is $PrintWriter$NullableType;
}

final class $PrintWriter$Type extends jni$_.JObjType<PrintWriter> {
  @jni$_.internal
  const $PrintWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PrintWriter;';

  @jni$_.internal
  @core$_.override
  PrintWriter fromReference(jni$_.JReference reference) =>
      PrintWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PrintWriter?> get nullableType =>
      const $PrintWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PrintWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PrintWriter$Type) && other is $PrintWriter$Type;
}

/// from: `java.io.StreamCorruptedException`
class StreamCorruptedException extends ObjectStreamException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StreamCorruptedException> $type;

  @jni$_.internal
  StreamCorruptedException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/StreamCorruptedException',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StreamCorruptedException$NullableType();
  static const type = $StreamCorruptedException$Type();
  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StreamCorruptedException.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return StreamCorruptedException.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'()V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StreamCorruptedException.new$5() =>
      StreamCorruptedException.fromReference(
        _new$5(
          _class.reference.pointer,
          _id_new$5 as jni$_.JMethodIDPtr,
        ).reference,
      );
}

final class $StreamCorruptedException$NullableType
    extends jni$_.JObjType<StreamCorruptedException?> {
  @jni$_.internal
  const $StreamCorruptedException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StreamCorruptedException;';

  @jni$_.internal
  @core$_.override
  StreamCorruptedException? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : StreamCorruptedException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StreamCorruptedException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($StreamCorruptedException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StreamCorruptedException$NullableType) &&
      other is $StreamCorruptedException$NullableType;
}

final class $StreamCorruptedException$Type
    extends jni$_.JObjType<StreamCorruptedException> {
  @jni$_.internal
  const $StreamCorruptedException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StreamCorruptedException;';

  @jni$_.internal
  @core$_.override
  StreamCorruptedException fromReference(jni$_.JReference reference) =>
      StreamCorruptedException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StreamCorruptedException?> get nullableType =>
      const $StreamCorruptedException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($StreamCorruptedException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StreamCorruptedException$Type) &&
      other is $StreamCorruptedException$Type;
}

/// from: `java.io.Externalizable`
class Externalizable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Externalizable> $type;

  @jni$_.internal
  Externalizable.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Externalizable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Externalizable$NullableType();
  static const type = $Externalizable$Type();
  static final _id_writeExternal = _class.instanceMethodId(
    r'writeExternal',
    r'(Ljava/io/ObjectOutput;)V',
  );

  static final _writeExternal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeExternal(java.io.ObjectOutput objectOutput)`
  void writeExternal(ObjectOutput? objectOutput) {
    final _$objectOutput = objectOutput?.reference ?? jni$_.jNullReference;
    _writeExternal(
      reference.pointer,
      _id_writeExternal as jni$_.JMethodIDPtr,
      _$objectOutput.pointer,
    ).check();
  }

  static final _id_readExternal = _class.instanceMethodId(
    r'readExternal',
    r'(Ljava/io/ObjectInput;)V',
  );

  static final _readExternal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void readExternal(java.io.ObjectInput objectInput)`
  void readExternal(ObjectInput? objectInput) {
    final _$objectInput = objectInput?.reference ?? jni$_.jNullReference;
    _readExternal(
      reference.pointer,
      _id_readExternal as jni$_.JMethodIDPtr,
      _$objectInput.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Externalizable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'writeExternal(Ljava/io/ObjectOutput;)V') {
        _$impls[$p]!.writeExternal(
          $a![0]?.as(const $ObjectOutput$Type(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'readExternal(Ljava/io/ObjectInput;)V') {
        _$impls[$p]!.readExternal(
          $a![0]?.as(const $ObjectInput$Type(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Externalizable $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.Externalizable', $p, _$invokePointer, [
      if ($impl.writeExternal$async) r'writeExternal(Ljava/io/ObjectOutput;)V',
      if ($impl.readExternal$async) r'readExternal(Ljava/io/ObjectInput;)V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Externalizable.implement($Externalizable $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Externalizable.fromReference($i.implementReference());
  }
}

abstract base mixin class $Externalizable {
  factory $Externalizable({
    required void Function(ObjectOutput? objectOutput) writeExternal,
    bool writeExternal$async,
    required void Function(ObjectInput? objectInput) readExternal,
    bool readExternal$async,
  }) = _$Externalizable;

  void writeExternal(ObjectOutput? objectOutput);
  bool get writeExternal$async => false;
  void readExternal(ObjectInput? objectInput);
  bool get readExternal$async => false;
}

final class _$Externalizable with $Externalizable {
  _$Externalizable({
    required void Function(ObjectOutput? objectOutput) writeExternal,
    this.writeExternal$async = false,
    required void Function(ObjectInput? objectInput) readExternal,
    this.readExternal$async = false,
  }) : _writeExternal = writeExternal,
       _readExternal = readExternal;

  final void Function(ObjectOutput? objectOutput) _writeExternal;
  final bool writeExternal$async;
  final void Function(ObjectInput? objectInput) _readExternal;
  final bool readExternal$async;

  void writeExternal(ObjectOutput? objectOutput) =>
      _writeExternal(objectOutput);

  void readExternal(ObjectInput? objectInput) => _readExternal(objectInput);
}

final class $Externalizable$NullableType
    extends jni$_.JObjType<Externalizable?> {
  @jni$_.internal
  const $Externalizable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Externalizable;';

  @jni$_.internal
  @core$_.override
  Externalizable? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Externalizable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Externalizable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Externalizable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Externalizable$NullableType) &&
      other is $Externalizable$NullableType;
}

final class $Externalizable$Type extends jni$_.JObjType<Externalizable> {
  @jni$_.internal
  const $Externalizable$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Externalizable;';

  @jni$_.internal
  @core$_.override
  Externalizable fromReference(jni$_.JReference reference) =>
      Externalizable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Externalizable?> get nullableType =>
      const $Externalizable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Externalizable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Externalizable$Type) &&
      other is $Externalizable$Type;
}

/// from: `java.io.ObjectInputValidation`
class ObjectInputValidation extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInputValidation> $type;

  @jni$_.internal
  ObjectInputValidation.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectInputValidation');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInputValidation$NullableType();
  static const type = $ObjectInputValidation$Type();
  static final _id_validateObject = _class.instanceMethodId(
    r'validateObject',
    r'()V',
  );

  static final _validateObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void validateObject()`
  void validateObject() {
    _validateObject(
      reference.pointer,
      _id_validateObject as jni$_.JMethodIDPtr,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ObjectInputValidation> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'validateObject()V') {
        _$impls[$p]!.validateObject();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ObjectInputValidation $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.ObjectInputValidation', $p, _$invokePointer, [
      if ($impl.validateObject$async) r'validateObject()V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ObjectInputValidation.implement($ObjectInputValidation $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ObjectInputValidation.fromReference($i.implementReference());
  }
}

abstract base mixin class $ObjectInputValidation {
  factory $ObjectInputValidation({
    required void Function() validateObject,
    bool validateObject$async,
  }) = _$ObjectInputValidation;

  void validateObject();
  bool get validateObject$async => false;
}

final class _$ObjectInputValidation with $ObjectInputValidation {
  _$ObjectInputValidation({
    required void Function() validateObject,
    this.validateObject$async = false,
  }) : _validateObject = validateObject;

  final void Function() _validateObject;
  final bool validateObject$async;

  void validateObject() => _validateObject();
}

final class $ObjectInputValidation$NullableType
    extends jni$_.JObjType<ObjectInputValidation?> {
  @jni$_.internal
  const $ObjectInputValidation$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputValidation;';

  @jni$_.internal
  @core$_.override
  ObjectInputValidation? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectInputValidation.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputValidation?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputValidation$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInputValidation$NullableType) &&
      other is $ObjectInputValidation$NullableType;
}

final class $ObjectInputValidation$Type
    extends jni$_.JObjType<ObjectInputValidation> {
  @jni$_.internal
  const $ObjectInputValidation$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputValidation;';

  @jni$_.internal
  @core$_.override
  ObjectInputValidation fromReference(jni$_.JReference reference) =>
      ObjectInputValidation.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputValidation?> get nullableType =>
      const $ObjectInputValidation$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputValidation$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInputValidation$Type) &&
      other is $ObjectInputValidation$Type;
}

/// from: `java.io.FilterOutputStream`
class FilterOutputStream extends OutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FilterOutputStream> $type;

  @jni$_.internal
  FilterOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FilterOutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FilterOutputStream$NullableType();
  static const type = $FilterOutputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FilterOutputStream(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return FilterOutputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(byte[] bs)`
  void write1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write1(
      reference.pointer,
      _id_write1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $FilterOutputStream$NullableType
    extends jni$_.JObjType<FilterOutputStream?> {
  @jni$_.internal
  const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterOutputStream;';

  @jni$_.internal
  @core$_.override
  FilterOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FilterOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterOutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FilterOutputStream$NullableType) &&
      other is $FilterOutputStream$NullableType;
}

final class $FilterOutputStream$Type
    extends jni$_.JObjType<FilterOutputStream> {
  @jni$_.internal
  const $FilterOutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterOutputStream;';

  @jni$_.internal
  @core$_.override
  FilterOutputStream fromReference(jni$_.JReference reference) =>
      FilterOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterOutputStream?> get nullableType =>
      const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterOutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FilterOutputStream$Type) &&
      other is $FilterOutputStream$Type;
}

/// from: `java.io.Reader`
class Reader extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Reader> $type;

  @jni$_.internal
  Reader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Reader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Reader$NullableType();
  static const type = $Reader$Type();
  static final _id_nullReader = _class.staticMethodId(
    r'nullReader',
    r'()Ljava/io/Reader;',
  );

  static final _nullReader =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.Reader nullReader()`
  /// The returned object must be released after use, by calling the [release] method.
  static Reader? nullReader() => _nullReader(
    _class.reference.pointer,
    _id_nullReader as jni$_.JMethodIDPtr,
  ).object<Reader?>(const $Reader$NullableType());

  static final _id_read = _class.instanceMethodId(
    r'read',
    r'(Ljava/nio/CharBuffer;)I',
  );

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(java.nio.CharBuffer charBuffer)`
  int read(jni$_.JObject? charBuffer) {
    final _$charBuffer = charBuffer?.reference ?? jni$_.jNullReference;
    return _read(
      reference.pointer,
      _id_read as jni$_.JMethodIDPtr,
      _$charBuffer.pointer,
    ).integer;
  }

  static final _id_read$1 = _class.instanceMethodId(r'read', r'()I');

  static final _read$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read$1() =>
      _read$1(reference.pointer, _id_read$1 as jni$_.JMethodIDPtr).integer;

  static final _id_read$2 = _class.instanceMethodId(r'read', r'([C)I');

  static final _read$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(char[] cs)`
  int read$2(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read$2(
      reference.pointer,
      _id_read$2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).integer;
  }

  static final _id_read$3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract int read(char[] cs, int i, int i1)`
  int read$3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read$3(
      reference.pointer,
      _id_read$3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() =>
      _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() =>
      _markSupported(
        reference.pointer,
        _id_markSupported as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_transferTo = _class.instanceMethodId(
    r'transferTo',
    r'(Ljava/io/Writer;)J',
  );

  static final _transferTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long transferTo(java.io.Writer writer)`
  int transferTo(Writer? writer) {
    final _$writer = writer?.reference ?? jni$_.jNullReference;
    return _transferTo(
      reference.pointer,
      _id_transferTo as jni$_.JMethodIDPtr,
      _$writer.pointer,
    ).long;
  }
}

final class $Reader$NullableType extends jni$_.JObjType<Reader?> {
  @jni$_.internal
  const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Reader;';

  @jni$_.internal
  @core$_.override
  Reader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Reader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Reader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Reader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Reader$NullableType) &&
      other is $Reader$NullableType;
}

final class $Reader$Type extends jni$_.JObjType<Reader> {
  @jni$_.internal
  const $Reader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Reader;';

  @jni$_.internal
  @core$_.override
  Reader fromReference(jni$_.JReference reference) =>
      Reader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Reader?> get nullableType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Reader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Reader$Type) && other is $Reader$Type;
}

/// from: `java.io.PipedWriter`
class PipedWriter extends Writer {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PipedWriter> $type;

  @jni$_.internal
  PipedWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PipedWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PipedWriter$NullableType();
  static const type = $PipedWriter$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/PipedReader;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.PipedReader pipedReader)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedWriter(PipedReader? pipedReader) {
    final _$pipedReader = pipedReader?.reference ?? jni$_.jNullReference;
    return PipedWriter.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$pipedReader.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'()V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedWriter.new$1() => PipedWriter.fromReference(
    _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr).reference,
  );

  static final _id_connect = _class.instanceMethodId(
    r'connect',
    r'(Ljava/io/PipedReader;)V',
  );

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void connect(java.io.PipedReader pipedReader)`
  void connect(PipedReader? pipedReader) {
    final _$pipedReader = pipedReader?.reference ?? jni$_.jNullReference;
    _connect(
      reference.pointer,
      _id_connect as jni$_.JMethodIDPtr,
      _$pipedReader.pointer,
    ).check();
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(char[] cs, int i, int i1)`
  void write2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $PipedWriter$NullableType extends jni$_.JObjType<PipedWriter?> {
  @jni$_.internal
  const $PipedWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedWriter;';

  @jni$_.internal
  @core$_.override
  PipedWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PipedWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PipedWriter$NullableType) &&
      other is $PipedWriter$NullableType;
}

final class $PipedWriter$Type extends jni$_.JObjType<PipedWriter> {
  @jni$_.internal
  const $PipedWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedWriter;';

  @jni$_.internal
  @core$_.override
  PipedWriter fromReference(jni$_.JReference reference) =>
      PipedWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedWriter?> get nullableType =>
      const $PipedWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PipedWriter$Type) && other is $PipedWriter$Type;
}

/// from: `java.io.Serializable`
class Serializable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Serializable> $type;

  @jni$_.internal
  Serializable.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Serializable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Serializable$NullableType();
  static const type = $Serializable$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Serializable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $Serializable $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.Serializable', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Serializable.implement($Serializable $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Serializable.fromReference($i.implementReference());
  }
}

abstract base mixin class $Serializable {
  factory $Serializable() = _$Serializable;
}

final class _$Serializable with $Serializable {
  _$Serializable();
}

final class $Serializable$NullableType extends jni$_.JObjType<Serializable?> {
  @jni$_.internal
  const $Serializable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Serializable;';

  @jni$_.internal
  @core$_.override
  Serializable? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Serializable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Serializable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Serializable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Serializable$NullableType) &&
      other is $Serializable$NullableType;
}

final class $Serializable$Type extends jni$_.JObjType<Serializable> {
  @jni$_.internal
  const $Serializable$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Serializable;';

  @jni$_.internal
  @core$_.override
  Serializable fromReference(jni$_.JReference reference) =>
      Serializable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Serializable?> get nullableType =>
      const $Serializable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Serializable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Serializable$Type) && other is $Serializable$Type;
}

/// from: `java.io.UncheckedIOException`
class UncheckedIOException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<UncheckedIOException> $type;

  @jni$_.internal
  UncheckedIOException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/UncheckedIOException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $UncheckedIOException$NullableType();
  static const type = $UncheckedIOException$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/io/IOException;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.io.IOException iOException)`
  /// The returned object must be released after use, by calling the [release] method.
  factory UncheckedIOException(
    jni$_.JString? string,
    IOException? iOException,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$iOException = iOException?.reference ?? jni$_.jNullReference;
    return UncheckedIOException.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$iOException.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/IOException;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.IOException iOException)`
  /// The returned object must be released after use, by calling the [release] method.
  factory UncheckedIOException.new$1(IOException? iOException) {
    final _$iOException = iOException?.reference ?? jni$_.jNullReference;
    return UncheckedIOException.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$iOException.pointer,
      ).reference,
    );
  }

  static final _id_getCause = _class.instanceMethodId(
    r'getCause',
    r'()Ljava/io/IOException;',
  );

  static final _getCause =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.IOException getCause()`
  /// The returned object must be released after use, by calling the [release] method.
  IOException? getCause() => _getCause(
    reference.pointer,
    _id_getCause as jni$_.JMethodIDPtr,
  ).object<IOException?>(const $IOException$NullableType());
}

final class $UncheckedIOException$NullableType
    extends jni$_.JObjType<UncheckedIOException?> {
  @jni$_.internal
  const $UncheckedIOException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/UncheckedIOException;';

  @jni$_.internal
  @core$_.override
  UncheckedIOException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : UncheckedIOException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UncheckedIOException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UncheckedIOException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($UncheckedIOException$NullableType) &&
      other is $UncheckedIOException$NullableType;
}

final class $UncheckedIOException$Type
    extends jni$_.JObjType<UncheckedIOException> {
  @jni$_.internal
  const $UncheckedIOException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/UncheckedIOException;';

  @jni$_.internal
  @core$_.override
  UncheckedIOException fromReference(jni$_.JReference reference) =>
      UncheckedIOException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UncheckedIOException?> get nullableType =>
      const $UncheckedIOException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UncheckedIOException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($UncheckedIOException$Type) &&
      other is $UncheckedIOException$Type;
}

/// from: `java.io.SyncFailedException`
class SyncFailedException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SyncFailedException> $type;

  @jni$_.internal
  SyncFailedException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/SyncFailedException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SyncFailedException$NullableType();
  static const type = $SyncFailedException$Type();
  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SyncFailedException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return SyncFailedException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $SyncFailedException$NullableType
    extends jni$_.JObjType<SyncFailedException?> {
  @jni$_.internal
  const $SyncFailedException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/SyncFailedException;';

  @jni$_.internal
  @core$_.override
  SyncFailedException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SyncFailedException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SyncFailedException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SyncFailedException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SyncFailedException$NullableType) &&
      other is $SyncFailedException$NullableType;
}

final class $SyncFailedException$Type
    extends jni$_.JObjType<SyncFailedException> {
  @jni$_.internal
  const $SyncFailedException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/SyncFailedException;';

  @jni$_.internal
  @core$_.override
  SyncFailedException fromReference(jni$_.JReference reference) =>
      SyncFailedException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SyncFailedException?> get nullableType =>
      const $SyncFailedException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SyncFailedException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SyncFailedException$Type) &&
      other is $SyncFailedException$Type;
}

/// from: `java.io.ObjectInputStream$GetField`
class ObjectInputStream$GetField extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInputStream$GetField> $type;

  @jni$_.internal
  ObjectInputStream$GetField.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/ObjectInputStream$GetField',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInputStream$GetField$NullableType();
  static const type = $ObjectInputStream$GetField$Type();
  static final _id_getObjectStreamClass = _class.instanceMethodId(
    r'getObjectStreamClass',
    r'()Ljava/io/ObjectStreamClass;',
  );

  static final _getObjectStreamClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.io.ObjectStreamClass getObjectStreamClass()`
  /// The returned object must be released after use, by calling the [release] method.
  ObjectStreamClass? getObjectStreamClass() => _getObjectStreamClass(
    reference.pointer,
    _id_getObjectStreamClass as jni$_.JMethodIDPtr,
  ).object<ObjectStreamClass?>(const $ObjectStreamClass$NullableType());

  static final _id_defaulted = _class.instanceMethodId(
    r'defaulted',
    r'(Ljava/lang/String;)Z',
  );

  static final _defaulted =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean defaulted(java.lang.String string)`
  bool defaulted(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _defaulted(
      reference.pointer,
      _id_defaulted as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).boolean;
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;Z)Z',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract boolean get(java.lang.String string, boolean z)`
  bool get(jni$_.JString? string, bool z) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$string.pointer,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_get$1 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;B)B',
  );

  static final _get$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract byte get(java.lang.String string, byte b)`
  int get$1(jni$_.JString? string, int b) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get$1(
      reference.pointer,
      _id_get$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      b,
    ).byte;
  }

  static final _id_get$2 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;C)C',
  );

  static final _get$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract char get(java.lang.String string, char c)`
  int get$2(jni$_.JString? string, int c) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get$2(
      reference.pointer,
      _id_get$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      c,
    ).char;
  }

  static final _id_get$3 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;S)S',
  );

  static final _get$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract short get(java.lang.String string, short s)`
  int get$3(jni$_.JString? string, int s) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get$3(
      reference.pointer,
      _id_get$3 as jni$_.JMethodIDPtr,
      _$string.pointer,
      s,
    ).short;
  }

  static final _id_get$4 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;I)I',
  );

  static final _get$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract int get(java.lang.String string, int i)`
  int get$4(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get$4(
      reference.pointer,
      _id_get$4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
    ).integer;
  }

  static final _id_get$5 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;J)J',
  );

  static final _get$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract long get(java.lang.String string, long j)`
  int get$5(jni$_.JString? string, int j) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get$5(
      reference.pointer,
      _id_get$5 as jni$_.JMethodIDPtr,
      _$string.pointer,
      j,
    ).long;
  }

  static final _id_get$6 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;F)F',
  );

  static final _get$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Double)>,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              double,
            )
          >();

  /// from: `public abstract float get(java.lang.String string, float f)`
  double get$6(jni$_.JString? string, double f) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get$6(
      reference.pointer,
      _id_get$6 as jni$_.JMethodIDPtr,
      _$string.pointer,
      f,
    ).float;
  }

  static final _id_get$7 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;D)D',
  );

  static final _get$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Double)>,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              double,
            )
          >();

  /// from: `public abstract double get(java.lang.String string, double d)`
  double get$7(jni$_.JString? string, double d) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get$7(
      reference.pointer,
      _id_get$7 as jni$_.JMethodIDPtr,
      _$string.pointer,
      d,
    ).doubleFloat;
  }

  static final _id_get$8 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _get$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object get(java.lang.String string, java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get$8(jni$_.JString? string, jni$_.JObject? object) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _get$8(
      reference.pointer,
      _id_get$8 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$object.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $ObjectInputStream$GetField$NullableType
    extends jni$_.JObjType<ObjectInputStream$GetField?> {
  @jni$_.internal
  const $ObjectInputStream$GetField$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputStream$GetField;';

  @jni$_.internal
  @core$_.override
  ObjectInputStream$GetField? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ObjectInputStream$GetField.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputStream$GetField?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputStream$GetField$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInputStream$GetField$NullableType) &&
      other is $ObjectInputStream$GetField$NullableType;
}

final class $ObjectInputStream$GetField$Type
    extends jni$_.JObjType<ObjectInputStream$GetField> {
  @jni$_.internal
  const $ObjectInputStream$GetField$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputStream$GetField;';

  @jni$_.internal
  @core$_.override
  ObjectInputStream$GetField fromReference(jni$_.JReference reference) =>
      ObjectInputStream$GetField.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputStream$GetField?> get nullableType =>
      const $ObjectInputStream$GetField$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputStream$GetField$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInputStream$GetField$Type) &&
      other is $ObjectInputStream$GetField$Type;
}

/// from: `java.io.WriteAbortedException`
class WriteAbortedException extends ObjectStreamException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<WriteAbortedException> $type;

  @jni$_.internal
  WriteAbortedException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/WriteAbortedException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $WriteAbortedException$NullableType();
  static const type = $WriteAbortedException$Type();
  static final _id_detail = _class.instanceFieldId(
    r'detail',
    r'Ljava/lang/Exception;',
  );

  /// from: `public java.lang.Exception detail`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get detail =>
      _id_detail.get(this, const jni$_.JObjectNullableType());

  /// from: `public java.lang.Exception detail`
  /// The returned object must be released after use, by calling the [release] method.
  set detail(jni$_.JObject? value) =>
      _id_detail.set(this, const jni$_.JObjectNullableType(), value);

  static final _id_new$4 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/Exception;)V',
  );

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.Exception exception)`
  /// The returned object must be released after use, by calling the [release] method.
  factory WriteAbortedException.new$4(
    jni$_.JString? string,
    jni$_.JObject? exception,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$exception = exception?.reference ?? jni$_.jNullReference;
    return WriteAbortedException.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$exception.pointer,
      ).reference,
    );
  }

  static final _id_getMessage = _class.instanceMethodId(
    r'getMessage',
    r'()Ljava/lang/String;',
  );

  static final _getMessage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getMessage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getMessage() => _getMessage(
    reference.pointer,
    _id_getMessage as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getCause = _class.instanceMethodId(
    r'getCause',
    r'()Ljava/lang/Throwable;',
  );

  static final _getCause =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Throwable getCause()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getCause() => _getCause(
    reference.pointer,
    _id_getCause as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
}

final class $WriteAbortedException$NullableType
    extends jni$_.JObjType<WriteAbortedException?> {
  @jni$_.internal
  const $WriteAbortedException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/WriteAbortedException;';

  @jni$_.internal
  @core$_.override
  WriteAbortedException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : WriteAbortedException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<WriteAbortedException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($WriteAbortedException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($WriteAbortedException$NullableType) &&
      other is $WriteAbortedException$NullableType;
}

final class $WriteAbortedException$Type
    extends jni$_.JObjType<WriteAbortedException> {
  @jni$_.internal
  const $WriteAbortedException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/WriteAbortedException;';

  @jni$_.internal
  @core$_.override
  WriteAbortedException fromReference(jni$_.JReference reference) =>
      WriteAbortedException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<WriteAbortedException?> get nullableType =>
      const $WriteAbortedException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($WriteAbortedException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($WriteAbortedException$Type) &&
      other is $WriteAbortedException$Type;
}

/// from: `java.io.FilenameFilter`
class FilenameFilter extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FilenameFilter> $type;

  @jni$_.internal
  FilenameFilter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FilenameFilter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FilenameFilter$NullableType();
  static const type = $FilenameFilter$Type();
  static final _id_accept = _class.instanceMethodId(
    r'accept',
    r'(Ljava/io/File;Ljava/lang/String;)Z',
  );

  static final _accept =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean accept(java.io.File file, java.lang.String string)`
  bool accept(File? file, jni$_.JString? string) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _accept(
      reference.pointer,
      _id_accept as jni$_.JMethodIDPtr,
      _$file.pointer,
      _$string.pointer,
    ).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $FilenameFilter> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'accept(Ljava/io/File;Ljava/lang/String;)Z') {
        final $r = _$impls[$p]!.accept(
          $a![0]?.as(const $File$Type(), releaseOriginal: true),
          $a![1]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $FilenameFilter $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.FilenameFilter', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory FilenameFilter.implement($FilenameFilter $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return FilenameFilter.fromReference($i.implementReference());
  }
}

abstract base mixin class $FilenameFilter {
  factory $FilenameFilter({
    required bool Function(File? file, jni$_.JString? string) accept,
  }) = _$FilenameFilter;

  bool accept(File? file, jni$_.JString? string);
}

final class _$FilenameFilter with $FilenameFilter {
  _$FilenameFilter({
    required bool Function(File? file, jni$_.JString? string) accept,
  }) : _accept = accept;

  final bool Function(File? file, jni$_.JString? string) _accept;

  bool accept(File? file, jni$_.JString? string) => _accept(file, string);
}

final class $FilenameFilter$NullableType
    extends jni$_.JObjType<FilenameFilter?> {
  @jni$_.internal
  const $FilenameFilter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilenameFilter;';

  @jni$_.internal
  @core$_.override
  FilenameFilter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FilenameFilter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilenameFilter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FilenameFilter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FilenameFilter$NullableType) &&
      other is $FilenameFilter$NullableType;
}

final class $FilenameFilter$Type extends jni$_.JObjType<FilenameFilter> {
  @jni$_.internal
  const $FilenameFilter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilenameFilter;';

  @jni$_.internal
  @core$_.override
  FilenameFilter fromReference(jni$_.JReference reference) =>
      FilenameFilter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilenameFilter?> get nullableType =>
      const $FilenameFilter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FilenameFilter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FilenameFilter$Type) &&
      other is $FilenameFilter$Type;
}

/// from: `java.io.ObjectInputFilter$FilterInfo`
class ObjectInputFilter$FilterInfo extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInputFilter$FilterInfo> $type;

  @jni$_.internal
  ObjectInputFilter$FilterInfo.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/ObjectInputFilter$FilterInfo',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInputFilter$FilterInfo$NullableType();
  static const type = $ObjectInputFilter$FilterInfo$Type();
  static final _id_serialClass = _class.instanceMethodId(
    r'serialClass',
    r'()Ljava/lang/Class;',
  );

  static final _serialClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.Class<?> serialClass()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? serialClass() => _serialClass(
    reference.pointer,
    _id_serialClass as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_arrayLength = _class.instanceMethodId(
    r'arrayLength',
    r'()J',
  );

  static final _arrayLength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract long arrayLength()`
  int arrayLength() =>
      _arrayLength(
        reference.pointer,
        _id_arrayLength as jni$_.JMethodIDPtr,
      ).long;

  static final _id_depth = _class.instanceMethodId(r'depth', r'()J');

  static final _depth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract long depth()`
  int depth() =>
      _depth(reference.pointer, _id_depth as jni$_.JMethodIDPtr).long;

  static final _id_references = _class.instanceMethodId(r'references', r'()J');

  static final _references =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract long references()`
  int references() =>
      _references(reference.pointer, _id_references as jni$_.JMethodIDPtr).long;

  static final _id_streamBytes = _class.instanceMethodId(
    r'streamBytes',
    r'()J',
  );

  static final _streamBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract long streamBytes()`
  int streamBytes() =>
      _streamBytes(
        reference.pointer,
        _id_streamBytes as jni$_.JMethodIDPtr,
      ).long;

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ObjectInputFilter$FilterInfo> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'serialClass()Ljava/lang/Class;') {
        final $r = _$impls[$p]!.serialClass();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'arrayLength()J') {
        final $r = _$impls[$p]!.arrayLength();
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'depth()J') {
        final $r = _$impls[$p]!.depth();
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'references()J') {
        final $r = _$impls[$p]!.references();
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'streamBytes()J') {
        final $r = _$impls[$p]!.streamBytes();
        return jni$_.JLong($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ObjectInputFilter$FilterInfo $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'java.io.ObjectInputFilter$FilterInfo',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ObjectInputFilter$FilterInfo.implement(
    $ObjectInputFilter$FilterInfo $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ObjectInputFilter$FilterInfo.fromReference($i.implementReference());
  }
}

abstract base mixin class $ObjectInputFilter$FilterInfo {
  factory $ObjectInputFilter$FilterInfo({
    required jni$_.JObject? Function() serialClass,
    required int Function() arrayLength,
    required int Function() depth,
    required int Function() references,
    required int Function() streamBytes,
  }) = _$ObjectInputFilter$FilterInfo;

  jni$_.JObject? serialClass();
  int arrayLength();
  int depth();
  int references();
  int streamBytes();
}

final class _$ObjectInputFilter$FilterInfo with $ObjectInputFilter$FilterInfo {
  _$ObjectInputFilter$FilterInfo({
    required jni$_.JObject? Function() serialClass,
    required int Function() arrayLength,
    required int Function() depth,
    required int Function() references,
    required int Function() streamBytes,
  }) : _serialClass = serialClass,
       _arrayLength = arrayLength,
       _depth = depth,
       _references = references,
       _streamBytes = streamBytes;

  final jni$_.JObject? Function() _serialClass;
  final int Function() _arrayLength;
  final int Function() _depth;
  final int Function() _references;
  final int Function() _streamBytes;

  jni$_.JObject? serialClass() => _serialClass();

  int arrayLength() => _arrayLength();

  int depth() => _depth();

  int references() => _references();

  int streamBytes() => _streamBytes();
}

final class $ObjectInputFilter$FilterInfo$NullableType
    extends jni$_.JObjType<ObjectInputFilter$FilterInfo?> {
  @jni$_.internal
  const $ObjectInputFilter$FilterInfo$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter$FilterInfo;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter$FilterInfo? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ObjectInputFilter$FilterInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter$FilterInfo?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$FilterInfo$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInputFilter$FilterInfo$NullableType) &&
      other is $ObjectInputFilter$FilterInfo$NullableType;
}

final class $ObjectInputFilter$FilterInfo$Type
    extends jni$_.JObjType<ObjectInputFilter$FilterInfo> {
  @jni$_.internal
  const $ObjectInputFilter$FilterInfo$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter$FilterInfo;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter$FilterInfo fromReference(jni$_.JReference reference) =>
      ObjectInputFilter$FilterInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter$FilterInfo?> get nullableType =>
      const $ObjectInputFilter$FilterInfo$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$FilterInfo$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInputFilter$FilterInfo$Type) &&
      other is $ObjectInputFilter$FilterInfo$Type;
}

/// from: `java.io.PipedReader`
class PipedReader extends Reader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PipedReader> $type;

  @jni$_.internal
  PipedReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PipedReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PipedReader$NullableType();
  static const type = $PipedReader$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/PipedWriter;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.PipedWriter pipedWriter)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedReader(PipedWriter? pipedWriter) {
    final _$pipedWriter = pipedWriter?.reference ?? jni$_.jNullReference;
    return PipedReader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$pipedWriter.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/PipedWriter;I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.PipedWriter pipedWriter, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedReader.new$1(PipedWriter? pipedWriter, int i) {
    final _$pipedWriter = pipedWriter?.reference ?? jni$_.jNullReference;
    return PipedReader.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$pipedWriter.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'()V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedReader.new$2() => PipedReader.fromReference(
    _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$3 = _class.constructorId(r'(I)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedReader.new$3(int i) => PipedReader.fromReference(
    _new$3(
      _class.reference.pointer,
      _id_new$3 as jni$_.JMethodIDPtr,
      i,
    ).reference,
  );

  static final _id_connect = _class.instanceMethodId(
    r'connect',
    r'(Ljava/io/PipedWriter;)V',
  );

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void connect(java.io.PipedWriter pipedWriter)`
  void connect(PipedWriter? pipedWriter) {
    final _$pipedWriter = pipedWriter?.reference ?? jni$_.jNullReference;
    _connect(
      reference.pointer,
      _id_connect as jni$_.JMethodIDPtr,
      _$pipedWriter.pointer,
    ).check();
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() =>
      _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() =>
      _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $PipedReader$NullableType extends jni$_.JObjType<PipedReader?> {
  @jni$_.internal
  const $PipedReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedReader;';

  @jni$_.internal
  @core$_.override
  PipedReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PipedReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PipedReader$NullableType) &&
      other is $PipedReader$NullableType;
}

final class $PipedReader$Type extends jni$_.JObjType<PipedReader> {
  @jni$_.internal
  const $PipedReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedReader;';

  @jni$_.internal
  @core$_.override
  PipedReader fromReference(jni$_.JReference reference) =>
      PipedReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedReader?> get nullableType =>
      const $PipedReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PipedReader$Type) && other is $PipedReader$Type;
}

/// from: `java.io.ByteArrayOutputStream`
class ByteArrayOutputStream extends OutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ByteArrayOutputStream> $type;

  @jni$_.internal
  ByteArrayOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ByteArrayOutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ByteArrayOutputStream$NullableType();
  static const type = $ByteArrayOutputStream$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ByteArrayOutputStream() => ByteArrayOutputStream.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$1 = _class.constructorId(r'(I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ByteArrayOutputStream.new$1(int i) =>
      ByteArrayOutputStream.fromReference(
        _new$1(
          _class.reference.pointer,
          _id_new$1 as jni$_.JMethodIDPtr,
          i,
        ).reference,
      );

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'([B)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeBytes(byte[] bs)`
  void writeBytes(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_writeTo = _class.instanceMethodId(
    r'writeTo',
    r'(Ljava/io/OutputStream;)V',
  );

  static final _writeTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeTo(java.io.OutputStream outputStream)`
  void writeTo(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    _writeTo(
      reference.pointer,
      _id_writeTo as jni$_.JMethodIDPtr,
      _$outputStream.pointer,
    ).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_toByteArray = _class.instanceMethodId(
    r'toByteArray',
    r'()[B',
  );

  static final _toByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] toByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? toByteArray() => _toByteArray(
    reference.pointer,
    _id_toByteArray as jni$_.JMethodIDPtr,
  ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());

  static final _id_size = _class.instanceMethodId(r'size', r'()I');

  static final _size =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int size()`
  int size() =>
      _size(reference.pointer, _id_size as jni$_.JMethodIDPtr).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_toString$2 = _class.instanceMethodId(
    r'toString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _toString$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String toString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$2(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _toString$2(
      reference.pointer,
      _id_toString$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toString$3 = _class.instanceMethodId(
    r'toString',
    r'(Ljava/nio/charset/Charset;)Ljava/lang/String;',
  );

  static final _toString$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String toString(java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$3(jni$_.JObject? charset) {
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return _toString$3(
      reference.pointer,
      _id_toString$3 as jni$_.JMethodIDPtr,
      _$charset.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toString$4 = _class.instanceMethodId(
    r'toString',
    r'(I)Ljava/lang/String;',
  );

  static final _toString$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.lang.String toString(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$4(int i) => _toString$4(
    reference.pointer,
    _id_toString$4 as jni$_.JMethodIDPtr,
    i,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $ByteArrayOutputStream$NullableType
    extends jni$_.JObjType<ByteArrayOutputStream?> {
  @jni$_.internal
  const $ByteArrayOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ByteArrayOutputStream;';

  @jni$_.internal
  @core$_.override
  ByteArrayOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ByteArrayOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ByteArrayOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ByteArrayOutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ByteArrayOutputStream$NullableType) &&
      other is $ByteArrayOutputStream$NullableType;
}

final class $ByteArrayOutputStream$Type
    extends jni$_.JObjType<ByteArrayOutputStream> {
  @jni$_.internal
  const $ByteArrayOutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ByteArrayOutputStream;';

  @jni$_.internal
  @core$_.override
  ByteArrayOutputStream fromReference(jni$_.JReference reference) =>
      ByteArrayOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ByteArrayOutputStream?> get nullableType =>
      const $ByteArrayOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ByteArrayOutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ByteArrayOutputStream$Type) &&
      other is $ByteArrayOutputStream$Type;
}

/// from: `java.io.InterruptedIOException`
class InterruptedIOException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InterruptedIOException> $type;

  @jni$_.internal
  InterruptedIOException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/InterruptedIOException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InterruptedIOException$NullableType();
  static const type = $InterruptedIOException$Type();
  static final _id_bytesTransferred = _class.instanceFieldId(
    r'bytesTransferred',
    r'I',
  );

  /// from: `public int bytesTransferred`
  int get bytesTransferred =>
      _id_bytesTransferred.get(this, const jni$_.jintType());

  /// from: `public int bytesTransferred`
  set bytesTransferred(int value) =>
      _id_bytesTransferred.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory InterruptedIOException() => InterruptedIOException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InterruptedIOException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return InterruptedIOException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $InterruptedIOException$NullableType
    extends jni$_.JObjType<InterruptedIOException?> {
  @jni$_.internal
  const $InterruptedIOException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InterruptedIOException;';

  @jni$_.internal
  @core$_.override
  InterruptedIOException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InterruptedIOException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InterruptedIOException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($InterruptedIOException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InterruptedIOException$NullableType) &&
      other is $InterruptedIOException$NullableType;
}

final class $InterruptedIOException$Type
    extends jni$_.JObjType<InterruptedIOException> {
  @jni$_.internal
  const $InterruptedIOException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InterruptedIOException;';

  @jni$_.internal
  @core$_.override
  InterruptedIOException fromReference(jni$_.JReference reference) =>
      InterruptedIOException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InterruptedIOException?> get nullableType =>
      const $InterruptedIOException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($InterruptedIOException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InterruptedIOException$Type) &&
      other is $InterruptedIOException$Type;
}

/// from: `java.io.BufferedOutputStream`
class BufferedOutputStream extends FilterOutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<BufferedOutputStream> $type;

  @jni$_.internal
  BufferedOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/BufferedOutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $BufferedOutputStream$NullableType();
  static const type = $BufferedOutputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedOutputStream(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return BufferedOutputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/OutputStream;I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedOutputStream.new$1(OutputStream? outputStream, int i) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return BufferedOutputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        i,
      ).reference,
    );
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }
}

final class $BufferedOutputStream$NullableType
    extends jni$_.JObjType<BufferedOutputStream?> {
  @jni$_.internal
  const $BufferedOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedOutputStream;';

  @jni$_.internal
  @core$_.override
  BufferedOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : BufferedOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($BufferedOutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($BufferedOutputStream$NullableType) &&
      other is $BufferedOutputStream$NullableType;
}

final class $BufferedOutputStream$Type
    extends jni$_.JObjType<BufferedOutputStream> {
  @jni$_.internal
  const $BufferedOutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedOutputStream;';

  @jni$_.internal
  @core$_.override
  BufferedOutputStream fromReference(jni$_.JReference reference) =>
      BufferedOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedOutputStream?> get nullableType =>
      const $BufferedOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($BufferedOutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($BufferedOutputStream$Type) &&
      other is $BufferedOutputStream$Type;
}

/// from: `java.io.Console`
class Console extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Console> $type;

  @jni$_.internal
  Console.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Console');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Console$NullableType();
  static const type = $Console$Type();
  static final _id_writer = _class.instanceMethodId(
    r'writer',
    r'()Ljava/io/PrintWriter;',
  );

  static final _writer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.PrintWriter writer()`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? writer() => _writer(
    reference.pointer,
    _id_writer as jni$_.JMethodIDPtr,
  ).object<PrintWriter?>(const $PrintWriter$NullableType());

  static final _id_reader = _class.instanceMethodId(
    r'reader',
    r'()Ljava/io/Reader;',
  );

  static final _reader =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.Reader reader()`
  /// The returned object must be released after use, by calling the [release] method.
  Reader? reader() => _reader(
    reference.pointer,
    _id_reader as jni$_.JMethodIDPtr,
  ).object<Reader?>(const $Reader$NullableType());

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/Console;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.Console format(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  Console? format(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<Console?>(const $Console$NullableType());
  }

  static final _id_printf = _class.instanceMethodId(
    r'printf',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/Console;',
  );

  static final _printf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.Console printf(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  Console? printf(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _printf(
      reference.pointer,
      _id_printf as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<Console?>(const $Console$NullableType());
  }

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String readLine(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _readLine(
      reference.pointer,
      _id_readLine as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_readLine$1 = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine$1() => _readLine$1(
    reference.pointer,
    _id_readLine$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_readPassword = _class.instanceMethodId(
    r'readPassword',
    r'(Ljava/lang/String;[Ljava/lang/Object;)[C',
  );

  static final _readPassword =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public char[] readPassword(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JCharArray? readPassword(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _readPassword(
      reference.pointer,
      _id_readPassword as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<jni$_.JCharArray?>(const jni$_.JCharArrayNullableType());
  }

  static final _id_readPassword$1 = _class.instanceMethodId(
    r'readPassword',
    r'()[C',
  );

  static final _readPassword$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char[] readPassword()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JCharArray? readPassword$1() => _readPassword$1(
    reference.pointer,
    _id_readPassword$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JCharArray?>(const jni$_.JCharArrayNullableType());

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_charset = _class.instanceMethodId(
    r'charset',
    r'()Ljava/nio/charset/Charset;',
  );

  static final _charset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.charset.Charset charset()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? charset() => _charset(
    reference.pointer,
    _id_charset as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
}

final class $Console$NullableType extends jni$_.JObjType<Console?> {
  @jni$_.internal
  const $Console$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Console;';

  @jni$_.internal
  @core$_.override
  Console? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Console.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Console?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Console$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Console$NullableType) &&
      other is $Console$NullableType;
}

final class $Console$Type extends jni$_.JObjType<Console> {
  @jni$_.internal
  const $Console$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Console;';

  @jni$_.internal
  @core$_.override
  Console fromReference(jni$_.JReference reference) =>
      Console.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Console?> get nullableType => const $Console$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Console$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Console$Type) && other is $Console$Type;
}

/// from: `java.io.ObjectOutputStream`
class ObjectOutputStream extends OutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectOutputStream> $type;

  @jni$_.internal
  ObjectOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectOutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectOutputStream$NullableType();
  static const type = $ObjectOutputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ObjectOutputStream(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return ObjectOutputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_useProtocolVersion = _class.instanceMethodId(
    r'useProtocolVersion',
    r'(I)V',
  );

  static final _useProtocolVersion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void useProtocolVersion(int i)`
  void useProtocolVersion(int i) {
    _useProtocolVersion(
      reference.pointer,
      _id_useProtocolVersion as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeObject = _class.instanceMethodId(
    r'writeObject',
    r'(Ljava/lang/Object;)V',
  );

  static final _writeObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void writeObject(java.lang.Object object)`
  void writeObject(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _writeObject(
      reference.pointer,
      _id_writeObject as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_writeUnshared = _class.instanceMethodId(
    r'writeUnshared',
    r'(Ljava/lang/Object;)V',
  );

  static final _writeUnshared =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeUnshared(java.lang.Object object)`
  void writeUnshared(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _writeUnshared(
      reference.pointer,
      _id_writeUnshared as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_defaultWriteObject = _class.instanceMethodId(
    r'defaultWriteObject',
    r'()V',
  );

  static final _defaultWriteObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void defaultWriteObject()`
  void defaultWriteObject() {
    _defaultWriteObject(
      reference.pointer,
      _id_defaultWriteObject as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_putFields = _class.instanceMethodId(
    r'putFields',
    r'()Ljava/io/ObjectOutputStream$PutField;',
  );

  static final _putFields =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.ObjectOutputStream$PutField putFields()`
  /// The returned object must be released after use, by calling the [release] method.
  ObjectOutputStream$PutField? putFields() => _putFields(
    reference.pointer,
    _id_putFields as jni$_.JMethodIDPtr,
  ).object<ObjectOutputStream$PutField?>(
    const $ObjectOutputStream$PutField$NullableType(),
  );

  static final _id_writeFields = _class.instanceMethodId(
    r'writeFields',
    r'()V',
  );

  static final _writeFields =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void writeFields()`
  void writeFields() {
    _writeFields(
      reference.pointer,
      _id_writeFields as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(byte[] bs)`
  void write1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write1(
      reference.pointer,
      _id_write1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_writeBoolean = _class.instanceMethodId(
    r'writeBoolean',
    r'(Z)V',
  );

  static final _writeBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void writeBoolean(boolean z)`
  void writeBoolean(bool z) {
    _writeBoolean(
      reference.pointer,
      _id_writeBoolean as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_writeByte = _class.instanceMethodId(r'writeByte', r'(I)V');

  static final _writeByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void writeByte(int i)`
  void writeByte(int i) {
    _writeByte(
      reference.pointer,
      _id_writeByte as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeShort = _class.instanceMethodId(r'writeShort', r'(I)V');

  static final _writeShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void writeShort(int i)`
  void writeShort(int i) {
    _writeShort(
      reference.pointer,
      _id_writeShort as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeChar = _class.instanceMethodId(r'writeChar', r'(I)V');

  static final _writeChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void writeChar(int i)`
  void writeChar(int i) {
    _writeChar(
      reference.pointer,
      _id_writeChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeInt = _class.instanceMethodId(r'writeInt', r'(I)V');

  static final _writeInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void writeInt(int i)`
  void writeInt(int i) {
    _writeInt(reference.pointer, _id_writeInt as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_writeLong = _class.instanceMethodId(r'writeLong', r'(J)V');

  static final _writeLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void writeLong(long j)`
  void writeLong(int j) {
    _writeLong(
      reference.pointer,
      _id_writeLong as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_writeFloat = _class.instanceMethodId(r'writeFloat', r'(F)V');

  static final _writeFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void writeFloat(float f)`
  void writeFloat(double f) {
    _writeFloat(
      reference.pointer,
      _id_writeFloat as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_writeDouble = _class.instanceMethodId(
    r'writeDouble',
    r'(D)V',
  );

  static final _writeDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void writeDouble(double d)`
  void writeDouble(double d) {
    _writeDouble(
      reference.pointer,
      _id_writeDouble as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'(Ljava/lang/String;)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeBytes(java.lang.String string)`
  void writeBytes(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeChars = _class.instanceMethodId(
    r'writeChars',
    r'(Ljava/lang/String;)V',
  );

  static final _writeChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeChars(java.lang.String string)`
  void writeChars(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeChars(
      reference.pointer,
      _id_writeChars as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeUTF = _class.instanceMethodId(
    r'writeUTF',
    r'(Ljava/lang/String;)V',
  );

  static final _writeUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeUTF(java.lang.String string)`
  void writeUTF(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeUTF(
      reference.pointer,
      _id_writeUTF as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }
}

final class $ObjectOutputStream$NullableType
    extends jni$_.JObjType<ObjectOutputStream?> {
  @jni$_.internal
  const $ObjectOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectOutputStream;';

  @jni$_.internal
  @core$_.override
  ObjectOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ObjectOutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectOutputStream$NullableType) &&
      other is $ObjectOutputStream$NullableType;
}

final class $ObjectOutputStream$Type
    extends jni$_.JObjType<ObjectOutputStream> {
  @jni$_.internal
  const $ObjectOutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectOutputStream;';

  @jni$_.internal
  @core$_.override
  ObjectOutputStream fromReference(jni$_.JReference reference) =>
      ObjectOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectOutputStream?> get nullableType =>
      const $ObjectOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ObjectOutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectOutputStream$Type) &&
      other is $ObjectOutputStream$Type;
}

/// from: `java.io.Flushable`
class Flushable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Flushable> $type;

  @jni$_.internal
  Flushable.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Flushable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Flushable$NullableType();
  static const type = $Flushable$Type();
  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Flushable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'flush()V') {
        _$impls[$p]!.flush();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $Flushable $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.Flushable', $p, _$invokePointer, [
      if ($impl.flush$async) r'flush()V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Flushable.implement($Flushable $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Flushable.fromReference($i.implementReference());
  }
}

abstract base mixin class $Flushable {
  factory $Flushable({required void Function() flush, bool flush$async}) =
      _$Flushable;

  void flush();
  bool get flush$async => false;
}

final class _$Flushable with $Flushable {
  _$Flushable({required void Function() flush, this.flush$async = false})
    : _flush = flush;

  final void Function() _flush;
  final bool flush$async;

  void flush() => _flush();
}

final class $Flushable$NullableType extends jni$_.JObjType<Flushable?> {
  @jni$_.internal
  const $Flushable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Flushable;';

  @jni$_.internal
  @core$_.override
  Flushable? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Flushable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Flushable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Flushable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Flushable$NullableType) &&
      other is $Flushable$NullableType;
}

final class $Flushable$Type extends jni$_.JObjType<Flushable> {
  @jni$_.internal
  const $Flushable$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Flushable;';

  @jni$_.internal
  @core$_.override
  Flushable fromReference(jni$_.JReference reference) =>
      Flushable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Flushable?> get nullableType =>
      const $Flushable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Flushable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Flushable$Type) && other is $Flushable$Type;
}

/// from: `java.io.DataOutput`
class DataOutput extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DataOutput> $type;

  @jni$_.internal
  DataOutput.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/DataOutput');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DataOutput$NullableType();
  static const type = $DataOutput$Type();
  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write$1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void write(byte[] bs)`
  void write$1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$1(
      reference.pointer,
      _id_write$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_write$2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract void write(byte[] bs, int i, int i1)`
  void write$2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$2(
      reference.pointer,
      _id_write$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_writeBoolean = _class.instanceMethodId(
    r'writeBoolean',
    r'(Z)V',
  );

  static final _writeBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeBoolean(boolean z)`
  void writeBoolean(bool z) {
    _writeBoolean(
      reference.pointer,
      _id_writeBoolean as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_writeByte = _class.instanceMethodId(r'writeByte', r'(I)V');

  static final _writeByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeByte(int i)`
  void writeByte(int i) {
    _writeByte(
      reference.pointer,
      _id_writeByte as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeShort = _class.instanceMethodId(r'writeShort', r'(I)V');

  static final _writeShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeShort(int i)`
  void writeShort(int i) {
    _writeShort(
      reference.pointer,
      _id_writeShort as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeChar = _class.instanceMethodId(r'writeChar', r'(I)V');

  static final _writeChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeChar(int i)`
  void writeChar(int i) {
    _writeChar(
      reference.pointer,
      _id_writeChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeInt = _class.instanceMethodId(r'writeInt', r'(I)V');

  static final _writeInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeInt(int i)`
  void writeInt(int i) {
    _writeInt(reference.pointer, _id_writeInt as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_writeLong = _class.instanceMethodId(r'writeLong', r'(J)V');

  static final _writeLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeLong(long j)`
  void writeLong(int j) {
    _writeLong(
      reference.pointer,
      _id_writeLong as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_writeFloat = _class.instanceMethodId(r'writeFloat', r'(F)V');

  static final _writeFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public abstract void writeFloat(float f)`
  void writeFloat(double f) {
    _writeFloat(
      reference.pointer,
      _id_writeFloat as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_writeDouble = _class.instanceMethodId(
    r'writeDouble',
    r'(D)V',
  );

  static final _writeDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public abstract void writeDouble(double d)`
  void writeDouble(double d) {
    _writeDouble(
      reference.pointer,
      _id_writeDouble as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'(Ljava/lang/String;)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeBytes(java.lang.String string)`
  void writeBytes(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeChars = _class.instanceMethodId(
    r'writeChars',
    r'(Ljava/lang/String;)V',
  );

  static final _writeChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeChars(java.lang.String string)`
  void writeChars(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeChars(
      reference.pointer,
      _id_writeChars as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeUTF = _class.instanceMethodId(
    r'writeUTF',
    r'(Ljava/lang/String;)V',
  );

  static final _writeUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeUTF(java.lang.String string)`
  void writeUTF(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeUTF(
      reference.pointer,
      _id_writeUTF as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $DataOutput> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'write(I)V') {
        _$impls[$p]!.write(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'write([B)V') {
        _$impls[$p]!.write$1(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'write([BII)V') {
        _$impls[$p]!.write$2(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeBoolean(Z)V') {
        _$impls[$p]!.writeBoolean(
          $a![0]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeByte(I)V') {
        _$impls[$p]!.writeByte(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeShort(I)V') {
        _$impls[$p]!.writeShort(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeChar(I)V') {
        _$impls[$p]!.writeChar(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeInt(I)V') {
        _$impls[$p]!.writeInt(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeLong(J)V') {
        _$impls[$p]!.writeLong(
          $a![0]!
              .as(const jni$_.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeFloat(F)V') {
        _$impls[$p]!.writeFloat(
          $a![0]!
              .as(const jni$_.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeDouble(D)V') {
        _$impls[$p]!.writeDouble(
          $a![0]!
              .as(const jni$_.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeBytes(Ljava/lang/String;)V') {
        _$impls[$p]!.writeBytes(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeChars(Ljava/lang/String;)V') {
        _$impls[$p]!.writeChars(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeUTF(Ljava/lang/String;)V') {
        _$impls[$p]!.writeUTF(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $DataOutput $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.DataOutput', $p, _$invokePointer, [
      if ($impl.write$async) r'write(I)V',
      if ($impl.write$1$async) r'write([B)V',
      if ($impl.write$2$async) r'write([BII)V',
      if ($impl.writeBoolean$async) r'writeBoolean(Z)V',
      if ($impl.writeByte$async) r'writeByte(I)V',
      if ($impl.writeShort$async) r'writeShort(I)V',
      if ($impl.writeChar$async) r'writeChar(I)V',
      if ($impl.writeInt$async) r'writeInt(I)V',
      if ($impl.writeLong$async) r'writeLong(J)V',
      if ($impl.writeFloat$async) r'writeFloat(F)V',
      if ($impl.writeDouble$async) r'writeDouble(D)V',
      if ($impl.writeBytes$async) r'writeBytes(Ljava/lang/String;)V',
      if ($impl.writeChars$async) r'writeChars(Ljava/lang/String;)V',
      if ($impl.writeUTF$async) r'writeUTF(Ljava/lang/String;)V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory DataOutput.implement($DataOutput $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return DataOutput.fromReference($i.implementReference());
  }
}

abstract base mixin class $DataOutput {
  factory $DataOutput({
    required void Function(int i) write,
    bool write$async,
    required void Function(jni$_.JByteArray? bs) write$1,
    bool write$1$async,
    required void Function(jni$_.JByteArray? bs, int i, int i1) write$2,
    bool write$2$async,
    required void Function(bool z) writeBoolean,
    bool writeBoolean$async,
    required void Function(int i) writeByte,
    bool writeByte$async,
    required void Function(int i) writeShort,
    bool writeShort$async,
    required void Function(int i) writeChar,
    bool writeChar$async,
    required void Function(int i) writeInt,
    bool writeInt$async,
    required void Function(int j) writeLong,
    bool writeLong$async,
    required void Function(double f) writeFloat,
    bool writeFloat$async,
    required void Function(double d) writeDouble,
    bool writeDouble$async,
    required void Function(jni$_.JString? string) writeBytes,
    bool writeBytes$async,
    required void Function(jni$_.JString? string) writeChars,
    bool writeChars$async,
    required void Function(jni$_.JString? string) writeUTF,
    bool writeUTF$async,
  }) = _$DataOutput;

  void write(int i);
  bool get write$async => false;
  void write$1(jni$_.JByteArray? bs);
  bool get write$1$async => false;
  void write$2(jni$_.JByteArray? bs, int i, int i1);
  bool get write$2$async => false;
  void writeBoolean(bool z);
  bool get writeBoolean$async => false;
  void writeByte(int i);
  bool get writeByte$async => false;
  void writeShort(int i);
  bool get writeShort$async => false;
  void writeChar(int i);
  bool get writeChar$async => false;
  void writeInt(int i);
  bool get writeInt$async => false;
  void writeLong(int j);
  bool get writeLong$async => false;
  void writeFloat(double f);
  bool get writeFloat$async => false;
  void writeDouble(double d);
  bool get writeDouble$async => false;
  void writeBytes(jni$_.JString? string);
  bool get writeBytes$async => false;
  void writeChars(jni$_.JString? string);
  bool get writeChars$async => false;
  void writeUTF(jni$_.JString? string);
  bool get writeUTF$async => false;
}

final class _$DataOutput with $DataOutput {
  _$DataOutput({
    required void Function(int i) write,
    this.write$async = false,
    required void Function(jni$_.JByteArray? bs) write$1,
    this.write$1$async = false,
    required void Function(jni$_.JByteArray? bs, int i, int i1) write$2,
    this.write$2$async = false,
    required void Function(bool z) writeBoolean,
    this.writeBoolean$async = false,
    required void Function(int i) writeByte,
    this.writeByte$async = false,
    required void Function(int i) writeShort,
    this.writeShort$async = false,
    required void Function(int i) writeChar,
    this.writeChar$async = false,
    required void Function(int i) writeInt,
    this.writeInt$async = false,
    required void Function(int j) writeLong,
    this.writeLong$async = false,
    required void Function(double f) writeFloat,
    this.writeFloat$async = false,
    required void Function(double d) writeDouble,
    this.writeDouble$async = false,
    required void Function(jni$_.JString? string) writeBytes,
    this.writeBytes$async = false,
    required void Function(jni$_.JString? string) writeChars,
    this.writeChars$async = false,
    required void Function(jni$_.JString? string) writeUTF,
    this.writeUTF$async = false,
  }) : _write = write,
       _write$1 = write$1,
       _write$2 = write$2,
       _writeBoolean = writeBoolean,
       _writeByte = writeByte,
       _writeShort = writeShort,
       _writeChar = writeChar,
       _writeInt = writeInt,
       _writeLong = writeLong,
       _writeFloat = writeFloat,
       _writeDouble = writeDouble,
       _writeBytes = writeBytes,
       _writeChars = writeChars,
       _writeUTF = writeUTF;

  final void Function(int i) _write;
  final bool write$async;
  final void Function(jni$_.JByteArray? bs) _write$1;
  final bool write$1$async;
  final void Function(jni$_.JByteArray? bs, int i, int i1) _write$2;
  final bool write$2$async;
  final void Function(bool z) _writeBoolean;
  final bool writeBoolean$async;
  final void Function(int i) _writeByte;
  final bool writeByte$async;
  final void Function(int i) _writeShort;
  final bool writeShort$async;
  final void Function(int i) _writeChar;
  final bool writeChar$async;
  final void Function(int i) _writeInt;
  final bool writeInt$async;
  final void Function(int j) _writeLong;
  final bool writeLong$async;
  final void Function(double f) _writeFloat;
  final bool writeFloat$async;
  final void Function(double d) _writeDouble;
  final bool writeDouble$async;
  final void Function(jni$_.JString? string) _writeBytes;
  final bool writeBytes$async;
  final void Function(jni$_.JString? string) _writeChars;
  final bool writeChars$async;
  final void Function(jni$_.JString? string) _writeUTF;
  final bool writeUTF$async;

  void write(int i) => _write(i);

  void write$1(jni$_.JByteArray? bs) => _write$1(bs);

  void write$2(jni$_.JByteArray? bs, int i, int i1) => _write$2(bs, i, i1);

  void writeBoolean(bool z) => _writeBoolean(z);

  void writeByte(int i) => _writeByte(i);

  void writeShort(int i) => _writeShort(i);

  void writeChar(int i) => _writeChar(i);

  void writeInt(int i) => _writeInt(i);

  void writeLong(int j) => _writeLong(j);

  void writeFloat(double f) => _writeFloat(f);

  void writeDouble(double d) => _writeDouble(d);

  void writeBytes(jni$_.JString? string) => _writeBytes(string);

  void writeChars(jni$_.JString? string) => _writeChars(string);

  void writeUTF(jni$_.JString? string) => _writeUTF(string);
}

final class $DataOutput$NullableType extends jni$_.JObjType<DataOutput?> {
  @jni$_.internal
  const $DataOutput$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataOutput;';

  @jni$_.internal
  @core$_.override
  DataOutput? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DataOutput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataOutput?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DataOutput$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DataOutput$NullableType) &&
      other is $DataOutput$NullableType;
}

final class $DataOutput$Type extends jni$_.JObjType<DataOutput> {
  @jni$_.internal
  const $DataOutput$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataOutput;';

  @jni$_.internal
  @core$_.override
  DataOutput fromReference(jni$_.JReference reference) =>
      DataOutput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataOutput?> get nullableType =>
      const $DataOutput$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DataOutput$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DataOutput$Type) && other is $DataOutput$Type;
}

/// from: `java.io.BufferedWriter`
class BufferedWriter extends Writer {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<BufferedWriter> $type;

  @jni$_.internal
  BufferedWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/BufferedWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $BufferedWriter$NullableType();
  static const type = $BufferedWriter$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/Writer;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.Writer writer)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedWriter(Writer? writer) {
    final _$writer = writer?.reference ?? jni$_.jNullReference;
    return BufferedWriter.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$writer.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/Writer;I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.Writer writer, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedWriter.new$1(Writer? writer, int i) {
    final _$writer = writer?.reference ?? jni$_.jNullReference;
    return BufferedWriter.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$writer.pointer,
        i,
      ).reference,
    );
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(char[] cs, int i, int i1)`
  void write2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write4 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;II)V',
  );

  static final _write4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(java.lang.String string, int i, int i1)`
  void write4(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write4(
      reference.pointer,
      _id_write4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_newLine = _class.instanceMethodId(r'newLine', r'()V');

  static final _newLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void newLine()`
  void newLine() {
    _newLine(reference.pointer, _id_newLine as jni$_.JMethodIDPtr).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $BufferedWriter$NullableType
    extends jni$_.JObjType<BufferedWriter?> {
  @jni$_.internal
  const $BufferedWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedWriter;';

  @jni$_.internal
  @core$_.override
  BufferedWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : BufferedWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($BufferedWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($BufferedWriter$NullableType) &&
      other is $BufferedWriter$NullableType;
}

final class $BufferedWriter$Type extends jni$_.JObjType<BufferedWriter> {
  @jni$_.internal
  const $BufferedWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedWriter;';

  @jni$_.internal
  @core$_.override
  BufferedWriter fromReference(jni$_.JReference reference) =>
      BufferedWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedWriter?> get nullableType =>
      const $BufferedWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($BufferedWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($BufferedWriter$Type) &&
      other is $BufferedWriter$Type;
}

/// from: `java.io.StringWriter`
class StringWriter extends Writer {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StringWriter> $type;

  @jni$_.internal
  StringWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/StringWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StringWriter$NullableType();
  static const type = $StringWriter$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringWriter() => StringWriter.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$1 = _class.constructorId(r'(I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringWriter.new$1(int i) => StringWriter.fromReference(
    _new$1(
      _class.reference.pointer,
      _id_new$1 as jni$_.JMethodIDPtr,
      i,
    ).reference,
  );

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(char[] cs, int i, int i1)`
  void write2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write3 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;)V',
  );

  static final _write3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(java.lang.String string)`
  void write3(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write3(
      reference.pointer,
      _id_write3 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_write4 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;II)V',
  );

  static final _write4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(java.lang.String string, int i, int i1)`
  void write4(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write4(
      reference.pointer,
      _id_write4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_append$3 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;)Ljava/io/StringWriter;',
  );

  static final _append$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.StringWriter append(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  StringWriter? append$3(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$3(
      reference.pointer,
      _id_append$3 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<StringWriter?>(const $StringWriter$NullableType());
  }

  static final _id_append$4 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;II)Ljava/io/StringWriter;',
  );

  static final _append$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public java.io.StringWriter append(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  StringWriter? append$4(jni$_.JObject? charSequence, int i, int i1) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$4(
      reference.pointer,
      _id_append$4 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
    ).object<StringWriter?>(const $StringWriter$NullableType());
  }

  static final _id_append$5 = _class.instanceMethodId(
    r'append',
    r'(C)Ljava/io/StringWriter;',
  );

  static final _append$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.io.StringWriter append(char c)`
  /// The returned object must be released after use, by calling the [release] method.
  StringWriter? append$5(int c) => _append$5(
    reference.pointer,
    _id_append$5 as jni$_.JMethodIDPtr,
    c,
  ).object<StringWriter?>(const $StringWriter$NullableType());

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getBuffer = _class.instanceMethodId(
    r'getBuffer',
    r'()Ljava/lang/StringBuffer;',
  );

  static final _getBuffer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.StringBuffer getBuffer()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getBuffer() => _getBuffer(
    reference.pointer,
    _id_getBuffer as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $StringWriter$NullableType extends jni$_.JObjType<StringWriter?> {
  @jni$_.internal
  const $StringWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StringWriter;';

  @jni$_.internal
  @core$_.override
  StringWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : StringWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($StringWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StringWriter$NullableType) &&
      other is $StringWriter$NullableType;
}

final class $StringWriter$Type extends jni$_.JObjType<StringWriter> {
  @jni$_.internal
  const $StringWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StringWriter;';

  @jni$_.internal
  @core$_.override
  StringWriter fromReference(jni$_.JReference reference) =>
      StringWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringWriter?> get nullableType =>
      const $StringWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($StringWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StringWriter$Type) && other is $StringWriter$Type;
}

/// from: `java.io.FileOutputStream`
class FileOutputStream extends OutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileOutputStream> $type;

  @jni$_.internal
  FileOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FileOutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileOutputStream$NullableType();
  static const type = $FileOutputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileOutputStream(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return FileOutputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/lang/String;Z)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileOutputStream.new$1(jni$_.JString? string, bool z) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return FileOutputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Ljava/io/File;)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileOutputStream.new$2(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return FileOutputStream.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$file.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(Ljava/io/File;Z)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.File file, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileOutputStream.new$3(File? file, bool z) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return FileOutputStream.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$file.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(r'(Ljava/io/FileDescriptor;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.FileDescriptor fileDescriptor)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileOutputStream.new$4(FileDescriptor? fileDescriptor) {
    final _$fileDescriptor = fileDescriptor?.reference ?? jni$_.jNullReference;
    return FileOutputStream.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$fileDescriptor.pointer,
      ).reference,
    );
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(byte[] bs)`
  void write1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write1(
      reference.pointer,
      _id_write1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_getFD = _class.instanceMethodId(
    r'getFD',
    r'()Ljava/io/FileDescriptor;',
  );

  static final _getFD =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.io.FileDescriptor getFD()`
  /// The returned object must be released after use, by calling the [release] method.
  FileDescriptor? getFD() => _getFD(
    reference.pointer,
    _id_getFD as jni$_.JMethodIDPtr,
  ).object<FileDescriptor?>(const $FileDescriptor$NullableType());

  static final _id_getChannel = _class.instanceMethodId(
    r'getChannel',
    r'()Ljava/nio/channels/FileChannel;',
  );

  static final _getChannel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.channels.FileChannel getChannel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChannel() => _getChannel(
    reference.pointer,
    _id_getChannel as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
}

final class $FileOutputStream$NullableType
    extends jni$_.JObjType<FileOutputStream?> {
  @jni$_.internal
  const $FileOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileOutputStream;';

  @jni$_.internal
  @core$_.override
  FileOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FileOutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileOutputStream$NullableType) &&
      other is $FileOutputStream$NullableType;
}

final class $FileOutputStream$Type extends jni$_.JObjType<FileOutputStream> {
  @jni$_.internal
  const $FileOutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileOutputStream;';

  @jni$_.internal
  @core$_.override
  FileOutputStream fromReference(jni$_.JReference reference) =>
      FileOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileOutputStream?> get nullableType =>
      const $FileOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FileOutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileOutputStream$Type) &&
      other is $FileOutputStream$Type;
}

/// from: `java.io.IOException`
class IOException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<IOException> $type;

  @jni$_.internal
  IOException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/IOException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $IOException$NullableType();
  static const type = $IOException$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory IOException() => IOException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory IOException.new$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return IOException.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/Throwable;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.Throwable throwable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory IOException.new$2(jni$_.JString? string, jni$_.JObject? throwable) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    return IOException.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$throwable.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(Ljava/lang/Throwable;)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.Throwable throwable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory IOException.new$3(jni$_.JObject? throwable) {
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    return IOException.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$throwable.pointer,
      ).reference,
    );
  }
}

final class $IOException$NullableType extends jni$_.JObjType<IOException?> {
  @jni$_.internal
  const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/IOException;';

  @jni$_.internal
  @core$_.override
  IOException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : IOException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IOException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IOException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($IOException$NullableType) &&
      other is $IOException$NullableType;
}

final class $IOException$Type extends jni$_.JObjType<IOException> {
  @jni$_.internal
  const $IOException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/IOException;';

  @jni$_.internal
  @core$_.override
  IOException fromReference(jni$_.JReference reference) =>
      IOException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IOException?> get nullableType =>
      const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IOException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($IOException$Type) && other is $IOException$Type;
}

/// from: `java.io.PipedOutputStream`
class PipedOutputStream extends OutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PipedOutputStream> $type;

  @jni$_.internal
  PipedOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PipedOutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PipedOutputStream$NullableType();
  static const type = $PipedOutputStream$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/io/PipedInputStream;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.PipedInputStream pipedInputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedOutputStream(PipedInputStream? pipedInputStream) {
    final _$pipedInputStream =
        pipedInputStream?.reference ?? jni$_.jNullReference;
    return PipedOutputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$pipedInputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'()V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedOutputStream.new$1() => PipedOutputStream.fromReference(
    _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr).reference,
  );

  static final _id_connect = _class.instanceMethodId(
    r'connect',
    r'(Ljava/io/PipedInputStream;)V',
  );

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void connect(java.io.PipedInputStream pipedInputStream)`
  void connect(PipedInputStream? pipedInputStream) {
    final _$pipedInputStream =
        pipedInputStream?.reference ?? jni$_.jNullReference;
    _connect(
      reference.pointer,
      _id_connect as jni$_.JMethodIDPtr,
      _$pipedInputStream.pointer,
    ).check();
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $PipedOutputStream$NullableType
    extends jni$_.JObjType<PipedOutputStream?> {
  @jni$_.internal
  const $PipedOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedOutputStream;';

  @jni$_.internal
  @core$_.override
  PipedOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PipedOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedOutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PipedOutputStream$NullableType) &&
      other is $PipedOutputStream$NullableType;
}

final class $PipedOutputStream$Type extends jni$_.JObjType<PipedOutputStream> {
  @jni$_.internal
  const $PipedOutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedOutputStream;';

  @jni$_.internal
  @core$_.override
  PipedOutputStream fromReference(jni$_.JReference reference) =>
      PipedOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedOutputStream?> get nullableType =>
      const $PipedOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedOutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PipedOutputStream$Type) &&
      other is $PipedOutputStream$Type;
}

/// from: `java.io.InputStreamReader`
class InputStreamReader extends Reader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InputStreamReader> $type;

  @jni$_.internal
  InputStreamReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/InputStreamReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InputStreamReader$NullableType();
  static const type = $InputStreamReader$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/InputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InputStreamReader(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return InputStreamReader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/io/InputStream;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InputStreamReader.new$1(
    InputStream? inputStream,
    jni$_.JString? string,
  ) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return InputStreamReader.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/io/InputStream;Ljava/nio/charset/Charset;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InputStreamReader.new$2(
    InputStream? inputStream,
    jni$_.JObject? charset,
  ) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return InputStreamReader.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/io/InputStream;Ljava/nio/charset/CharsetDecoder;)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream, java.nio.charset.CharsetDecoder charsetDecoder)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InputStreamReader.new$3(
    InputStream? inputStream,
    jni$_.JObject? charsetDecoder,
  ) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    final _$charsetDecoder = charsetDecoder?.reference ?? jni$_.jNullReference;
    return InputStreamReader.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
        _$charsetDecoder.pointer,
      ).reference,
    );
  }

  static final _id_getEncoding = _class.instanceMethodId(
    r'getEncoding',
    r'()Ljava/lang/String;',
  );

  static final _getEncoding =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getEncoding()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getEncoding() => _getEncoding(
    reference.pointer,
    _id_getEncoding as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_read = _class.instanceMethodId(
    r'read',
    r'(Ljava/nio/CharBuffer;)I',
  );

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(java.nio.CharBuffer charBuffer)`
  int read(jni$_.JObject? charBuffer) {
    final _$charBuffer = charBuffer?.reference ?? jni$_.jNullReference;
    return _read(
      reference.pointer,
      _id_read as jni$_.JMethodIDPtr,
      _$charBuffer.pointer,
    ).integer;
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() =>
      _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() =>
      _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $InputStreamReader$NullableType
    extends jni$_.JObjType<InputStreamReader?> {
  @jni$_.internal
  const $InputStreamReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InputStreamReader;';

  @jni$_.internal
  @core$_.override
  InputStreamReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InputStreamReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InputStreamReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($InputStreamReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InputStreamReader$NullableType) &&
      other is $InputStreamReader$NullableType;
}

final class $InputStreamReader$Type extends jni$_.JObjType<InputStreamReader> {
  @jni$_.internal
  const $InputStreamReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InputStreamReader;';

  @jni$_.internal
  @core$_.override
  InputStreamReader fromReference(jni$_.JReference reference) =>
      InputStreamReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InputStreamReader?> get nullableType =>
      const $InputStreamReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($InputStreamReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InputStreamReader$Type) &&
      other is $InputStreamReader$Type;
}

/// from: `java.io.File`
class File extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<File> $type;

  @jni$_.internal
  File.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/File');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $File$NullableType();
  static const type = $File$Type();
  static final _id_separatorChar = _class.staticFieldId(r'separatorChar', r'C');

  /// from: `static public final char separatorChar`
  static int get separatorChar =>
      _id_separatorChar.get(_class, const jni$_.jcharType());

  static final _id_separator = _class.staticFieldId(
    r'separator',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String separator`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get separator =>
      _id_separator.get(_class, const jni$_.JStringNullableType());

  static final _id_pathSeparatorChar = _class.staticFieldId(
    r'pathSeparatorChar',
    r'C',
  );

  /// from: `static public final char pathSeparatorChar`
  static int get pathSeparatorChar =>
      _id_pathSeparatorChar.get(_class, const jni$_.jcharType());

  static final _id_pathSeparator = _class.staticFieldId(
    r'pathSeparator',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String pathSeparator`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get pathSeparator =>
      _id_pathSeparator.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return File.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$1(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return File.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/io/File;Ljava/lang/String;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$2(File? file, jni$_.JString? string) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return File.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(Ljava/net/URI;)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.URI uRI)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$3(URI? uRI) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    return File.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$uRI.pointer,
      ).reference,
    );
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() => _getName(
    reference.pointer,
    _id_getName as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getParent = _class.instanceMethodId(
    r'getParent',
    r'()Ljava/lang/String;',
  );

  static final _getParent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getParent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getParent() => _getParent(
    reference.pointer,
    _id_getParent as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getParentFile = _class.instanceMethodId(
    r'getParentFile',
    r'()Ljava/io/File;',
  );

  static final _getParentFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.File getParentFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getParentFile() => _getParentFile(
    reference.pointer,
    _id_getParentFile as jni$_.JMethodIDPtr,
  ).object<File?>(const $File$NullableType());

  static final _id_getPath = _class.instanceMethodId(
    r'getPath',
    r'()Ljava/lang/String;',
  );

  static final _getPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPath() => _getPath(
    reference.pointer,
    _id_getPath as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_isAbsolute = _class.instanceMethodId(r'isAbsolute', r'()Z');

  static final _isAbsolute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isAbsolute()`
  bool isAbsolute() =>
      _isAbsolute(
        reference.pointer,
        _id_isAbsolute as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_getAbsolutePath = _class.instanceMethodId(
    r'getAbsolutePath',
    r'()Ljava/lang/String;',
  );

  static final _getAbsolutePath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getAbsolutePath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAbsolutePath() => _getAbsolutePath(
    reference.pointer,
    _id_getAbsolutePath as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getAbsoluteFile = _class.instanceMethodId(
    r'getAbsoluteFile',
    r'()Ljava/io/File;',
  );

  static final _getAbsoluteFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.File getAbsoluteFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getAbsoluteFile() => _getAbsoluteFile(
    reference.pointer,
    _id_getAbsoluteFile as jni$_.JMethodIDPtr,
  ).object<File?>(const $File$NullableType());

  static final _id_getCanonicalPath = _class.instanceMethodId(
    r'getCanonicalPath',
    r'()Ljava/lang/String;',
  );

  static final _getCanonicalPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getCanonicalPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCanonicalPath() => _getCanonicalPath(
    reference.pointer,
    _id_getCanonicalPath as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getCanonicalFile = _class.instanceMethodId(
    r'getCanonicalFile',
    r'()Ljava/io/File;',
  );

  static final _getCanonicalFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.File getCanonicalFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getCanonicalFile() => _getCanonicalFile(
    reference.pointer,
    _id_getCanonicalFile as jni$_.JMethodIDPtr,
  ).object<File?>(const $File$NullableType());

  static final _id_toURL = _class.instanceMethodId(
    r'toURL',
    r'()Ljava/net/URL;',
  );

  static final _toURL =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URL toURL()`
  /// The returned object must be released after use, by calling the [release] method.
  URL? toURL() => _toURL(
    reference.pointer,
    _id_toURL as jni$_.JMethodIDPtr,
  ).object<URL?>(const $URL$NullableType());

  static final _id_toURI = _class.instanceMethodId(
    r'toURI',
    r'()Ljava/net/URI;',
  );

  static final _toURI =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URI toURI()`
  /// The returned object must be released after use, by calling the [release] method.
  URI? toURI() => _toURI(
    reference.pointer,
    _id_toURI as jni$_.JMethodIDPtr,
  ).object<URI?>(const $URI$NullableType());

  static final _id_canRead = _class.instanceMethodId(r'canRead', r'()Z');

  static final _canRead =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean canRead()`
  bool canRead() =>
      _canRead(reference.pointer, _id_canRead as jni$_.JMethodIDPtr).boolean;

  static final _id_canWrite = _class.instanceMethodId(r'canWrite', r'()Z');

  static final _canWrite =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean canWrite()`
  bool canWrite() =>
      _canWrite(reference.pointer, _id_canWrite as jni$_.JMethodIDPtr).boolean;

  static final _id_exists = _class.instanceMethodId(r'exists', r'()Z');

  static final _exists =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean exists()`
  bool exists() =>
      _exists(reference.pointer, _id_exists as jni$_.JMethodIDPtr).boolean;

  static final _id_isDirectory = _class.instanceMethodId(
    r'isDirectory',
    r'()Z',
  );

  static final _isDirectory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isDirectory()`
  bool isDirectory() =>
      _isDirectory(
        reference.pointer,
        _id_isDirectory as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isFile = _class.instanceMethodId(r'isFile', r'()Z');

  static final _isFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isFile()`
  bool isFile() =>
      _isFile(reference.pointer, _id_isFile as jni$_.JMethodIDPtr).boolean;

  static final _id_isHidden = _class.instanceMethodId(r'isHidden', r'()Z');

  static final _isHidden =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isHidden()`
  bool isHidden() =>
      _isHidden(reference.pointer, _id_isHidden as jni$_.JMethodIDPtr).boolean;

  static final _id_lastModified = _class.instanceMethodId(
    r'lastModified',
    r'()J',
  );

  static final _lastModified =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long lastModified()`
  int lastModified() =>
      _lastModified(
        reference.pointer,
        _id_lastModified as jni$_.JMethodIDPtr,
      ).long;

  static final _id_length = _class.instanceMethodId(r'length', r'()J');

  static final _length =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long length()`
  int length() =>
      _length(reference.pointer, _id_length as jni$_.JMethodIDPtr).long;

  static final _id_createNewFile = _class.instanceMethodId(
    r'createNewFile',
    r'()Z',
  );

  static final _createNewFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean createNewFile()`
  bool createNewFile() =>
      _createNewFile(
        reference.pointer,
        _id_createNewFile as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_delete = _class.instanceMethodId(r'delete', r'()Z');

  static final _delete =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean delete()`
  bool delete() =>
      _delete(reference.pointer, _id_delete as jni$_.JMethodIDPtr).boolean;

  static final _id_deleteOnExit = _class.instanceMethodId(
    r'deleteOnExit',
    r'()V',
  );

  static final _deleteOnExit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void deleteOnExit()`
  void deleteOnExit() {
    _deleteOnExit(
      reference.pointer,
      _id_deleteOnExit as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_list = _class.instanceMethodId(
    r'list',
    r'()[Ljava/lang/String;',
  );

  static final _list =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String[] list()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? list() => _list(
    reference.pointer,
    _id_list as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<jni$_.JString?>?>(
    const jni$_.JArrayNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
  );

  static final _id_list$1 = _class.instanceMethodId(
    r'list',
    r'(Ljava/io/FilenameFilter;)[Ljava/lang/String;',
  );

  static final _list$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String[] list(java.io.FilenameFilter filenameFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? list$1(FilenameFilter? filenameFilter) {
    final _$filenameFilter = filenameFilter?.reference ?? jni$_.jNullReference;
    return _list$1(
      reference.pointer,
      _id_list$1 as jni$_.JMethodIDPtr,
      _$filenameFilter.pointer,
    ).object<jni$_.JArray<jni$_.JString?>?>(
      const jni$_.JArrayNullableType<jni$_.JString?>(
        jni$_.JStringNullableType(),
      ),
    );
  }

  static final _id_listFiles = _class.instanceMethodId(
    r'listFiles',
    r'()[Ljava/io/File;',
  );

  static final _listFiles =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.File[] listFiles()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles() => _listFiles(
    reference.pointer,
    _id_listFiles as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<File?>?>(
    const jni$_.JArrayNullableType<File?>($File$NullableType()),
  );

  static final _id_listFiles$1 = _class.instanceMethodId(
    r'listFiles',
    r'(Ljava/io/FilenameFilter;)[Ljava/io/File;',
  );

  static final _listFiles$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.File[] listFiles(java.io.FilenameFilter filenameFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles$1(FilenameFilter? filenameFilter) {
    final _$filenameFilter = filenameFilter?.reference ?? jni$_.jNullReference;
    return _listFiles$1(
      reference.pointer,
      _id_listFiles$1 as jni$_.JMethodIDPtr,
      _$filenameFilter.pointer,
    ).object<jni$_.JArray<File?>?>(
      const jni$_.JArrayNullableType<File?>($File$NullableType()),
    );
  }

  static final _id_listFiles$2 = _class.instanceMethodId(
    r'listFiles',
    r'(Ljava/io/FileFilter;)[Ljava/io/File;',
  );

  static final _listFiles$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.File[] listFiles(java.io.FileFilter fileFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles$2(FileFilter? fileFilter) {
    final _$fileFilter = fileFilter?.reference ?? jni$_.jNullReference;
    return _listFiles$2(
      reference.pointer,
      _id_listFiles$2 as jni$_.JMethodIDPtr,
      _$fileFilter.pointer,
    ).object<jni$_.JArray<File?>?>(
      const jni$_.JArrayNullableType<File?>($File$NullableType()),
    );
  }

  static final _id_mkdir = _class.instanceMethodId(r'mkdir', r'()Z');

  static final _mkdir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean mkdir()`
  bool mkdir() =>
      _mkdir(reference.pointer, _id_mkdir as jni$_.JMethodIDPtr).boolean;

  static final _id_mkdirs = _class.instanceMethodId(r'mkdirs', r'()Z');

  static final _mkdirs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean mkdirs()`
  bool mkdirs() =>
      _mkdirs(reference.pointer, _id_mkdirs as jni$_.JMethodIDPtr).boolean;

  static final _id_renameTo = _class.instanceMethodId(
    r'renameTo',
    r'(Ljava/io/File;)Z',
  );

  static final _renameTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean renameTo(java.io.File file)`
  bool renameTo(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _renameTo(
      reference.pointer,
      _id_renameTo as jni$_.JMethodIDPtr,
      _$file.pointer,
    ).boolean;
  }

  static final _id_setLastModified = _class.instanceMethodId(
    r'setLastModified',
    r'(J)Z',
  );

  static final _setLastModified =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean setLastModified(long j)`
  bool setLastModified(int j) =>
      _setLastModified(
        reference.pointer,
        _id_setLastModified as jni$_.JMethodIDPtr,
        j,
      ).boolean;

  static final _id_setReadOnly = _class.instanceMethodId(
    r'setReadOnly',
    r'()Z',
  );

  static final _setReadOnly =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean setReadOnly()`
  bool setReadOnly() =>
      _setReadOnly(
        reference.pointer,
        _id_setReadOnly as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setWritable = _class.instanceMethodId(
    r'setWritable',
    r'(ZZ)Z',
  );

  static final _setWritable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public boolean setWritable(boolean z, boolean z1)`
  bool setWritable(bool z, bool z1) =>
      _setWritable(
        reference.pointer,
        _id_setWritable as jni$_.JMethodIDPtr,
        z ? 1 : 0,
        z1 ? 1 : 0,
      ).boolean;

  static final _id_setWritable$1 = _class.instanceMethodId(
    r'setWritable',
    r'(Z)Z',
  );

  static final _setWritable$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean setWritable(boolean z)`
  bool setWritable$1(bool z) =>
      _setWritable$1(
        reference.pointer,
        _id_setWritable$1 as jni$_.JMethodIDPtr,
        z ? 1 : 0,
      ).boolean;

  static final _id_setReadable = _class.instanceMethodId(
    r'setReadable',
    r'(ZZ)Z',
  );

  static final _setReadable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public boolean setReadable(boolean z, boolean z1)`
  bool setReadable(bool z, bool z1) =>
      _setReadable(
        reference.pointer,
        _id_setReadable as jni$_.JMethodIDPtr,
        z ? 1 : 0,
        z1 ? 1 : 0,
      ).boolean;

  static final _id_setReadable$1 = _class.instanceMethodId(
    r'setReadable',
    r'(Z)Z',
  );

  static final _setReadable$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean setReadable(boolean z)`
  bool setReadable$1(bool z) =>
      _setReadable$1(
        reference.pointer,
        _id_setReadable$1 as jni$_.JMethodIDPtr,
        z ? 1 : 0,
      ).boolean;

  static final _id_setExecutable = _class.instanceMethodId(
    r'setExecutable',
    r'(ZZ)Z',
  );

  static final _setExecutable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public boolean setExecutable(boolean z, boolean z1)`
  bool setExecutable(bool z, bool z1) =>
      _setExecutable(
        reference.pointer,
        _id_setExecutable as jni$_.JMethodIDPtr,
        z ? 1 : 0,
        z1 ? 1 : 0,
      ).boolean;

  static final _id_setExecutable$1 = _class.instanceMethodId(
    r'setExecutable',
    r'(Z)Z',
  );

  static final _setExecutable$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean setExecutable(boolean z)`
  bool setExecutable$1(bool z) =>
      _setExecutable$1(
        reference.pointer,
        _id_setExecutable$1 as jni$_.JMethodIDPtr,
        z ? 1 : 0,
      ).boolean;

  static final _id_canExecute = _class.instanceMethodId(r'canExecute', r'()Z');

  static final _canExecute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean canExecute()`
  bool canExecute() =>
      _canExecute(
        reference.pointer,
        _id_canExecute as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_listRoots = _class.staticMethodId(
    r'listRoots',
    r'()[Ljava/io/File;',
  );

  static final _listRoots =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.File[] listRoots()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<File?>? listRoots() => _listRoots(
    _class.reference.pointer,
    _id_listRoots as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<File?>?>(
    const jni$_.JArrayNullableType<File?>($File$NullableType()),
  );

  static final _id_getTotalSpace = _class.instanceMethodId(
    r'getTotalSpace',
    r'()J',
  );

  static final _getTotalSpace =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getTotalSpace()`
  int getTotalSpace() =>
      _getTotalSpace(
        reference.pointer,
        _id_getTotalSpace as jni$_.JMethodIDPtr,
      ).long;

  static final _id_getFreeSpace = _class.instanceMethodId(
    r'getFreeSpace',
    r'()J',
  );

  static final _getFreeSpace =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getFreeSpace()`
  int getFreeSpace() =>
      _getFreeSpace(
        reference.pointer,
        _id_getFreeSpace as jni$_.JMethodIDPtr,
      ).long;

  static final _id_getUsableSpace = _class.instanceMethodId(
    r'getUsableSpace',
    r'()J',
  );

  static final _getUsableSpace =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getUsableSpace()`
  int getUsableSpace() =>
      _getUsableSpace(
        reference.pointer,
        _id_getUsableSpace as jni$_.JMethodIDPtr,
      ).long;

  static final _id_createTempFile = _class.staticMethodId(
    r'createTempFile',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File;',
  );

  static final _createTempFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.File createTempFile(java.lang.String string, java.lang.String string1, java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  static File? createTempFile(
    jni$_.JString? string,
    jni$_.JString? string1,
    File? file,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _createTempFile(
      _class.reference.pointer,
      _id_createTempFile as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
      _$file.pointer,
    ).object<File?>(const $File$NullableType());
  }

  static final _id_createTempFile$1 = _class.staticMethodId(
    r'createTempFile',
    r'(Ljava/lang/String;Ljava/lang/String;)Ljava/io/File;',
  );

  static final _createTempFile$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.File createTempFile(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static File? createTempFile$1(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _createTempFile$1(
      _class.reference.pointer,
      _id_createTempFile$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).object<File?>(const $File$NullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/io/File;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.io.File file)`
  int compareTo(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$file.pointer,
    ).integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_toPath = _class.instanceMethodId(
    r'toPath',
    r'()Ljava/nio/file/Path;',
  );

  static final _toPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.file.Path toPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toPath() => _toPath(
    reference.pointer,
    _id_toPath as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  bool operator <(File? file) => compareTo(file) < 0;

  bool operator <=(File? file) => compareTo(file) <= 0;

  bool operator >(File? file) => compareTo(file) > 0;

  bool operator >=(File? file) => compareTo(file) >= 0;
}

final class $File$NullableType extends jni$_.JObjType<File?> {
  @jni$_.internal
  const $File$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/File;';

  @jni$_.internal
  @core$_.override
  File? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : File.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<File?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($File$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($File$NullableType) && other is $File$NullableType;
}

final class $File$Type extends jni$_.JObjType<File> {
  @jni$_.internal
  const $File$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/File;';

  @jni$_.internal
  @core$_.override
  File fromReference(jni$_.JReference reference) =>
      File.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<File?> get nullableType => const $File$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($File$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($File$Type) && other is $File$Type;
}

/// from: `java.io.IOError`
class IOError extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<IOError> $type;

  @jni$_.internal
  IOError.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/IOError');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $IOError$NullableType();
  static const type = $IOError$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/Throwable;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.Throwable throwable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory IOError(jni$_.JObject? throwable) {
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    return IOError.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$throwable.pointer,
      ).reference,
    );
  }
}

final class $IOError$NullableType extends jni$_.JObjType<IOError?> {
  @jni$_.internal
  const $IOError$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/IOError;';

  @jni$_.internal
  @core$_.override
  IOError? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : IOError.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IOError?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IOError$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($IOError$NullableType) &&
      other is $IOError$NullableType;
}

final class $IOError$Type extends jni$_.JObjType<IOError> {
  @jni$_.internal
  const $IOError$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/IOError;';

  @jni$_.internal
  @core$_.override
  IOError fromReference(jni$_.JReference reference) =>
      IOError.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IOError?> get nullableType => const $IOError$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IOError$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($IOError$Type) && other is $IOError$Type;
}

/// from: `java.io.ObjectStreamException`
class ObjectStreamException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectStreamException> $type;

  @jni$_.internal
  ObjectStreamException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectStreamException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectStreamException$NullableType();
  static const type = $ObjectStreamException$Type();
}

final class $ObjectStreamException$NullableType
    extends jni$_.JObjType<ObjectStreamException?> {
  @jni$_.internal
  const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamException;';

  @jni$_.internal
  @core$_.override
  ObjectStreamException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectStreamException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ObjectStreamException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectStreamException$NullableType) &&
      other is $ObjectStreamException$NullableType;
}

final class $ObjectStreamException$Type
    extends jni$_.JObjType<ObjectStreamException> {
  @jni$_.internal
  const $ObjectStreamException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamException;';

  @jni$_.internal
  @core$_.override
  ObjectStreamException fromReference(jni$_.JReference reference) =>
      ObjectStreamException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamException?> get nullableType =>
      const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ObjectStreamException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectStreamException$Type) &&
      other is $ObjectStreamException$Type;
}

/// from: `java.io.FileFilter`
class FileFilter extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileFilter> $type;

  @jni$_.internal
  FileFilter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FileFilter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileFilter$NullableType();
  static const type = $FileFilter$Type();
  static final _id_accept = _class.instanceMethodId(
    r'accept',
    r'(Ljava/io/File;)Z',
  );

  static final _accept =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean accept(java.io.File file)`
  bool accept(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _accept(
      reference.pointer,
      _id_accept as jni$_.JMethodIDPtr,
      _$file.pointer,
    ).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $FileFilter> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'accept(Ljava/io/File;)Z') {
        final $r = _$impls[$p]!.accept(
          $a![0]?.as(const $File$Type(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $FileFilter $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.FileFilter', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory FileFilter.implement($FileFilter $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return FileFilter.fromReference($i.implementReference());
  }
}

abstract base mixin class $FileFilter {
  factory $FileFilter({required bool Function(File? file) accept}) =
      _$FileFilter;

  bool accept(File? file);
}

final class _$FileFilter with $FileFilter {
  _$FileFilter({required bool Function(File? file) accept}) : _accept = accept;

  final bool Function(File? file) _accept;

  bool accept(File? file) => _accept(file);
}

final class $FileFilter$NullableType extends jni$_.JObjType<FileFilter?> {
  @jni$_.internal
  const $FileFilter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileFilter;';

  @jni$_.internal
  @core$_.override
  FileFilter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileFilter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileFilter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FileFilter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileFilter$NullableType) &&
      other is $FileFilter$NullableType;
}

final class $FileFilter$Type extends jni$_.JObjType<FileFilter> {
  @jni$_.internal
  const $FileFilter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileFilter;';

  @jni$_.internal
  @core$_.override
  FileFilter fromReference(jni$_.JReference reference) =>
      FileFilter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileFilter?> get nullableType =>
      const $FileFilter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FileFilter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileFilter$Type) && other is $FileFilter$Type;
}

/// from: `java.io.StringReader`
class StringReader extends Reader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StringReader> $type;

  @jni$_.internal
  StringReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/StringReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StringReader$NullableType();
  static const type = $StringReader$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringReader(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return StringReader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() =>
      _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() =>
      _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() =>
      _markSupported(
        reference.pointer,
        _id_markSupported as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $StringReader$NullableType extends jni$_.JObjType<StringReader?> {
  @jni$_.internal
  const $StringReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StringReader;';

  @jni$_.internal
  @core$_.override
  StringReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : StringReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($StringReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StringReader$NullableType) &&
      other is $StringReader$NullableType;
}

final class $StringReader$Type extends jni$_.JObjType<StringReader> {
  @jni$_.internal
  const $StringReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StringReader;';

  @jni$_.internal
  @core$_.override
  StringReader fromReference(jni$_.JReference reference) =>
      StringReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringReader?> get nullableType =>
      const $StringReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($StringReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StringReader$Type) && other is $StringReader$Type;
}

/// from: `java.io.BufferedReader`
class BufferedReader extends Reader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<BufferedReader> $type;

  @jni$_.internal
  BufferedReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/BufferedReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $BufferedReader$NullableType();
  static const type = $BufferedReader$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/Reader;I)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.Reader reader, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedReader(Reader? reader, int i) {
    final _$reader = reader?.reference ?? jni$_.jNullReference;
    return BufferedReader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$reader.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/Reader;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.Reader reader)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedReader.new$1(Reader? reader) {
    final _$reader = reader?.reference ?? jni$_.jNullReference;
    return BufferedReader.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$reader.pointer,
      ).reference,
    );
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() =>
      _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine() => _readLine(
    reference.pointer,
    _id_readLine as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() =>
      _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() =>
      _markSupported(
        reference.pointer,
        _id_markSupported as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_lines = _class.instanceMethodId(
    r'lines',
    r'()Ljava/util/stream/Stream;',
  );

  static final _lines =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.stream.Stream<java.lang.String> lines()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? lines() => _lines(
    reference.pointer,
    _id_lines as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
}

final class $BufferedReader$NullableType
    extends jni$_.JObjType<BufferedReader?> {
  @jni$_.internal
  const $BufferedReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedReader;';

  @jni$_.internal
  @core$_.override
  BufferedReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : BufferedReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($BufferedReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($BufferedReader$NullableType) &&
      other is $BufferedReader$NullableType;
}

final class $BufferedReader$Type extends jni$_.JObjType<BufferedReader> {
  @jni$_.internal
  const $BufferedReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedReader;';

  @jni$_.internal
  @core$_.override
  BufferedReader fromReference(jni$_.JReference reference) =>
      BufferedReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedReader?> get nullableType =>
      const $BufferedReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($BufferedReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($BufferedReader$Type) &&
      other is $BufferedReader$Type;
}

/// from: `java.io.ObjectOutput`
class ObjectOutput extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectOutput> $type;

  @jni$_.internal
  ObjectOutput.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectOutput');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectOutput$NullableType();
  static const type = $ObjectOutput$Type();
  static final _id_writeObject = _class.instanceMethodId(
    r'writeObject',
    r'(Ljava/lang/Object;)V',
  );

  static final _writeObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeObject(java.lang.Object object)`
  void writeObject(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _writeObject(
      reference.pointer,
      _id_writeObject as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write$1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void write(byte[] bs)`
  void write$1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$1(
      reference.pointer,
      _id_write$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_write$2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract void write(byte[] bs, int i, int i1)`
  void write$2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$2(
      reference.pointer,
      _id_write$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_writeBoolean = _class.instanceMethodId(
    r'writeBoolean',
    r'(Z)V',
  );

  static final _writeBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeBoolean(boolean z)`
  void writeBoolean(bool z) {
    _writeBoolean(
      reference.pointer,
      _id_writeBoolean as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_writeByte = _class.instanceMethodId(r'writeByte', r'(I)V');

  static final _writeByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeByte(int i)`
  void writeByte(int i) {
    _writeByte(
      reference.pointer,
      _id_writeByte as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeShort = _class.instanceMethodId(r'writeShort', r'(I)V');

  static final _writeShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeShort(int i)`
  void writeShort(int i) {
    _writeShort(
      reference.pointer,
      _id_writeShort as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeChar = _class.instanceMethodId(r'writeChar', r'(I)V');

  static final _writeChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeChar(int i)`
  void writeChar(int i) {
    _writeChar(
      reference.pointer,
      _id_writeChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeInt = _class.instanceMethodId(r'writeInt', r'(I)V');

  static final _writeInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeInt(int i)`
  void writeInt(int i) {
    _writeInt(reference.pointer, _id_writeInt as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_writeLong = _class.instanceMethodId(r'writeLong', r'(J)V');

  static final _writeLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeLong(long j)`
  void writeLong(int j) {
    _writeLong(
      reference.pointer,
      _id_writeLong as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_writeFloat = _class.instanceMethodId(r'writeFloat', r'(F)V');

  static final _writeFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public abstract void writeFloat(float f)`
  void writeFloat(double f) {
    _writeFloat(
      reference.pointer,
      _id_writeFloat as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_writeDouble = _class.instanceMethodId(
    r'writeDouble',
    r'(D)V',
  );

  static final _writeDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public abstract void writeDouble(double d)`
  void writeDouble(double d) {
    _writeDouble(
      reference.pointer,
      _id_writeDouble as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'(Ljava/lang/String;)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeBytes(java.lang.String string)`
  void writeBytes(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeChars = _class.instanceMethodId(
    r'writeChars',
    r'(Ljava/lang/String;)V',
  );

  static final _writeChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeChars(java.lang.String string)`
  void writeChars(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeChars(
      reference.pointer,
      _id_writeChars as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeUTF = _class.instanceMethodId(
    r'writeUTF',
    r'(Ljava/lang/String;)V',
  );

  static final _writeUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeUTF(java.lang.String string)`
  void writeUTF(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeUTF(
      reference.pointer,
      _id_writeUTF as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ObjectOutput> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'writeObject(Ljava/lang/Object;)V') {
        _$impls[$p]!.writeObject(
          $a![0]?.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'write(I)V') {
        _$impls[$p]!.write(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'write([B)V') {
        _$impls[$p]!.write$1(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'write([BII)V') {
        _$impls[$p]!.write$2(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'flush()V') {
        _$impls[$p]!.flush();
        return jni$_.nullptr;
      }
      if ($d == r'close()V') {
        _$impls[$p]!.close();
        return jni$_.nullptr;
      }
      if ($d == r'writeBoolean(Z)V') {
        _$impls[$p]!.writeBoolean(
          $a![0]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeByte(I)V') {
        _$impls[$p]!.writeByte(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeShort(I)V') {
        _$impls[$p]!.writeShort(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeChar(I)V') {
        _$impls[$p]!.writeChar(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeInt(I)V') {
        _$impls[$p]!.writeInt(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeLong(J)V') {
        _$impls[$p]!.writeLong(
          $a![0]!
              .as(const jni$_.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeFloat(F)V') {
        _$impls[$p]!.writeFloat(
          $a![0]!
              .as(const jni$_.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeDouble(D)V') {
        _$impls[$p]!.writeDouble(
          $a![0]!
              .as(const jni$_.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeBytes(Ljava/lang/String;)V') {
        _$impls[$p]!.writeBytes(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeChars(Ljava/lang/String;)V') {
        _$impls[$p]!.writeChars(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeUTF(Ljava/lang/String;)V') {
        _$impls[$p]!.writeUTF(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $ObjectOutput $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.ObjectOutput', $p, _$invokePointer, [
      if ($impl.writeObject$async) r'writeObject(Ljava/lang/Object;)V',
      if ($impl.write$async) r'write(I)V',
      if ($impl.write$1$async) r'write([B)V',
      if ($impl.write$2$async) r'write([BII)V',
      if ($impl.flush$async) r'flush()V',
      if ($impl.close$async) r'close()V',
      if ($impl.writeBoolean$async) r'writeBoolean(Z)V',
      if ($impl.writeByte$async) r'writeByte(I)V',
      if ($impl.writeShort$async) r'writeShort(I)V',
      if ($impl.writeChar$async) r'writeChar(I)V',
      if ($impl.writeInt$async) r'writeInt(I)V',
      if ($impl.writeLong$async) r'writeLong(J)V',
      if ($impl.writeFloat$async) r'writeFloat(F)V',
      if ($impl.writeDouble$async) r'writeDouble(D)V',
      if ($impl.writeBytes$async) r'writeBytes(Ljava/lang/String;)V',
      if ($impl.writeChars$async) r'writeChars(Ljava/lang/String;)V',
      if ($impl.writeUTF$async) r'writeUTF(Ljava/lang/String;)V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ObjectOutput.implement($ObjectOutput $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ObjectOutput.fromReference($i.implementReference());
  }
}

abstract base mixin class $ObjectOutput {
  factory $ObjectOutput({
    required void Function(jni$_.JObject? object) writeObject,
    bool writeObject$async,
    required void Function(int i) write,
    bool write$async,
    required void Function(jni$_.JByteArray? bs) write$1,
    bool write$1$async,
    required void Function(jni$_.JByteArray? bs, int i, int i1) write$2,
    bool write$2$async,
    required void Function() flush,
    bool flush$async,
    required void Function() close,
    bool close$async,
    required void Function(bool z) writeBoolean,
    bool writeBoolean$async,
    required void Function(int i) writeByte,
    bool writeByte$async,
    required void Function(int i) writeShort,
    bool writeShort$async,
    required void Function(int i) writeChar,
    bool writeChar$async,
    required void Function(int i) writeInt,
    bool writeInt$async,
    required void Function(int j) writeLong,
    bool writeLong$async,
    required void Function(double f) writeFloat,
    bool writeFloat$async,
    required void Function(double d) writeDouble,
    bool writeDouble$async,
    required void Function(jni$_.JString? string) writeBytes,
    bool writeBytes$async,
    required void Function(jni$_.JString? string) writeChars,
    bool writeChars$async,
    required void Function(jni$_.JString? string) writeUTF,
    bool writeUTF$async,
  }) = _$ObjectOutput;

  void writeObject(jni$_.JObject? object);
  bool get writeObject$async => false;
  void write(int i);
  bool get write$async => false;
  void write$1(jni$_.JByteArray? bs);
  bool get write$1$async => false;
  void write$2(jni$_.JByteArray? bs, int i, int i1);
  bool get write$2$async => false;
  void flush();
  bool get flush$async => false;
  void close();
  bool get close$async => false;
  void writeBoolean(bool z);
  bool get writeBoolean$async => false;
  void writeByte(int i);
  bool get writeByte$async => false;
  void writeShort(int i);
  bool get writeShort$async => false;
  void writeChar(int i);
  bool get writeChar$async => false;
  void writeInt(int i);
  bool get writeInt$async => false;
  void writeLong(int j);
  bool get writeLong$async => false;
  void writeFloat(double f);
  bool get writeFloat$async => false;
  void writeDouble(double d);
  bool get writeDouble$async => false;
  void writeBytes(jni$_.JString? string);
  bool get writeBytes$async => false;
  void writeChars(jni$_.JString? string);
  bool get writeChars$async => false;
  void writeUTF(jni$_.JString? string);
  bool get writeUTF$async => false;
}

final class _$ObjectOutput with $ObjectOutput {
  _$ObjectOutput({
    required void Function(jni$_.JObject? object) writeObject,
    this.writeObject$async = false,
    required void Function(int i) write,
    this.write$async = false,
    required void Function(jni$_.JByteArray? bs) write$1,
    this.write$1$async = false,
    required void Function(jni$_.JByteArray? bs, int i, int i1) write$2,
    this.write$2$async = false,
    required void Function() flush,
    this.flush$async = false,
    required void Function() close,
    this.close$async = false,
    required void Function(bool z) writeBoolean,
    this.writeBoolean$async = false,
    required void Function(int i) writeByte,
    this.writeByte$async = false,
    required void Function(int i) writeShort,
    this.writeShort$async = false,
    required void Function(int i) writeChar,
    this.writeChar$async = false,
    required void Function(int i) writeInt,
    this.writeInt$async = false,
    required void Function(int j) writeLong,
    this.writeLong$async = false,
    required void Function(double f) writeFloat,
    this.writeFloat$async = false,
    required void Function(double d) writeDouble,
    this.writeDouble$async = false,
    required void Function(jni$_.JString? string) writeBytes,
    this.writeBytes$async = false,
    required void Function(jni$_.JString? string) writeChars,
    this.writeChars$async = false,
    required void Function(jni$_.JString? string) writeUTF,
    this.writeUTF$async = false,
  }) : _writeObject = writeObject,
       _write = write,
       _write$1 = write$1,
       _write$2 = write$2,
       _flush = flush,
       _close = close,
       _writeBoolean = writeBoolean,
       _writeByte = writeByte,
       _writeShort = writeShort,
       _writeChar = writeChar,
       _writeInt = writeInt,
       _writeLong = writeLong,
       _writeFloat = writeFloat,
       _writeDouble = writeDouble,
       _writeBytes = writeBytes,
       _writeChars = writeChars,
       _writeUTF = writeUTF;

  final void Function(jni$_.JObject? object) _writeObject;
  final bool writeObject$async;
  final void Function(int i) _write;
  final bool write$async;
  final void Function(jni$_.JByteArray? bs) _write$1;
  final bool write$1$async;
  final void Function(jni$_.JByteArray? bs, int i, int i1) _write$2;
  final bool write$2$async;
  final void Function() _flush;
  final bool flush$async;
  final void Function() _close;
  final bool close$async;
  final void Function(bool z) _writeBoolean;
  final bool writeBoolean$async;
  final void Function(int i) _writeByte;
  final bool writeByte$async;
  final void Function(int i) _writeShort;
  final bool writeShort$async;
  final void Function(int i) _writeChar;
  final bool writeChar$async;
  final void Function(int i) _writeInt;
  final bool writeInt$async;
  final void Function(int j) _writeLong;
  final bool writeLong$async;
  final void Function(double f) _writeFloat;
  final bool writeFloat$async;
  final void Function(double d) _writeDouble;
  final bool writeDouble$async;
  final void Function(jni$_.JString? string) _writeBytes;
  final bool writeBytes$async;
  final void Function(jni$_.JString? string) _writeChars;
  final bool writeChars$async;
  final void Function(jni$_.JString? string) _writeUTF;
  final bool writeUTF$async;

  void writeObject(jni$_.JObject? object) => _writeObject(object);

  void write(int i) => _write(i);

  void write$1(jni$_.JByteArray? bs) => _write$1(bs);

  void write$2(jni$_.JByteArray? bs, int i, int i1) => _write$2(bs, i, i1);

  void flush() => _flush();

  void close() => _close();

  void writeBoolean(bool z) => _writeBoolean(z);

  void writeByte(int i) => _writeByte(i);

  void writeShort(int i) => _writeShort(i);

  void writeChar(int i) => _writeChar(i);

  void writeInt(int i) => _writeInt(i);

  void writeLong(int j) => _writeLong(j);

  void writeFloat(double f) => _writeFloat(f);

  void writeDouble(double d) => _writeDouble(d);

  void writeBytes(jni$_.JString? string) => _writeBytes(string);

  void writeChars(jni$_.JString? string) => _writeChars(string);

  void writeUTF(jni$_.JString? string) => _writeUTF(string);
}

final class $ObjectOutput$NullableType extends jni$_.JObjType<ObjectOutput?> {
  @jni$_.internal
  const $ObjectOutput$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectOutput;';

  @jni$_.internal
  @core$_.override
  ObjectOutput? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectOutput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectOutput?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectOutput$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectOutput$NullableType) &&
      other is $ObjectOutput$NullableType;
}

final class $ObjectOutput$Type extends jni$_.JObjType<ObjectOutput> {
  @jni$_.internal
  const $ObjectOutput$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectOutput;';

  @jni$_.internal
  @core$_.override
  ObjectOutput fromReference(jni$_.JReference reference) =>
      ObjectOutput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectOutput?> get nullableType =>
      const $ObjectOutput$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectOutput$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectOutput$Type) && other is $ObjectOutput$Type;
}

/// from: `java.io.ObjectInputStream`
class ObjectInputStream extends InputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInputStream> $type;

  @jni$_.internal
  ObjectInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInputStream$NullableType();
  static const type = $ObjectInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/InputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ObjectInputStream(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return ObjectInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
      ).reference,
    );
  }

  static final _id_readObject = _class.instanceMethodId(
    r'readObject',
    r'()Ljava/lang/Object;',
  );

  static final _readObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Object readObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? readObject() => _readObject(
    reference.pointer,
    _id_readObject as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_readUnshared = _class.instanceMethodId(
    r'readUnshared',
    r'()Ljava/lang/Object;',
  );

  static final _readUnshared =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object readUnshared()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? readUnshared() => _readUnshared(
    reference.pointer,
    _id_readUnshared as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_defaultReadObject = _class.instanceMethodId(
    r'defaultReadObject',
    r'()V',
  );

  static final _defaultReadObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void defaultReadObject()`
  void defaultReadObject() {
    _defaultReadObject(
      reference.pointer,
      _id_defaultReadObject as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_readFields = _class.instanceMethodId(
    r'readFields',
    r'()Ljava/io/ObjectInputStream$GetField;',
  );

  static final _readFields =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.ObjectInputStream$GetField readFields()`
  /// The returned object must be released after use, by calling the [release] method.
  ObjectInputStream$GetField? readFields() => _readFields(
    reference.pointer,
    _id_readFields as jni$_.JMethodIDPtr,
  ).object<ObjectInputStream$GetField?>(
    const $ObjectInputStream$GetField$NullableType(),
  );

  static final _id_registerValidation = _class.instanceMethodId(
    r'registerValidation',
    r'(Ljava/io/ObjectInputValidation;I)V',
  );

  static final _registerValidation =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void registerValidation(java.io.ObjectInputValidation objectInputValidation, int i)`
  void registerValidation(ObjectInputValidation? objectInputValidation, int i) {
    final _$objectInputValidation =
        objectInputValidation?.reference ?? jni$_.jNullReference;
    _registerValidation(
      reference.pointer,
      _id_registerValidation as jni$_.JMethodIDPtr,
      _$objectInputValidation.pointer,
      i,
    ).check();
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() =>
      _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() =>
      _available(
        reference.pointer,
        _id_available as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_readBoolean = _class.instanceMethodId(
    r'readBoolean',
    r'()Z',
  );

  static final _readBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean readBoolean()`
  bool readBoolean() =>
      _readBoolean(
        reference.pointer,
        _id_readBoolean as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_readByte = _class.instanceMethodId(r'readByte', r'()B');

  static final _readByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte readByte()`
  int readByte() =>
      _readByte(reference.pointer, _id_readByte as jni$_.JMethodIDPtr).byte;

  static final _id_readUnsignedByte = _class.instanceMethodId(
    r'readUnsignedByte',
    r'()I',
  );

  static final _readUnsignedByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int readUnsignedByte()`
  int readUnsignedByte() =>
      _readUnsignedByte(
        reference.pointer,
        _id_readUnsignedByte as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_readChar = _class.instanceMethodId(r'readChar', r'()C');

  static final _readChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char readChar()`
  int readChar() =>
      _readChar(reference.pointer, _id_readChar as jni$_.JMethodIDPtr).char;

  static final _id_readShort = _class.instanceMethodId(r'readShort', r'()S');

  static final _readShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public short readShort()`
  int readShort() =>
      _readShort(reference.pointer, _id_readShort as jni$_.JMethodIDPtr).short;

  static final _id_readUnsignedShort = _class.instanceMethodId(
    r'readUnsignedShort',
    r'()I',
  );

  static final _readUnsignedShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int readUnsignedShort()`
  int readUnsignedShort() =>
      _readUnsignedShort(
        reference.pointer,
        _id_readUnsignedShort as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_readInt = _class.instanceMethodId(r'readInt', r'()I');

  static final _readInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int readInt()`
  int readInt() =>
      _readInt(reference.pointer, _id_readInt as jni$_.JMethodIDPtr).integer;

  static final _id_readLong = _class.instanceMethodId(r'readLong', r'()J');

  static final _readLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long readLong()`
  int readLong() =>
      _readLong(reference.pointer, _id_readLong as jni$_.JMethodIDPtr).long;

  static final _id_readFloat = _class.instanceMethodId(r'readFloat', r'()F');

  static final _readFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float readFloat()`
  double readFloat() =>
      _readFloat(reference.pointer, _id_readFloat as jni$_.JMethodIDPtr).float;

  static final _id_readDouble = _class.instanceMethodId(r'readDouble', r'()D');

  static final _readDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double readDouble()`
  double readDouble() =>
      _readDouble(
        reference.pointer,
        _id_readDouble as jni$_.JMethodIDPtr,
      ).doubleFloat;

  static final _id_readFully = _class.instanceMethodId(r'readFully', r'([B)V');

  static final _readFully =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void readFully(byte[] bs)`
  void readFully(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully(
      reference.pointer,
      _id_readFully as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_readFully$1 = _class.instanceMethodId(
    r'readFully',
    r'([BII)V',
  );

  static final _readFully$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void readFully(byte[] bs, int i, int i1)`
  void readFully$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully$1(
      reference.pointer,
      _id_readFully$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_skipBytes = _class.instanceMethodId(r'skipBytes', r'(I)I');

  static final _skipBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int skipBytes(int i)`
  int skipBytes(int i) =>
      _skipBytes(
        reference.pointer,
        _id_skipBytes as jni$_.JMethodIDPtr,
        i,
      ).integer;

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine() => _readLine(
    reference.pointer,
    _id_readLine as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_readUTF = _class.instanceMethodId(
    r'readUTF',
    r'()Ljava/lang/String;',
  );

  static final _readUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String readUTF()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readUTF() => _readUTF(
    reference.pointer,
    _id_readUTF as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getObjectInputFilter = _class.instanceMethodId(
    r'getObjectInputFilter',
    r'()Ljava/io/ObjectInputFilter;',
  );

  static final _getObjectInputFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.io.ObjectInputFilter getObjectInputFilter()`
  /// The returned object must be released after use, by calling the [release] method.
  ObjectInputFilter? getObjectInputFilter() => _getObjectInputFilter(
    reference.pointer,
    _id_getObjectInputFilter as jni$_.JMethodIDPtr,
  ).object<ObjectInputFilter?>(const $ObjectInputFilter$NullableType());

  static final _id_setObjectInputFilter = _class.instanceMethodId(
    r'setObjectInputFilter',
    r'(Ljava/io/ObjectInputFilter;)V',
  );

  static final _setObjectInputFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void setObjectInputFilter(java.io.ObjectInputFilter objectInputFilter)`
  void setObjectInputFilter(ObjectInputFilter? objectInputFilter) {
    final _$objectInputFilter =
        objectInputFilter?.reference ?? jni$_.jNullReference;
    _setObjectInputFilter(
      reference.pointer,
      _id_setObjectInputFilter as jni$_.JMethodIDPtr,
      _$objectInputFilter.pointer,
    ).check();
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'([B)I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract int read(byte[] bs)`
  int read1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read1(
      reference.pointer,
      _id_read1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
}

final class $ObjectInputStream$NullableType
    extends jni$_.JObjType<ObjectInputStream?> {
  @jni$_.internal
  const $ObjectInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputStream;';

  @jni$_.internal
  @core$_.override
  ObjectInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ObjectInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInputStream$NullableType) &&
      other is $ObjectInputStream$NullableType;
}

final class $ObjectInputStream$Type extends jni$_.JObjType<ObjectInputStream> {
  @jni$_.internal
  const $ObjectInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputStream;';

  @jni$_.internal
  @core$_.override
  ObjectInputStream fromReference(jni$_.JReference reference) =>
      ObjectInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputStream?> get nullableType =>
      const $ObjectInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ObjectInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInputStream$Type) &&
      other is $ObjectInputStream$Type;
}

/// from: `java.io.LineNumberInputStream`
class LineNumberInputStream extends FilterInputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<LineNumberInputStream> $type;

  @jni$_.internal
  LineNumberInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/LineNumberInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $LineNumberInputStream$NullableType();
  static const type = $LineNumberInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/InputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory LineNumberInputStream(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return LineNumberInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
      ).reference,
    );
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() =>
      _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_setLineNumber = _class.instanceMethodId(
    r'setLineNumber',
    r'(I)V',
  );

  static final _setLineNumber =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setLineNumber(int i)`
  void setLineNumber(int i) {
    _setLineNumber(
      reference.pointer,
      _id_setLineNumber as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getLineNumber = _class.instanceMethodId(
    r'getLineNumber',
    r'()I',
  );

  static final _getLineNumber =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLineNumber()`
  int getLineNumber() =>
      _getLineNumber(
        reference.pointer,
        _id_getLineNumber as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() =>
      _available(
        reference.pointer,
        _id_available as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }
}

final class $LineNumberInputStream$NullableType
    extends jni$_.JObjType<LineNumberInputStream?> {
  @jni$_.internal
  const $LineNumberInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/LineNumberInputStream;';

  @jni$_.internal
  @core$_.override
  LineNumberInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : LineNumberInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LineNumberInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($LineNumberInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($LineNumberInputStream$NullableType) &&
      other is $LineNumberInputStream$NullableType;
}

final class $LineNumberInputStream$Type
    extends jni$_.JObjType<LineNumberInputStream> {
  @jni$_.internal
  const $LineNumberInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/LineNumberInputStream;';

  @jni$_.internal
  @core$_.override
  LineNumberInputStream fromReference(jni$_.JReference reference) =>
      LineNumberInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LineNumberInputStream?> get nullableType =>
      const $LineNumberInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($LineNumberInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($LineNumberInputStream$Type) &&
      other is $LineNumberInputStream$Type;
}

/// from: `java.io.ByteArrayInputStream`
class ByteArrayInputStream extends InputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ByteArrayInputStream> $type;

  @jni$_.internal
  ByteArrayInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ByteArrayInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ByteArrayInputStream$NullableType();
  static const type = $ByteArrayInputStream$Type();
  static final _id_new$ = _class.constructorId(r'([B)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ByteArrayInputStream(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return ByteArrayInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$bs.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'([BII)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void <init>(byte[] bs, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ByteArrayInputStream.new$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return ByteArrayInputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$bs.pointer,
        i,
        i1,
      ).reference,
    );
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() =>
      _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_readAllBytes = _class.instanceMethodId(
    r'readAllBytes',
    r'()[B',
  );

  static final _readAllBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] readAllBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? readAllBytes() => _readAllBytes(
    reference.pointer,
    _id_readAllBytes as jni$_.JMethodIDPtr,
  ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());

  static final _id_readNBytes1 = _class.instanceMethodId(
    r'readNBytes',
    r'([BII)I',
  );

  static final _readNBytes1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int readNBytes(byte[] bs, int i, int i1)`
  int readNBytes1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _readNBytes1(
      reference.pointer,
      _id_readNBytes1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_transferTo = _class.instanceMethodId(
    r'transferTo',
    r'(Ljava/io/OutputStream;)J',
  );

  static final _transferTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long transferTo(java.io.OutputStream outputStream)`
  int transferTo(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return _transferTo(
      reference.pointer,
      _id_transferTo as jni$_.JMethodIDPtr,
      _$outputStream.pointer,
    ).long;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() =>
      _available(
        reference.pointer,
        _id_available as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() =>
      _markSupported(
        reference.pointer,
        _id_markSupported as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $ByteArrayInputStream$NullableType
    extends jni$_.JObjType<ByteArrayInputStream?> {
  @jni$_.internal
  const $ByteArrayInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ByteArrayInputStream;';

  @jni$_.internal
  @core$_.override
  ByteArrayInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ByteArrayInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ByteArrayInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ByteArrayInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ByteArrayInputStream$NullableType) &&
      other is $ByteArrayInputStream$NullableType;
}

final class $ByteArrayInputStream$Type
    extends jni$_.JObjType<ByteArrayInputStream> {
  @jni$_.internal
  const $ByteArrayInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ByteArrayInputStream;';

  @jni$_.internal
  @core$_.override
  ByteArrayInputStream fromReference(jni$_.JReference reference) =>
      ByteArrayInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ByteArrayInputStream?> get nullableType =>
      const $ByteArrayInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ByteArrayInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ByteArrayInputStream$Type) &&
      other is $ByteArrayInputStream$Type;
}

/// from: `java.io.StreamTokenizer`
class StreamTokenizer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StreamTokenizer> $type;

  @jni$_.internal
  StreamTokenizer.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/StreamTokenizer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StreamTokenizer$NullableType();
  static const type = $StreamTokenizer$Type();
  static final _id_ttype = _class.instanceFieldId(r'ttype', r'I');

  /// from: `public int ttype`
  int get ttype => _id_ttype.get(this, const jni$_.jintType());

  /// from: `public int ttype`
  set ttype(int value) => _id_ttype.set(this, const jni$_.jintType(), value);

  /// from: `static public final int TT_EOF`
  static const TT_EOF = -1;

  /// from: `static public final int TT_EOL`
  static const TT_EOL = 10;

  /// from: `static public final int TT_NUMBER`
  static const TT_NUMBER = -2;

  /// from: `static public final int TT_WORD`
  static const TT_WORD = -3;
  static final _id_sval = _class.instanceFieldId(
    r'sval',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String sval`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get sval =>
      _id_sval.get(this, const jni$_.JStringNullableType());

  /// from: `public java.lang.String sval`
  /// The returned object must be released after use, by calling the [release] method.
  set sval(jni$_.JString? value) =>
      _id_sval.set(this, const jni$_.JStringNullableType(), value);

  static final _id_nval = _class.instanceFieldId(r'nval', r'D');

  /// from: `public double nval`
  double get nval => _id_nval.get(this, const jni$_.jdoubleType());

  /// from: `public double nval`
  set nval(double value) =>
      _id_nval.set(this, const jni$_.jdoubleType(), value);

  static final _id_new$ = _class.constructorId(r'(Ljava/io/InputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StreamTokenizer(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return StreamTokenizer.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/Reader;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.Reader reader)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StreamTokenizer.new$1(Reader? reader) {
    final _$reader = reader?.reference ?? jni$_.jNullReference;
    return StreamTokenizer.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$reader.pointer,
      ).reference,
    );
  }

  static final _id_resetSyntax = _class.instanceMethodId(
    r'resetSyntax',
    r'()V',
  );

  static final _resetSyntax =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void resetSyntax()`
  void resetSyntax() {
    _resetSyntax(
      reference.pointer,
      _id_resetSyntax as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_wordChars = _class.instanceMethodId(r'wordChars', r'(II)V');

  static final _wordChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void wordChars(int i, int i1)`
  void wordChars(int i, int i1) {
    _wordChars(
      reference.pointer,
      _id_wordChars as jni$_.JMethodIDPtr,
      i,
      i1,
    ).check();
  }

  static final _id_whitespaceChars = _class.instanceMethodId(
    r'whitespaceChars',
    r'(II)V',
  );

  static final _whitespaceChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void whitespaceChars(int i, int i1)`
  void whitespaceChars(int i, int i1) {
    _whitespaceChars(
      reference.pointer,
      _id_whitespaceChars as jni$_.JMethodIDPtr,
      i,
      i1,
    ).check();
  }

  static final _id_ordinaryChars = _class.instanceMethodId(
    r'ordinaryChars',
    r'(II)V',
  );

  static final _ordinaryChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void ordinaryChars(int i, int i1)`
  void ordinaryChars(int i, int i1) {
    _ordinaryChars(
      reference.pointer,
      _id_ordinaryChars as jni$_.JMethodIDPtr,
      i,
      i1,
    ).check();
  }

  static final _id_ordinaryChar = _class.instanceMethodId(
    r'ordinaryChar',
    r'(I)V',
  );

  static final _ordinaryChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void ordinaryChar(int i)`
  void ordinaryChar(int i) {
    _ordinaryChar(
      reference.pointer,
      _id_ordinaryChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_commentChar = _class.instanceMethodId(
    r'commentChar',
    r'(I)V',
  );

  static final _commentChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void commentChar(int i)`
  void commentChar(int i) {
    _commentChar(
      reference.pointer,
      _id_commentChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_quoteChar = _class.instanceMethodId(r'quoteChar', r'(I)V');

  static final _quoteChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void quoteChar(int i)`
  void quoteChar(int i) {
    _quoteChar(
      reference.pointer,
      _id_quoteChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_parseNumbers = _class.instanceMethodId(
    r'parseNumbers',
    r'()V',
  );

  static final _parseNumbers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void parseNumbers()`
  void parseNumbers() {
    _parseNumbers(
      reference.pointer,
      _id_parseNumbers as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_eolIsSignificant = _class.instanceMethodId(
    r'eolIsSignificant',
    r'(Z)V',
  );

  static final _eolIsSignificant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void eolIsSignificant(boolean z)`
  void eolIsSignificant(bool z) {
    _eolIsSignificant(
      reference.pointer,
      _id_eolIsSignificant as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_slashStarComments = _class.instanceMethodId(
    r'slashStarComments',
    r'(Z)V',
  );

  static final _slashStarComments =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void slashStarComments(boolean z)`
  void slashStarComments(bool z) {
    _slashStarComments(
      reference.pointer,
      _id_slashStarComments as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_slashSlashComments = _class.instanceMethodId(
    r'slashSlashComments',
    r'(Z)V',
  );

  static final _slashSlashComments =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void slashSlashComments(boolean z)`
  void slashSlashComments(bool z) {
    _slashSlashComments(
      reference.pointer,
      _id_slashSlashComments as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_lowerCaseMode = _class.instanceMethodId(
    r'lowerCaseMode',
    r'(Z)V',
  );

  static final _lowerCaseMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void lowerCaseMode(boolean z)`
  void lowerCaseMode(bool z) {
    _lowerCaseMode(
      reference.pointer,
      _id_lowerCaseMode as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_nextToken = _class.instanceMethodId(r'nextToken', r'()I');

  static final _nextToken =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int nextToken()`
  int nextToken() =>
      _nextToken(
        reference.pointer,
        _id_nextToken as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_pushBack = _class.instanceMethodId(r'pushBack', r'()V');

  static final _pushBack =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void pushBack()`
  void pushBack() {
    _pushBack(reference.pointer, _id_pushBack as jni$_.JMethodIDPtr).check();
  }

  static final _id_lineno = _class.instanceMethodId(r'lineno', r'()I');

  static final _lineno =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int lineno()`
  int lineno() =>
      _lineno(reference.pointer, _id_lineno as jni$_.JMethodIDPtr).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $StreamTokenizer$NullableType
    extends jni$_.JObjType<StreamTokenizer?> {
  @jni$_.internal
  const $StreamTokenizer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StreamTokenizer;';

  @jni$_.internal
  @core$_.override
  StreamTokenizer? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : StreamTokenizer.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StreamTokenizer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StreamTokenizer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StreamTokenizer$NullableType) &&
      other is $StreamTokenizer$NullableType;
}

final class $StreamTokenizer$Type extends jni$_.JObjType<StreamTokenizer> {
  @jni$_.internal
  const $StreamTokenizer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StreamTokenizer;';

  @jni$_.internal
  @core$_.override
  StreamTokenizer fromReference(jni$_.JReference reference) =>
      StreamTokenizer.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StreamTokenizer?> get nullableType =>
      const $StreamTokenizer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StreamTokenizer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StreamTokenizer$Type) &&
      other is $StreamTokenizer$Type;
}

/// from: `java.io.Serial`
class Serial extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Serial> $type;

  @jni$_.internal
  Serial.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Serial');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Serial$NullableType();
  static const type = $Serial$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Serial> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $Serial $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.Serial', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Serial.implement($Serial $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Serial.fromReference($i.implementReference());
  }
}

abstract base mixin class $Serial {
  factory $Serial() = _$Serial;
}

final class _$Serial with $Serial {
  _$Serial();
}

final class $Serial$NullableType extends jni$_.JObjType<Serial?> {
  @jni$_.internal
  const $Serial$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Serial;';

  @jni$_.internal
  @core$_.override
  Serial? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Serial.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Serial?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Serial$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Serial$NullableType) &&
      other is $Serial$NullableType;
}

final class $Serial$Type extends jni$_.JObjType<Serial> {
  @jni$_.internal
  const $Serial$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Serial;';

  @jni$_.internal
  @core$_.override
  Serial fromReference(jni$_.JReference reference) =>
      Serial.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Serial?> get nullableType => const $Serial$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Serial$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Serial$Type) && other is $Serial$Type;
}

/// from: `java.io.LineNumberReader`
class LineNumberReader extends BufferedReader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<LineNumberReader> $type;

  @jni$_.internal
  LineNumberReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/LineNumberReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $LineNumberReader$NullableType();
  static const type = $LineNumberReader$Type();
  static final _id_new1 = _class.constructorId(r'(Ljava/io/Reader;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.Reader reader)`
  /// The returned object must be released after use, by calling the [release] method.
  factory LineNumberReader.new1(Reader? reader) {
    final _$reader = reader?.reference ?? jni$_.jNullReference;
    return LineNumberReader.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$reader.pointer,
      ).reference,
    );
  }

  static final _id_new$ = _class.constructorId(r'(Ljava/io/Reader;I)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.Reader reader, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory LineNumberReader(Reader? reader, int i) {
    final _$reader = reader?.reference ?? jni$_.jNullReference;
    return LineNumberReader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$reader.pointer,
        i,
      ).reference,
    );
  }

  static final _id_setLineNumber = _class.instanceMethodId(
    r'setLineNumber',
    r'(I)V',
  );

  static final _setLineNumber =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setLineNumber(int i)`
  void setLineNumber(int i) {
    _setLineNumber(
      reference.pointer,
      _id_setLineNumber as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getLineNumber = _class.instanceMethodId(
    r'getLineNumber',
    r'()I',
  );

  static final _getLineNumber =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLineNumber()`
  int getLineNumber() =>
      _getLineNumber(
        reference.pointer,
        _id_getLineNumber as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() =>
      _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine() => _readLine(
    reference.pointer,
    _id_readLine as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }
}

final class $LineNumberReader$NullableType
    extends jni$_.JObjType<LineNumberReader?> {
  @jni$_.internal
  const $LineNumberReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/LineNumberReader;';

  @jni$_.internal
  @core$_.override
  LineNumberReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : LineNumberReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $BufferedReader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LineNumberReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($LineNumberReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($LineNumberReader$NullableType) &&
      other is $LineNumberReader$NullableType;
}

final class $LineNumberReader$Type extends jni$_.JObjType<LineNumberReader> {
  @jni$_.internal
  const $LineNumberReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/LineNumberReader;';

  @jni$_.internal
  @core$_.override
  LineNumberReader fromReference(jni$_.JReference reference) =>
      LineNumberReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $BufferedReader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LineNumberReader?> get nullableType =>
      const $LineNumberReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($LineNumberReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($LineNumberReader$Type) &&
      other is $LineNumberReader$Type;
}

/// from: `java.io.CharArrayWriter`
class CharArrayWriter extends Writer {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CharArrayWriter> $type;

  @jni$_.internal
  CharArrayWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/CharArrayWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CharArrayWriter$NullableType();
  static const type = $CharArrayWriter$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory CharArrayWriter() => CharArrayWriter.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$1 = _class.constructorId(r'(I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CharArrayWriter.new$1(int i) => CharArrayWriter.fromReference(
    _new$1(
      _class.reference.pointer,
      _id_new$1 as jni$_.JMethodIDPtr,
      i,
    ).reference,
  );

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(char[] cs, int i, int i1)`
  void write2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write4 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;II)V',
  );

  static final _write4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(java.lang.String string, int i, int i1)`
  void write4(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write4(
      reference.pointer,
      _id_write4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_writeTo = _class.instanceMethodId(
    r'writeTo',
    r'(Ljava/io/Writer;)V',
  );

  static final _writeTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeTo(java.io.Writer writer)`
  void writeTo(Writer? writer) {
    final _$writer = writer?.reference ?? jni$_.jNullReference;
    _writeTo(
      reference.pointer,
      _id_writeTo as jni$_.JMethodIDPtr,
      _$writer.pointer,
    ).check();
  }

  static final _id_append$3 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;)Ljava/io/CharArrayWriter;',
  );

  static final _append$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.CharArrayWriter append(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  CharArrayWriter? append$3(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$3(
      reference.pointer,
      _id_append$3 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<CharArrayWriter?>(const $CharArrayWriter$NullableType());
  }

  static final _id_append$4 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;II)Ljava/io/CharArrayWriter;',
  );

  static final _append$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public java.io.CharArrayWriter append(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  CharArrayWriter? append$4(jni$_.JObject? charSequence, int i, int i1) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$4(
      reference.pointer,
      _id_append$4 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
    ).object<CharArrayWriter?>(const $CharArrayWriter$NullableType());
  }

  static final _id_append$5 = _class.instanceMethodId(
    r'append',
    r'(C)Ljava/io/CharArrayWriter;',
  );

  static final _append$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.io.CharArrayWriter append(char c)`
  /// The returned object must be released after use, by calling the [release] method.
  CharArrayWriter? append$5(int c) => _append$5(
    reference.pointer,
    _id_append$5 as jni$_.JMethodIDPtr,
    c,
  ).object<CharArrayWriter?>(const $CharArrayWriter$NullableType());

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_toCharArray = _class.instanceMethodId(
    r'toCharArray',
    r'()[C',
  );

  static final _toCharArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char[] toCharArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JCharArray? toCharArray() => _toCharArray(
    reference.pointer,
    _id_toCharArray as jni$_.JMethodIDPtr,
  ).object<jni$_.JCharArray?>(const jni$_.JCharArrayNullableType());

  static final _id_size = _class.instanceMethodId(r'size', r'()I');

  static final _size =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int size()`
  int size() =>
      _size(reference.pointer, _id_size as jni$_.JMethodIDPtr).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $CharArrayWriter$NullableType
    extends jni$_.JObjType<CharArrayWriter?> {
  @jni$_.internal
  const $CharArrayWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/CharArrayWriter;';

  @jni$_.internal
  @core$_.override
  CharArrayWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CharArrayWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CharArrayWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($CharArrayWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CharArrayWriter$NullableType) &&
      other is $CharArrayWriter$NullableType;
}

final class $CharArrayWriter$Type extends jni$_.JObjType<CharArrayWriter> {
  @jni$_.internal
  const $CharArrayWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/CharArrayWriter;';

  @jni$_.internal
  @core$_.override
  CharArrayWriter fromReference(jni$_.JReference reference) =>
      CharArrayWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CharArrayWriter?> get nullableType =>
      const $CharArrayWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($CharArrayWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CharArrayWriter$Type) &&
      other is $CharArrayWriter$Type;
}

/// from: `java.io.EOFException`
class EOFException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<EOFException> $type;

  @jni$_.internal
  EOFException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/EOFException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $EOFException$NullableType();
  static const type = $EOFException$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory EOFException() => EOFException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory EOFException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return EOFException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $EOFException$NullableType extends jni$_.JObjType<EOFException?> {
  @jni$_.internal
  const $EOFException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/EOFException;';

  @jni$_.internal
  @core$_.override
  EOFException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : EOFException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EOFException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($EOFException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($EOFException$NullableType) &&
      other is $EOFException$NullableType;
}

final class $EOFException$Type extends jni$_.JObjType<EOFException> {
  @jni$_.internal
  const $EOFException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/EOFException;';

  @jni$_.internal
  @core$_.override
  EOFException fromReference(jni$_.JReference reference) =>
      EOFException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EOFException?> get nullableType =>
      const $EOFException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($EOFException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($EOFException$Type) && other is $EOFException$Type;
}

/// from: `java.io.FileNotFoundException`
class FileNotFoundException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileNotFoundException> $type;

  @jni$_.internal
  FileNotFoundException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FileNotFoundException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileNotFoundException$NullableType();
  static const type = $FileNotFoundException$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileNotFoundException() => FileNotFoundException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileNotFoundException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return FileNotFoundException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $FileNotFoundException$NullableType
    extends jni$_.JObjType<FileNotFoundException?> {
  @jni$_.internal
  const $FileNotFoundException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileNotFoundException;';

  @jni$_.internal
  @core$_.override
  FileNotFoundException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileNotFoundException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileNotFoundException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FileNotFoundException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileNotFoundException$NullableType) &&
      other is $FileNotFoundException$NullableType;
}

final class $FileNotFoundException$Type
    extends jni$_.JObjType<FileNotFoundException> {
  @jni$_.internal
  const $FileNotFoundException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileNotFoundException;';

  @jni$_.internal
  @core$_.override
  FileNotFoundException fromReference(jni$_.JReference reference) =>
      FileNotFoundException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileNotFoundException?> get nullableType =>
      const $FileNotFoundException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FileNotFoundException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileNotFoundException$Type) &&
      other is $FileNotFoundException$Type;
}

/// from: `java.io.CharConversionException`
class CharConversionException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CharConversionException> $type;

  @jni$_.internal
  CharConversionException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/CharConversionException',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CharConversionException$NullableType();
  static const type = $CharConversionException$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory CharConversionException() => CharConversionException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CharConversionException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return CharConversionException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $CharConversionException$NullableType
    extends jni$_.JObjType<CharConversionException?> {
  @jni$_.internal
  const $CharConversionException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/CharConversionException;';

  @jni$_.internal
  @core$_.override
  CharConversionException? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : CharConversionException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CharConversionException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($CharConversionException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CharConversionException$NullableType) &&
      other is $CharConversionException$NullableType;
}

final class $CharConversionException$Type
    extends jni$_.JObjType<CharConversionException> {
  @jni$_.internal
  const $CharConversionException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/CharConversionException;';

  @jni$_.internal
  @core$_.override
  CharConversionException fromReference(jni$_.JReference reference) =>
      CharConversionException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CharConversionException?> get nullableType =>
      const $CharConversionException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($CharConversionException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CharConversionException$Type) &&
      other is $CharConversionException$Type;
}

/// from: `java.io.ObjectInputFilter$Config`
class ObjectInputFilter$Config extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInputFilter$Config> $type;

  @jni$_.internal
  ObjectInputFilter$Config.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/ObjectInputFilter$Config',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInputFilter$Config$NullableType();
  static const type = $ObjectInputFilter$Config$Type();
  static final _id_getSerialFilter = _class.staticMethodId(
    r'getSerialFilter',
    r'()Ljava/io/ObjectInputFilter;',
  );

  static final _getSerialFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter getSerialFilter()`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter? getSerialFilter() => _getSerialFilter(
    _class.reference.pointer,
    _id_getSerialFilter as jni$_.JMethodIDPtr,
  ).object<ObjectInputFilter?>(const $ObjectInputFilter$NullableType());

  static final _id_setSerialFilter = _class.staticMethodId(
    r'setSerialFilter',
    r'(Ljava/io/ObjectInputFilter;)V',
  );

  static final _setSerialFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setSerialFilter(java.io.ObjectInputFilter objectInputFilter)`
  static void setSerialFilter(ObjectInputFilter? objectInputFilter) {
    final _$objectInputFilter =
        objectInputFilter?.reference ?? jni$_.jNullReference;
    _setSerialFilter(
      _class.reference.pointer,
      _id_setSerialFilter as jni$_.JMethodIDPtr,
      _$objectInputFilter.pointer,
    ).check();
  }

  static final _id_getSerialFilterFactory = _class.staticMethodId(
    r'getSerialFilterFactory',
    r'()Ljava/util/function/BinaryOperator;',
  );

  static final _getSerialFilterFactory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.function.BinaryOperator<java.io.ObjectInputFilter> getSerialFilterFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getSerialFilterFactory() => _getSerialFilterFactory(
    _class.reference.pointer,
    _id_getSerialFilterFactory as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_setSerialFilterFactory = _class.staticMethodId(
    r'setSerialFilterFactory',
    r'(Ljava/util/function/BinaryOperator;)V',
  );

  static final _setSerialFilterFactory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setSerialFilterFactory(java.util.function.BinaryOperator<java.io.ObjectInputFilter> binaryOperator)`
  static void setSerialFilterFactory(jni$_.JObject? binaryOperator) {
    final _$binaryOperator = binaryOperator?.reference ?? jni$_.jNullReference;
    _setSerialFilterFactory(
      _class.reference.pointer,
      _id_setSerialFilterFactory as jni$_.JMethodIDPtr,
      _$binaryOperator.pointer,
    ).check();
  }

  static final _id_createFilter = _class.staticMethodId(
    r'createFilter',
    r'(Ljava/lang/String;)Ljava/io/ObjectInputFilter;',
  );

  static final _createFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter createFilter(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter? createFilter(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createFilter(
      _class.reference.pointer,
      _id_createFilter as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<ObjectInputFilter?>(const $ObjectInputFilter$NullableType());
  }
}

final class $ObjectInputFilter$Config$NullableType
    extends jni$_.JObjType<ObjectInputFilter$Config?> {
  @jni$_.internal
  const $ObjectInputFilter$Config$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter$Config;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter$Config? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ObjectInputFilter$Config.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter$Config?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$Config$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInputFilter$Config$NullableType) &&
      other is $ObjectInputFilter$Config$NullableType;
}

final class $ObjectInputFilter$Config$Type
    extends jni$_.JObjType<ObjectInputFilter$Config> {
  @jni$_.internal
  const $ObjectInputFilter$Config$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter$Config;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter$Config fromReference(jni$_.JReference reference) =>
      ObjectInputFilter$Config.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter$Config?> get nullableType =>
      const $ObjectInputFilter$Config$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$Config$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInputFilter$Config$Type) &&
      other is $ObjectInputFilter$Config$Type;
}

/// from: `java.io.PushbackReader`
class PushbackReader extends FilterReader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PushbackReader> $type;

  @jni$_.internal
  PushbackReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PushbackReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PushbackReader$NullableType();
  static const type = $PushbackReader$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/Reader;I)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.Reader reader, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PushbackReader(Reader? reader, int i) {
    final _$reader = reader?.reference ?? jni$_.jNullReference;
    return PushbackReader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$reader.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/Reader;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.Reader reader)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PushbackReader.new$1(Reader? reader) {
    final _$reader = reader?.reference ?? jni$_.jNullReference;
    return PushbackReader.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$reader.pointer,
      ).reference,
    );
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() =>
      _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_unread = _class.instanceMethodId(r'unread', r'(I)V');

  static final _unread =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void unread(int i)`
  void unread(int i) {
    _unread(reference.pointer, _id_unread as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_unread$1 = _class.instanceMethodId(r'unread', r'([CII)V');

  static final _unread$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void unread(char[] cs, int i, int i1)`
  void unread$1(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _unread$1(
      reference.pointer,
      _id_unread$1 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_unread$2 = _class.instanceMethodId(r'unread', r'([C)V');

  static final _unread$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void unread(char[] cs)`
  void unread$2(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _unread$2(
      reference.pointer,
      _id_unread$2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).check();
  }

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() =>
      _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() =>
      _markSupported(
        reference.pointer,
        _id_markSupported as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
}

final class $PushbackReader$NullableType
    extends jni$_.JObjType<PushbackReader?> {
  @jni$_.internal
  const $PushbackReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PushbackReader;';

  @jni$_.internal
  @core$_.override
  PushbackReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PushbackReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterReader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PushbackReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($PushbackReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PushbackReader$NullableType) &&
      other is $PushbackReader$NullableType;
}

final class $PushbackReader$Type extends jni$_.JObjType<PushbackReader> {
  @jni$_.internal
  const $PushbackReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PushbackReader;';

  @jni$_.internal
  @core$_.override
  PushbackReader fromReference(jni$_.JReference reference) =>
      PushbackReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterReader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PushbackReader?> get nullableType =>
      const $PushbackReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($PushbackReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PushbackReader$Type) &&
      other is $PushbackReader$Type;
}

/// from: `java.io.DataInput`
class DataInput extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DataInput> $type;

  @jni$_.internal
  DataInput.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/DataInput');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DataInput$NullableType();
  static const type = $DataInput$Type();
  static final _id_readFully = _class.instanceMethodId(r'readFully', r'([B)V');

  static final _readFully =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void readFully(byte[] bs)`
  void readFully(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully(
      reference.pointer,
      _id_readFully as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_readFully$1 = _class.instanceMethodId(
    r'readFully',
    r'([BII)V',
  );

  static final _readFully$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract void readFully(byte[] bs, int i, int i1)`
  void readFully$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully$1(
      reference.pointer,
      _id_readFully$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_skipBytes = _class.instanceMethodId(r'skipBytes', r'(I)I');

  static final _skipBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract int skipBytes(int i)`
  int skipBytes(int i) =>
      _skipBytes(
        reference.pointer,
        _id_skipBytes as jni$_.JMethodIDPtr,
        i,
      ).integer;

  static final _id_readBoolean = _class.instanceMethodId(
    r'readBoolean',
    r'()Z',
  );

  static final _readBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract boolean readBoolean()`
  bool readBoolean() =>
      _readBoolean(
        reference.pointer,
        _id_readBoolean as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_readByte = _class.instanceMethodId(r'readByte', r'()B');

  static final _readByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract byte readByte()`
  int readByte() =>
      _readByte(reference.pointer, _id_readByte as jni$_.JMethodIDPtr).byte;

  static final _id_readUnsignedByte = _class.instanceMethodId(
    r'readUnsignedByte',
    r'()I',
  );

  static final _readUnsignedByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int readUnsignedByte()`
  int readUnsignedByte() =>
      _readUnsignedByte(
        reference.pointer,
        _id_readUnsignedByte as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_readShort = _class.instanceMethodId(r'readShort', r'()S');

  static final _readShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract short readShort()`
  int readShort() =>
      _readShort(reference.pointer, _id_readShort as jni$_.JMethodIDPtr).short;

  static final _id_readUnsignedShort = _class.instanceMethodId(
    r'readUnsignedShort',
    r'()I',
  );

  static final _readUnsignedShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int readUnsignedShort()`
  int readUnsignedShort() =>
      _readUnsignedShort(
        reference.pointer,
        _id_readUnsignedShort as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_readChar = _class.instanceMethodId(r'readChar', r'()C');

  static final _readChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract char readChar()`
  int readChar() =>
      _readChar(reference.pointer, _id_readChar as jni$_.JMethodIDPtr).char;

  static final _id_readInt = _class.instanceMethodId(r'readInt', r'()I');

  static final _readInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int readInt()`
  int readInt() =>
      _readInt(reference.pointer, _id_readInt as jni$_.JMethodIDPtr).integer;

  static final _id_readLong = _class.instanceMethodId(r'readLong', r'()J');

  static final _readLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract long readLong()`
  int readLong() =>
      _readLong(reference.pointer, _id_readLong as jni$_.JMethodIDPtr).long;

  static final _id_readFloat = _class.instanceMethodId(r'readFloat', r'()F');

  static final _readFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract float readFloat()`
  double readFloat() =>
      _readFloat(reference.pointer, _id_readFloat as jni$_.JMethodIDPtr).float;

  static final _id_readDouble = _class.instanceMethodId(r'readDouble', r'()D');

  static final _readDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract double readDouble()`
  double readDouble() =>
      _readDouble(
        reference.pointer,
        _id_readDouble as jni$_.JMethodIDPtr,
      ).doubleFloat;

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine() => _readLine(
    reference.pointer,
    _id_readLine as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_readUTF = _class.instanceMethodId(
    r'readUTF',
    r'()Ljava/lang/String;',
  );

  static final _readUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String readUTF()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readUTF() => _readUTF(
    reference.pointer,
    _id_readUTF as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $DataInput> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'readFully([B)V') {
        _$impls[$p]!.readFully(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'readFully([BII)V') {
        _$impls[$p]!.readFully$1(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'skipBytes(I)I') {
        final $r = _$impls[$p]!.skipBytes(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readBoolean()Z') {
        final $r = _$impls[$p]!.readBoolean();
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'readByte()B') {
        final $r = _$impls[$p]!.readByte();
        return jni$_.JByte($r).reference.toPointer();
      }
      if ($d == r'readUnsignedByte()I') {
        final $r = _$impls[$p]!.readUnsignedByte();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readShort()S') {
        final $r = _$impls[$p]!.readShort();
        return jni$_.JShort($r).reference.toPointer();
      }
      if ($d == r'readUnsignedShort()I') {
        final $r = _$impls[$p]!.readUnsignedShort();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readChar()C') {
        final $r = _$impls[$p]!.readChar();
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'readInt()I') {
        final $r = _$impls[$p]!.readInt();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readLong()J') {
        final $r = _$impls[$p]!.readLong();
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'readFloat()F') {
        final $r = _$impls[$p]!.readFloat();
        return jni$_.JFloat($r).reference.toPointer();
      }
      if ($d == r'readDouble()D') {
        final $r = _$impls[$p]!.readDouble();
        return jni$_.JDouble($r).reference.toPointer();
      }
      if ($d == r'readLine()Ljava/lang/String;') {
        final $r = _$impls[$p]!.readLine();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'readUTF()Ljava/lang/String;') {
        final $r = _$impls[$p]!.readUTF();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $DataInput $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.DataInput', $p, _$invokePointer, [
      if ($impl.readFully$async) r'readFully([B)V',
      if ($impl.readFully$1$async) r'readFully([BII)V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory DataInput.implement($DataInput $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return DataInput.fromReference($i.implementReference());
  }
}

abstract base mixin class $DataInput {
  factory $DataInput({
    required void Function(jni$_.JByteArray? bs) readFully,
    bool readFully$async,
    required void Function(jni$_.JByteArray? bs, int i, int i1) readFully$1,
    bool readFully$1$async,
    required int Function(int i) skipBytes,
    required bool Function() readBoolean,
    required int Function() readByte,
    required int Function() readUnsignedByte,
    required int Function() readShort,
    required int Function() readUnsignedShort,
    required int Function() readChar,
    required int Function() readInt,
    required int Function() readLong,
    required double Function() readFloat,
    required double Function() readDouble,
    required jni$_.JString? Function() readLine,
    required jni$_.JString? Function() readUTF,
  }) = _$DataInput;

  void readFully(jni$_.JByteArray? bs);
  bool get readFully$async => false;
  void readFully$1(jni$_.JByteArray? bs, int i, int i1);
  bool get readFully$1$async => false;
  int skipBytes(int i);
  bool readBoolean();
  int readByte();
  int readUnsignedByte();
  int readShort();
  int readUnsignedShort();
  int readChar();
  int readInt();
  int readLong();
  double readFloat();
  double readDouble();
  jni$_.JString? readLine();
  jni$_.JString? readUTF();
}

final class _$DataInput with $DataInput {
  _$DataInput({
    required void Function(jni$_.JByteArray? bs) readFully,
    this.readFully$async = false,
    required void Function(jni$_.JByteArray? bs, int i, int i1) readFully$1,
    this.readFully$1$async = false,
    required int Function(int i) skipBytes,
    required bool Function() readBoolean,
    required int Function() readByte,
    required int Function() readUnsignedByte,
    required int Function() readShort,
    required int Function() readUnsignedShort,
    required int Function() readChar,
    required int Function() readInt,
    required int Function() readLong,
    required double Function() readFloat,
    required double Function() readDouble,
    required jni$_.JString? Function() readLine,
    required jni$_.JString? Function() readUTF,
  }) : _readFully = readFully,
       _readFully$1 = readFully$1,
       _skipBytes = skipBytes,
       _readBoolean = readBoolean,
       _readByte = readByte,
       _readUnsignedByte = readUnsignedByte,
       _readShort = readShort,
       _readUnsignedShort = readUnsignedShort,
       _readChar = readChar,
       _readInt = readInt,
       _readLong = readLong,
       _readFloat = readFloat,
       _readDouble = readDouble,
       _readLine = readLine,
       _readUTF = readUTF;

  final void Function(jni$_.JByteArray? bs) _readFully;
  final bool readFully$async;
  final void Function(jni$_.JByteArray? bs, int i, int i1) _readFully$1;
  final bool readFully$1$async;
  final int Function(int i) _skipBytes;
  final bool Function() _readBoolean;
  final int Function() _readByte;
  final int Function() _readUnsignedByte;
  final int Function() _readShort;
  final int Function() _readUnsignedShort;
  final int Function() _readChar;
  final int Function() _readInt;
  final int Function() _readLong;
  final double Function() _readFloat;
  final double Function() _readDouble;
  final jni$_.JString? Function() _readLine;
  final jni$_.JString? Function() _readUTF;

  void readFully(jni$_.JByteArray? bs) => _readFully(bs);

  void readFully$1(jni$_.JByteArray? bs, int i, int i1) =>
      _readFully$1(bs, i, i1);

  int skipBytes(int i) => _skipBytes(i);

  bool readBoolean() => _readBoolean();

  int readByte() => _readByte();

  int readUnsignedByte() => _readUnsignedByte();

  int readShort() => _readShort();

  int readUnsignedShort() => _readUnsignedShort();

  int readChar() => _readChar();

  int readInt() => _readInt();

  int readLong() => _readLong();

  double readFloat() => _readFloat();

  double readDouble() => _readDouble();

  jni$_.JString? readLine() => _readLine();

  jni$_.JString? readUTF() => _readUTF();
}

final class $DataInput$NullableType extends jni$_.JObjType<DataInput?> {
  @jni$_.internal
  const $DataInput$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataInput;';

  @jni$_.internal
  @core$_.override
  DataInput? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DataInput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataInput?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DataInput$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DataInput$NullableType) &&
      other is $DataInput$NullableType;
}

final class $DataInput$Type extends jni$_.JObjType<DataInput> {
  @jni$_.internal
  const $DataInput$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataInput;';

  @jni$_.internal
  @core$_.override
  DataInput fromReference(jni$_.JReference reference) =>
      DataInput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataInput?> get nullableType =>
      const $DataInput$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DataInput$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DataInput$Type) && other is $DataInput$Type;
}

/// from: `java.io.Writer`
class Writer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Writer> $type;

  @jni$_.internal
  Writer.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Writer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Writer$NullableType();
  static const type = $Writer$Type();
  static final _id_nullWriter = _class.staticMethodId(
    r'nullWriter',
    r'()Ljava/io/Writer;',
  );

  static final _nullWriter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.Writer nullWriter()`
  /// The returned object must be released after use, by calling the [release] method.
  static Writer? nullWriter() => _nullWriter(
    _class.reference.pointer,
    _id_nullWriter as jni$_.JMethodIDPtr,
  ).object<Writer?>(const $Writer$NullableType());

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write$1 = _class.instanceMethodId(r'write', r'([C)V');

  static final _write$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(char[] cs)`
  void write$1(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write$1(
      reference.pointer,
      _id_write$1 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).check();
  }

  static final _id_write$2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract void write(char[] cs, int i, int i1)`
  void write$2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write$2(
      reference.pointer,
      _id_write$2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write$3 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;)V',
  );

  static final _write$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(java.lang.String string)`
  void write$3(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write$3(
      reference.pointer,
      _id_write$3 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_write$4 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;II)V',
  );

  static final _write$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(java.lang.String string, int i, int i1)`
  void write$4(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write$4(
      reference.pointer,
      _id_write$4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_append = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;)Ljava/io/Writer;',
  );

  static final _append =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.Writer append(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  Writer? append(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append(
      reference.pointer,
      _id_append as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<Writer?>(const $Writer$NullableType());
  }

  static final _id_append$1 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;II)Ljava/io/Writer;',
  );

  static final _append$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public java.io.Writer append(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  Writer? append$1(jni$_.JObject? charSequence, int i, int i1) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$1(
      reference.pointer,
      _id_append$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
    ).object<Writer?>(const $Writer$NullableType());
  }

  static final _id_append$2 = _class.instanceMethodId(
    r'append',
    r'(C)Ljava/io/Writer;',
  );

  static final _append$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.io.Writer append(char c)`
  /// The returned object must be released after use, by calling the [release] method.
  Writer? append$2(int c) => _append$2(
    reference.pointer,
    _id_append$2 as jni$_.JMethodIDPtr,
    c,
  ).object<Writer?>(const $Writer$NullableType());

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $Writer$NullableType extends jni$_.JObjType<Writer?> {
  @jni$_.internal
  const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Writer;';

  @jni$_.internal
  @core$_.override
  Writer? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Writer.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Writer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Writer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Writer$NullableType) &&
      other is $Writer$NullableType;
}

final class $Writer$Type extends jni$_.JObjType<Writer> {
  @jni$_.internal
  const $Writer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Writer;';

  @jni$_.internal
  @core$_.override
  Writer fromReference(jni$_.JReference reference) =>
      Writer.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Writer?> get nullableType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Writer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Writer$Type) && other is $Writer$Type;
}

/// from: `java.io.ObjectInput`
class ObjectInput extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInput> $type;

  @jni$_.internal
  ObjectInput.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectInput');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInput$NullableType();
  static const type = $ObjectInput$Type();
  static final _id_readObject = _class.instanceMethodId(
    r'readObject',
    r'()Ljava/lang/Object;',
  );

  static final _readObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.Object readObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? readObject() => _readObject(
    reference.pointer,
    _id_readObject as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int read()`
  int read() =>
      _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;

  static final _id_read$1 = _class.instanceMethodId(r'read', r'([B)I');

  static final _read$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract int read(byte[] bs)`
  int read$1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read$1(
      reference.pointer,
      _id_read$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).integer;
  }

  static final _id_read$2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract int read(byte[] bs, int i, int i1)`
  int read$2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read$2(
      reference.pointer,
      _id_read$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int available()`
  int available() =>
      _available(
        reference.pointer,
        _id_available as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_readFully = _class.instanceMethodId(r'readFully', r'([B)V');

  static final _readFully =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void readFully(byte[] bs)`
  void readFully(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully(
      reference.pointer,
      _id_readFully as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_readFully$1 = _class.instanceMethodId(
    r'readFully',
    r'([BII)V',
  );

  static final _readFully$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract void readFully(byte[] bs, int i, int i1)`
  void readFully$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully$1(
      reference.pointer,
      _id_readFully$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_skipBytes = _class.instanceMethodId(r'skipBytes', r'(I)I');

  static final _skipBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract int skipBytes(int i)`
  int skipBytes(int i) =>
      _skipBytes(
        reference.pointer,
        _id_skipBytes as jni$_.JMethodIDPtr,
        i,
      ).integer;

  static final _id_readBoolean = _class.instanceMethodId(
    r'readBoolean',
    r'()Z',
  );

  static final _readBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract boolean readBoolean()`
  bool readBoolean() =>
      _readBoolean(
        reference.pointer,
        _id_readBoolean as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_readByte = _class.instanceMethodId(r'readByte', r'()B');

  static final _readByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract byte readByte()`
  int readByte() =>
      _readByte(reference.pointer, _id_readByte as jni$_.JMethodIDPtr).byte;

  static final _id_readUnsignedByte = _class.instanceMethodId(
    r'readUnsignedByte',
    r'()I',
  );

  static final _readUnsignedByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int readUnsignedByte()`
  int readUnsignedByte() =>
      _readUnsignedByte(
        reference.pointer,
        _id_readUnsignedByte as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_readShort = _class.instanceMethodId(r'readShort', r'()S');

  static final _readShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract short readShort()`
  int readShort() =>
      _readShort(reference.pointer, _id_readShort as jni$_.JMethodIDPtr).short;

  static final _id_readUnsignedShort = _class.instanceMethodId(
    r'readUnsignedShort',
    r'()I',
  );

  static final _readUnsignedShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int readUnsignedShort()`
  int readUnsignedShort() =>
      _readUnsignedShort(
        reference.pointer,
        _id_readUnsignedShort as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_readChar = _class.instanceMethodId(r'readChar', r'()C');

  static final _readChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract char readChar()`
  int readChar() =>
      _readChar(reference.pointer, _id_readChar as jni$_.JMethodIDPtr).char;

  static final _id_readInt = _class.instanceMethodId(r'readInt', r'()I');

  static final _readInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int readInt()`
  int readInt() =>
      _readInt(reference.pointer, _id_readInt as jni$_.JMethodIDPtr).integer;

  static final _id_readLong = _class.instanceMethodId(r'readLong', r'()J');

  static final _readLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract long readLong()`
  int readLong() =>
      _readLong(reference.pointer, _id_readLong as jni$_.JMethodIDPtr).long;

  static final _id_readFloat = _class.instanceMethodId(r'readFloat', r'()F');

  static final _readFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract float readFloat()`
  double readFloat() =>
      _readFloat(reference.pointer, _id_readFloat as jni$_.JMethodIDPtr).float;

  static final _id_readDouble = _class.instanceMethodId(r'readDouble', r'()D');

  static final _readDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract double readDouble()`
  double readDouble() =>
      _readDouble(
        reference.pointer,
        _id_readDouble as jni$_.JMethodIDPtr,
      ).doubleFloat;

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine() => _readLine(
    reference.pointer,
    _id_readLine as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_readUTF = _class.instanceMethodId(
    r'readUTF',
    r'()Ljava/lang/String;',
  );

  static final _readUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String readUTF()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readUTF() => _readUTF(
    reference.pointer,
    _id_readUTF as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ObjectInput> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'readObject()Ljava/lang/Object;') {
        final $r = _$impls[$p]!.readObject();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'read()I') {
        final $r = _$impls[$p]!.read();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'read([B)I') {
        final $r = _$impls[$p]!.read$1(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'read([BII)I') {
        final $r = _$impls[$p]!.read$2(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'skip(J)J') {
        final $r = _$impls[$p]!.skip(
          $a![0]!
              .as(const jni$_.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'available()I') {
        final $r = _$impls[$p]!.available();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'close()V') {
        _$impls[$p]!.close();
        return jni$_.nullptr;
      }
      if ($d == r'readFully([B)V') {
        _$impls[$p]!.readFully(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'readFully([BII)V') {
        _$impls[$p]!.readFully$1(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'skipBytes(I)I') {
        final $r = _$impls[$p]!.skipBytes(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readBoolean()Z') {
        final $r = _$impls[$p]!.readBoolean();
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'readByte()B') {
        final $r = _$impls[$p]!.readByte();
        return jni$_.JByte($r).reference.toPointer();
      }
      if ($d == r'readUnsignedByte()I') {
        final $r = _$impls[$p]!.readUnsignedByte();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readShort()S') {
        final $r = _$impls[$p]!.readShort();
        return jni$_.JShort($r).reference.toPointer();
      }
      if ($d == r'readUnsignedShort()I') {
        final $r = _$impls[$p]!.readUnsignedShort();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readChar()C') {
        final $r = _$impls[$p]!.readChar();
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'readInt()I') {
        final $r = _$impls[$p]!.readInt();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readLong()J') {
        final $r = _$impls[$p]!.readLong();
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'readFloat()F') {
        final $r = _$impls[$p]!.readFloat();
        return jni$_.JFloat($r).reference.toPointer();
      }
      if ($d == r'readDouble()D') {
        final $r = _$impls[$p]!.readDouble();
        return jni$_.JDouble($r).reference.toPointer();
      }
      if ($d == r'readLine()Ljava/lang/String;') {
        final $r = _$impls[$p]!.readLine();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'readUTF()Ljava/lang/String;') {
        final $r = _$impls[$p]!.readUTF();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $ObjectInput $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.ObjectInput', $p, _$invokePointer, [
      if ($impl.close$async) r'close()V',
      if ($impl.readFully$async) r'readFully([B)V',
      if ($impl.readFully$1$async) r'readFully([BII)V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ObjectInput.implement($ObjectInput $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ObjectInput.fromReference($i.implementReference());
  }
}

abstract base mixin class $ObjectInput {
  factory $ObjectInput({
    required jni$_.JObject? Function() readObject,
    required int Function() read,
    required int Function(jni$_.JByteArray? bs) read$1,
    required int Function(jni$_.JByteArray? bs, int i, int i1) read$2,
    required int Function(int j) skip,
    required int Function() available,
    required void Function() close,
    bool close$async,
    required void Function(jni$_.JByteArray? bs) readFully,
    bool readFully$async,
    required void Function(jni$_.JByteArray? bs, int i, int i1) readFully$1,
    bool readFully$1$async,
    required int Function(int i) skipBytes,
    required bool Function() readBoolean,
    required int Function() readByte,
    required int Function() readUnsignedByte,
    required int Function() readShort,
    required int Function() readUnsignedShort,
    required int Function() readChar,
    required int Function() readInt,
    required int Function() readLong,
    required double Function() readFloat,
    required double Function() readDouble,
    required jni$_.JString? Function() readLine,
    required jni$_.JString? Function() readUTF,
  }) = _$ObjectInput;

  jni$_.JObject? readObject();
  int read();
  int read$1(jni$_.JByteArray? bs);
  int read$2(jni$_.JByteArray? bs, int i, int i1);
  int skip(int j);
  int available();
  void close();
  bool get close$async => false;
  void readFully(jni$_.JByteArray? bs);
  bool get readFully$async => false;
  void readFully$1(jni$_.JByteArray? bs, int i, int i1);
  bool get readFully$1$async => false;
  int skipBytes(int i);
  bool readBoolean();
  int readByte();
  int readUnsignedByte();
  int readShort();
  int readUnsignedShort();
  int readChar();
  int readInt();
  int readLong();
  double readFloat();
  double readDouble();
  jni$_.JString? readLine();
  jni$_.JString? readUTF();
}

final class _$ObjectInput with $ObjectInput {
  _$ObjectInput({
    required jni$_.JObject? Function() readObject,
    required int Function() read,
    required int Function(jni$_.JByteArray? bs) read$1,
    required int Function(jni$_.JByteArray? bs, int i, int i1) read$2,
    required int Function(int j) skip,
    required int Function() available,
    required void Function() close,
    this.close$async = false,
    required void Function(jni$_.JByteArray? bs) readFully,
    this.readFully$async = false,
    required void Function(jni$_.JByteArray? bs, int i, int i1) readFully$1,
    this.readFully$1$async = false,
    required int Function(int i) skipBytes,
    required bool Function() readBoolean,
    required int Function() readByte,
    required int Function() readUnsignedByte,
    required int Function() readShort,
    required int Function() readUnsignedShort,
    required int Function() readChar,
    required int Function() readInt,
    required int Function() readLong,
    required double Function() readFloat,
    required double Function() readDouble,
    required jni$_.JString? Function() readLine,
    required jni$_.JString? Function() readUTF,
  }) : _readObject = readObject,
       _read = read,
       _read$1 = read$1,
       _read$2 = read$2,
       _skip = skip,
       _available = available,
       _close = close,
       _readFully = readFully,
       _readFully$1 = readFully$1,
       _skipBytes = skipBytes,
       _readBoolean = readBoolean,
       _readByte = readByte,
       _readUnsignedByte = readUnsignedByte,
       _readShort = readShort,
       _readUnsignedShort = readUnsignedShort,
       _readChar = readChar,
       _readInt = readInt,
       _readLong = readLong,
       _readFloat = readFloat,
       _readDouble = readDouble,
       _readLine = readLine,
       _readUTF = readUTF;

  final jni$_.JObject? Function() _readObject;
  final int Function() _read;
  final int Function(jni$_.JByteArray? bs) _read$1;
  final int Function(jni$_.JByteArray? bs, int i, int i1) _read$2;
  final int Function(int j) _skip;
  final int Function() _available;
  final void Function() _close;
  final bool close$async;
  final void Function(jni$_.JByteArray? bs) _readFully;
  final bool readFully$async;
  final void Function(jni$_.JByteArray? bs, int i, int i1) _readFully$1;
  final bool readFully$1$async;
  final int Function(int i) _skipBytes;
  final bool Function() _readBoolean;
  final int Function() _readByte;
  final int Function() _readUnsignedByte;
  final int Function() _readShort;
  final int Function() _readUnsignedShort;
  final int Function() _readChar;
  final int Function() _readInt;
  final int Function() _readLong;
  final double Function() _readFloat;
  final double Function() _readDouble;
  final jni$_.JString? Function() _readLine;
  final jni$_.JString? Function() _readUTF;

  jni$_.JObject? readObject() => _readObject();

  int read() => _read();

  int read$1(jni$_.JByteArray? bs) => _read$1(bs);

  int read$2(jni$_.JByteArray? bs, int i, int i1) => _read$2(bs, i, i1);

  int skip(int j) => _skip(j);

  int available() => _available();

  void close() => _close();

  void readFully(jni$_.JByteArray? bs) => _readFully(bs);

  void readFully$1(jni$_.JByteArray? bs, int i, int i1) =>
      _readFully$1(bs, i, i1);

  int skipBytes(int i) => _skipBytes(i);

  bool readBoolean() => _readBoolean();

  int readByte() => _readByte();

  int readUnsignedByte() => _readUnsignedByte();

  int readShort() => _readShort();

  int readUnsignedShort() => _readUnsignedShort();

  int readChar() => _readChar();

  int readInt() => _readInt();

  int readLong() => _readLong();

  double readFloat() => _readFloat();

  double readDouble() => _readDouble();

  jni$_.JString? readLine() => _readLine();

  jni$_.JString? readUTF() => _readUTF();
}

final class $ObjectInput$NullableType extends jni$_.JObjType<ObjectInput?> {
  @jni$_.internal
  const $ObjectInput$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInput;';

  @jni$_.internal
  @core$_.override
  ObjectInput? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectInput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInput?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInput$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInput$NullableType) &&
      other is $ObjectInput$NullableType;
}

final class $ObjectInput$Type extends jni$_.JObjType<ObjectInput> {
  @jni$_.internal
  const $ObjectInput$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInput;';

  @jni$_.internal
  @core$_.override
  ObjectInput fromReference(jni$_.JReference reference) =>
      ObjectInput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInput?> get nullableType =>
      const $ObjectInput$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInput$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInput$Type) && other is $ObjectInput$Type;
}

/// from: `java.io.ObjectInputFilter`
class ObjectInputFilter extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInputFilter> $type;

  @jni$_.internal
  ObjectInputFilter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectInputFilter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInputFilter$NullableType();
  static const type = $ObjectInputFilter$Type();
  static final _id_checkInput = _class.instanceMethodId(
    r'checkInput',
    r'(Ljava/io/ObjectInputFilter$FilterInfo;)Ljava/io/ObjectInputFilter$Status;',
  );

  static final _checkInput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.io.ObjectInputFilter$Status checkInput(java.io.ObjectInputFilter$FilterInfo filterInfo)`
  /// The returned object must be released after use, by calling the [release] method.
  ObjectInputFilter$Status? checkInput(
    ObjectInputFilter$FilterInfo? filterInfo,
  ) {
    final _$filterInfo = filterInfo?.reference ?? jni$_.jNullReference;
    return _checkInput(
      reference.pointer,
      _id_checkInput as jni$_.JMethodIDPtr,
      _$filterInfo.pointer,
    ).object<ObjectInputFilter$Status?>(
      const $ObjectInputFilter$Status$NullableType(),
    );
  }

  static final _id_allowFilter = _class.staticMethodId(
    r'allowFilter',
    r'(Ljava/util/function/Predicate;Ljava/io/ObjectInputFilter$Status;)Ljava/io/ObjectInputFilter;',
  );

  static final _allowFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter allowFilter(java.util.function.Predicate<java.lang.Class<?>> predicate, java.io.ObjectInputFilter$Status status)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter? allowFilter(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  ) {
    final _$predicate = predicate?.reference ?? jni$_.jNullReference;
    final _$status = status?.reference ?? jni$_.jNullReference;
    return _allowFilter(
      _class.reference.pointer,
      _id_allowFilter as jni$_.JMethodIDPtr,
      _$predicate.pointer,
      _$status.pointer,
    ).object<ObjectInputFilter?>(const $ObjectInputFilter$NullableType());
  }

  static final _id_rejectFilter = _class.staticMethodId(
    r'rejectFilter',
    r'(Ljava/util/function/Predicate;Ljava/io/ObjectInputFilter$Status;)Ljava/io/ObjectInputFilter;',
  );

  static final _rejectFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter rejectFilter(java.util.function.Predicate<java.lang.Class<?>> predicate, java.io.ObjectInputFilter$Status status)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter? rejectFilter(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  ) {
    final _$predicate = predicate?.reference ?? jni$_.jNullReference;
    final _$status = status?.reference ?? jni$_.jNullReference;
    return _rejectFilter(
      _class.reference.pointer,
      _id_rejectFilter as jni$_.JMethodIDPtr,
      _$predicate.pointer,
      _$status.pointer,
    ).object<ObjectInputFilter?>(const $ObjectInputFilter$NullableType());
  }

  static final _id_merge = _class.staticMethodId(
    r'merge',
    r'(Ljava/io/ObjectInputFilter;Ljava/io/ObjectInputFilter;)Ljava/io/ObjectInputFilter;',
  );

  static final _merge =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter merge(java.io.ObjectInputFilter objectInputFilter, java.io.ObjectInputFilter objectInputFilter1)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter? merge(
    ObjectInputFilter? objectInputFilter,
    ObjectInputFilter? objectInputFilter1,
  ) {
    final _$objectInputFilter =
        objectInputFilter?.reference ?? jni$_.jNullReference;
    final _$objectInputFilter1 =
        objectInputFilter1?.reference ?? jni$_.jNullReference;
    return _merge(
      _class.reference.pointer,
      _id_merge as jni$_.JMethodIDPtr,
      _$objectInputFilter.pointer,
      _$objectInputFilter1.pointer,
    ).object<ObjectInputFilter?>(const $ObjectInputFilter$NullableType());
  }

  static final _id_rejectUndecidedClass = _class.staticMethodId(
    r'rejectUndecidedClass',
    r'(Ljava/io/ObjectInputFilter;)Ljava/io/ObjectInputFilter;',
  );

  static final _rejectUndecidedClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter rejectUndecidedClass(java.io.ObjectInputFilter objectInputFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter? rejectUndecidedClass(
    ObjectInputFilter? objectInputFilter,
  ) {
    final _$objectInputFilter =
        objectInputFilter?.reference ?? jni$_.jNullReference;
    return _rejectUndecidedClass(
      _class.reference.pointer,
      _id_rejectUndecidedClass as jni$_.JMethodIDPtr,
      _$objectInputFilter.pointer,
    ).object<ObjectInputFilter?>(const $ObjectInputFilter$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ObjectInputFilter> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'checkInput(Ljava/io/ObjectInputFilter$FilterInfo;)Ljava/io/ObjectInputFilter$Status;') {
        final $r = _$impls[$p]!.checkInput(
          $a![0]?.as(
            const $ObjectInputFilter$FilterInfo$Type(),
            releaseOriginal: true,
          ),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'allowFilter(Ljava/util/function/Predicate;Ljava/io/ObjectInputFilter$Status;)Ljava/io/ObjectInputFilter;') {
        final $r = _$impls[$p]!.allowFilter(
          $a![0]?.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]?.as(
            const $ObjectInputFilter$Status$Type(),
            releaseOriginal: true,
          ),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'rejectFilter(Ljava/util/function/Predicate;Ljava/io/ObjectInputFilter$Status;)Ljava/io/ObjectInputFilter;') {
        final $r = _$impls[$p]!.rejectFilter(
          $a![0]?.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]?.as(
            const $ObjectInputFilter$Status$Type(),
            releaseOriginal: true,
          ),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'merge(Ljava/io/ObjectInputFilter;Ljava/io/ObjectInputFilter;)Ljava/io/ObjectInputFilter;') {
        final $r = _$impls[$p]!.merge(
          $a![0]?.as(const $ObjectInputFilter$Type(), releaseOriginal: true),
          $a![1]?.as(const $ObjectInputFilter$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'rejectUndecidedClass(Ljava/io/ObjectInputFilter;)Ljava/io/ObjectInputFilter;') {
        final $r = _$impls[$p]!.rejectUndecidedClass(
          $a![0]?.as(const $ObjectInputFilter$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ObjectInputFilter $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.ObjectInputFilter', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ObjectInputFilter.implement($ObjectInputFilter $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ObjectInputFilter.fromReference($i.implementReference());
  }
}

abstract base mixin class $ObjectInputFilter {
  factory $ObjectInputFilter({
    required ObjectInputFilter$Status? Function(
      ObjectInputFilter$FilterInfo? filterInfo,
    )
    checkInput,
    required ObjectInputFilter? Function(
      jni$_.JObject? predicate,
      ObjectInputFilter$Status? status,
    )
    allowFilter,
    required ObjectInputFilter? Function(
      jni$_.JObject? predicate,
      ObjectInputFilter$Status? status,
    )
    rejectFilter,
    required ObjectInputFilter? Function(
      ObjectInputFilter? objectInputFilter,
      ObjectInputFilter? objectInputFilter1,
    )
    merge,
    required ObjectInputFilter? Function(ObjectInputFilter? objectInputFilter)
    rejectUndecidedClass,
  }) = _$ObjectInputFilter;

  ObjectInputFilter$Status? checkInput(
    ObjectInputFilter$FilterInfo? filterInfo,
  );
  ObjectInputFilter? allowFilter(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  );
  ObjectInputFilter? rejectFilter(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  );
  ObjectInputFilter? merge(
    ObjectInputFilter? objectInputFilter,
    ObjectInputFilter? objectInputFilter1,
  );
  ObjectInputFilter? rejectUndecidedClass(ObjectInputFilter? objectInputFilter);
}

final class _$ObjectInputFilter with $ObjectInputFilter {
  _$ObjectInputFilter({
    required ObjectInputFilter$Status? Function(
      ObjectInputFilter$FilterInfo? filterInfo,
    )
    checkInput,
    required ObjectInputFilter? Function(
      jni$_.JObject? predicate,
      ObjectInputFilter$Status? status,
    )
    allowFilter,
    required ObjectInputFilter? Function(
      jni$_.JObject? predicate,
      ObjectInputFilter$Status? status,
    )
    rejectFilter,
    required ObjectInputFilter? Function(
      ObjectInputFilter? objectInputFilter,
      ObjectInputFilter? objectInputFilter1,
    )
    merge,
    required ObjectInputFilter? Function(ObjectInputFilter? objectInputFilter)
    rejectUndecidedClass,
  }) : _checkInput = checkInput,
       _allowFilter = allowFilter,
       _rejectFilter = rejectFilter,
       _merge = merge,
       _rejectUndecidedClass = rejectUndecidedClass;

  final ObjectInputFilter$Status? Function(
    ObjectInputFilter$FilterInfo? filterInfo,
  )
  _checkInput;
  final ObjectInputFilter? Function(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  )
  _allowFilter;
  final ObjectInputFilter? Function(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  )
  _rejectFilter;
  final ObjectInputFilter? Function(
    ObjectInputFilter? objectInputFilter,
    ObjectInputFilter? objectInputFilter1,
  )
  _merge;
  final ObjectInputFilter? Function(ObjectInputFilter? objectInputFilter)
  _rejectUndecidedClass;

  ObjectInputFilter$Status? checkInput(
    ObjectInputFilter$FilterInfo? filterInfo,
  ) => _checkInput(filterInfo);

  ObjectInputFilter? allowFilter(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  ) => _allowFilter(predicate, status);

  ObjectInputFilter? rejectFilter(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  ) => _rejectFilter(predicate, status);

  ObjectInputFilter? merge(
    ObjectInputFilter? objectInputFilter,
    ObjectInputFilter? objectInputFilter1,
  ) => _merge(objectInputFilter, objectInputFilter1);

  ObjectInputFilter? rejectUndecidedClass(
    ObjectInputFilter? objectInputFilter,
  ) => _rejectUndecidedClass(objectInputFilter);
}

final class $ObjectInputFilter$NullableType
    extends jni$_.JObjType<ObjectInputFilter?> {
  @jni$_.internal
  const $ObjectInputFilter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectInputFilter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInputFilter$NullableType) &&
      other is $ObjectInputFilter$NullableType;
}

final class $ObjectInputFilter$Type extends jni$_.JObjType<ObjectInputFilter> {
  @jni$_.internal
  const $ObjectInputFilter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter fromReference(jni$_.JReference reference) =>
      ObjectInputFilter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter?> get nullableType =>
      const $ObjectInputFilter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInputFilter$Type) &&
      other is $ObjectInputFilter$Type;
}

/// from: `java.io.UnsupportedEncodingException`
class UnsupportedEncodingException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<UnsupportedEncodingException> $type;

  @jni$_.internal
  UnsupportedEncodingException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/UnsupportedEncodingException',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $UnsupportedEncodingException$NullableType();
  static const type = $UnsupportedEncodingException$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory UnsupportedEncodingException() =>
      UnsupportedEncodingException.fromReference(
        _new$(
          _class.reference.pointer,
          _id_new$ as jni$_.JMethodIDPtr,
        ).reference,
      );

  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory UnsupportedEncodingException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return UnsupportedEncodingException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $UnsupportedEncodingException$NullableType
    extends jni$_.JObjType<UnsupportedEncodingException?> {
  @jni$_.internal
  const $UnsupportedEncodingException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/UnsupportedEncodingException;';

  @jni$_.internal
  @core$_.override
  UnsupportedEncodingException? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : UnsupportedEncodingException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UnsupportedEncodingException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UnsupportedEncodingException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($UnsupportedEncodingException$NullableType) &&
      other is $UnsupportedEncodingException$NullableType;
}

final class $UnsupportedEncodingException$Type
    extends jni$_.JObjType<UnsupportedEncodingException> {
  @jni$_.internal
  const $UnsupportedEncodingException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/UnsupportedEncodingException;';

  @jni$_.internal
  @core$_.override
  UnsupportedEncodingException fromReference(jni$_.JReference reference) =>
      UnsupportedEncodingException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UnsupportedEncodingException?> get nullableType =>
      const $UnsupportedEncodingException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UnsupportedEncodingException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($UnsupportedEncodingException$Type) &&
      other is $UnsupportedEncodingException$Type;
}

/// from: `java.io.UTFDataFormatException`
class UTFDataFormatException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<UTFDataFormatException> $type;

  @jni$_.internal
  UTFDataFormatException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/UTFDataFormatException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $UTFDataFormatException$NullableType();
  static const type = $UTFDataFormatException$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory UTFDataFormatException() => UTFDataFormatException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory UTFDataFormatException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return UTFDataFormatException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $UTFDataFormatException$NullableType
    extends jni$_.JObjType<UTFDataFormatException?> {
  @jni$_.internal
  const $UTFDataFormatException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/UTFDataFormatException;';

  @jni$_.internal
  @core$_.override
  UTFDataFormatException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : UTFDataFormatException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UTFDataFormatException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UTFDataFormatException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($UTFDataFormatException$NullableType) &&
      other is $UTFDataFormatException$NullableType;
}

final class $UTFDataFormatException$Type
    extends jni$_.JObjType<UTFDataFormatException> {
  @jni$_.internal
  const $UTFDataFormatException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/UTFDataFormatException;';

  @jni$_.internal
  @core$_.override
  UTFDataFormatException fromReference(jni$_.JReference reference) =>
      UTFDataFormatException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UTFDataFormatException?> get nullableType =>
      const $UTFDataFormatException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UTFDataFormatException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($UTFDataFormatException$Type) &&
      other is $UTFDataFormatException$Type;
}

/// from: `java.io.DataInputStream`
class DataInputStream extends FilterInputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DataInputStream> $type;

  @jni$_.internal
  DataInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/DataInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DataInputStream$NullableType();
  static const type = $DataInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/InputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DataInputStream(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return DataInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
      ).reference,
    );
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'([B)I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final int read(byte[] bs)`
  int read1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read1(
      reference.pointer,
      _id_read1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).integer;
  }

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public final int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_readFully = _class.instanceMethodId(r'readFully', r'([B)V');

  static final _readFully =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void readFully(byte[] bs)`
  void readFully(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully(
      reference.pointer,
      _id_readFully as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_readFully$1 = _class.instanceMethodId(
    r'readFully',
    r'([BII)V',
  );

  static final _readFully$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public final void readFully(byte[] bs, int i, int i1)`
  void readFully$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully$1(
      reference.pointer,
      _id_readFully$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_skipBytes = _class.instanceMethodId(r'skipBytes', r'(I)I');

  static final _skipBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final int skipBytes(int i)`
  int skipBytes(int i) =>
      _skipBytes(
        reference.pointer,
        _id_skipBytes as jni$_.JMethodIDPtr,
        i,
      ).integer;

  static final _id_readBoolean = _class.instanceMethodId(
    r'readBoolean',
    r'()Z',
  );

  static final _readBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean readBoolean()`
  bool readBoolean() =>
      _readBoolean(
        reference.pointer,
        _id_readBoolean as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_readByte = _class.instanceMethodId(r'readByte', r'()B');

  static final _readByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final byte readByte()`
  int readByte() =>
      _readByte(reference.pointer, _id_readByte as jni$_.JMethodIDPtr).byte;

  static final _id_readUnsignedByte = _class.instanceMethodId(
    r'readUnsignedByte',
    r'()I',
  );

  static final _readUnsignedByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int readUnsignedByte()`
  int readUnsignedByte() =>
      _readUnsignedByte(
        reference.pointer,
        _id_readUnsignedByte as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_readShort = _class.instanceMethodId(r'readShort', r'()S');

  static final _readShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final short readShort()`
  int readShort() =>
      _readShort(reference.pointer, _id_readShort as jni$_.JMethodIDPtr).short;

  static final _id_readUnsignedShort = _class.instanceMethodId(
    r'readUnsignedShort',
    r'()I',
  );

  static final _readUnsignedShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int readUnsignedShort()`
  int readUnsignedShort() =>
      _readUnsignedShort(
        reference.pointer,
        _id_readUnsignedShort as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_readChar = _class.instanceMethodId(r'readChar', r'()C');

  static final _readChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final char readChar()`
  int readChar() =>
      _readChar(reference.pointer, _id_readChar as jni$_.JMethodIDPtr).char;

  static final _id_readInt = _class.instanceMethodId(r'readInt', r'()I');

  static final _readInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int readInt()`
  int readInt() =>
      _readInt(reference.pointer, _id_readInt as jni$_.JMethodIDPtr).integer;

  static final _id_readLong = _class.instanceMethodId(r'readLong', r'()J');

  static final _readLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long readLong()`
  int readLong() =>
      _readLong(reference.pointer, _id_readLong as jni$_.JMethodIDPtr).long;

  static final _id_readFloat = _class.instanceMethodId(r'readFloat', r'()F');

  static final _readFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final float readFloat()`
  double readFloat() =>
      _readFloat(reference.pointer, _id_readFloat as jni$_.JMethodIDPtr).float;

  static final _id_readDouble = _class.instanceMethodId(r'readDouble', r'()D');

  static final _readDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final double readDouble()`
  double readDouble() =>
      _readDouble(
        reference.pointer,
        _id_readDouble as jni$_.JMethodIDPtr,
      ).doubleFloat;

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine() => _readLine(
    reference.pointer,
    _id_readLine as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_readUTF = _class.instanceMethodId(
    r'readUTF',
    r'()Ljava/lang/String;',
  );

  static final _readUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String readUTF()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readUTF() => _readUTF(
    reference.pointer,
    _id_readUTF as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_readUTF$1 = _class.staticMethodId(
    r'readUTF',
    r'(Ljava/io/DataInput;)Ljava/lang/String;',
  );

  static final _readUTF$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public final java.lang.String readUTF(java.io.DataInput dataInput)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? readUTF$1(DataInput? dataInput) {
    final _$dataInput = dataInput?.reference ?? jni$_.jNullReference;
    return _readUTF$1(
      _class.reference.pointer,
      _id_readUTF$1 as jni$_.JMethodIDPtr,
      _$dataInput.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $DataInputStream$NullableType
    extends jni$_.JObjType<DataInputStream?> {
  @jni$_.internal
  const $DataInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataInputStream;';

  @jni$_.internal
  @core$_.override
  DataInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DataInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($DataInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DataInputStream$NullableType) &&
      other is $DataInputStream$NullableType;
}

final class $DataInputStream$Type extends jni$_.JObjType<DataInputStream> {
  @jni$_.internal
  const $DataInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataInputStream;';

  @jni$_.internal
  @core$_.override
  DataInputStream fromReference(jni$_.JReference reference) =>
      DataInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataInputStream?> get nullableType =>
      const $DataInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($DataInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DataInputStream$Type) &&
      other is $DataInputStream$Type;
}

/// from: `java.io.ObjectStreamClass`
class ObjectStreamClass extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectStreamClass> $type;

  @jni$_.internal
  ObjectStreamClass.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectStreamClass');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectStreamClass$NullableType();
  static const type = $ObjectStreamClass$Type();
  static final _id_NO_FIELDS = _class.staticFieldId(
    r'NO_FIELDS',
    r'[Ljava/io/ObjectStreamField;',
  );

  /// from: `static public final java.io.ObjectStreamField[] NO_FIELDS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<ObjectStreamField?>? get NO_FIELDS => _id_NO_FIELDS.get(
    _class,
    const jni$_.JArrayNullableType<ObjectStreamField?>(
      $ObjectStreamField$NullableType(),
    ),
  );

  static final _id_lookup = _class.staticMethodId(
    r'lookup',
    r'(Ljava/lang/Class;)Ljava/io/ObjectStreamClass;',
  );

  static final _lookup =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectStreamClass lookup(java.lang.Class<?> class)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectStreamClass? lookup(jni$_.JObject? class$) {
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    return _lookup(
      _class.reference.pointer,
      _id_lookup as jni$_.JMethodIDPtr,
      _$class$.pointer,
    ).object<ObjectStreamClass?>(const $ObjectStreamClass$NullableType());
  }

  static final _id_lookupAny = _class.staticMethodId(
    r'lookupAny',
    r'(Ljava/lang/Class;)Ljava/io/ObjectStreamClass;',
  );

  static final _lookupAny =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectStreamClass lookupAny(java.lang.Class<?> class)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectStreamClass? lookupAny(jni$_.JObject? class$) {
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    return _lookupAny(
      _class.reference.pointer,
      _id_lookupAny as jni$_.JMethodIDPtr,
      _$class$.pointer,
    ).object<ObjectStreamClass?>(const $ObjectStreamClass$NullableType());
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() => _getName(
    reference.pointer,
    _id_getName as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getSerialVersionUID = _class.instanceMethodId(
    r'getSerialVersionUID',
    r'()J',
  );

  static final _getSerialVersionUID =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getSerialVersionUID()`
  int getSerialVersionUID() =>
      _getSerialVersionUID(
        reference.pointer,
        _id_getSerialVersionUID as jni$_.JMethodIDPtr,
      ).long;

  static final _id_forClass = _class.instanceMethodId(
    r'forClass',
    r'()Ljava/lang/Class;',
  );

  static final _forClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Class<?> forClass()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? forClass() => _forClass(
    reference.pointer,
    _id_forClass as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getFields = _class.instanceMethodId(
    r'getFields',
    r'()[Ljava/io/ObjectStreamField;',
  );

  static final _getFields =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.ObjectStreamField[] getFields()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<ObjectStreamField?>? getFields() => _getFields(
    reference.pointer,
    _id_getFields as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<ObjectStreamField?>?>(
    const jni$_.JArrayNullableType<ObjectStreamField?>(
      $ObjectStreamField$NullableType(),
    ),
  );

  static final _id_getField = _class.instanceMethodId(
    r'getField',
    r'(Ljava/lang/String;)Ljava/io/ObjectStreamField;',
  );

  static final _getField =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.ObjectStreamField getField(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  ObjectStreamField? getField(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getField(
      reference.pointer,
      _id_getField as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<ObjectStreamField?>(const $ObjectStreamField$NullableType());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $ObjectStreamClass$NullableType
    extends jni$_.JObjType<ObjectStreamClass?> {
  @jni$_.internal
  const $ObjectStreamClass$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamClass;';

  @jni$_.internal
  @core$_.override
  ObjectStreamClass? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectStreamClass.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamClass?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectStreamClass$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectStreamClass$NullableType) &&
      other is $ObjectStreamClass$NullableType;
}

final class $ObjectStreamClass$Type extends jni$_.JObjType<ObjectStreamClass> {
  @jni$_.internal
  const $ObjectStreamClass$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamClass;';

  @jni$_.internal
  @core$_.override
  ObjectStreamClass fromReference(jni$_.JReference reference) =>
      ObjectStreamClass.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamClass?> get nullableType =>
      const $ObjectStreamClass$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectStreamClass$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectStreamClass$Type) &&
      other is $ObjectStreamClass$Type;
}

/// from: `java.io.StringBufferInputStream`
class StringBufferInputStream extends InputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StringBufferInputStream> $type;

  @jni$_.internal
  StringBufferInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/StringBufferInputStream',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StringBufferInputStream$NullableType();
  static const type = $StringBufferInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringBufferInputStream(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return StringBufferInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() =>
      _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() =>
      _available(
        reference.pointer,
        _id_available as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }
}

final class $StringBufferInputStream$NullableType
    extends jni$_.JObjType<StringBufferInputStream?> {
  @jni$_.internal
  const $StringBufferInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StringBufferInputStream;';

  @jni$_.internal
  @core$_.override
  StringBufferInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : StringBufferInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringBufferInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($StringBufferInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StringBufferInputStream$NullableType) &&
      other is $StringBufferInputStream$NullableType;
}

final class $StringBufferInputStream$Type
    extends jni$_.JObjType<StringBufferInputStream> {
  @jni$_.internal
  const $StringBufferInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StringBufferInputStream;';

  @jni$_.internal
  @core$_.override
  StringBufferInputStream fromReference(jni$_.JReference reference) =>
      StringBufferInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringBufferInputStream?> get nullableType =>
      const $StringBufferInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($StringBufferInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StringBufferInputStream$Type) &&
      other is $StringBufferInputStream$Type;
}

/// from: `java.io.InvalidClassException`
class InvalidClassException extends ObjectStreamException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InvalidClassException> $type;

  @jni$_.internal
  InvalidClassException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/InvalidClassException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InvalidClassException$NullableType();
  static const type = $InvalidClassException$Type();
  static final _id_classname = _class.instanceFieldId(
    r'classname',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String classname`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get classname =>
      _id_classname.get(this, const jni$_.JStringNullableType());

  /// from: `public java.lang.String classname`
  /// The returned object must be released after use, by calling the [release] method.
  set classname(jni$_.JString? value) =>
      _id_classname.set(this, const jni$_.JStringNullableType(), value);

  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InvalidClassException.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return InvalidClassException.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InvalidClassException.new$5(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return InvalidClassException.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_getMessage = _class.instanceMethodId(
    r'getMessage',
    r'()Ljava/lang/String;',
  );

  static final _getMessage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getMessage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getMessage() => _getMessage(
    reference.pointer,
    _id_getMessage as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $InvalidClassException$NullableType
    extends jni$_.JObjType<InvalidClassException?> {
  @jni$_.internal
  const $InvalidClassException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InvalidClassException;';

  @jni$_.internal
  @core$_.override
  InvalidClassException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InvalidClassException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InvalidClassException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($InvalidClassException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InvalidClassException$NullableType) &&
      other is $InvalidClassException$NullableType;
}

final class $InvalidClassException$Type
    extends jni$_.JObjType<InvalidClassException> {
  @jni$_.internal
  const $InvalidClassException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InvalidClassException;';

  @jni$_.internal
  @core$_.override
  InvalidClassException fromReference(jni$_.JReference reference) =>
      InvalidClassException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InvalidClassException?> get nullableType =>
      const $InvalidClassException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($InvalidClassException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InvalidClassException$Type) &&
      other is $InvalidClassException$Type;
}

/// from: `java.io.SerializablePermission`
class SerializablePermission extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SerializablePermission> $type;

  @jni$_.internal
  SerializablePermission.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/SerializablePermission');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SerializablePermission$NullableType();
  static const type = $SerializablePermission$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SerializablePermission(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return SerializablePermission.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SerializablePermission.new$1(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return SerializablePermission.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }
}

final class $SerializablePermission$NullableType
    extends jni$_.JObjType<SerializablePermission?> {
  @jni$_.internal
  const $SerializablePermission$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/SerializablePermission;';

  @jni$_.internal
  @core$_.override
  SerializablePermission? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SerializablePermission.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SerializablePermission?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SerializablePermission$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SerializablePermission$NullableType) &&
      other is $SerializablePermission$NullableType;
}

final class $SerializablePermission$Type
    extends jni$_.JObjType<SerializablePermission> {
  @jni$_.internal
  const $SerializablePermission$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/SerializablePermission;';

  @jni$_.internal
  @core$_.override
  SerializablePermission fromReference(jni$_.JReference reference) =>
      SerializablePermission.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SerializablePermission?> get nullableType =>
      const $SerializablePermission$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SerializablePermission$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SerializablePermission$Type) &&
      other is $SerializablePermission$Type;
}

/// from: `java.io.FilterInputStream`
class FilterInputStream extends InputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FilterInputStream> $type;

  @jni$_.internal
  FilterInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FilterInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FilterInputStream$NullableType();
  static const type = $FilterInputStream$Type();
  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() =>
      _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;

  static final _id_read1 = _class.instanceMethodId(r'read', r'([B)I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(byte[] bs)`
  int read1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read1(
      reference.pointer,
      _id_read1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).integer;
  }

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() =>
      _available(
        reference.pointer,
        _id_available as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() =>
      _markSupported(
        reference.pointer,
        _id_markSupported as jni$_.JMethodIDPtr,
      ).boolean;
}

final class $FilterInputStream$NullableType
    extends jni$_.JObjType<FilterInputStream?> {
  @jni$_.internal
  const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterInputStream;';

  @jni$_.internal
  @core$_.override
  FilterInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FilterInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FilterInputStream$NullableType) &&
      other is $FilterInputStream$NullableType;
}

final class $FilterInputStream$Type extends jni$_.JObjType<FilterInputStream> {
  @jni$_.internal
  const $FilterInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterInputStream;';

  @jni$_.internal
  @core$_.override
  FilterInputStream fromReference(jni$_.JReference reference) =>
      FilterInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterInputStream?> get nullableType =>
      const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FilterInputStream$Type) &&
      other is $FilterInputStream$Type;
}

/// from: `java.io.OutputStreamWriter`
class OutputStreamWriter extends Writer {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OutputStreamWriter> $type;

  @jni$_.internal
  OutputStreamWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/OutputStreamWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OutputStreamWriter$NullableType();
  static const type = $OutputStreamWriter$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/io/OutputStream;Ljava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory OutputStreamWriter(
    OutputStream? outputStream,
    jni$_.JString? string,
  ) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return OutputStreamWriter.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory OutputStreamWriter.new$1(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return OutputStreamWriter.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/io/OutputStream;Ljava/nio/charset/Charset;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory OutputStreamWriter.new$2(
    OutputStream? outputStream,
    jni$_.JObject? charset,
  ) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return OutputStreamWriter.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/io/OutputStream;Ljava/nio/charset/CharsetEncoder;)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, java.nio.charset.CharsetEncoder charsetEncoder)`
  /// The returned object must be released after use, by calling the [release] method.
  factory OutputStreamWriter.new$3(
    OutputStream? outputStream,
    jni$_.JObject? charsetEncoder,
  ) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    final _$charsetEncoder = charsetEncoder?.reference ?? jni$_.jNullReference;
    return OutputStreamWriter.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        _$charsetEncoder.pointer,
      ).reference,
    );
  }

  static final _id_getEncoding = _class.instanceMethodId(
    r'getEncoding',
    r'()Ljava/lang/String;',
  );

  static final _getEncoding =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getEncoding()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getEncoding() => _getEncoding(
    reference.pointer,
    _id_getEncoding as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(char[] cs, int i, int i1)`
  void write2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write4 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;II)V',
  );

  static final _write4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(java.lang.String string, int i, int i1)`
  void write4(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write4(
      reference.pointer,
      _id_write4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_append1 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;II)Ljava/io/Writer;',
  );

  static final _append1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public java.io.Writer append(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  Writer? append1(jni$_.JObject? charSequence, int i, int i1) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append1(
      reference.pointer,
      _id_append1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
    ).object<Writer?>(const $Writer$NullableType());
  }

  static final _id_append = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;)Ljava/io/Writer;',
  );

  static final _append =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.Writer append(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  Writer? append(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append(
      reference.pointer,
      _id_append as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<Writer?>(const $Writer$NullableType());
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $OutputStreamWriter$NullableType
    extends jni$_.JObjType<OutputStreamWriter?> {
  @jni$_.internal
  const $OutputStreamWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/OutputStreamWriter;';

  @jni$_.internal
  @core$_.override
  OutputStreamWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : OutputStreamWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OutputStreamWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($OutputStreamWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($OutputStreamWriter$NullableType) &&
      other is $OutputStreamWriter$NullableType;
}

final class $OutputStreamWriter$Type
    extends jni$_.JObjType<OutputStreamWriter> {
  @jni$_.internal
  const $OutputStreamWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/OutputStreamWriter;';

  @jni$_.internal
  @core$_.override
  OutputStreamWriter fromReference(jni$_.JReference reference) =>
      OutputStreamWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OutputStreamWriter?> get nullableType =>
      const $OutputStreamWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($OutputStreamWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($OutputStreamWriter$Type) &&
      other is $OutputStreamWriter$Type;
}

/// from: `java.io.NotActiveException`
class NotActiveException extends ObjectStreamException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NotActiveException> $type;

  @jni$_.internal
  NotActiveException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/NotActiveException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NotActiveException$NullableType();
  static const type = $NotActiveException$Type();
  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NotActiveException.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return NotActiveException.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'()V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NotActiveException.new$5() => NotActiveException.fromReference(
    _new$5(_class.reference.pointer, _id_new$5 as jni$_.JMethodIDPtr).reference,
  );
}

final class $NotActiveException$NullableType
    extends jni$_.JObjType<NotActiveException?> {
  @jni$_.internal
  const $NotActiveException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/NotActiveException;';

  @jni$_.internal
  @core$_.override
  NotActiveException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NotActiveException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NotActiveException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($NotActiveException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NotActiveException$NullableType) &&
      other is $NotActiveException$NullableType;
}

final class $NotActiveException$Type
    extends jni$_.JObjType<NotActiveException> {
  @jni$_.internal
  const $NotActiveException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/NotActiveException;';

  @jni$_.internal
  @core$_.override
  NotActiveException fromReference(jni$_.JReference reference) =>
      NotActiveException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NotActiveException?> get nullableType =>
      const $NotActiveException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($NotActiveException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NotActiveException$Type) &&
      other is $NotActiveException$Type;
}

/// from: `java.io.OutputStream`
class OutputStream extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OutputStream> $type;

  @jni$_.internal
  OutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/OutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OutputStream$NullableType();
  static const type = $OutputStream$Type();
  static final _id_nullOutputStream = _class.staticMethodId(
    r'nullOutputStream',
    r'()Ljava/io/OutputStream;',
  );

  static final _nullOutputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.OutputStream nullOutputStream()`
  /// The returned object must be released after use, by calling the [release] method.
  static OutputStream? nullOutputStream() => _nullOutputStream(
    _class.reference.pointer,
    _id_nullOutputStream as jni$_.JMethodIDPtr,
  ).object<OutputStream?>(const $OutputStream$NullableType());

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write$1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(byte[] bs)`
  void write$1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$1(
      reference.pointer,
      _id_write$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_write$2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write$2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$2(
      reference.pointer,
      _id_write$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $OutputStream$NullableType extends jni$_.JObjType<OutputStream?> {
  @jni$_.internal
  const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/OutputStream;';

  @jni$_.internal
  @core$_.override
  OutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : OutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($OutputStream$NullableType) &&
      other is $OutputStream$NullableType;
}

final class $OutputStream$Type extends jni$_.JObjType<OutputStream> {
  @jni$_.internal
  const $OutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/OutputStream;';

  @jni$_.internal
  @core$_.override
  OutputStream fromReference(jni$_.JReference reference) =>
      OutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OutputStream?> get nullableType =>
      const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($OutputStream$Type) && other is $OutputStream$Type;
}

/// from: `java.io.PrintStream`
class PrintStream extends FilterOutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PrintStream> $type;

  @jni$_.internal
  PrintStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PrintStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PrintStream$NullableType();
  static const type = $PrintStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/OutputStream;Z)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$1(OutputStream? outputStream, bool z) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/io/OutputStream;ZLjava/lang/String;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, boolean z, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$2(
    OutputStream? outputStream,
    bool z,
    jni$_.JString? string,
  ) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        z ? 1 : 0,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/io/OutputStream;ZLjava/nio/charset/Charset;)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, boolean z, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$3(
    OutputStream? outputStream,
    bool z,
    jni$_.JObject? charset,
  ) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        z ? 1 : 0,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$5(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_new$6 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;)V',
  );

  static final _new$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$6(jni$_.JString? string, jni$_.JObject? charset) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$6(
        _class.reference.pointer,
        _id_new$6 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$7 = _class.constructorId(r'(Ljava/io/File;)V');

  static final _new$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$7(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$7(
        _class.reference.pointer,
        _id_new$7 as jni$_.JMethodIDPtr,
        _$file.pointer,
      ).reference,
    );
  }

  static final _id_new$8 = _class.constructorId(
    r'(Ljava/io/File;Ljava/lang/String;)V',
  );

  static final _new$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$8(File? file, jni$_.JString? string) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$8(
        _class.reference.pointer,
        _id_new$8 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$9 = _class.constructorId(
    r'(Ljava/io/File;Ljava/nio/charset/Charset;)V',
  );

  static final _new$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$9(File? file, jni$_.JObject? charset) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$9(
        _class.reference.pointer,
        _id_new$9 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_checkError = _class.instanceMethodId(r'checkError', r'()Z');

  static final _checkError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean checkError()`
  bool checkError() =>
      _checkError(
        reference.pointer,
        _id_checkError as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(byte[] bs)`
  void write1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write1(
      reference.pointer,
      _id_write1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'([B)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeBytes(byte[] bs)`
  void writeBytes(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_print = _class.instanceMethodId(r'print', r'(Z)V');

  static final _print =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(boolean z)`
  void print(bool z) {
    _print(
      reference.pointer,
      _id_print as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_print$1 = _class.instanceMethodId(r'print', r'(C)V');

  static final _print$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(char c)`
  void print$1(int c) {
    _print$1(reference.pointer, _id_print$1 as jni$_.JMethodIDPtr, c).check();
  }

  static final _id_print$2 = _class.instanceMethodId(r'print', r'(I)V');

  static final _print$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(int i)`
  void print$2(int i) {
    _print$2(reference.pointer, _id_print$2 as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_print$3 = _class.instanceMethodId(r'print', r'(J)V');

  static final _print$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(long j)`
  void print$3(int j) {
    _print$3(reference.pointer, _id_print$3 as jni$_.JMethodIDPtr, j).check();
  }

  static final _id_print$4 = _class.instanceMethodId(r'print', r'(F)V');

  static final _print$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void print(float f)`
  void print$4(double f) {
    _print$4(reference.pointer, _id_print$4 as jni$_.JMethodIDPtr, f).check();
  }

  static final _id_print$5 = _class.instanceMethodId(r'print', r'(D)V');

  static final _print$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void print(double d)`
  void print$5(double d) {
    _print$5(reference.pointer, _id_print$5 as jni$_.JMethodIDPtr, d).check();
  }

  static final _id_print$6 = _class.instanceMethodId(r'print', r'([C)V');

  static final _print$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void print(char[] cs)`
  void print$6(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _print$6(
      reference.pointer,
      _id_print$6 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).check();
  }

  static final _id_print$7 = _class.instanceMethodId(
    r'print',
    r'(Ljava/lang/String;)V',
  );

  static final _print$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void print(java.lang.String string)`
  void print$7(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _print$7(
      reference.pointer,
      _id_print$7 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_print$8 = _class.instanceMethodId(
    r'print',
    r'(Ljava/lang/Object;)V',
  );

  static final _print$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void print(java.lang.Object object)`
  void print$8(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _print$8(
      reference.pointer,
      _id_print$8 as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_println = _class.instanceMethodId(r'println', r'()V');

  static final _println =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void println()`
  void println() {
    _println(reference.pointer, _id_println as jni$_.JMethodIDPtr).check();
  }

  static final _id_println$1 = _class.instanceMethodId(r'println', r'(Z)V');

  static final _println$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(boolean z)`
  void println$1(bool z) {
    _println$1(
      reference.pointer,
      _id_println$1 as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_println$2 = _class.instanceMethodId(r'println', r'(C)V');

  static final _println$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(char c)`
  void println$2(int c) {
    _println$2(
      reference.pointer,
      _id_println$2 as jni$_.JMethodIDPtr,
      c,
    ).check();
  }

  static final _id_println$3 = _class.instanceMethodId(r'println', r'(I)V');

  static final _println$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(int i)`
  void println$3(int i) {
    _println$3(
      reference.pointer,
      _id_println$3 as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_println$4 = _class.instanceMethodId(r'println', r'(J)V');

  static final _println$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(long j)`
  void println$4(int j) {
    _println$4(
      reference.pointer,
      _id_println$4 as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_println$5 = _class.instanceMethodId(r'println', r'(F)V');

  static final _println$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void println(float f)`
  void println$5(double f) {
    _println$5(
      reference.pointer,
      _id_println$5 as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_println$6 = _class.instanceMethodId(r'println', r'(D)V');

  static final _println$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void println(double d)`
  void println$6(double d) {
    _println$6(
      reference.pointer,
      _id_println$6 as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_println$7 = _class.instanceMethodId(r'println', r'([C)V');

  static final _println$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void println(char[] cs)`
  void println$7(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _println$7(
      reference.pointer,
      _id_println$7 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).check();
  }

  static final _id_println$8 = _class.instanceMethodId(
    r'println',
    r'(Ljava/lang/String;)V',
  );

  static final _println$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void println(java.lang.String string)`
  void println$8(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _println$8(
      reference.pointer,
      _id_println$8 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_println$9 = _class.instanceMethodId(
    r'println',
    r'(Ljava/lang/Object;)V',
  );

  static final _println$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void println(java.lang.Object object)`
  void println$9(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _println$9(
      reference.pointer,
      _id_println$9 as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_printf = _class.instanceMethodId(
    r'printf',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;',
  );

  static final _printf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintStream printf(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintStream? printf(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _printf(
      reference.pointer,
      _id_printf as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintStream?>(const $PrintStream$NullableType());
  }

  static final _id_printf$1 = _class.instanceMethodId(
    r'printf',
    r'(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;',
  );

  static final _printf$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintStream printf(java.util.Locale locale, java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintStream? printf$1(
    jni$_.JObject? locale,
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _printf$1(
      reference.pointer,
      _id_printf$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintStream?>(const $PrintStream$NullableType());
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintStream format(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintStream? format(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintStream?>(const $PrintStream$NullableType());
  }

  static final _id_format$1 = _class.instanceMethodId(
    r'format',
    r'(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;',
  );

  static final _format$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintStream format(java.util.Locale locale, java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintStream? format$1(
    jni$_.JObject? locale,
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _format$1(
      reference.pointer,
      _id_format$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintStream?>(const $PrintStream$NullableType());
  }

  static final _id_append = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;)Ljava/io/PrintStream;',
  );

  static final _append =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintStream append(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintStream? append(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append(
      reference.pointer,
      _id_append as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<PrintStream?>(const $PrintStream$NullableType());
  }

  static final _id_append$1 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;II)Ljava/io/PrintStream;',
  );

  static final _append$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public java.io.PrintStream append(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintStream? append$1(jni$_.JObject? charSequence, int i, int i1) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$1(
      reference.pointer,
      _id_append$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
    ).object<PrintStream?>(const $PrintStream$NullableType());
  }

  static final _id_append$2 = _class.instanceMethodId(
    r'append',
    r'(C)Ljava/io/PrintStream;',
  );

  static final _append$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.io.PrintStream append(char c)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintStream? append$2(int c) => _append$2(
    reference.pointer,
    _id_append$2 as jni$_.JMethodIDPtr,
    c,
  ).object<PrintStream?>(const $PrintStream$NullableType());
}

final class $PrintStream$NullableType extends jni$_.JObjType<PrintStream?> {
  @jni$_.internal
  const $PrintStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PrintStream;';

  @jni$_.internal
  @core$_.override
  PrintStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PrintStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PrintStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($PrintStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PrintStream$NullableType) &&
      other is $PrintStream$NullableType;
}

final class $PrintStream$Type extends jni$_.JObjType<PrintStream> {
  @jni$_.internal
  const $PrintStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PrintStream;';

  @jni$_.internal
  @core$_.override
  PrintStream fromReference(jni$_.JReference reference) =>
      PrintStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PrintStream?> get nullableType =>
      const $PrintStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($PrintStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PrintStream$Type) && other is $PrintStream$Type;
}

/// from: `java.io.SequenceInputStream`
class SequenceInputStream extends InputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SequenceInputStream> $type;

  @jni$_.internal
  SequenceInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/SequenceInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SequenceInputStream$NullableType();
  static const type = $SequenceInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/util/Enumeration;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.util.Enumeration<? extends java.io.InputStream> enumeration)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SequenceInputStream(jni$_.JObject? enumeration) {
    final _$enumeration = enumeration?.reference ?? jni$_.jNullReference;
    return SequenceInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$enumeration.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/io/InputStream;Ljava/io/InputStream;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream, java.io.InputStream inputStream1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SequenceInputStream.new$1(
    InputStream? inputStream,
    InputStream? inputStream1,
  ) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    final _$inputStream1 = inputStream1?.reference ?? jni$_.jNullReference;
    return SequenceInputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
        _$inputStream1.pointer,
      ).reference,
    );
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() =>
      _available(
        reference.pointer,
        _id_available as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() =>
      _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $SequenceInputStream$NullableType
    extends jni$_.JObjType<SequenceInputStream?> {
  @jni$_.internal
  const $SequenceInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/SequenceInputStream;';

  @jni$_.internal
  @core$_.override
  SequenceInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SequenceInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SequenceInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SequenceInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SequenceInputStream$NullableType) &&
      other is $SequenceInputStream$NullableType;
}

final class $SequenceInputStream$Type
    extends jni$_.JObjType<SequenceInputStream> {
  @jni$_.internal
  const $SequenceInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/SequenceInputStream;';

  @jni$_.internal
  @core$_.override
  SequenceInputStream fromReference(jni$_.JReference reference) =>
      SequenceInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SequenceInputStream?> get nullableType =>
      const $SequenceInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SequenceInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SequenceInputStream$Type) &&
      other is $SequenceInputStream$Type;
}

/// from: `java.io.FilterWriter`
class FilterWriter extends Writer {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FilterWriter> $type;

  @jni$_.internal
  FilterWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FilterWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FilterWriter$NullableType();
  static const type = $FilterWriter$Type();
  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(char[] cs, int i, int i1)`
  void write2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write4 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;II)V',
  );

  static final _write4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(java.lang.String string, int i, int i1)`
  void write4(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write4(
      reference.pointer,
      _id_write4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $FilterWriter$NullableType extends jni$_.JObjType<FilterWriter?> {
  @jni$_.internal
  const $FilterWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterWriter;';

  @jni$_.internal
  @core$_.override
  FilterWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FilterWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FilterWriter$NullableType) &&
      other is $FilterWriter$NullableType;
}

final class $FilterWriter$Type extends jni$_.JObjType<FilterWriter> {
  @jni$_.internal
  const $FilterWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterWriter;';

  @jni$_.internal
  @core$_.override
  FilterWriter fromReference(jni$_.JReference reference) =>
      FilterWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterWriter?> get nullableType =>
      const $FilterWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FilterWriter$Type) && other is $FilterWriter$Type;
}

/// from: `java.io.FileWriter`
class FileWriter extends OutputStreamWriter {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileWriter> $type;

  @jni$_.internal
  FileWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FileWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileWriter$NullableType();
  static const type = $FileWriter$Type();
  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'(Ljava/lang/String;Z)V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$5(jni$_.JString? string, bool z) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$string.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$6 = _class.constructorId(r'(Ljava/io/File;)V');

  static final _new$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$6(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$6(
        _class.reference.pointer,
        _id_new$6 as jni$_.JMethodIDPtr,
        _$file.pointer,
      ).reference,
    );
  }

  static final _id_new$7 = _class.constructorId(r'(Ljava/io/File;Z)V');

  static final _new$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.File file, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$7(File? file, bool z) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$7(
        _class.reference.pointer,
        _id_new$7 as jni$_.JMethodIDPtr,
        _$file.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$8 = _class.constructorId(r'(Ljava/io/FileDescriptor;)V');

  static final _new$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.FileDescriptor fileDescriptor)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$8(FileDescriptor? fileDescriptor) {
    final _$fileDescriptor = fileDescriptor?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$8(
        _class.reference.pointer,
        _id_new$8 as jni$_.JMethodIDPtr,
        _$fileDescriptor.pointer,
      ).reference,
    );
  }

  static final _id_new$9 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;)V',
  );

  static final _new$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$9(jni$_.JString? string, jni$_.JObject? charset) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$9(
        _class.reference.pointer,
        _id_new$9 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$10 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;Z)V',
  );

  static final _new$10 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.nio.charset.Charset charset, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$10(
    jni$_.JString? string,
    jni$_.JObject? charset,
    bool z,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$10(
        _class.reference.pointer,
        _id_new$10 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$charset.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$11 = _class.constructorId(
    r'(Ljava/io/File;Ljava/nio/charset/Charset;)V',
  );

  static final _new$11 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$11(File? file, jni$_.JObject? charset) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$11(
        _class.reference.pointer,
        _id_new$11 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$12 = _class.constructorId(
    r'(Ljava/io/File;Ljava/nio/charset/Charset;Z)V',
  );

  static final _new$12 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.nio.charset.Charset charset, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$12(File? file, jni$_.JObject? charset, bool z) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$12(
        _class.reference.pointer,
        _id_new$12 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$charset.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }
}

final class $FileWriter$NullableType extends jni$_.JObjType<FileWriter?> {
  @jni$_.internal
  const $FileWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileWriter;';

  @jni$_.internal
  @core$_.override
  FileWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStreamWriter$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($FileWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileWriter$NullableType) &&
      other is $FileWriter$NullableType;
}

final class $FileWriter$Type extends jni$_.JObjType<FileWriter> {
  @jni$_.internal
  const $FileWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileWriter;';

  @jni$_.internal
  @core$_.override
  FileWriter fromReference(jni$_.JReference reference) =>
      FileWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStreamWriter$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileWriter?> get nullableType =>
      const $FileWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($FileWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileWriter$Type) && other is $FileWriter$Type;
}

/// from: `java.io.OptionalDataException`
class OptionalDataException extends ObjectStreamException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OptionalDataException> $type;

  @jni$_.internal
  OptionalDataException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/OptionalDataException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OptionalDataException$NullableType();
  static const type = $OptionalDataException$Type();
  static final _id_length = _class.instanceFieldId(r'length', r'I');

  /// from: `public int length`
  int get length => _id_length.get(this, const jni$_.jintType());

  /// from: `public int length`
  set length(int value) => _id_length.set(this, const jni$_.jintType(), value);

  static final _id_eof = _class.instanceFieldId(r'eof', r'Z');

  /// from: `public boolean eof`
  bool get eof => _id_eof.get(this, const jni$_.jbooleanType());

  /// from: `public boolean eof`
  set eof(bool value) => _id_eof.set(this, const jni$_.jbooleanType(), value);
}

final class $OptionalDataException$NullableType
    extends jni$_.JObjType<OptionalDataException?> {
  @jni$_.internal
  const $OptionalDataException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/OptionalDataException;';

  @jni$_.internal
  @core$_.override
  OptionalDataException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : OptionalDataException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OptionalDataException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($OptionalDataException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($OptionalDataException$NullableType) &&
      other is $OptionalDataException$NullableType;
}

final class $OptionalDataException$Type
    extends jni$_.JObjType<OptionalDataException> {
  @jni$_.internal
  const $OptionalDataException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/OptionalDataException;';

  @jni$_.internal
  @core$_.override
  OptionalDataException fromReference(jni$_.JReference reference) =>
      OptionalDataException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OptionalDataException?> get nullableType =>
      const $OptionalDataException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($OptionalDataException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($OptionalDataException$Type) &&
      other is $OptionalDataException$Type;
}

/// from: `java.io.FileInputStream`
class FileInputStream extends InputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileInputStream> $type;

  @jni$_.internal
  FileInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FileInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileInputStream$NullableType();
  static const type = $FileInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileInputStream(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return FileInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/File;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileInputStream.new$1(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return FileInputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$file.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Ljava/io/FileDescriptor;)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.FileDescriptor fileDescriptor)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileInputStream.new$2(FileDescriptor? fileDescriptor) {
    final _$fileDescriptor = fileDescriptor?.reference ?? jni$_.jNullReference;
    return FileInputStream.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$fileDescriptor.pointer,
      ).reference,
    );
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() =>
      _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;

  static final _id_read1 = _class.instanceMethodId(r'read', r'([B)I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(byte[] bs)`
  int read1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read1(
      reference.pointer,
      _id_read1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).integer;
  }

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_readAllBytes = _class.instanceMethodId(
    r'readAllBytes',
    r'()[B',
  );

  static final _readAllBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] readAllBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? readAllBytes() => _readAllBytes(
    reference.pointer,
    _id_readAllBytes as jni$_.JMethodIDPtr,
  ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());

  static final _id_readNBytes = _class.instanceMethodId(
    r'readNBytes',
    r'(I)[B',
  );

  static final _readNBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public byte[] readNBytes(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? readNBytes(int i) => _readNBytes(
    reference.pointer,
    _id_readNBytes as jni$_.JMethodIDPtr,
    i,
  ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() =>
      _available(
        reference.pointer,
        _id_available as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_getFD = _class.instanceMethodId(
    r'getFD',
    r'()Ljava/io/FileDescriptor;',
  );

  static final _getFD =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.io.FileDescriptor getFD()`
  /// The returned object must be released after use, by calling the [release] method.
  FileDescriptor? getFD() => _getFD(
    reference.pointer,
    _id_getFD as jni$_.JMethodIDPtr,
  ).object<FileDescriptor?>(const $FileDescriptor$NullableType());

  static final _id_getChannel = _class.instanceMethodId(
    r'getChannel',
    r'()Ljava/nio/channels/FileChannel;',
  );

  static final _getChannel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.channels.FileChannel getChannel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChannel() => _getChannel(
    reference.pointer,
    _id_getChannel as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
}

final class $FileInputStream$NullableType
    extends jni$_.JObjType<FileInputStream?> {
  @jni$_.internal
  const $FileInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileInputStream;';

  @jni$_.internal
  @core$_.override
  FileInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FileInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileInputStream$NullableType) &&
      other is $FileInputStream$NullableType;
}

final class $FileInputStream$Type extends jni$_.JObjType<FileInputStream> {
  @jni$_.internal
  const $FileInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileInputStream;';

  @jni$_.internal
  @core$_.override
  FileInputStream fromReference(jni$_.JReference reference) =>
      FileInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileInputStream?> get nullableType =>
      const $FileInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FileInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileInputStream$Type) &&
      other is $FileInputStream$Type;
}

/// from: `java.io.NotSerializableException`
class NotSerializableException extends ObjectStreamException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NotSerializableException> $type;

  @jni$_.internal
  NotSerializableException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/NotSerializableException',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NotSerializableException$NullableType();
  static const type = $NotSerializableException$Type();
  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NotSerializableException.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return NotSerializableException.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'()V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NotSerializableException.new$5() =>
      NotSerializableException.fromReference(
        _new$5(
          _class.reference.pointer,
          _id_new$5 as jni$_.JMethodIDPtr,
        ).reference,
      );
}

final class $NotSerializableException$NullableType
    extends jni$_.JObjType<NotSerializableException?> {
  @jni$_.internal
  const $NotSerializableException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/NotSerializableException;';

  @jni$_.internal
  @core$_.override
  NotSerializableException? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NotSerializableException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NotSerializableException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($NotSerializableException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NotSerializableException$NullableType) &&
      other is $NotSerializableException$NullableType;
}

final class $NotSerializableException$Type
    extends jni$_.JObjType<NotSerializableException> {
  @jni$_.internal
  const $NotSerializableException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/NotSerializableException;';

  @jni$_.internal
  @core$_.override
  NotSerializableException fromReference(jni$_.JReference reference) =>
      NotSerializableException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NotSerializableException?> get nullableType =>
      const $NotSerializableException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($NotSerializableException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NotSerializableException$Type) &&
      other is $NotSerializableException$Type;
}

/// from: `java.io.Closeable`
class Closeable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Closeable> $type;

  @jni$_.internal
  Closeable.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Closeable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Closeable$NullableType();
  static const type = $Closeable$Type();
  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Closeable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'close()V') {
        _$impls[$p]!.close();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $Closeable $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.Closeable', $p, _$invokePointer, [
      if ($impl.close$async) r'close()V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Closeable.implement($Closeable $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Closeable.fromReference($i.implementReference());
  }
}

abstract base mixin class $Closeable {
  factory $Closeable({required void Function() close, bool close$async}) =
      _$Closeable;

  void close();
  bool get close$async => false;
}

final class _$Closeable with $Closeable {
  _$Closeable({required void Function() close, this.close$async = false})
    : _close = close;

  final void Function() _close;
  final bool close$async;

  void close() => _close();
}

final class $Closeable$NullableType extends jni$_.JObjType<Closeable?> {
  @jni$_.internal
  const $Closeable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Closeable;';

  @jni$_.internal
  @core$_.override
  Closeable? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Closeable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Closeable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Closeable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Closeable$NullableType) &&
      other is $Closeable$NullableType;
}

final class $Closeable$Type extends jni$_.JObjType<Closeable> {
  @jni$_.internal
  const $Closeable$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Closeable;';

  @jni$_.internal
  @core$_.override
  Closeable fromReference(jni$_.JReference reference) =>
      Closeable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Closeable?> get nullableType =>
      const $Closeable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Closeable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Closeable$Type) && other is $Closeable$Type;
}

/// from: `java.io.FileDescriptor`
class FileDescriptor extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileDescriptor> $type;

  @jni$_.internal
  FileDescriptor.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FileDescriptor');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileDescriptor$NullableType();
  static const type = $FileDescriptor$Type();
  static final _id_in$ = _class.staticFieldId(
    r'in',
    r'Ljava/io/FileDescriptor;',
  );

  /// from: `static public final java.io.FileDescriptor in`
  /// The returned object must be released after use, by calling the [release] method.
  static FileDescriptor? get in$ =>
      _id_in$.get(_class, const $FileDescriptor$NullableType());

  static final _id_out = _class.staticFieldId(
    r'out',
    r'Ljava/io/FileDescriptor;',
  );

  /// from: `static public final java.io.FileDescriptor out`
  /// The returned object must be released after use, by calling the [release] method.
  static FileDescriptor? get out =>
      _id_out.get(_class, const $FileDescriptor$NullableType());

  static final _id_err = _class.staticFieldId(
    r'err',
    r'Ljava/io/FileDescriptor;',
  );

  /// from: `static public final java.io.FileDescriptor err`
  /// The returned object must be released after use, by calling the [release] method.
  static FileDescriptor? get err =>
      _id_err.get(_class, const $FileDescriptor$NullableType());

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileDescriptor() => FileDescriptor.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_valid = _class.instanceMethodId(r'valid', r'()Z');

  static final _valid =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean valid()`
  bool valid() =>
      _valid(reference.pointer, _id_valid as jni$_.JMethodIDPtr).boolean;

  static final _id_sync = _class.instanceMethodId(r'sync', r'()V');

  static final _sync =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public native void sync()`
  void sync() {
    _sync(reference.pointer, _id_sync as jni$_.JMethodIDPtr).check();
  }
}

final class $FileDescriptor$NullableType
    extends jni$_.JObjType<FileDescriptor?> {
  @jni$_.internal
  const $FileDescriptor$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileDescriptor;';

  @jni$_.internal
  @core$_.override
  FileDescriptor? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileDescriptor.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileDescriptor?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FileDescriptor$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileDescriptor$NullableType) &&
      other is $FileDescriptor$NullableType;
}

final class $FileDescriptor$Type extends jni$_.JObjType<FileDescriptor> {
  @jni$_.internal
  const $FileDescriptor$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileDescriptor;';

  @jni$_.internal
  @core$_.override
  FileDescriptor fromReference(jni$_.JReference reference) =>
      FileDescriptor.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileDescriptor?> get nullableType =>
      const $FileDescriptor$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FileDescriptor$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileDescriptor$Type) &&
      other is $FileDescriptor$Type;
}

/// from: `java.io.ObjectInputFilter$Status`
class ObjectInputFilter$Status extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInputFilter$Status> $type;

  @jni$_.internal
  ObjectInputFilter$Status.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/ObjectInputFilter$Status',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInputFilter$Status$NullableType();
  static const type = $ObjectInputFilter$Status$Type();
  static final _id_UNDECIDED = _class.staticFieldId(
    r'UNDECIDED',
    r'Ljava/io/ObjectInputFilter$Status;',
  );

  /// from: `static public final java.io.ObjectInputFilter$Status UNDECIDED`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter$Status get UNDECIDED =>
      _id_UNDECIDED.get(_class, const $ObjectInputFilter$Status$Type());

  static final _id_ALLOWED = _class.staticFieldId(
    r'ALLOWED',
    r'Ljava/io/ObjectInputFilter$Status;',
  );

  /// from: `static public final java.io.ObjectInputFilter$Status ALLOWED`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter$Status get ALLOWED =>
      _id_ALLOWED.get(_class, const $ObjectInputFilter$Status$Type());

  static final _id_REJECTED = _class.staticFieldId(
    r'REJECTED',
    r'Ljava/io/ObjectInputFilter$Status;',
  );

  /// from: `static public final java.io.ObjectInputFilter$Status REJECTED`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter$Status get REJECTED =>
      _id_REJECTED.get(_class, const $ObjectInputFilter$Status$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/io/ObjectInputFilter$Status;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter$Status[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<ObjectInputFilter$Status?>? values() => _values(
    _class.reference.pointer,
    _id_values as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<ObjectInputFilter$Status?>?>(
    const jni$_.JArrayNullableType<ObjectInputFilter$Status?>(
      $ObjectInputFilter$Status$NullableType(),
    ),
  );

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/io/ObjectInputFilter$Status;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter$Status valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter$Status? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<ObjectInputFilter$Status?>(
      const $ObjectInputFilter$Status$NullableType(),
    );
  }
}

final class $ObjectInputFilter$Status$NullableType
    extends jni$_.JObjType<ObjectInputFilter$Status?> {
  @jni$_.internal
  const $ObjectInputFilter$Status$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter$Status;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter$Status? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ObjectInputFilter$Status.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter$Status?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$Status$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInputFilter$Status$NullableType) &&
      other is $ObjectInputFilter$Status$NullableType;
}

final class $ObjectInputFilter$Status$Type
    extends jni$_.JObjType<ObjectInputFilter$Status> {
  @jni$_.internal
  const $ObjectInputFilter$Status$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter$Status;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter$Status fromReference(jni$_.JReference reference) =>
      ObjectInputFilter$Status.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter$Status?> get nullableType =>
      const $ObjectInputFilter$Status$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$Status$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectInputFilter$Status$Type) &&
      other is $ObjectInputFilter$Status$Type;
}

/// from: `java.io.FileReader`
class FileReader extends InputStreamReader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileReader> $type;

  @jni$_.internal
  FileReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FileReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileReader$NullableType();
  static const type = $FileReader$Type();
  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileReader.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return FileReader.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'(Ljava/io/File;)V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileReader.new$5(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return FileReader.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$file.pointer,
      ).reference,
    );
  }

  static final _id_new$6 = _class.constructorId(r'(Ljava/io/FileDescriptor;)V');

  static final _new$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.FileDescriptor fileDescriptor)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileReader.new$6(FileDescriptor? fileDescriptor) {
    final _$fileDescriptor = fileDescriptor?.reference ?? jni$_.jNullReference;
    return FileReader.fromReference(
      _new$6(
        _class.reference.pointer,
        _id_new$6 as jni$_.JMethodIDPtr,
        _$fileDescriptor.pointer,
      ).reference,
    );
  }

  static final _id_new$7 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;)V',
  );

  static final _new$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileReader.new$7(jni$_.JString? string, jni$_.JObject? charset) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return FileReader.fromReference(
      _new$7(
        _class.reference.pointer,
        _id_new$7 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$8 = _class.constructorId(
    r'(Ljava/io/File;Ljava/nio/charset/Charset;)V',
  );

  static final _new$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileReader.new$8(File? file, jni$_.JObject? charset) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return FileReader.fromReference(
      _new$8(
        _class.reference.pointer,
        _id_new$8 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$charset.pointer,
      ).reference,
    );
  }
}

final class $FileReader$NullableType extends jni$_.JObjType<FileReader?> {
  @jni$_.internal
  const $FileReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileReader;';

  @jni$_.internal
  @core$_.override
  FileReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStreamReader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($FileReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileReader$NullableType) &&
      other is $FileReader$NullableType;
}

final class $FileReader$Type extends jni$_.JObjType<FileReader> {
  @jni$_.internal
  const $FileReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileReader;';

  @jni$_.internal
  @core$_.override
  FileReader fromReference(jni$_.JReference reference) =>
      FileReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStreamReader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileReader?> get nullableType =>
      const $FileReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($FileReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileReader$Type) && other is $FileReader$Type;
}

/// from: `java.io.ObjectStreamConstants`
class ObjectStreamConstants extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectStreamConstants> $type;

  @jni$_.internal
  ObjectStreamConstants.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectStreamConstants');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectStreamConstants$NullableType();
  static const type = $ObjectStreamConstants$Type();

  /// from: `static public final short STREAM_MAGIC`
  static const STREAM_MAGIC = -21267;

  /// from: `static public final short STREAM_VERSION`
  static const STREAM_VERSION = 5;

  /// from: `static public final byte TC_BASE`
  static const TC_BASE = 112;

  /// from: `static public final byte TC_NULL`
  static const TC_NULL = 112;

  /// from: `static public final byte TC_REFERENCE`
  static const TC_REFERENCE = 113;

  /// from: `static public final byte TC_CLASSDESC`
  static const TC_CLASSDESC = 114;

  /// from: `static public final byte TC_OBJECT`
  static const TC_OBJECT = 115;

  /// from: `static public final byte TC_STRING`
  static const TC_STRING = 116;

  /// from: `static public final byte TC_ARRAY`
  static const TC_ARRAY = 117;

  /// from: `static public final byte TC_CLASS`
  static const TC_CLASS = 118;

  /// from: `static public final byte TC_BLOCKDATA`
  static const TC_BLOCKDATA = 119;

  /// from: `static public final byte TC_ENDBLOCKDATA`
  static const TC_ENDBLOCKDATA = 120;

  /// from: `static public final byte TC_RESET`
  static const TC_RESET = 121;

  /// from: `static public final byte TC_BLOCKDATALONG`
  static const TC_BLOCKDATALONG = 122;

  /// from: `static public final byte TC_EXCEPTION`
  static const TC_EXCEPTION = 123;

  /// from: `static public final byte TC_LONGSTRING`
  static const TC_LONGSTRING = 124;

  /// from: `static public final byte TC_PROXYCLASSDESC`
  static const TC_PROXYCLASSDESC = 125;

  /// from: `static public final byte TC_ENUM`
  static const TC_ENUM = 126;

  /// from: `static public final byte TC_MAX`
  static const TC_MAX = 126;

  /// from: `static public final int baseWireHandle`
  static const baseWireHandle = 8257536;

  /// from: `static public final byte SC_WRITE_METHOD`
  static const SC_WRITE_METHOD = 1;

  /// from: `static public final byte SC_BLOCK_DATA`
  static const SC_BLOCK_DATA = 8;

  /// from: `static public final byte SC_SERIALIZABLE`
  static const SC_SERIALIZABLE = 2;

  /// from: `static public final byte SC_EXTERNALIZABLE`
  static const SC_EXTERNALIZABLE = 4;

  /// from: `static public final byte SC_ENUM`
  static const SC_ENUM = 16;
  static final _id_SUBSTITUTION_PERMISSION = _class.staticFieldId(
    r'SUBSTITUTION_PERMISSION',
    r'Ljava/io/SerializablePermission;',
  );

  /// from: `static public final java.io.SerializablePermission SUBSTITUTION_PERMISSION`
  /// The returned object must be released after use, by calling the [release] method.
  static SerializablePermission? get SUBSTITUTION_PERMISSION =>
      _id_SUBSTITUTION_PERMISSION.get(
        _class,
        const $SerializablePermission$NullableType(),
      );

  static final _id_SUBCLASS_IMPLEMENTATION_PERMISSION = _class.staticFieldId(
    r'SUBCLASS_IMPLEMENTATION_PERMISSION',
    r'Ljava/io/SerializablePermission;',
  );

  /// from: `static public final java.io.SerializablePermission SUBCLASS_IMPLEMENTATION_PERMISSION`
  /// The returned object must be released after use, by calling the [release] method.
  static SerializablePermission? get SUBCLASS_IMPLEMENTATION_PERMISSION =>
      _id_SUBCLASS_IMPLEMENTATION_PERMISSION.get(
        _class,
        const $SerializablePermission$NullableType(),
      );

  static final _id_SERIAL_FILTER_PERMISSION = _class.staticFieldId(
    r'SERIAL_FILTER_PERMISSION',
    r'Ljava/io/SerializablePermission;',
  );

  /// from: `static public final java.io.SerializablePermission SERIAL_FILTER_PERMISSION`
  /// The returned object must be released after use, by calling the [release] method.
  static SerializablePermission? get SERIAL_FILTER_PERMISSION =>
      _id_SERIAL_FILTER_PERMISSION.get(
        _class,
        const $SerializablePermission$NullableType(),
      );

  /// from: `static public final int PROTOCOL_VERSION_1`
  static const PROTOCOL_VERSION_1 = 1;

  /// from: `static public final int PROTOCOL_VERSION_2`
  static const PROTOCOL_VERSION_2 = 2;

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ObjectStreamConstants> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ObjectStreamConstants $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.ObjectStreamConstants', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ObjectStreamConstants.implement($ObjectStreamConstants $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ObjectStreamConstants.fromReference($i.implementReference());
  }
}

abstract base mixin class $ObjectStreamConstants {
  factory $ObjectStreamConstants() = _$ObjectStreamConstants;
}

final class _$ObjectStreamConstants with $ObjectStreamConstants {
  _$ObjectStreamConstants();
}

final class $ObjectStreamConstants$NullableType
    extends jni$_.JObjType<ObjectStreamConstants?> {
  @jni$_.internal
  const $ObjectStreamConstants$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamConstants;';

  @jni$_.internal
  @core$_.override
  ObjectStreamConstants? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectStreamConstants.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamConstants?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectStreamConstants$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectStreamConstants$NullableType) &&
      other is $ObjectStreamConstants$NullableType;
}

final class $ObjectStreamConstants$Type
    extends jni$_.JObjType<ObjectStreamConstants> {
  @jni$_.internal
  const $ObjectStreamConstants$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamConstants;';

  @jni$_.internal
  @core$_.override
  ObjectStreamConstants fromReference(jni$_.JReference reference) =>
      ObjectStreamConstants.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamConstants?> get nullableType =>
      const $ObjectStreamConstants$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectStreamConstants$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ObjectStreamConstants$Type) &&
      other is $ObjectStreamConstants$Type;
}

/// from: `java.io.InputStream`
class InputStream extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InputStream> $type;

  @jni$_.internal
  InputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/InputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InputStream$NullableType();
  static const type = $InputStream$Type();
  static final _id_nullInputStream = _class.staticMethodId(
    r'nullInputStream',
    r'()Ljava/io/InputStream;',
  );

  static final _nullInputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.InputStream nullInputStream()`
  /// The returned object must be released after use, by calling the [release] method.
  static InputStream? nullInputStream() => _nullInputStream(
    _class.reference.pointer,
    _id_nullInputStream as jni$_.JMethodIDPtr,
  ).object<InputStream?>(const $InputStream$NullableType());

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int read()`
  int read() =>
      _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;

  static final _id_read$1 = _class.instanceMethodId(r'read', r'([B)I');

  static final _read$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(byte[] bs)`
  int read$1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read$1(
      reference.pointer,
      _id_read$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).integer;
  }

  static final _id_read$2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read$2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read$2(
      reference.pointer,
      _id_read$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_readAllBytes = _class.instanceMethodId(
    r'readAllBytes',
    r'()[B',
  );

  static final _readAllBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] readAllBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? readAllBytes() => _readAllBytes(
    reference.pointer,
    _id_readAllBytes as jni$_.JMethodIDPtr,
  ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());

  static final _id_readNBytes = _class.instanceMethodId(
    r'readNBytes',
    r'(I)[B',
  );

  static final _readNBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public byte[] readNBytes(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? readNBytes(int i) => _readNBytes(
    reference.pointer,
    _id_readNBytes as jni$_.JMethodIDPtr,
    i,
  ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());

  static final _id_readNBytes$1 = _class.instanceMethodId(
    r'readNBytes',
    r'([BII)I',
  );

  static final _readNBytes$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int readNBytes(byte[] bs, int i, int i1)`
  int readNBytes$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _readNBytes$1(
      reference.pointer,
      _id_readNBytes$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) =>
      _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;

  static final _id_skipNBytes = _class.instanceMethodId(r'skipNBytes', r'(J)V');

  static final _skipNBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void skipNBytes(long j)`
  void skipNBytes(int j) {
    _skipNBytes(
      reference.pointer,
      _id_skipNBytes as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() =>
      _available(
        reference.pointer,
        _id_available as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() =>
      _markSupported(
        reference.pointer,
        _id_markSupported as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_transferTo = _class.instanceMethodId(
    r'transferTo',
    r'(Ljava/io/OutputStream;)J',
  );

  static final _transferTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long transferTo(java.io.OutputStream outputStream)`
  int transferTo(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return _transferTo(
      reference.pointer,
      _id_transferTo as jni$_.JMethodIDPtr,
      _$outputStream.pointer,
    ).long;
  }
}

final class $InputStream$NullableType extends jni$_.JObjType<InputStream?> {
  @jni$_.internal
  const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InputStream;';

  @jni$_.internal
  @core$_.override
  InputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InputStream$NullableType) &&
      other is $InputStream$NullableType;
}

final class $InputStream$Type extends jni$_.JObjType<InputStream> {
  @jni$_.internal
  const $InputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InputStream;';

  @jni$_.internal
  @core$_.override
  InputStream fromReference(jni$_.JReference reference) =>
      InputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InputStream?> get nullableType =>
      const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InputStream$Type) && other is $InputStream$Type;
}

/// from: `java.time.InstantSource`
class InstantSource extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InstantSource> $type;

  @jni$_.internal
  InstantSource.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/InstantSource');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InstantSource$NullableType();
  static const type = $InstantSource$Type();
  static final _id_system = _class.staticMethodId(
    r'system',
    r'()Ljava/time/InstantSource;',
  );

  static final _system =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.InstantSource system()`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? system() => _system(
    _class.reference.pointer,
    _id_system as jni$_.JMethodIDPtr,
  ).object<InstantSource?>(const $InstantSource$NullableType());

  static final _id_tick = _class.staticMethodId(
    r'tick',
    r'(Ljava/time/InstantSource;Ljava/time/Duration;)Ljava/time/InstantSource;',
  );

  static final _tick =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.InstantSource tick(java.time.InstantSource instantSource, java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? tick(InstantSource? instantSource, Duration? duration) {
    final _$instantSource = instantSource?.reference ?? jni$_.jNullReference;
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _tick(
      _class.reference.pointer,
      _id_tick as jni$_.JMethodIDPtr,
      _$instantSource.pointer,
      _$duration.pointer,
    ).object<InstantSource?>(const $InstantSource$NullableType());
  }

  static final _id_fixed = _class.staticMethodId(
    r'fixed',
    r'(Ljava/time/Instant;)Ljava/time/InstantSource;',
  );

  static final _fixed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.InstantSource fixed(java.time.Instant instant)`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? fixed(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _fixed(
      _class.reference.pointer,
      _id_fixed as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).object<InstantSource?>(const $InstantSource$NullableType());
  }

  static final _id_offset = _class.staticMethodId(
    r'offset',
    r'(Ljava/time/InstantSource;Ljava/time/Duration;)Ljava/time/InstantSource;',
  );

  static final _offset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.InstantSource offset(java.time.InstantSource instantSource, java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? offset(
    InstantSource? instantSource,
    Duration? duration,
  ) {
    final _$instantSource = instantSource?.reference ?? jni$_.jNullReference;
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _offset(
      _class.reference.pointer,
      _id_offset as jni$_.JMethodIDPtr,
      _$instantSource.pointer,
      _$duration.pointer,
    ).object<InstantSource?>(const $InstantSource$NullableType());
  }

  static final _id_instant = _class.instanceMethodId(
    r'instant',
    r'()Ljava/time/Instant;',
  );

  static final _instant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.time.Instant instant()`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? instant() => _instant(
    reference.pointer,
    _id_instant as jni$_.JMethodIDPtr,
  ).object<Instant?>(const $Instant$NullableType());

  static final _id_millis = _class.instanceMethodId(r'millis', r'()J');

  static final _millis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long millis()`
  int millis() =>
      _millis(reference.pointer, _id_millis as jni$_.JMethodIDPtr).long;

  static final _id_withZone = _class.instanceMethodId(
    r'withZone',
    r'(Ljava/time/ZoneId;)Ljava/time/Clock;',
  );

  static final _withZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Clock withZone(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  Clock? withZone(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _withZone(
      reference.pointer,
      _id_withZone as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $InstantSource> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'system()Ljava/time/InstantSource;') {
        final $r = _$impls[$p]!.system();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'tick(Ljava/time/InstantSource;Ljava/time/Duration;)Ljava/time/InstantSource;') {
        final $r = _$impls[$p]!.tick(
          $a![0]?.as(const $InstantSource$Type(), releaseOriginal: true),
          $a![1]?.as(const $Duration$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'fixed(Ljava/time/Instant;)Ljava/time/InstantSource;') {
        final $r = _$impls[$p]!.fixed(
          $a![0]?.as(const $Instant$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'offset(Ljava/time/InstantSource;Ljava/time/Duration;)Ljava/time/InstantSource;') {
        final $r = _$impls[$p]!.offset(
          $a![0]?.as(const $InstantSource$Type(), releaseOriginal: true),
          $a![1]?.as(const $Duration$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'instant()Ljava/time/Instant;') {
        final $r = _$impls[$p]!.instant();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'millis()J') {
        final $r = _$impls[$p]!.millis();
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'withZone(Ljava/time/ZoneId;)Ljava/time/Clock;') {
        final $r = _$impls[$p]!.withZone(
          $a![0]?.as(const $ZoneId$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $InstantSource $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.time.InstantSource', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory InstantSource.implement($InstantSource $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return InstantSource.fromReference($i.implementReference());
  }
}

abstract base mixin class $InstantSource {
  factory $InstantSource({
    required InstantSource? Function() system,
    required InstantSource? Function(
      InstantSource? instantSource,
      Duration? duration,
    )
    tick,
    required InstantSource? Function(Instant? instant) fixed,
    required InstantSource? Function(
      InstantSource? instantSource,
      Duration? duration,
    )
    offset,
    required Instant? Function() instant,
    required int Function() millis,
    required Clock? Function(ZoneId? zoneId) withZone,
  }) = _$InstantSource;

  InstantSource? system();
  InstantSource? tick(InstantSource? instantSource, Duration? duration);
  InstantSource? fixed(Instant? instant);
  InstantSource? offset(InstantSource? instantSource, Duration? duration);
  Instant? instant();
  int millis();
  Clock? withZone(ZoneId? zoneId);
}

final class _$InstantSource with $InstantSource {
  _$InstantSource({
    required InstantSource? Function() system,
    required InstantSource? Function(
      InstantSource? instantSource,
      Duration? duration,
    )
    tick,
    required InstantSource? Function(Instant? instant) fixed,
    required InstantSource? Function(
      InstantSource? instantSource,
      Duration? duration,
    )
    offset,
    required Instant? Function() instant,
    required int Function() millis,
    required Clock? Function(ZoneId? zoneId) withZone,
  }) : _system = system,
       _tick = tick,
       _fixed = fixed,
       _offset = offset,
       _instant = instant,
       _millis = millis,
       _withZone = withZone;

  final InstantSource? Function() _system;
  final InstantSource? Function(
    InstantSource? instantSource,
    Duration? duration,
  )
  _tick;
  final InstantSource? Function(Instant? instant) _fixed;
  final InstantSource? Function(
    InstantSource? instantSource,
    Duration? duration,
  )
  _offset;
  final Instant? Function() _instant;
  final int Function() _millis;
  final Clock? Function(ZoneId? zoneId) _withZone;

  InstantSource? system() => _system();

  InstantSource? tick(InstantSource? instantSource, Duration? duration) =>
      _tick(instantSource, duration);

  InstantSource? fixed(Instant? instant) => _fixed(instant);

  InstantSource? offset(InstantSource? instantSource, Duration? duration) =>
      _offset(instantSource, duration);

  Instant? instant() => _instant();

  int millis() => _millis();

  Clock? withZone(ZoneId? zoneId) => _withZone(zoneId);
}

final class $InstantSource$NullableType extends jni$_.JObjType<InstantSource?> {
  @jni$_.internal
  const $InstantSource$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/InstantSource;';

  @jni$_.internal
  @core$_.override
  InstantSource? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InstantSource.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InstantSource?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InstantSource$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InstantSource$NullableType) &&
      other is $InstantSource$NullableType;
}

final class $InstantSource$Type extends jni$_.JObjType<InstantSource> {
  @jni$_.internal
  const $InstantSource$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/InstantSource;';

  @jni$_.internal
  @core$_.override
  InstantSource fromReference(jni$_.JReference reference) =>
      InstantSource.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InstantSource?> get nullableType =>
      const $InstantSource$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InstantSource$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InstantSource$Type) &&
      other is $InstantSource$Type;
}

/// from: `java.time.ZonedDateTime`
class ZonedDateTime extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZonedDateTime> $type;

  @jni$_.internal
  ZonedDateTime.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/ZonedDateTime');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZonedDateTime$NullableType();
  static const type = $ZonedDateTime$Type();
  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.ZonedDateTime now()`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? now() => _now(
    _class.reference.pointer,
    _id_now as jni$_.JMethodIDPtr,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/ZonedDateTime;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDate;Ljava/time/LocalTime;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime of(java.time.LocalDate localDate, java.time.LocalTime localTime, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? of(
    LocalDate? localDate,
    LocalTime? localTime,
    ZoneId? zoneId,
  ) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$localDate.pointer,
      _$localTime.pointer,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime of(java.time.LocalDateTime localDateTime, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? of$1(LocalDateTime? localDateTime, ZoneId? zoneId) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(IIIIIIILjava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _of$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime of(int i, int i1, int i2, int i3, int i4, int i5, int i6, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? of$2(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
    ZoneId? zoneId,
  ) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _of$2(
      _class.reference.pointer,
      _id_of$2 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
      i4,
      i5,
      i6,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofLocal = _class.staticMethodId(
    r'ofLocal',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneId;Ljava/time/ZoneOffset;)Ljava/time/ZonedDateTime;',
  );

  static final _ofLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime ofLocal(java.time.LocalDateTime localDateTime, java.time.ZoneId zoneId, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? ofLocal(
    LocalDateTime? localDateTime,
    ZoneId? zoneId,
    ZoneOffset? zoneOffset,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _ofLocal(
      _class.reference.pointer,
      _id_ofLocal as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$zoneId.pointer,
      _$zoneOffset.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime ofInstant(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? ofInstant(Instant? instant, ZoneId? zoneId) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant(
      _class.reference.pointer,
      _id_ofInstant as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofInstant$1 = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneOffset;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofInstant$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime ofInstant(java.time.LocalDateTime localDateTime, java.time.ZoneOffset zoneOffset, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? ofInstant$1(
    LocalDateTime? localDateTime,
    ZoneOffset? zoneOffset,
    ZoneId? zoneId,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant$1(
      _class.reference.pointer,
      _id_ofInstant$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$zoneOffset.pointer,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofStrict = _class.staticMethodId(
    r'ofStrict',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneOffset;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofStrict =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime ofStrict(java.time.LocalDateTime localDateTime, java.time.ZoneOffset zoneOffset, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? ofStrict(
    LocalDateTime? localDateTime,
    ZoneOffset? zoneOffset,
    ZoneId? zoneId,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofStrict(
      _class.reference.pointer,
      _id_ofStrict as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$zoneOffset.pointer,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/ZonedDateTime;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/ZonedDateTime;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/ZonedDateTime;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getOffset = _class.instanceMethodId(
    r'getOffset',
    r'()Ljava/time/ZoneOffset;',
  );

  static final _getOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZoneOffset getOffset()`
  /// The returned object must be released after use, by calling the [release] method.
  ZoneOffset? getOffset() => _getOffset(
    reference.pointer,
    _id_getOffset as jni$_.JMethodIDPtr,
  ).object<ZoneOffset?>(const $ZoneOffset$NullableType());

  static final _id_withEarlierOffsetAtOverlap = _class.instanceMethodId(
    r'withEarlierOffsetAtOverlap',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withEarlierOffsetAtOverlap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZonedDateTime withEarlierOffsetAtOverlap()`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withEarlierOffsetAtOverlap() => _withEarlierOffsetAtOverlap(
    reference.pointer,
    _id_withEarlierOffsetAtOverlap as jni$_.JMethodIDPtr,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_withLaterOffsetAtOverlap = _class.instanceMethodId(
    r'withLaterOffsetAtOverlap',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withLaterOffsetAtOverlap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZonedDateTime withLaterOffsetAtOverlap()`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withLaterOffsetAtOverlap() => _withLaterOffsetAtOverlap(
    reference.pointer,
    _id_withLaterOffsetAtOverlap as jni$_.JMethodIDPtr,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_getZone = _class.instanceMethodId(
    r'getZone',
    r'()Ljava/time/ZoneId;',
  );

  static final _getZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZoneId getZone()`
  /// The returned object must be released after use, by calling the [release] method.
  ZoneId? getZone() => _getZone(
    reference.pointer,
    _id_getZone as jni$_.JMethodIDPtr,
  ).object<ZoneId?>(const $ZoneId$NullableType());

  static final _id_withZoneSameLocal = _class.instanceMethodId(
    r'withZoneSameLocal',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _withZoneSameLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime withZoneSameLocal(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withZoneSameLocal(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _withZoneSameLocal(
      reference.pointer,
      _id_withZoneSameLocal as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withZoneSameInstant = _class.instanceMethodId(
    r'withZoneSameInstant',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _withZoneSameInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime withZoneSameInstant(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withZoneSameInstant(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _withZoneSameInstant(
      reference.pointer,
      _id_withZoneSameInstant as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withFixedOffsetZone = _class.instanceMethodId(
    r'withFixedOffsetZone',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withFixedOffsetZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZonedDateTime withFixedOffsetZone()`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withFixedOffsetZone() => _withFixedOffsetZone(
    reference.pointer,
    _id_withFixedOffsetZone as jni$_.JMethodIDPtr,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_toLocalDateTime = _class.instanceMethodId(
    r'toLocalDateTime',
    r'()Ljava/time/LocalDateTime;',
  );

  static final _toLocalDateTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDateTime toLocalDateTime()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? toLocalDateTime() => _toLocalDateTime(
    reference.pointer,
    _id_toLocalDateTime as jni$_.JMethodIDPtr,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_toLocalDate = _class.instanceMethodId(
    r'toLocalDate',
    r'()Ljava/time/LocalDate;',
  );

  static final _toLocalDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDate toLocalDate()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? toLocalDate() => _toLocalDate(
    reference.pointer,
    _id_toLocalDate as jni$_.JMethodIDPtr,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_getYear = _class.instanceMethodId(r'getYear', r'()I');

  static final _getYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getYear()`
  int getYear() =>
      _getYear(reference.pointer, _id_getYear as jni$_.JMethodIDPtr).integer;

  static final _id_getMonthValue = _class.instanceMethodId(
    r'getMonthValue',
    r'()I',
  );

  static final _getMonthValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMonthValue()`
  int getMonthValue() =>
      _getMonthValue(
        reference.pointer,
        _id_getMonthValue as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()Ljava/time/Month;',
  );

  static final _getMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  Month? getMonth() => _getMonth(
    reference.pointer,
    _id_getMonth as jni$_.JMethodIDPtr,
  ).object<Month?>(const $Month$NullableType());

  static final _id_getDayOfMonth = _class.instanceMethodId(
    r'getDayOfMonth',
    r'()I',
  );

  static final _getDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfMonth()`
  int getDayOfMonth() =>
      _getDayOfMonth(
        reference.pointer,
        _id_getDayOfMonth as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getDayOfYear = _class.instanceMethodId(
    r'getDayOfYear',
    r'()I',
  );

  static final _getDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfYear()`
  int getDayOfYear() =>
      _getDayOfYear(
        reference.pointer,
        _id_getDayOfYear as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getDayOfWeek = _class.instanceMethodId(
    r'getDayOfWeek',
    r'()Ljava/time/DayOfWeek;',
  );

  static final _getDayOfWeek =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.DayOfWeek getDayOfWeek()`
  /// The returned object must be released after use, by calling the [release] method.
  DayOfWeek? getDayOfWeek() => _getDayOfWeek(
    reference.pointer,
    _id_getDayOfWeek as jni$_.JMethodIDPtr,
  ).object<DayOfWeek?>(const $DayOfWeek$NullableType());

  static final _id_toLocalTime = _class.instanceMethodId(
    r'toLocalTime',
    r'()Ljava/time/LocalTime;',
  );

  static final _toLocalTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalTime toLocalTime()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? toLocalTime() => _toLocalTime(
    reference.pointer,
    _id_toLocalTime as jni$_.JMethodIDPtr,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_getHour = _class.instanceMethodId(r'getHour', r'()I');

  static final _getHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getHour()`
  int getHour() =>
      _getHour(reference.pointer, _id_getHour as jni$_.JMethodIDPtr).integer;

  static final _id_getMinute = _class.instanceMethodId(r'getMinute', r'()I');

  static final _getMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMinute()`
  int getMinute() =>
      _getMinute(
        reference.pointer,
        _id_getMinute as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getSecond = _class.instanceMethodId(r'getSecond', r'()I');

  static final _getSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSecond()`
  int getSecond() =>
      _getSecond(
        reference.pointer,
        _id_getSecond as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() =>
      _getNano(reference.pointer, _id_getNano as jni$_.JMethodIDPtr).integer;

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/ZonedDateTime;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/ZonedDateTime;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withYear = _class.instanceMethodId(
    r'withYear',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withYear(int i) => _withYear(
    reference.pointer,
    _id_withYear as jni$_.JMethodIDPtr,
    i,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_withMonth = _class.instanceMethodId(
    r'withMonth',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withMonth(int i) => _withMonth(
    reference.pointer,
    _id_withMonth as jni$_.JMethodIDPtr,
    i,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_withDayOfMonth = _class.instanceMethodId(
    r'withDayOfMonth',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withDayOfMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withDayOfMonth(int i) => _withDayOfMonth(
    reference.pointer,
    _id_withDayOfMonth as jni$_.JMethodIDPtr,
    i,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_withDayOfYear = _class.instanceMethodId(
    r'withDayOfYear',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withDayOfYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withDayOfYear(int i) => _withDayOfYear(
    reference.pointer,
    _id_withDayOfYear as jni$_.JMethodIDPtr,
    i,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_withHour = _class.instanceMethodId(
    r'withHour',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withHour(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withHour(int i) => _withHour(
    reference.pointer,
    _id_withHour as jni$_.JMethodIDPtr,
    i,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_withMinute = _class.instanceMethodId(
    r'withMinute',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withMinute(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withMinute(int i) => _withMinute(
    reference.pointer,
    _id_withMinute as jni$_.JMethodIDPtr,
    i,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_withSecond = _class.instanceMethodId(
    r'withSecond',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withSecond(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withSecond(int i) => _withSecond(
    reference.pointer,
    _id_withSecond as jni$_.JMethodIDPtr,
    i,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_withNano = _class.instanceMethodId(
    r'withNano',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime withNano(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withNano(int i) => _withNano(
    reference.pointer,
    _id_withNano as jni$_.JMethodIDPtr,
    i,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/ZonedDateTime;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusYears(int j) => _plusYears(
    reference.pointer,
    _id_plusYears as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_plusMonths = _class.instanceMethodId(
    r'plusMonths',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusMonths(int j) => _plusMonths(
    reference.pointer,
    _id_plusMonths as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_plusWeeks = _class.instanceMethodId(
    r'plusWeeks',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusWeeks(int j) => _plusWeeks(
    reference.pointer,
    _id_plusWeeks as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_plusDays = _class.instanceMethodId(
    r'plusDays',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusDays(int j) => _plusDays(
    reference.pointer,
    _id_plusDays as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_plusHours = _class.instanceMethodId(
    r'plusHours',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusHours(int j) => _plusHours(
    reference.pointer,
    _id_plusHours as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_plusMinutes = _class.instanceMethodId(
    r'plusMinutes',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusMinutes(int j) => _plusMinutes(
    reference.pointer,
    _id_plusMinutes as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusSeconds(int j) => _plusSeconds(
    reference.pointer,
    _id_plusSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusNanos(int j) => _plusNanos(
    reference.pointer,
    _id_plusNanos as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/ZonedDateTime;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusYears(int j) => _minusYears(
    reference.pointer,
    _id_minusYears as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_minusMonths = _class.instanceMethodId(
    r'minusMonths',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusMonths(int j) => _minusMonths(
    reference.pointer,
    _id_minusMonths as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_minusWeeks = _class.instanceMethodId(
    r'minusWeeks',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusWeeks(int j) => _minusWeeks(
    reference.pointer,
    _id_minusWeeks as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_minusDays = _class.instanceMethodId(
    r'minusDays',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusDays(int j) => _minusDays(
    reference.pointer,
    _id_minusDays as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_minusHours = _class.instanceMethodId(
    r'minusHours',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusHours(int j) => _minusHours(
    reference.pointer,
    _id_minusHours as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_minusMinutes = _class.instanceMethodId(
    r'minusMinutes',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusMinutes(int j) => _minusMinutes(
    reference.pointer,
    _id_minusMinutes as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusSeconds(int j) => _minusSeconds(
    reference.pointer,
    _id_minusSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.ZonedDateTime minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusNanos(int j) => _minusNanos(
    reference.pointer,
    _id_minusNanos as jni$_.JMethodIDPtr,
    j,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toOffsetDateTime = _class.instanceMethodId(
    r'toOffsetDateTime',
    r'()Ljava/time/OffsetDateTime;',
  );

  static final _toOffsetDateTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.OffsetDateTime toOffsetDateTime()`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? toOffsetDateTime() => _toOffsetDateTime(
    reference.pointer,
    _id_toOffsetDateTime as jni$_.JMethodIDPtr,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $ZonedDateTime$NullableType extends jni$_.JObjType<ZonedDateTime?> {
  @jni$_.internal
  const $ZonedDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZonedDateTime;';

  @jni$_.internal
  @core$_.override
  ZonedDateTime? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ZonedDateTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZonedDateTime?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZonedDateTime$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ZonedDateTime$NullableType) &&
      other is $ZonedDateTime$NullableType;
}

final class $ZonedDateTime$Type extends jni$_.JObjType<ZonedDateTime> {
  @jni$_.internal
  const $ZonedDateTime$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZonedDateTime;';

  @jni$_.internal
  @core$_.override
  ZonedDateTime fromReference(jni$_.JReference reference) =>
      ZonedDateTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZonedDateTime?> get nullableType =>
      const $ZonedDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZonedDateTime$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ZonedDateTime$Type) &&
      other is $ZonedDateTime$Type;
}

/// from: `java.time.LocalDateTime`
class LocalDateTime extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<LocalDateTime> $type;

  @jni$_.internal
  LocalDateTime.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/LocalDateTime');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $LocalDateTime$NullableType();
  static const type = $LocalDateTime$Type();
  static final _id_MIN = _class.staticFieldId(
    r'MIN',
    r'Ljava/time/LocalDateTime;',
  );

  /// from: `static public final java.time.LocalDateTime MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? get MIN =>
      _id_MIN.get(_class, const $LocalDateTime$NullableType());

  static final _id_MAX = _class.staticFieldId(
    r'MAX',
    r'Ljava/time/LocalDateTime;',
  );

  /// from: `static public final java.time.LocalDateTime MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? get MAX =>
      _id_MAX.get(_class, const $LocalDateTime$NullableType());

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/LocalDateTime;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.LocalDateTime now()`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? now() => _now(
    _class.reference.pointer,
    _id_now as jni$_.JMethodIDPtr,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/LocalDateTime;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/LocalDateTime;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(ILjava/time/Month;III)Ljava/time/LocalDateTime;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDateTime of(int i, java.time.Month month, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? of(int i, Month? month, int i1, int i2, int i3) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      i,
      _$month.pointer,
      i1,
      i2,
      i3,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(ILjava/time/Month;IIII)Ljava/time/LocalDateTime;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDateTime of(int i, java.time.Month month, int i1, int i2, int i3, int i4)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? of$1(
    int i,
    Month? month,
    int i1,
    int i2,
    int i3,
    int i4,
  ) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      i,
      _$month.pointer,
      i1,
      i2,
      i3,
      i4,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(ILjava/time/Month;IIIII)Ljava/time/LocalDateTime;',
  );

  static final _of$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDateTime of(int i, java.time.Month month, int i1, int i2, int i3, int i4, int i5)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? of$2(
    int i,
    Month? month,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _of$2(
      _class.reference.pointer,
      _id_of$2 as jni$_.JMethodIDPtr,
      i,
      _$month.pointer,
      i1,
      i2,
      i3,
      i4,
      i5,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_of$3 = _class.staticMethodId(
    r'of',
    r'(IIIII)Ljava/time/LocalDateTime;',
  );

  static final _of$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDateTime of(int i, int i1, int i2, int i3, int i4)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? of$3(int i, int i1, int i2, int i3, int i4) => _of$3(
    _class.reference.pointer,
    _id_of$3 as jni$_.JMethodIDPtr,
    i,
    i1,
    i2,
    i3,
    i4,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_of$4 = _class.staticMethodId(
    r'of',
    r'(IIIIII)Ljava/time/LocalDateTime;',
  );

  static final _of$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDateTime of(int i, int i1, int i2, int i3, int i4, int i5)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? of$4(int i, int i1, int i2, int i3, int i4, int i5) =>
      _of$4(
        _class.reference.pointer,
        _id_of$4 as jni$_.JMethodIDPtr,
        i,
        i1,
        i2,
        i3,
        i4,
        i5,
      ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_of$5 = _class.staticMethodId(
    r'of',
    r'(IIIIIII)Ljava/time/LocalDateTime;',
  );

  static final _of$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDateTime of(int i, int i1, int i2, int i3, int i4, int i5, int i6)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? of$5(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
  ) => _of$5(
    _class.reference.pointer,
    _id_of$5 as jni$_.JMethodIDPtr,
    i,
    i1,
    i2,
    i3,
    i4,
    i5,
    i6,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_of$6 = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDate;Ljava/time/LocalTime;)Ljava/time/LocalDateTime;',
  );

  static final _of$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime of(java.time.LocalDate localDate, java.time.LocalTime localTime)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? of$6(LocalDate? localDate, LocalTime? localTime) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    return _of$6(
      _class.reference.pointer,
      _id_of$6 as jni$_.JMethodIDPtr,
      _$localDate.pointer,
      _$localTime.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/LocalDateTime;',
  );

  static final _ofInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime ofInstant(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? ofInstant(Instant? instant, ZoneId? zoneId) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant(
      _class.reference.pointer,
      _id_ofInstant as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zoneId.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_ofEpochSecond = _class.staticMethodId(
    r'ofEpochSecond',
    r'(JILjava/time/ZoneOffset;)Ljava/time/LocalDateTime;',
  );

  static final _ofEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int64, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime ofEpochSecond(long j, int i, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? ofEpochSecond(int j, int i, ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _ofEpochSecond(
      _class.reference.pointer,
      _id_ofEpochSecond as jni$_.JMethodIDPtr,
      j,
      i,
      _$zoneOffset.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/LocalDateTime;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/LocalDateTime;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/LocalDateTime;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDateTime parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDateTime? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_toLocalDate = _class.instanceMethodId(
    r'toLocalDate',
    r'()Ljava/time/LocalDate;',
  );

  static final _toLocalDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDate toLocalDate()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? toLocalDate() => _toLocalDate(
    reference.pointer,
    _id_toLocalDate as jni$_.JMethodIDPtr,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_getYear = _class.instanceMethodId(r'getYear', r'()I');

  static final _getYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getYear()`
  int getYear() =>
      _getYear(reference.pointer, _id_getYear as jni$_.JMethodIDPtr).integer;

  static final _id_getMonthValue = _class.instanceMethodId(
    r'getMonthValue',
    r'()I',
  );

  static final _getMonthValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMonthValue()`
  int getMonthValue() =>
      _getMonthValue(
        reference.pointer,
        _id_getMonthValue as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()Ljava/time/Month;',
  );

  static final _getMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  Month? getMonth() => _getMonth(
    reference.pointer,
    _id_getMonth as jni$_.JMethodIDPtr,
  ).object<Month?>(const $Month$NullableType());

  static final _id_getDayOfMonth = _class.instanceMethodId(
    r'getDayOfMonth',
    r'()I',
  );

  static final _getDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfMonth()`
  int getDayOfMonth() =>
      _getDayOfMonth(
        reference.pointer,
        _id_getDayOfMonth as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getDayOfYear = _class.instanceMethodId(
    r'getDayOfYear',
    r'()I',
  );

  static final _getDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfYear()`
  int getDayOfYear() =>
      _getDayOfYear(
        reference.pointer,
        _id_getDayOfYear as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getDayOfWeek = _class.instanceMethodId(
    r'getDayOfWeek',
    r'()Ljava/time/DayOfWeek;',
  );

  static final _getDayOfWeek =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.DayOfWeek getDayOfWeek()`
  /// The returned object must be released after use, by calling the [release] method.
  DayOfWeek? getDayOfWeek() => _getDayOfWeek(
    reference.pointer,
    _id_getDayOfWeek as jni$_.JMethodIDPtr,
  ).object<DayOfWeek?>(const $DayOfWeek$NullableType());

  static final _id_toLocalTime = _class.instanceMethodId(
    r'toLocalTime',
    r'()Ljava/time/LocalTime;',
  );

  static final _toLocalTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalTime toLocalTime()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? toLocalTime() => _toLocalTime(
    reference.pointer,
    _id_toLocalTime as jni$_.JMethodIDPtr,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_getHour = _class.instanceMethodId(r'getHour', r'()I');

  static final _getHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getHour()`
  int getHour() =>
      _getHour(reference.pointer, _id_getHour as jni$_.JMethodIDPtr).integer;

  static final _id_getMinute = _class.instanceMethodId(r'getMinute', r'()I');

  static final _getMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMinute()`
  int getMinute() =>
      _getMinute(
        reference.pointer,
        _id_getMinute as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getSecond = _class.instanceMethodId(r'getSecond', r'()I');

  static final _getSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSecond()`
  int getSecond() =>
      _getSecond(
        reference.pointer,
        _id_getSecond as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() =>
      _getNano(reference.pointer, _id_getNano as jni$_.JMethodIDPtr).integer;

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/LocalDateTime;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/LocalDateTime;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_withYear = _class.instanceMethodId(
    r'withYear',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withYear(int i) => _withYear(
    reference.pointer,
    _id_withYear as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_withMonth = _class.instanceMethodId(
    r'withMonth',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withMonth(int i) => _withMonth(
    reference.pointer,
    _id_withMonth as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_withDayOfMonth = _class.instanceMethodId(
    r'withDayOfMonth',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withDayOfMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withDayOfMonth(int i) => _withDayOfMonth(
    reference.pointer,
    _id_withDayOfMonth as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_withDayOfYear = _class.instanceMethodId(
    r'withDayOfYear',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withDayOfYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withDayOfYear(int i) => _withDayOfYear(
    reference.pointer,
    _id_withDayOfYear as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_withHour = _class.instanceMethodId(
    r'withHour',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withHour(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withHour(int i) => _withHour(
    reference.pointer,
    _id_withHour as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_withMinute = _class.instanceMethodId(
    r'withMinute',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withMinute(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withMinute(int i) => _withMinute(
    reference.pointer,
    _id_withMinute as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_withSecond = _class.instanceMethodId(
    r'withSecond',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withSecond(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withSecond(int i) => _withSecond(
    reference.pointer,
    _id_withSecond as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_withNano = _class.instanceMethodId(
    r'withNano',
    r'(I)Ljava/time/LocalDateTime;',
  );

  static final _withNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime withNano(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? withNano(int i) => _withNano(
    reference.pointer,
    _id_withNano as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/LocalDateTime;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/LocalDateTime;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/LocalDateTime;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusYears(int j) => _plusYears(
    reference.pointer,
    _id_plusYears as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_plusMonths = _class.instanceMethodId(
    r'plusMonths',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusMonths(int j) => _plusMonths(
    reference.pointer,
    _id_plusMonths as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_plusWeeks = _class.instanceMethodId(
    r'plusWeeks',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusWeeks(int j) => _plusWeeks(
    reference.pointer,
    _id_plusWeeks as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_plusDays = _class.instanceMethodId(
    r'plusDays',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusDays(int j) => _plusDays(
    reference.pointer,
    _id_plusDays as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_plusHours = _class.instanceMethodId(
    r'plusHours',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusHours(int j) => _plusHours(
    reference.pointer,
    _id_plusHours as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_plusMinutes = _class.instanceMethodId(
    r'plusMinutes',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusMinutes(int j) => _plusMinutes(
    reference.pointer,
    _id_plusMinutes as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusSeconds(int j) => _plusSeconds(
    reference.pointer,
    _id_plusSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? plusNanos(int j) => _plusNanos(
    reference.pointer,
    _id_plusNanos as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/LocalDateTime;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/LocalDateTime;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusYears(int j) => _minusYears(
    reference.pointer,
    _id_minusYears as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_minusMonths = _class.instanceMethodId(
    r'minusMonths',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusMonths(int j) => _minusMonths(
    reference.pointer,
    _id_minusMonths as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_minusWeeks = _class.instanceMethodId(
    r'minusWeeks',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusWeeks(int j) => _minusWeeks(
    reference.pointer,
    _id_minusWeeks as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_minusDays = _class.instanceMethodId(
    r'minusDays',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusDays(int j) => _minusDays(
    reference.pointer,
    _id_minusDays as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_minusHours = _class.instanceMethodId(
    r'minusHours',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusHours(int j) => _minusHours(
    reference.pointer,
    _id_minusHours as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_minusMinutes = _class.instanceMethodId(
    r'minusMinutes',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusMinutes(int j) => _minusMinutes(
    reference.pointer,
    _id_minusMinutes as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusSeconds(int j) => _minusSeconds(
    reference.pointer,
    _id_minusSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/LocalDateTime;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? minusNanos(int j) => _minusNanos(
    reference.pointer,
    _id_minusNanos as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atOffset = _class.instanceMethodId(
    r'atOffset',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _atOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime atOffset(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? atOffset(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _atOffset(
      reference.pointer,
      _id_atOffset as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_atZone = _class.instanceMethodId(
    r'atZone',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _atZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime atZone(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? atZone(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _atZone(
      reference.pointer,
      _id_atZone as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/chrono/ChronoLocalDateTime;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.chrono.ChronoLocalDateTime<?> chronoLocalDateTime)`
  int compareTo(jni$_.JObject? chronoLocalDateTime) {
    final _$chronoLocalDateTime =
        chronoLocalDateTime?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$chronoLocalDateTime.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/chrono/ChronoLocalDateTime;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.chrono.ChronoLocalDateTime<?> chronoLocalDateTime)`
  bool isAfter(jni$_.JObject? chronoLocalDateTime) {
    final _$chronoLocalDateTime =
        chronoLocalDateTime?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$chronoLocalDateTime.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/chrono/ChronoLocalDateTime;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.chrono.ChronoLocalDateTime<?> chronoLocalDateTime)`
  bool isBefore(jni$_.JObject? chronoLocalDateTime) {
    final _$chronoLocalDateTime =
        chronoLocalDateTime?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$chronoLocalDateTime.pointer,
    ).boolean;
  }

  static final _id_isEqual = _class.instanceMethodId(
    r'isEqual',
    r'(Ljava/time/chrono/ChronoLocalDateTime;)Z',
  );

  static final _isEqual =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isEqual(java.time.chrono.ChronoLocalDateTime<?> chronoLocalDateTime)`
  bool isEqual(jni$_.JObject? chronoLocalDateTime) {
    final _$chronoLocalDateTime =
        chronoLocalDateTime?.reference ?? jni$_.jNullReference;
    return _isEqual(
      reference.pointer,
      _id_isEqual as jni$_.JMethodIDPtr,
      _$chronoLocalDateTime.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $LocalDateTime$NullableType extends jni$_.JObjType<LocalDateTime?> {
  @jni$_.internal
  const $LocalDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/LocalDateTime;';

  @jni$_.internal
  @core$_.override
  LocalDateTime? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : LocalDateTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LocalDateTime?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($LocalDateTime$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($LocalDateTime$NullableType) &&
      other is $LocalDateTime$NullableType;
}

final class $LocalDateTime$Type extends jni$_.JObjType<LocalDateTime> {
  @jni$_.internal
  const $LocalDateTime$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/LocalDateTime;';

  @jni$_.internal
  @core$_.override
  LocalDateTime fromReference(jni$_.JReference reference) =>
      LocalDateTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LocalDateTime?> get nullableType =>
      const $LocalDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($LocalDateTime$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($LocalDateTime$Type) &&
      other is $LocalDateTime$Type;
}

/// from: `java.time.Duration`
class Duration extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Duration> $type;

  @jni$_.internal
  Duration.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Duration');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Duration$NullableType();
  static const type = $Duration$Type();
  static final _id_ZERO = _class.staticFieldId(
    r'ZERO',
    r'Ljava/time/Duration;',
  );

  /// from: `static public final java.time.Duration ZERO`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? get ZERO =>
      _id_ZERO.get(_class, const $Duration$NullableType());

  static final _id_ofDays = _class.staticMethodId(
    r'ofDays',
    r'(J)Ljava/time/Duration;',
  );

  static final _ofDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Duration ofDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? ofDays(int j) => _ofDays(
    _class.reference.pointer,
    _id_ofDays as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_ofHours = _class.staticMethodId(
    r'ofHours',
    r'(J)Ljava/time/Duration;',
  );

  static final _ofHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Duration ofHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? ofHours(int j) => _ofHours(
    _class.reference.pointer,
    _id_ofHours as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_ofMinutes = _class.staticMethodId(
    r'ofMinutes',
    r'(J)Ljava/time/Duration;',
  );

  static final _ofMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Duration ofMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? ofMinutes(int j) => _ofMinutes(
    _class.reference.pointer,
    _id_ofMinutes as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_ofSeconds = _class.staticMethodId(
    r'ofSeconds',
    r'(J)Ljava/time/Duration;',
  );

  static final _ofSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Duration ofSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? ofSeconds(int j) => _ofSeconds(
    _class.reference.pointer,
    _id_ofSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_ofSeconds$1 = _class.staticMethodId(
    r'ofSeconds',
    r'(JJ)Ljava/time/Duration;',
  );

  static final _ofSeconds$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.Duration ofSeconds(long j, long j1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? ofSeconds$1(int j, int j1) => _ofSeconds$1(
    _class.reference.pointer,
    _id_ofSeconds$1 as jni$_.JMethodIDPtr,
    j,
    j1,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_ofMillis = _class.staticMethodId(
    r'ofMillis',
    r'(J)Ljava/time/Duration;',
  );

  static final _ofMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Duration ofMillis(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? ofMillis(int j) => _ofMillis(
    _class.reference.pointer,
    _id_ofMillis as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_ofNanos = _class.staticMethodId(
    r'ofNanos',
    r'(J)Ljava/time/Duration;',
  );

  static final _ofNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Duration ofNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? ofNanos(int j) => _ofNanos(
    _class.reference.pointer,
    _id_ofNanos as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Duration;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Duration of(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? of(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Duration;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Duration from(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? from(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/Duration;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Duration parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_between = _class.staticMethodId(
    r'between',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/Temporal;)Ljava/time/Duration;',
  );

  static final _between =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Duration between(java.time.temporal.Temporal temporal, java.time.temporal.Temporal temporal1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Duration? between(jni$_.JObject? temporal, jni$_.JObject? temporal1) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporal1 = temporal1?.reference ?? jni$_.jNullReference;
    return _between(
      _class.reference.pointer,
      _id_between as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporal1.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long get(java.time.temporal.TemporalUnit temporalUnit)`
  int get(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_getUnits = _class.instanceMethodId(
    r'getUnits',
    r'()Ljava/util/List;',
  );

  static final _getUnits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<java.time.temporal.TemporalUnit> getUnits()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getUnits() => _getUnits(
    reference.pointer,
    _id_getUnits as jni$_.JMethodIDPtr,
  ).object<jni$_.JList<jni$_.JObject?>?>(
    const jni$_.JListNullableType<jni$_.JObject?>(jni$_.JObjectNullableType()),
  );

  static final _id_isZero = _class.instanceMethodId(r'isZero', r'()Z');

  static final _isZero =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isZero()`
  bool isZero() =>
      _isZero(reference.pointer, _id_isZero as jni$_.JMethodIDPtr).boolean;

  static final _id_isNegative = _class.instanceMethodId(r'isNegative', r'()Z');

  static final _isNegative =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isNegative()`
  bool isNegative() =>
      _isNegative(
        reference.pointer,
        _id_isNegative as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_getSeconds = _class.instanceMethodId(r'getSeconds', r'()J');

  static final _getSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getSeconds()`
  int getSeconds() =>
      _getSeconds(reference.pointer, _id_getSeconds as jni$_.JMethodIDPtr).long;

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() =>
      _getNano(reference.pointer, _id_getNano as jni$_.JMethodIDPtr).integer;

  static final _id_withSeconds = _class.instanceMethodId(
    r'withSeconds',
    r'(J)Ljava/time/Duration;',
  );

  static final _withSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration withSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? withSeconds(int j) => _withSeconds(
    reference.pointer,
    _id_withSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_withNanos = _class.instanceMethodId(
    r'withNanos',
    r'(I)Ljava/time/Duration;',
  );

  static final _withNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration withNanos(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? withNanos(int i) => _withNanos(
    reference.pointer,
    _id_withNanos as jni$_.JMethodIDPtr,
    i,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/Duration;)Ljava/time/Duration;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Duration plus(java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plus(Duration? duration) {
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$duration.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Duration;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Duration plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_plusDays = _class.instanceMethodId(
    r'plusDays',
    r'(J)Ljava/time/Duration;',
  );

  static final _plusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration plusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plusDays(int j) => _plusDays(
    reference.pointer,
    _id_plusDays as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_plusHours = _class.instanceMethodId(
    r'plusHours',
    r'(J)Ljava/time/Duration;',
  );

  static final _plusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration plusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plusHours(int j) => _plusHours(
    reference.pointer,
    _id_plusHours as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_plusMinutes = _class.instanceMethodId(
    r'plusMinutes',
    r'(J)Ljava/time/Duration;',
  );

  static final _plusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration plusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plusMinutes(int j) => _plusMinutes(
    reference.pointer,
    _id_plusMinutes as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/Duration;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plusSeconds(int j) => _plusSeconds(
    reference.pointer,
    _id_plusSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_plusMillis = _class.instanceMethodId(
    r'plusMillis',
    r'(J)Ljava/time/Duration;',
  );

  static final _plusMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration plusMillis(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plusMillis(int j) => _plusMillis(
    reference.pointer,
    _id_plusMillis as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/Duration;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? plusNanos(int j) => _plusNanos(
    reference.pointer,
    _id_plusNanos as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/Duration;)Ljava/time/Duration;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Duration minus(java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minus(Duration? duration) {
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$duration.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Duration;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Duration minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_minusDays = _class.instanceMethodId(
    r'minusDays',
    r'(J)Ljava/time/Duration;',
  );

  static final _minusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration minusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minusDays(int j) => _minusDays(
    reference.pointer,
    _id_minusDays as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_minusHours = _class.instanceMethodId(
    r'minusHours',
    r'(J)Ljava/time/Duration;',
  );

  static final _minusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration minusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minusHours(int j) => _minusHours(
    reference.pointer,
    _id_minusHours as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_minusMinutes = _class.instanceMethodId(
    r'minusMinutes',
    r'(J)Ljava/time/Duration;',
  );

  static final _minusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration minusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minusMinutes(int j) => _minusMinutes(
    reference.pointer,
    _id_minusMinutes as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/Duration;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minusSeconds(int j) => _minusSeconds(
    reference.pointer,
    _id_minusSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_minusMillis = _class.instanceMethodId(
    r'minusMillis',
    r'(J)Ljava/time/Duration;',
  );

  static final _minusMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration minusMillis(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minusMillis(int j) => _minusMillis(
    reference.pointer,
    _id_minusMillis as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/Duration;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? minusNanos(int j) => _minusNanos(
    reference.pointer,
    _id_minusNanos as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_multipliedBy = _class.instanceMethodId(
    r'multipliedBy',
    r'(J)Ljava/time/Duration;',
  );

  static final _multipliedBy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration multipliedBy(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? multipliedBy(int j) => _multipliedBy(
    reference.pointer,
    _id_multipliedBy as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_dividedBy = _class.instanceMethodId(
    r'dividedBy',
    r'(J)Ljava/time/Duration;',
  );

  static final _dividedBy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Duration dividedBy(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? dividedBy(int j) => _dividedBy(
    reference.pointer,
    _id_dividedBy as jni$_.JMethodIDPtr,
    j,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_dividedBy$1 = _class.instanceMethodId(
    r'dividedBy',
    r'(Ljava/time/Duration;)J',
  );

  static final _dividedBy$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long dividedBy(java.time.Duration duration)`
  int dividedBy$1(Duration? duration) {
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _dividedBy$1(
      reference.pointer,
      _id_dividedBy$1 as jni$_.JMethodIDPtr,
      _$duration.pointer,
    ).long;
  }

  static final _id_negated = _class.instanceMethodId(
    r'negated',
    r'()Ljava/time/Duration;',
  );

  static final _negated =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Duration negated()`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? negated() => _negated(
    reference.pointer,
    _id_negated as jni$_.JMethodIDPtr,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_abs = _class.instanceMethodId(
    r'abs',
    r'()Ljava/time/Duration;',
  );

  static final _abs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Duration abs()`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? abs() => _abs(
    reference.pointer,
    _id_abs as jni$_.JMethodIDPtr,
  ).object<Duration?>(const $Duration$NullableType());

  static final _id_addTo = _class.instanceMethodId(
    r'addTo',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _addTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal addTo(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? addTo(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _addTo(
      reference.pointer,
      _id_addTo as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_subtractFrom = _class.instanceMethodId(
    r'subtractFrom',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _subtractFrom =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal subtractFrom(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? subtractFrom(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _subtractFrom(
      reference.pointer,
      _id_subtractFrom as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toDays = _class.instanceMethodId(r'toDays', r'()J');

  static final _toDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toDays()`
  int toDays() =>
      _toDays(reference.pointer, _id_toDays as jni$_.JMethodIDPtr).long;

  static final _id_toHours = _class.instanceMethodId(r'toHours', r'()J');

  static final _toHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toHours()`
  int toHours() =>
      _toHours(reference.pointer, _id_toHours as jni$_.JMethodIDPtr).long;

  static final _id_toMinutes = _class.instanceMethodId(r'toMinutes', r'()J');

  static final _toMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toMinutes()`
  int toMinutes() =>
      _toMinutes(reference.pointer, _id_toMinutes as jni$_.JMethodIDPtr).long;

  static final _id_toSeconds = _class.instanceMethodId(r'toSeconds', r'()J');

  static final _toSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toSeconds()`
  int toSeconds() =>
      _toSeconds(reference.pointer, _id_toSeconds as jni$_.JMethodIDPtr).long;

  static final _id_toMillis = _class.instanceMethodId(r'toMillis', r'()J');

  static final _toMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toMillis()`
  int toMillis() =>
      _toMillis(reference.pointer, _id_toMillis as jni$_.JMethodIDPtr).long;

  static final _id_toNanos = _class.instanceMethodId(r'toNanos', r'()J');

  static final _toNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toNanos()`
  int toNanos() =>
      _toNanos(reference.pointer, _id_toNanos as jni$_.JMethodIDPtr).long;

  static final _id_toDaysPart = _class.instanceMethodId(r'toDaysPart', r'()J');

  static final _toDaysPart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toDaysPart()`
  int toDaysPart() =>
      _toDaysPart(reference.pointer, _id_toDaysPart as jni$_.JMethodIDPtr).long;

  static final _id_toHoursPart = _class.instanceMethodId(
    r'toHoursPart',
    r'()I',
  );

  static final _toHoursPart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int toHoursPart()`
  int toHoursPart() =>
      _toHoursPart(
        reference.pointer,
        _id_toHoursPart as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toMinutesPart = _class.instanceMethodId(
    r'toMinutesPart',
    r'()I',
  );

  static final _toMinutesPart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int toMinutesPart()`
  int toMinutesPart() =>
      _toMinutesPart(
        reference.pointer,
        _id_toMinutesPart as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toSecondsPart = _class.instanceMethodId(
    r'toSecondsPart',
    r'()I',
  );

  static final _toSecondsPart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int toSecondsPart()`
  int toSecondsPart() =>
      _toSecondsPart(
        reference.pointer,
        _id_toSecondsPart as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toMillisPart = _class.instanceMethodId(
    r'toMillisPart',
    r'()I',
  );

  static final _toMillisPart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int toMillisPart()`
  int toMillisPart() =>
      _toMillisPart(
        reference.pointer,
        _id_toMillisPart as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toNanosPart = _class.instanceMethodId(
    r'toNanosPart',
    r'()I',
  );

  static final _toNanosPart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int toNanosPart()`
  int toNanosPart() =>
      _toNanosPart(
        reference.pointer,
        _id_toNanosPart as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/Duration;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Duration truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Duration? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<Duration?>(const $Duration$NullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/Duration;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.Duration duration)`
  int compareTo(Duration? duration) {
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$duration.pointer,
    ).integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  bool operator <(Duration? duration) => compareTo(duration) < 0;

  bool operator <=(Duration? duration) => compareTo(duration) <= 0;

  bool operator >(Duration? duration) => compareTo(duration) > 0;

  bool operator >=(Duration? duration) => compareTo(duration) >= 0;
}

final class $Duration$NullableType extends jni$_.JObjType<Duration?> {
  @jni$_.internal
  const $Duration$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Duration;';

  @jni$_.internal
  @core$_.override
  Duration? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Duration.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Duration?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Duration$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Duration$NullableType) &&
      other is $Duration$NullableType;
}

final class $Duration$Type extends jni$_.JObjType<Duration> {
  @jni$_.internal
  const $Duration$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Duration;';

  @jni$_.internal
  @core$_.override
  Duration fromReference(jni$_.JReference reference) =>
      Duration.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Duration?> get nullableType => const $Duration$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Duration$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Duration$Type) && other is $Duration$Type;
}

/// from: `java.time.LocalTime`
class LocalTime extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<LocalTime> $type;

  @jni$_.internal
  LocalTime.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/LocalTime');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $LocalTime$NullableType();
  static const type = $LocalTime$Type();
  static final _id_MIN = _class.staticFieldId(r'MIN', r'Ljava/time/LocalTime;');

  /// from: `static public final java.time.LocalTime MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? get MIN =>
      _id_MIN.get(_class, const $LocalTime$NullableType());

  static final _id_MAX = _class.staticFieldId(r'MAX', r'Ljava/time/LocalTime;');

  /// from: `static public final java.time.LocalTime MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? get MAX =>
      _id_MAX.get(_class, const $LocalTime$NullableType());

  static final _id_MIDNIGHT = _class.staticFieldId(
    r'MIDNIGHT',
    r'Ljava/time/LocalTime;',
  );

  /// from: `static public final java.time.LocalTime MIDNIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? get MIDNIGHT =>
      _id_MIDNIGHT.get(_class, const $LocalTime$NullableType());

  static final _id_NOON = _class.staticFieldId(
    r'NOON',
    r'Ljava/time/LocalTime;',
  );

  /// from: `static public final java.time.LocalTime NOON`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? get NOON =>
      _id_NOON.get(_class, const $LocalTime$NullableType());

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/LocalTime;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.LocalTime now()`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? now() => _now(
    _class.reference.pointer,
    _id_now as jni$_.JMethodIDPtr,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/LocalTime;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalTime now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/LocalTime;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalTime now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(II)Ljava/time/LocalTime;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalTime of(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? of(int i, int i1) => _of(
    _class.reference.pointer,
    _id_of as jni$_.JMethodIDPtr,
    i,
    i1,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(III)Ljava/time/LocalTime;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalTime of(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? of$1(int i, int i1, int i2) => _of$1(
    _class.reference.pointer,
    _id_of$1 as jni$_.JMethodIDPtr,
    i,
    i1,
    i2,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(IIII)Ljava/time/LocalTime;',
  );

  static final _of$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalTime of(int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? of$2(int i, int i1, int i2, int i3) => _of$2(
    _class.reference.pointer,
    _id_of$2 as jni$_.JMethodIDPtr,
    i,
    i1,
    i2,
    i3,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/LocalTime;',
  );

  static final _ofInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalTime ofInstant(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? ofInstant(Instant? instant, ZoneId? zoneId) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant(
      _class.reference.pointer,
      _id_ofInstant as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zoneId.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_ofSecondOfDay = _class.staticMethodId(
    r'ofSecondOfDay',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _ofSecondOfDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.LocalTime ofSecondOfDay(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? ofSecondOfDay(int j) => _ofSecondOfDay(
    _class.reference.pointer,
    _id_ofSecondOfDay as jni$_.JMethodIDPtr,
    j,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_ofNanoOfDay = _class.staticMethodId(
    r'ofNanoOfDay',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _ofNanoOfDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.LocalTime ofNanoOfDay(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? ofNanoOfDay(int j) => _ofNanoOfDay(
    _class.reference.pointer,
    _id_ofNanoOfDay as jni$_.JMethodIDPtr,
    j,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/LocalTime;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalTime from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/LocalTime;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalTime parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/LocalTime;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalTime parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalTime? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getHour = _class.instanceMethodId(r'getHour', r'()I');

  static final _getHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getHour()`
  int getHour() =>
      _getHour(reference.pointer, _id_getHour as jni$_.JMethodIDPtr).integer;

  static final _id_getMinute = _class.instanceMethodId(r'getMinute', r'()I');

  static final _getMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMinute()`
  int getMinute() =>
      _getMinute(
        reference.pointer,
        _id_getMinute as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getSecond = _class.instanceMethodId(r'getSecond', r'()I');

  static final _getSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSecond()`
  int getSecond() =>
      _getSecond(
        reference.pointer,
        _id_getSecond as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() =>
      _getNano(reference.pointer, _id_getNano as jni$_.JMethodIDPtr).integer;

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/LocalTime;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalTime with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/LocalTime;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.LocalTime with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_withHour = _class.instanceMethodId(
    r'withHour',
    r'(I)Ljava/time/LocalTime;',
  );

  static final _withHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime withHour(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? withHour(int i) => _withHour(
    reference.pointer,
    _id_withHour as jni$_.JMethodIDPtr,
    i,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_withMinute = _class.instanceMethodId(
    r'withMinute',
    r'(I)Ljava/time/LocalTime;',
  );

  static final _withMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime withMinute(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? withMinute(int i) => _withMinute(
    reference.pointer,
    _id_withMinute as jni$_.JMethodIDPtr,
    i,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_withSecond = _class.instanceMethodId(
    r'withSecond',
    r'(I)Ljava/time/LocalTime;',
  );

  static final _withSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime withSecond(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? withSecond(int i) => _withSecond(
    reference.pointer,
    _id_withSecond as jni$_.JMethodIDPtr,
    i,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_withNano = _class.instanceMethodId(
    r'withNano',
    r'(I)Ljava/time/LocalTime;',
  );

  static final _withNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime withNano(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? withNano(int i) => _withNano(
    reference.pointer,
    _id_withNano as jni$_.JMethodIDPtr,
    i,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/LocalTime;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalTime truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/LocalTime;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalTime plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/LocalTime;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalTime plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_plusHours = _class.instanceMethodId(
    r'plusHours',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _plusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime plusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? plusHours(int j) => _plusHours(
    reference.pointer,
    _id_plusHours as jni$_.JMethodIDPtr,
    j,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_plusMinutes = _class.instanceMethodId(
    r'plusMinutes',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _plusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime plusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? plusMinutes(int j) => _plusMinutes(
    reference.pointer,
    _id_plusMinutes as jni$_.JMethodIDPtr,
    j,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? plusSeconds(int j) => _plusSeconds(
    reference.pointer,
    _id_plusSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? plusNanos(int j) => _plusNanos(
    reference.pointer,
    _id_plusNanos as jni$_.JMethodIDPtr,
    j,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/LocalTime;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalTime minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/LocalTime;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalTime minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<LocalTime?>(const $LocalTime$NullableType());
  }

  static final _id_minusHours = _class.instanceMethodId(
    r'minusHours',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _minusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime minusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? minusHours(int j) => _minusHours(
    reference.pointer,
    _id_minusHours as jni$_.JMethodIDPtr,
    j,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_minusMinutes = _class.instanceMethodId(
    r'minusMinutes',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _minusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime minusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? minusMinutes(int j) => _minusMinutes(
    reference.pointer,
    _id_minusMinutes as jni$_.JMethodIDPtr,
    j,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? minusSeconds(int j) => _minusSeconds(
    reference.pointer,
    _id_minusSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/LocalTime;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalTime minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? minusNanos(int j) => _minusNanos(
    reference.pointer,
    _id_minusNanos as jni$_.JMethodIDPtr,
    j,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atDate = _class.instanceMethodId(
    r'atDate',
    r'(Ljava/time/LocalDate;)Ljava/time/LocalDateTime;',
  );

  static final _atDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime atDate(java.time.LocalDate localDate)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? atDate(LocalDate? localDate) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    return _atDate(
      reference.pointer,
      _id_atDate as jni$_.JMethodIDPtr,
      _$localDate.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_atOffset = _class.instanceMethodId(
    r'atOffset',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetTime;',
  );

  static final _atOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime atOffset(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? atOffset(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _atOffset(
      reference.pointer,
      _id_atOffset as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_toSecondOfDay = _class.instanceMethodId(
    r'toSecondOfDay',
    r'()I',
  );

  static final _toSecondOfDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int toSecondOfDay()`
  int toSecondOfDay() =>
      _toSecondOfDay(
        reference.pointer,
        _id_toSecondOfDay as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toNanoOfDay = _class.instanceMethodId(
    r'toNanoOfDay',
    r'()J',
  );

  static final _toNanoOfDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toNanoOfDay()`
  int toNanoOfDay() =>
      _toNanoOfDay(
        reference.pointer,
        _id_toNanoOfDay as jni$_.JMethodIDPtr,
      ).long;

  static final _id_toEpochSecond = _class.instanceMethodId(
    r'toEpochSecond',
    r'(Ljava/time/LocalDate;Ljava/time/ZoneOffset;)J',
  );

  static final _toEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long toEpochSecond(java.time.LocalDate localDate, java.time.ZoneOffset zoneOffset)`
  int toEpochSecond(LocalDate? localDate, ZoneOffset? zoneOffset) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _toEpochSecond(
      reference.pointer,
      _id_toEpochSecond as jni$_.JMethodIDPtr,
      _$localDate.pointer,
      _$zoneOffset.pointer,
    ).long;
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/LocalTime;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.LocalTime localTime)`
  int compareTo(LocalTime? localTime) {
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$localTime.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/LocalTime;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.LocalTime localTime)`
  bool isAfter(LocalTime? localTime) {
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$localTime.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/LocalTime;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.LocalTime localTime)`
  bool isBefore(LocalTime? localTime) {
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$localTime.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  bool operator <(LocalTime? localTime) => compareTo(localTime) < 0;

  bool operator <=(LocalTime? localTime) => compareTo(localTime) <= 0;

  bool operator >(LocalTime? localTime) => compareTo(localTime) > 0;

  bool operator >=(LocalTime? localTime) => compareTo(localTime) >= 0;
}

final class $LocalTime$NullableType extends jni$_.JObjType<LocalTime?> {
  @jni$_.internal
  const $LocalTime$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/LocalTime;';

  @jni$_.internal
  @core$_.override
  LocalTime? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : LocalTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LocalTime?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($LocalTime$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($LocalTime$NullableType) &&
      other is $LocalTime$NullableType;
}

final class $LocalTime$Type extends jni$_.JObjType<LocalTime> {
  @jni$_.internal
  const $LocalTime$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/LocalTime;';

  @jni$_.internal
  @core$_.override
  LocalTime fromReference(jni$_.JReference reference) =>
      LocalTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LocalTime?> get nullableType =>
      const $LocalTime$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($LocalTime$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($LocalTime$Type) && other is $LocalTime$Type;
}

/// from: `java.time.ZoneOffset`
class ZoneOffset extends ZoneId {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZoneOffset> $type;

  @jni$_.internal
  ZoneOffset.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/ZoneOffset');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZoneOffset$NullableType();
  static const type = $ZoneOffset$Type();
  static final _id_UTC = _class.staticFieldId(
    r'UTC',
    r'Ljava/time/ZoneOffset;',
  );

  /// from: `static public final java.time.ZoneOffset UTC`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? get UTC =>
      _id_UTC.get(_class, const $ZoneOffset$NullableType());

  static final _id_MIN = _class.staticFieldId(
    r'MIN',
    r'Ljava/time/ZoneOffset;',
  );

  /// from: `static public final java.time.ZoneOffset MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? get MIN =>
      _id_MIN.get(_class, const $ZoneOffset$NullableType());

  static final _id_MAX = _class.staticFieldId(
    r'MAX',
    r'Ljava/time/ZoneOffset;',
  );

  /// from: `static public final java.time.ZoneOffset MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? get MAX =>
      _id_MAX.get(_class, const $ZoneOffset$NullableType());

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/String;)Ljava/time/ZoneOffset;',
  );

  static final _of$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZoneOffset of(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? of$2(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _of$2(
      _class.reference.pointer,
      _id_of$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofHours = _class.staticMethodId(
    r'ofHours',
    r'(I)Ljava/time/ZoneOffset;',
  );

  static final _ofHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.ZoneOffset ofHours(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? ofHours(int i) => _ofHours(
    _class.reference.pointer,
    _id_ofHours as jni$_.JMethodIDPtr,
    i,
  ).object<ZoneOffset?>(const $ZoneOffset$NullableType());

  static final _id_ofHoursMinutes = _class.staticMethodId(
    r'ofHoursMinutes',
    r'(II)Ljava/time/ZoneOffset;',
  );

  static final _ofHoursMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.ZoneOffset ofHoursMinutes(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? ofHoursMinutes(int i, int i1) => _ofHoursMinutes(
    _class.reference.pointer,
    _id_ofHoursMinutes as jni$_.JMethodIDPtr,
    i,
    i1,
  ).object<ZoneOffset?>(const $ZoneOffset$NullableType());

  static final _id_ofHoursMinutesSeconds = _class.staticMethodId(
    r'ofHoursMinutesSeconds',
    r'(III)Ljava/time/ZoneOffset;',
  );

  static final _ofHoursMinutesSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.ZoneOffset ofHoursMinutesSeconds(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? ofHoursMinutesSeconds(int i, int i1, int i2) =>
      _ofHoursMinutesSeconds(
        _class.reference.pointer,
        _id_ofHoursMinutesSeconds as jni$_.JMethodIDPtr,
        i,
        i1,
        i2,
      ).object<ZoneOffset?>(const $ZoneOffset$NullableType());

  static final _id_from$1 = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/ZoneOffset;',
  );

  static final _from$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZoneOffset from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? from$1(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from$1(
      _class.reference.pointer,
      _id_from$1 as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofTotalSeconds = _class.staticMethodId(
    r'ofTotalSeconds',
    r'(I)Ljava/time/ZoneOffset;',
  );

  static final _ofTotalSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.ZoneOffset ofTotalSeconds(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? ofTotalSeconds(int i) => _ofTotalSeconds(
    _class.reference.pointer,
    _id_ofTotalSeconds as jni$_.JMethodIDPtr,
    i,
  ).object<ZoneOffset?>(const $ZoneOffset$NullableType());

  static final _id_getTotalSeconds = _class.instanceMethodId(
    r'getTotalSeconds',
    r'()I',
  );

  static final _getTotalSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getTotalSeconds()`
  int getTotalSeconds() =>
      _getTotalSeconds(
        reference.pointer,
        _id_getTotalSeconds as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getId() => _getId(
    reference.pointer,
    _id_getId as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getRules = _class.instanceMethodId(
    r'getRules',
    r'()Ljava/time/zone/ZoneRules;',
  );

  static final _getRules =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.zone.ZoneRules getRules()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRules() => _getRules(
    reference.pointer,
    _id_getRules as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/ZoneOffset;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.ZoneOffset zoneOffset)`
  int compareTo(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode1() =>
      _hashCode1(
        reference.pointer,
        _id_hashCode1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString1() => _toString1(
    reference.pointer,
    _id_toString1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  bool operator <(ZoneOffset? zoneOffset) => compareTo(zoneOffset) < 0;

  bool operator <=(ZoneOffset? zoneOffset) => compareTo(zoneOffset) <= 0;

  bool operator >(ZoneOffset? zoneOffset) => compareTo(zoneOffset) > 0;

  bool operator >=(ZoneOffset? zoneOffset) => compareTo(zoneOffset) >= 0;
}

final class $ZoneOffset$NullableType extends jni$_.JObjType<ZoneOffset?> {
  @jni$_.internal
  const $ZoneOffset$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneOffset;';

  @jni$_.internal
  @core$_.override
  ZoneOffset? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ZoneOffset.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneOffset?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ZoneOffset$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ZoneOffset$NullableType) &&
      other is $ZoneOffset$NullableType;
}

final class $ZoneOffset$Type extends jni$_.JObjType<ZoneOffset> {
  @jni$_.internal
  const $ZoneOffset$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneOffset;';

  @jni$_.internal
  @core$_.override
  ZoneOffset fromReference(jni$_.JReference reference) =>
      ZoneOffset.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneOffset?> get nullableType =>
      const $ZoneOffset$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ZoneOffset$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ZoneOffset$Type) && other is $ZoneOffset$Type;
}

/// from: `java.time.DateTimeException`
class DateTimeException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DateTimeException> $type;

  @jni$_.internal
  DateTimeException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/DateTimeException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DateTimeException$NullableType();
  static const type = $DateTimeException$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DateTimeException(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return DateTimeException.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/Throwable;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.Throwable throwable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DateTimeException.new$1(
    jni$_.JString? string,
    jni$_.JObject? throwable,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    return DateTimeException.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$throwable.pointer,
      ).reference,
    );
  }
}

final class $DateTimeException$NullableType
    extends jni$_.JObjType<DateTimeException?> {
  @jni$_.internal
  const $DateTimeException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/DateTimeException;';

  @jni$_.internal
  @core$_.override
  DateTimeException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DateTimeException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DateTimeException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DateTimeException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DateTimeException$NullableType) &&
      other is $DateTimeException$NullableType;
}

final class $DateTimeException$Type extends jni$_.JObjType<DateTimeException> {
  @jni$_.internal
  const $DateTimeException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/DateTimeException;';

  @jni$_.internal
  @core$_.override
  DateTimeException fromReference(jni$_.JReference reference) =>
      DateTimeException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DateTimeException?> get nullableType =>
      const $DateTimeException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DateTimeException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DateTimeException$Type) &&
      other is $DateTimeException$Type;
}

/// from: `java.time.OffsetTime`
class OffsetTime extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OffsetTime> $type;

  @jni$_.internal
  OffsetTime.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/OffsetTime');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OffsetTime$NullableType();
  static const type = $OffsetTime$Type();
  static final _id_MIN = _class.staticFieldId(
    r'MIN',
    r'Ljava/time/OffsetTime;',
  );

  /// from: `static public final java.time.OffsetTime MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? get MIN =>
      _id_MIN.get(_class, const $OffsetTime$NullableType());

  static final _id_MAX = _class.staticFieldId(
    r'MAX',
    r'Ljava/time/OffsetTime;',
  );

  /// from: `static public final java.time.OffsetTime MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? get MAX =>
      _id_MAX.get(_class, const $OffsetTime$NullableType());

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/OffsetTime;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.OffsetTime now()`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? now() => _now(
    _class.reference.pointer,
    _id_now as jni$_.JMethodIDPtr,
  ).object<OffsetTime?>(const $OffsetTime$NullableType());

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/OffsetTime;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/OffsetTime;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalTime;Ljava/time/ZoneOffset;)Ljava/time/OffsetTime;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime of(java.time.LocalTime localTime, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? of(LocalTime? localTime, ZoneOffset? zoneOffset) {
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$localTime.pointer,
      _$zoneOffset.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(IIIILjava/time/ZoneOffset;)Ljava/time/OffsetTime;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime of(int i, int i1, int i2, int i3, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? of$1(
    int i,
    int i1,
    int i2,
    int i3,
    ZoneOffset? zoneOffset,
  ) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
      _$zoneOffset.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/OffsetTime;',
  );

  static final _ofInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime ofInstant(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? ofInstant(Instant? instant, ZoneId? zoneId) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant(
      _class.reference.pointer,
      _id_ofInstant as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zoneId.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/OffsetTime;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/OffsetTime;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/OffsetTime;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetTime parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetTime? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getOffset = _class.instanceMethodId(
    r'getOffset',
    r'()Ljava/time/ZoneOffset;',
  );

  static final _getOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZoneOffset getOffset()`
  /// The returned object must be released after use, by calling the [release] method.
  ZoneOffset? getOffset() => _getOffset(
    reference.pointer,
    _id_getOffset as jni$_.JMethodIDPtr,
  ).object<ZoneOffset?>(const $ZoneOffset$NullableType());

  static final _id_withOffsetSameLocal = _class.instanceMethodId(
    r'withOffsetSameLocal',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetTime;',
  );

  static final _withOffsetSameLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime withOffsetSameLocal(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? withOffsetSameLocal(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _withOffsetSameLocal(
      reference.pointer,
      _id_withOffsetSameLocal as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_withOffsetSameInstant = _class.instanceMethodId(
    r'withOffsetSameInstant',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetTime;',
  );

  static final _withOffsetSameInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime withOffsetSameInstant(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? withOffsetSameInstant(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _withOffsetSameInstant(
      reference.pointer,
      _id_withOffsetSameInstant as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_toLocalTime = _class.instanceMethodId(
    r'toLocalTime',
    r'()Ljava/time/LocalTime;',
  );

  static final _toLocalTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalTime toLocalTime()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? toLocalTime() => _toLocalTime(
    reference.pointer,
    _id_toLocalTime as jni$_.JMethodIDPtr,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_getHour = _class.instanceMethodId(r'getHour', r'()I');

  static final _getHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getHour()`
  int getHour() =>
      _getHour(reference.pointer, _id_getHour as jni$_.JMethodIDPtr).integer;

  static final _id_getMinute = _class.instanceMethodId(r'getMinute', r'()I');

  static final _getMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMinute()`
  int getMinute() =>
      _getMinute(
        reference.pointer,
        _id_getMinute as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getSecond = _class.instanceMethodId(r'getSecond', r'()I');

  static final _getSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSecond()`
  int getSecond() =>
      _getSecond(
        reference.pointer,
        _id_getSecond as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() =>
      _getNano(reference.pointer, _id_getNano as jni$_.JMethodIDPtr).integer;

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/OffsetTime;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/OffsetTime;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_withHour = _class.instanceMethodId(
    r'withHour',
    r'(I)Ljava/time/OffsetTime;',
  );

  static final _withHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime withHour(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? withHour(int i) => _withHour(
    reference.pointer,
    _id_withHour as jni$_.JMethodIDPtr,
    i,
  ).object<OffsetTime?>(const $OffsetTime$NullableType());

  static final _id_withMinute = _class.instanceMethodId(
    r'withMinute',
    r'(I)Ljava/time/OffsetTime;',
  );

  static final _withMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime withMinute(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? withMinute(int i) => _withMinute(
    reference.pointer,
    _id_withMinute as jni$_.JMethodIDPtr,
    i,
  ).object<OffsetTime?>(const $OffsetTime$NullableType());

  static final _id_withSecond = _class.instanceMethodId(
    r'withSecond',
    r'(I)Ljava/time/OffsetTime;',
  );

  static final _withSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime withSecond(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? withSecond(int i) => _withSecond(
    reference.pointer,
    _id_withSecond as jni$_.JMethodIDPtr,
    i,
  ).object<OffsetTime?>(const $OffsetTime$NullableType());

  static final _id_withNano = _class.instanceMethodId(
    r'withNano',
    r'(I)Ljava/time/OffsetTime;',
  );

  static final _withNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime withNano(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? withNano(int i) => _withNano(
    reference.pointer,
    _id_withNano as jni$_.JMethodIDPtr,
    i,
  ).object<OffsetTime?>(const $OffsetTime$NullableType());

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/OffsetTime;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/OffsetTime;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/OffsetTime;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_plusHours = _class.instanceMethodId(
    r'plusHours',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _plusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime plusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? plusHours(int j) => _plusHours(
    reference.pointer,
    _id_plusHours as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetTime?>(const $OffsetTime$NullableType());

  static final _id_plusMinutes = _class.instanceMethodId(
    r'plusMinutes',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _plusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime plusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? plusMinutes(int j) => _plusMinutes(
    reference.pointer,
    _id_plusMinutes as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetTime?>(const $OffsetTime$NullableType());

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? plusSeconds(int j) => _plusSeconds(
    reference.pointer,
    _id_plusSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetTime?>(const $OffsetTime$NullableType());

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? plusNanos(int j) => _plusNanos(
    reference.pointer,
    _id_plusNanos as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetTime?>(const $OffsetTime$NullableType());

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/OffsetTime;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/OffsetTime;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetTime minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<OffsetTime?>(const $OffsetTime$NullableType());
  }

  static final _id_minusHours = _class.instanceMethodId(
    r'minusHours',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _minusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime minusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? minusHours(int j) => _minusHours(
    reference.pointer,
    _id_minusHours as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetTime?>(const $OffsetTime$NullableType());

  static final _id_minusMinutes = _class.instanceMethodId(
    r'minusMinutes',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _minusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime minusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? minusMinutes(int j) => _minusMinutes(
    reference.pointer,
    _id_minusMinutes as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetTime?>(const $OffsetTime$NullableType());

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? minusSeconds(int j) => _minusSeconds(
    reference.pointer,
    _id_minusSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetTime?>(const $OffsetTime$NullableType());

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/OffsetTime;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetTime minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? minusNanos(int j) => _minusNanos(
    reference.pointer,
    _id_minusNanos as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetTime?>(const $OffsetTime$NullableType());

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atDate = _class.instanceMethodId(
    r'atDate',
    r'(Ljava/time/LocalDate;)Ljava/time/OffsetDateTime;',
  );

  static final _atDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime atDate(java.time.LocalDate localDate)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? atDate(LocalDate? localDate) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    return _atDate(
      reference.pointer,
      _id_atDate as jni$_.JMethodIDPtr,
      _$localDate.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_toEpochSecond = _class.instanceMethodId(
    r'toEpochSecond',
    r'(Ljava/time/LocalDate;)J',
  );

  static final _toEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long toEpochSecond(java.time.LocalDate localDate)`
  int toEpochSecond(LocalDate? localDate) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    return _toEpochSecond(
      reference.pointer,
      _id_toEpochSecond as jni$_.JMethodIDPtr,
      _$localDate.pointer,
    ).long;
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/OffsetTime;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.OffsetTime offsetTime)`
  int compareTo(OffsetTime? offsetTime) {
    final _$offsetTime = offsetTime?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$offsetTime.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/OffsetTime;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.OffsetTime offsetTime)`
  bool isAfter(OffsetTime? offsetTime) {
    final _$offsetTime = offsetTime?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$offsetTime.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/OffsetTime;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.OffsetTime offsetTime)`
  bool isBefore(OffsetTime? offsetTime) {
    final _$offsetTime = offsetTime?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$offsetTime.pointer,
    ).boolean;
  }

  static final _id_isEqual = _class.instanceMethodId(
    r'isEqual',
    r'(Ljava/time/OffsetTime;)Z',
  );

  static final _isEqual =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isEqual(java.time.OffsetTime offsetTime)`
  bool isEqual(OffsetTime? offsetTime) {
    final _$offsetTime = offsetTime?.reference ?? jni$_.jNullReference;
    return _isEqual(
      reference.pointer,
      _id_isEqual as jni$_.JMethodIDPtr,
      _$offsetTime.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  bool operator <(OffsetTime? offsetTime) => compareTo(offsetTime) < 0;

  bool operator <=(OffsetTime? offsetTime) => compareTo(offsetTime) <= 0;

  bool operator >(OffsetTime? offsetTime) => compareTo(offsetTime) > 0;

  bool operator >=(OffsetTime? offsetTime) => compareTo(offsetTime) >= 0;
}

final class $OffsetTime$NullableType extends jni$_.JObjType<OffsetTime?> {
  @jni$_.internal
  const $OffsetTime$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/OffsetTime;';

  @jni$_.internal
  @core$_.override
  OffsetTime? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : OffsetTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OffsetTime?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OffsetTime$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($OffsetTime$NullableType) &&
      other is $OffsetTime$NullableType;
}

final class $OffsetTime$Type extends jni$_.JObjType<OffsetTime> {
  @jni$_.internal
  const $OffsetTime$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/OffsetTime;';

  @jni$_.internal
  @core$_.override
  OffsetTime fromReference(jni$_.JReference reference) =>
      OffsetTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OffsetTime?> get nullableType =>
      const $OffsetTime$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OffsetTime$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($OffsetTime$Type) && other is $OffsetTime$Type;
}

/// from: `java.time.Period`
class Period extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Period> $type;

  @jni$_.internal
  Period.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Period');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Period$NullableType();
  static const type = $Period$Type();
  static final _id_ZERO = _class.staticFieldId(r'ZERO', r'Ljava/time/Period;');

  /// from: `static public final java.time.Period ZERO`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? get ZERO => _id_ZERO.get(_class, const $Period$NullableType());

  static final _id_ofYears = _class.staticMethodId(
    r'ofYears',
    r'(I)Ljava/time/Period;',
  );

  static final _ofYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Period ofYears(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? ofYears(int i) => _ofYears(
    _class.reference.pointer,
    _id_ofYears as jni$_.JMethodIDPtr,
    i,
  ).object<Period?>(const $Period$NullableType());

  static final _id_ofMonths = _class.staticMethodId(
    r'ofMonths',
    r'(I)Ljava/time/Period;',
  );

  static final _ofMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Period ofMonths(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? ofMonths(int i) => _ofMonths(
    _class.reference.pointer,
    _id_ofMonths as jni$_.JMethodIDPtr,
    i,
  ).object<Period?>(const $Period$NullableType());

  static final _id_ofWeeks = _class.staticMethodId(
    r'ofWeeks',
    r'(I)Ljava/time/Period;',
  );

  static final _ofWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Period ofWeeks(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? ofWeeks(int i) => _ofWeeks(
    _class.reference.pointer,
    _id_ofWeeks as jni$_.JMethodIDPtr,
    i,
  ).object<Period?>(const $Period$NullableType());

  static final _id_ofDays = _class.staticMethodId(
    r'ofDays',
    r'(I)Ljava/time/Period;',
  );

  static final _ofDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Period ofDays(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? ofDays(int i) => _ofDays(
    _class.reference.pointer,
    _id_ofDays as jni$_.JMethodIDPtr,
    i,
  ).object<Period?>(const $Period$NullableType());

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(III)Ljava/time/Period;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.Period of(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? of(int i, int i1, int i2) => _of(
    _class.reference.pointer,
    _id_of as jni$_.JMethodIDPtr,
    i,
    i1,
    i2,
  ).object<Period?>(const $Period$NullableType());

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Period;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Period from(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? from(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/Period;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Period parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_between = _class.staticMethodId(
    r'between',
    r'(Ljava/time/LocalDate;Ljava/time/LocalDate;)Ljava/time/Period;',
  );

  static final _between =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Period between(java.time.LocalDate localDate, java.time.LocalDate localDate1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Period? between(LocalDate? localDate, LocalDate? localDate1) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    final _$localDate1 = localDate1?.reference ?? jni$_.jNullReference;
    return _between(
      _class.reference.pointer,
      _id_between as jni$_.JMethodIDPtr,
      _$localDate.pointer,
      _$localDate1.pointer,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long get(java.time.temporal.TemporalUnit temporalUnit)`
  int get(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_getUnits = _class.instanceMethodId(
    r'getUnits',
    r'()Ljava/util/List;',
  );

  static final _getUnits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<java.time.temporal.TemporalUnit> getUnits()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getUnits() => _getUnits(
    reference.pointer,
    _id_getUnits as jni$_.JMethodIDPtr,
  ).object<jni$_.JList<jni$_.JObject?>?>(
    const jni$_.JListNullableType<jni$_.JObject?>(jni$_.JObjectNullableType()),
  );

  static final _id_getChronology = _class.instanceMethodId(
    r'getChronology',
    r'()Ljava/time/chrono/IsoChronology;',
  );

  static final _getChronology =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.chrono.IsoChronology getChronology()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChronology() => _getChronology(
    reference.pointer,
    _id_getChronology as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_isZero = _class.instanceMethodId(r'isZero', r'()Z');

  static final _isZero =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isZero()`
  bool isZero() =>
      _isZero(reference.pointer, _id_isZero as jni$_.JMethodIDPtr).boolean;

  static final _id_isNegative = _class.instanceMethodId(r'isNegative', r'()Z');

  static final _isNegative =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isNegative()`
  bool isNegative() =>
      _isNegative(
        reference.pointer,
        _id_isNegative as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_getYears = _class.instanceMethodId(r'getYears', r'()I');

  static final _getYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getYears()`
  int getYears() =>
      _getYears(reference.pointer, _id_getYears as jni$_.JMethodIDPtr).integer;

  static final _id_getMonths = _class.instanceMethodId(r'getMonths', r'()I');

  static final _getMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMonths()`
  int getMonths() =>
      _getMonths(
        reference.pointer,
        _id_getMonths as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getDays = _class.instanceMethodId(r'getDays', r'()I');

  static final _getDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDays()`
  int getDays() =>
      _getDays(reference.pointer, _id_getDays as jni$_.JMethodIDPtr).integer;

  static final _id_withYears = _class.instanceMethodId(
    r'withYears',
    r'(I)Ljava/time/Period;',
  );

  static final _withYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period withYears(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? withYears(int i) => _withYears(
    reference.pointer,
    _id_withYears as jni$_.JMethodIDPtr,
    i,
  ).object<Period?>(const $Period$NullableType());

  static final _id_withMonths = _class.instanceMethodId(
    r'withMonths',
    r'(I)Ljava/time/Period;',
  );

  static final _withMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period withMonths(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? withMonths(int i) => _withMonths(
    reference.pointer,
    _id_withMonths as jni$_.JMethodIDPtr,
    i,
  ).object<Period?>(const $Period$NullableType());

  static final _id_withDays = _class.instanceMethodId(
    r'withDays',
    r'(I)Ljava/time/Period;',
  );

  static final _withDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period withDays(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? withDays(int i) => _withDays(
    reference.pointer,
    _id_withDays as jni$_.JMethodIDPtr,
    i,
  ).object<Period?>(const $Period$NullableType());

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Period;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Period plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/Period;',
  );

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? plusYears(int j) => _plusYears(
    reference.pointer,
    _id_plusYears as jni$_.JMethodIDPtr,
    j,
  ).object<Period?>(const $Period$NullableType());

  static final _id_plusMonths = _class.instanceMethodId(
    r'plusMonths',
    r'(J)Ljava/time/Period;',
  );

  static final _plusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period plusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? plusMonths(int j) => _plusMonths(
    reference.pointer,
    _id_plusMonths as jni$_.JMethodIDPtr,
    j,
  ).object<Period?>(const $Period$NullableType());

  static final _id_plusDays = _class.instanceMethodId(
    r'plusDays',
    r'(J)Ljava/time/Period;',
  );

  static final _plusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period plusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? plusDays(int j) => _plusDays(
    reference.pointer,
    _id_plusDays as jni$_.JMethodIDPtr,
    j,
  ).object<Period?>(const $Period$NullableType());

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Period;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Period minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/Period;',
  );

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? minusYears(int j) => _minusYears(
    reference.pointer,
    _id_minusYears as jni$_.JMethodIDPtr,
    j,
  ).object<Period?>(const $Period$NullableType());

  static final _id_minusMonths = _class.instanceMethodId(
    r'minusMonths',
    r'(J)Ljava/time/Period;',
  );

  static final _minusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period minusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? minusMonths(int j) => _minusMonths(
    reference.pointer,
    _id_minusMonths as jni$_.JMethodIDPtr,
    j,
  ).object<Period?>(const $Period$NullableType());

  static final _id_minusDays = _class.instanceMethodId(
    r'minusDays',
    r'(J)Ljava/time/Period;',
  );

  static final _minusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period minusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? minusDays(int j) => _minusDays(
    reference.pointer,
    _id_minusDays as jni$_.JMethodIDPtr,
    j,
  ).object<Period?>(const $Period$NullableType());

  static final _id_multipliedBy = _class.instanceMethodId(
    r'multipliedBy',
    r'(I)Ljava/time/Period;',
  );

  static final _multipliedBy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Period multipliedBy(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? multipliedBy(int i) => _multipliedBy(
    reference.pointer,
    _id_multipliedBy as jni$_.JMethodIDPtr,
    i,
  ).object<Period?>(const $Period$NullableType());

  static final _id_negated = _class.instanceMethodId(
    r'negated',
    r'()Ljava/time/Period;',
  );

  static final _negated =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Period negated()`
  /// The returned object must be released after use, by calling the [release] method.
  Period? negated() => _negated(
    reference.pointer,
    _id_negated as jni$_.JMethodIDPtr,
  ).object<Period?>(const $Period$NullableType());

  static final _id_normalized = _class.instanceMethodId(
    r'normalized',
    r'()Ljava/time/Period;',
  );

  static final _normalized =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Period normalized()`
  /// The returned object must be released after use, by calling the [release] method.
  Period? normalized() => _normalized(
    reference.pointer,
    _id_normalized as jni$_.JMethodIDPtr,
  ).object<Period?>(const $Period$NullableType());

  static final _id_toTotalMonths = _class.instanceMethodId(
    r'toTotalMonths',
    r'()J',
  );

  static final _toTotalMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toTotalMonths()`
  int toTotalMonths() =>
      _toTotalMonths(
        reference.pointer,
        _id_toTotalMonths as jni$_.JMethodIDPtr,
      ).long;

  static final _id_addTo = _class.instanceMethodId(
    r'addTo',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _addTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal addTo(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? addTo(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _addTo(
      reference.pointer,
      _id_addTo as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_subtractFrom = _class.instanceMethodId(
    r'subtractFrom',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _subtractFrom =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal subtractFrom(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? subtractFrom(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _subtractFrom(
      reference.pointer,
      _id_subtractFrom as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $Period$NullableType extends jni$_.JObjType<Period?> {
  @jni$_.internal
  const $Period$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Period;';

  @jni$_.internal
  @core$_.override
  Period? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Period.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Period?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Period$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Period$NullableType) &&
      other is $Period$NullableType;
}

final class $Period$Type extends jni$_.JObjType<Period> {
  @jni$_.internal
  const $Period$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Period;';

  @jni$_.internal
  @core$_.override
  Period fromReference(jni$_.JReference reference) =>
      Period.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Period?> get nullableType => const $Period$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Period$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Period$Type) && other is $Period$Type;
}

/// from: `java.time.Month`
class Month extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Month> $type;

  @jni$_.internal
  Month.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Month');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Month$NullableType();
  static const type = $Month$Type();
  static final _id_JANUARY = _class.staticFieldId(
    r'JANUARY',
    r'Ljava/time/Month;',
  );

  /// from: `static public final java.time.Month JANUARY`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get JANUARY => _id_JANUARY.get(_class, const $Month$Type());

  static final _id_FEBRUARY = _class.staticFieldId(
    r'FEBRUARY',
    r'Ljava/time/Month;',
  );

  /// from: `static public final java.time.Month FEBRUARY`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get FEBRUARY => _id_FEBRUARY.get(_class, const $Month$Type());

  static final _id_MARCH = _class.staticFieldId(r'MARCH', r'Ljava/time/Month;');

  /// from: `static public final java.time.Month MARCH`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get MARCH => _id_MARCH.get(_class, const $Month$Type());

  static final _id_APRIL = _class.staticFieldId(r'APRIL', r'Ljava/time/Month;');

  /// from: `static public final java.time.Month APRIL`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get APRIL => _id_APRIL.get(_class, const $Month$Type());

  static final _id_MAY = _class.staticFieldId(r'MAY', r'Ljava/time/Month;');

  /// from: `static public final java.time.Month MAY`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get MAY => _id_MAY.get(_class, const $Month$Type());

  static final _id_JUNE = _class.staticFieldId(r'JUNE', r'Ljava/time/Month;');

  /// from: `static public final java.time.Month JUNE`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get JUNE => _id_JUNE.get(_class, const $Month$Type());

  static final _id_JULY = _class.staticFieldId(r'JULY', r'Ljava/time/Month;');

  /// from: `static public final java.time.Month JULY`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get JULY => _id_JULY.get(_class, const $Month$Type());

  static final _id_AUGUST = _class.staticFieldId(
    r'AUGUST',
    r'Ljava/time/Month;',
  );

  /// from: `static public final java.time.Month AUGUST`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get AUGUST => _id_AUGUST.get(_class, const $Month$Type());

  static final _id_SEPTEMBER = _class.staticFieldId(
    r'SEPTEMBER',
    r'Ljava/time/Month;',
  );

  /// from: `static public final java.time.Month SEPTEMBER`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get SEPTEMBER => _id_SEPTEMBER.get(_class, const $Month$Type());

  static final _id_OCTOBER = _class.staticFieldId(
    r'OCTOBER',
    r'Ljava/time/Month;',
  );

  /// from: `static public final java.time.Month OCTOBER`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get OCTOBER => _id_OCTOBER.get(_class, const $Month$Type());

  static final _id_NOVEMBER = _class.staticFieldId(
    r'NOVEMBER',
    r'Ljava/time/Month;',
  );

  /// from: `static public final java.time.Month NOVEMBER`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get NOVEMBER => _id_NOVEMBER.get(_class, const $Month$Type());

  static final _id_DECEMBER = _class.staticFieldId(
    r'DECEMBER',
    r'Ljava/time/Month;',
  );

  /// from: `static public final java.time.Month DECEMBER`
  /// The returned object must be released after use, by calling the [release] method.
  static Month get DECEMBER => _id_DECEMBER.get(_class, const $Month$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/time/Month;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.Month[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Month?>? values() => _values(
    _class.reference.pointer,
    _id_values as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<Month?>?>(
    const jni$_.JArrayNullableType<Month?>($Month$NullableType()),
  );

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/time/Month;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Month valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Month? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Month?>(const $Month$NullableType());
  }

  static final _id_of = _class.staticMethodId(r'of', r'(I)Ljava/time/Month;');

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Month of(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Month? of(int i) => _of(
    _class.reference.pointer,
    _id_of as jni$_.JMethodIDPtr,
    i,
  ).object<Month?>(const $Month$NullableType());

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/Month;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Month from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static Month? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<Month?>(const $Month$NullableType());
  }

  static final _id_getValue = _class.instanceMethodId(r'getValue', r'()I');

  static final _getValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getValue()`
  int getValue() =>
      _getValue(reference.pointer, _id_getValue as jni$_.JMethodIDPtr).integer;

  static final _id_getDisplayName = _class.instanceMethodId(
    r'getDisplayName',
    r'(Ljava/time/format/TextStyle;Ljava/util/Locale;)Ljava/lang/String;',
  );

  static final _getDisplayName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getDisplayName(java.time.format.TextStyle textStyle, java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayName(
    jni$_.JObject? textStyle,
    jni$_.JObject? locale,
  ) {
    final _$textStyle = textStyle?.reference ?? jni$_.jNullReference;
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDisplayName(
      reference.pointer,
      _id_getDisplayName as jni$_.JMethodIDPtr,
      _$textStyle.pointer,
      _$locale.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(J)Ljava/time/Month;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Month plus(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Month? plus(int j) => _plus(
    reference.pointer,
    _id_plus as jni$_.JMethodIDPtr,
    j,
  ).object<Month?>(const $Month$NullableType());

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(J)Ljava/time/Month;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Month minus(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Month? minus(int j) => _minus(
    reference.pointer,
    _id_minus as jni$_.JMethodIDPtr,
    j,
  ).object<Month?>(const $Month$NullableType());

  static final _id_length = _class.instanceMethodId(r'length', r'(Z)I');

  static final _length =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int length(boolean z)`
  int length(bool z) =>
      _length(
        reference.pointer,
        _id_length as jni$_.JMethodIDPtr,
        z ? 1 : 0,
      ).integer;

  static final _id_minLength = _class.instanceMethodId(r'minLength', r'()I');

  static final _minLength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int minLength()`
  int minLength() =>
      _minLength(
        reference.pointer,
        _id_minLength as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_maxLength = _class.instanceMethodId(r'maxLength', r'()I');

  static final _maxLength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int maxLength()`
  int maxLength() =>
      _maxLength(
        reference.pointer,
        _id_maxLength as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_firstDayOfYear = _class.instanceMethodId(
    r'firstDayOfYear',
    r'(Z)I',
  );

  static final _firstDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int firstDayOfYear(boolean z)`
  int firstDayOfYear(bool z) =>
      _firstDayOfYear(
        reference.pointer,
        _id_firstDayOfYear as jni$_.JMethodIDPtr,
        z ? 1 : 0,
      ).integer;

  static final _id_firstMonthOfQuarter = _class.instanceMethodId(
    r'firstMonthOfQuarter',
    r'()Ljava/time/Month;',
  );

  static final _firstMonthOfQuarter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Month firstMonthOfQuarter()`
  /// The returned object must be released after use, by calling the [release] method.
  Month? firstMonthOfQuarter() => _firstMonthOfQuarter(
    reference.pointer,
    _id_firstMonthOfQuarter as jni$_.JMethodIDPtr,
  ).object<Month?>(const $Month$NullableType());

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $Month$NullableType extends jni$_.JObjType<Month?> {
  @jni$_.internal
  const $Month$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Month;';

  @jni$_.internal
  @core$_.override
  Month? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Month.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Month?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Month$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Month$NullableType) &&
      other is $Month$NullableType;
}

final class $Month$Type extends jni$_.JObjType<Month> {
  @jni$_.internal
  const $Month$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Month;';

  @jni$_.internal
  @core$_.override
  Month fromReference(jni$_.JReference reference) =>
      Month.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Month?> get nullableType => const $Month$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Month$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Month$Type) && other is $Month$Type;
}

/// from: `java.time.MonthDay`
class MonthDay extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MonthDay> $type;

  @jni$_.internal
  MonthDay.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/MonthDay');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MonthDay$NullableType();
  static const type = $MonthDay$Type();
  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/MonthDay;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.MonthDay now()`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? now() => _now(
    _class.reference.pointer,
    _id_now as jni$_.JMethodIDPtr,
  ).object<MonthDay?>(const $MonthDay$NullableType());

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/MonthDay;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.MonthDay now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/MonthDay;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.MonthDay now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/time/Month;I)Ljava/time/MonthDay;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public java.time.MonthDay of(java.time.Month month, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? of(Month? month, int i) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$month.pointer,
      i,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(II)Ljava/time/MonthDay;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.MonthDay of(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? of$1(int i, int i1) => _of$1(
    _class.reference.pointer,
    _id_of$1 as jni$_.JMethodIDPtr,
    i,
    i1,
  ).object<MonthDay?>(const $MonthDay$NullableType());

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/MonthDay;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.MonthDay from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/MonthDay;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.MonthDay parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/MonthDay;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.MonthDay parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static MonthDay? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getMonthValue = _class.instanceMethodId(
    r'getMonthValue',
    r'()I',
  );

  static final _getMonthValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMonthValue()`
  int getMonthValue() =>
      _getMonthValue(
        reference.pointer,
        _id_getMonthValue as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()Ljava/time/Month;',
  );

  static final _getMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  Month? getMonth() => _getMonth(
    reference.pointer,
    _id_getMonth as jni$_.JMethodIDPtr,
  ).object<Month?>(const $Month$NullableType());

  static final _id_getDayOfMonth = _class.instanceMethodId(
    r'getDayOfMonth',
    r'()I',
  );

  static final _getDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfMonth()`
  int getDayOfMonth() =>
      _getDayOfMonth(
        reference.pointer,
        _id_getDayOfMonth as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_isValidYear = _class.instanceMethodId(
    r'isValidYear',
    r'(I)Z',
  );

  static final _isValidYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean isValidYear(int i)`
  bool isValidYear(int i) =>
      _isValidYear(
        reference.pointer,
        _id_isValidYear as jni$_.JMethodIDPtr,
        i,
      ).boolean;

  static final _id_withMonth = _class.instanceMethodId(
    r'withMonth',
    r'(I)Ljava/time/MonthDay;',
  );

  static final _withMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.MonthDay withMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MonthDay? withMonth(int i) => _withMonth(
    reference.pointer,
    _id_withMonth as jni$_.JMethodIDPtr,
    i,
  ).object<MonthDay?>(const $MonthDay$NullableType());

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/Month;)Ljava/time/MonthDay;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.MonthDay with(java.time.Month month)`
  /// The returned object must be released after use, by calling the [release] method.
  MonthDay? with$(Month? month) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$month.pointer,
    ).object<MonthDay?>(const $MonthDay$NullableType());
  }

  static final _id_withDayOfMonth = _class.instanceMethodId(
    r'withDayOfMonth',
    r'(I)Ljava/time/MonthDay;',
  );

  static final _withDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.MonthDay withDayOfMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  MonthDay? withDayOfMonth(int i) => _withDayOfMonth(
    reference.pointer,
    _id_withDayOfMonth as jni$_.JMethodIDPtr,
    i,
  ).object<MonthDay?>(const $MonthDay$NullableType());

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atYear = _class.instanceMethodId(
    r'atYear',
    r'(I)Ljava/time/LocalDate;',
  );

  static final _atYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate atYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? atYear(int i) => _atYear(
    reference.pointer,
    _id_atYear as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/MonthDay;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.MonthDay monthDay)`
  int compareTo(MonthDay? monthDay) {
    final _$monthDay = monthDay?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$monthDay.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/MonthDay;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.MonthDay monthDay)`
  bool isAfter(MonthDay? monthDay) {
    final _$monthDay = monthDay?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$monthDay.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/MonthDay;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.MonthDay monthDay)`
  bool isBefore(MonthDay? monthDay) {
    final _$monthDay = monthDay?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$monthDay.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  bool operator <(MonthDay? monthDay) => compareTo(monthDay) < 0;

  bool operator <=(MonthDay? monthDay) => compareTo(monthDay) <= 0;

  bool operator >(MonthDay? monthDay) => compareTo(monthDay) > 0;

  bool operator >=(MonthDay? monthDay) => compareTo(monthDay) >= 0;
}

final class $MonthDay$NullableType extends jni$_.JObjType<MonthDay?> {
  @jni$_.internal
  const $MonthDay$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/MonthDay;';

  @jni$_.internal
  @core$_.override
  MonthDay? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : MonthDay.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MonthDay?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MonthDay$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($MonthDay$NullableType) &&
      other is $MonthDay$NullableType;
}

final class $MonthDay$Type extends jni$_.JObjType<MonthDay> {
  @jni$_.internal
  const $MonthDay$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/MonthDay;';

  @jni$_.internal
  @core$_.override
  MonthDay fromReference(jni$_.JReference reference) =>
      MonthDay.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MonthDay?> get nullableType => const $MonthDay$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($MonthDay$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($MonthDay$Type) && other is $MonthDay$Type;
}

/// from: `java.time.Instant`
class Instant extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Instant> $type;

  @jni$_.internal
  Instant.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Instant');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Instant$NullableType();
  static const type = $Instant$Type();
  static final _id_EPOCH = _class.staticFieldId(
    r'EPOCH',
    r'Ljava/time/Instant;',
  );

  /// from: `static public final java.time.Instant EPOCH`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? get EPOCH =>
      _id_EPOCH.get(_class, const $Instant$NullableType());

  static final _id_MIN = _class.staticFieldId(r'MIN', r'Ljava/time/Instant;');

  /// from: `static public final java.time.Instant MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? get MIN => _id_MIN.get(_class, const $Instant$NullableType());

  static final _id_MAX = _class.staticFieldId(r'MAX', r'Ljava/time/Instant;');

  /// from: `static public final java.time.Instant MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? get MAX => _id_MAX.get(_class, const $Instant$NullableType());

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/Instant;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.Instant now()`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? now() => _now(
    _class.reference.pointer,
    _id_now as jni$_.JMethodIDPtr,
  ).object<Instant?>(const $Instant$NullableType());

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/Instant;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Instant now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? now$1(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochSecond = _class.staticMethodId(
    r'ofEpochSecond',
    r'(J)Ljava/time/Instant;',
  );

  static final _ofEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Instant ofEpochSecond(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? ofEpochSecond(int j) => _ofEpochSecond(
    _class.reference.pointer,
    _id_ofEpochSecond as jni$_.JMethodIDPtr,
    j,
  ).object<Instant?>(const $Instant$NullableType());

  static final _id_ofEpochSecond$1 = _class.staticMethodId(
    r'ofEpochSecond',
    r'(JJ)Ljava/time/Instant;',
  );

  static final _ofEpochSecond$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.Instant ofEpochSecond(long j, long j1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? ofEpochSecond$1(int j, int j1) => _ofEpochSecond$1(
    _class.reference.pointer,
    _id_ofEpochSecond$1 as jni$_.JMethodIDPtr,
    j,
    j1,
  ).object<Instant?>(const $Instant$NullableType());

  static final _id_ofEpochMilli = _class.staticMethodId(
    r'ofEpochMilli',
    r'(J)Ljava/time/Instant;',
  );

  static final _ofEpochMilli =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Instant ofEpochMilli(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? ofEpochMilli(int j) => _ofEpochMilli(
    _class.reference.pointer,
    _id_ofEpochMilli as jni$_.JMethodIDPtr,
    j,
  ).object<Instant?>(const $Instant$NullableType());

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/Instant;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Instant from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/Instant;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Instant parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getEpochSecond = _class.instanceMethodId(
    r'getEpochSecond',
    r'()J',
  );

  static final _getEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getEpochSecond()`
  int getEpochSecond() =>
      _getEpochSecond(
        reference.pointer,
        _id_getEpochSecond as jni$_.JMethodIDPtr,
      ).long;

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() =>
      _getNano(reference.pointer, _id_getNano as jni$_.JMethodIDPtr).integer;

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/Instant;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/Instant;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.Instant with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Instant;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plusSeconds(int j) => _plusSeconds(
    reference.pointer,
    _id_plusSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<Instant?>(const $Instant$NullableType());

  static final _id_plusMillis = _class.instanceMethodId(
    r'plusMillis',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant plusMillis(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plusMillis(int j) => _plusMillis(
    reference.pointer,
    _id_plusMillis as jni$_.JMethodIDPtr,
    j,
  ).object<Instant?>(const $Instant$NullableType());

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plusNanos(int j) => _plusNanos(
    reference.pointer,
    _id_plusNanos as jni$_.JMethodIDPtr,
    j,
  ).object<Instant?>(const $Instant$NullableType());

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Instant;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Instant minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minusSeconds(int j) => _minusSeconds(
    reference.pointer,
    _id_minusSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<Instant?>(const $Instant$NullableType());

  static final _id_minusMillis = _class.instanceMethodId(
    r'minusMillis',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant minusMillis(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minusMillis(int j) => _minusMillis(
    reference.pointer,
    _id_minusMillis as jni$_.JMethodIDPtr,
    j,
  ).object<Instant?>(const $Instant$NullableType());

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Instant minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minusNanos(int j) => _minusNanos(
    reference.pointer,
    _id_minusNanos as jni$_.JMethodIDPtr,
    j,
  ).object<Instant?>(const $Instant$NullableType());

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_atOffset = _class.instanceMethodId(
    r'atOffset',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _atOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime atOffset(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? atOffset(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _atOffset(
      reference.pointer,
      _id_atOffset as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_atZone = _class.instanceMethodId(
    r'atZone',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _atZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime atZone(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? atZone(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _atZone(
      reference.pointer,
      _id_atZone as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_toEpochMilli = _class.instanceMethodId(
    r'toEpochMilli',
    r'()J',
  );

  static final _toEpochMilli =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toEpochMilli()`
  int toEpochMilli() =>
      _toEpochMilli(
        reference.pointer,
        _id_toEpochMilli as jni$_.JMethodIDPtr,
      ).long;

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/Instant;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.Instant instant)`
  int compareTo(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/Instant;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.Instant instant)`
  bool isAfter(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/Instant;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.Instant instant)`
  bool isBefore(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  bool operator <(Instant? instant) => compareTo(instant) < 0;

  bool operator <=(Instant? instant) => compareTo(instant) <= 0;

  bool operator >(Instant? instant) => compareTo(instant) > 0;

  bool operator >=(Instant? instant) => compareTo(instant) >= 0;
}

final class $Instant$NullableType extends jni$_.JObjType<Instant?> {
  @jni$_.internal
  const $Instant$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Instant;';

  @jni$_.internal
  @core$_.override
  Instant? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Instant.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Instant?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Instant$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Instant$NullableType) &&
      other is $Instant$NullableType;
}

final class $Instant$Type extends jni$_.JObjType<Instant> {
  @jni$_.internal
  const $Instant$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Instant;';

  @jni$_.internal
  @core$_.override
  Instant fromReference(jni$_.JReference reference) =>
      Instant.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Instant?> get nullableType => const $Instant$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Instant$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Instant$Type) && other is $Instant$Type;
}

/// from: `java.time.ZoneId`
class ZoneId extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZoneId> $type;

  @jni$_.internal
  ZoneId.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/ZoneId');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZoneId$NullableType();
  static const type = $ZoneId$Type();
  static final _id_SHORT_IDS = _class.staticFieldId(
    r'SHORT_IDS',
    r'Ljava/util/Map;',
  );

  /// from: `static public final java.util.Map<java.lang.String, java.lang.String> SHORT_IDS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JMap<jni$_.JString?, jni$_.JString?>? get SHORT_IDS =>
      _id_SHORT_IDS.get(
        _class,
        const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
          jni$_.JStringNullableType(),
          jni$_.JStringNullableType(),
        ),
      );

  static final _id_systemDefault = _class.staticMethodId(
    r'systemDefault',
    r'()Ljava/time/ZoneId;',
  );

  static final _systemDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.ZoneId systemDefault()`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneId? systemDefault() => _systemDefault(
    _class.reference.pointer,
    _id_systemDefault as jni$_.JMethodIDPtr,
  ).object<ZoneId?>(const $ZoneId$NullableType());

  static final _id_getAvailableZoneIds = _class.staticMethodId(
    r'getAvailableZoneIds',
    r'()Ljava/util/Set;',
  );

  static final _getAvailableZoneIds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Set<java.lang.String> getAvailableZoneIds()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JSet<jni$_.JString?>? getAvailableZoneIds() =>
      _getAvailableZoneIds(
        _class.reference.pointer,
        _id_getAvailableZoneIds as jni$_.JMethodIDPtr,
      ).object<jni$_.JSet<jni$_.JString?>?>(
        const jni$_.JSetNullableType<jni$_.JString?>(
          jni$_.JStringNullableType(),
        ),
      );

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/String;Ljava/util/Map;)Ljava/time/ZoneId;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZoneId of(java.lang.String string, java.util.Map<java.lang.String, java.lang.String> map)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneId? of(
    jni$_.JString? string,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? map,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$map.pointer,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/String;)Ljava/time/ZoneId;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZoneId of(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneId? of$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_ofOffset = _class.staticMethodId(
    r'ofOffset',
    r'(Ljava/lang/String;Ljava/time/ZoneOffset;)Ljava/time/ZoneId;',
  );

  static final _ofOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZoneId ofOffset(java.lang.String string, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneId? ofOffset(jni$_.JString? string, ZoneOffset? zoneOffset) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _ofOffset(
      _class.reference.pointer,
      _id_ofOffset as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$zoneOffset.pointer,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/ZoneId;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZoneId from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneId? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getId() => _getId(
    reference.pointer,
    _id_getId as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getDisplayName = _class.instanceMethodId(
    r'getDisplayName',
    r'(Ljava/time/format/TextStyle;Ljava/util/Locale;)Ljava/lang/String;',
  );

  static final _getDisplayName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getDisplayName(java.time.format.TextStyle textStyle, java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayName(
    jni$_.JObject? textStyle,
    jni$_.JObject? locale,
  ) {
    final _$textStyle = textStyle?.reference ?? jni$_.jNullReference;
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDisplayName(
      reference.pointer,
      _id_getDisplayName as jni$_.JMethodIDPtr,
      _$textStyle.pointer,
      _$locale.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getRules = _class.instanceMethodId(
    r'getRules',
    r'()Ljava/time/zone/ZoneRules;',
  );

  static final _getRules =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.time.zone.ZoneRules getRules()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRules() => _getRules(
    reference.pointer,
    _id_getRules as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_normalized = _class.instanceMethodId(
    r'normalized',
    r'()Ljava/time/ZoneId;',
  );

  static final _normalized =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZoneId normalized()`
  /// The returned object must be released after use, by calling the [release] method.
  ZoneId? normalized() => _normalized(
    reference.pointer,
    _id_normalized as jni$_.JMethodIDPtr,
  ).object<ZoneId?>(const $ZoneId$NullableType());

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $ZoneId$NullableType extends jni$_.JObjType<ZoneId?> {
  @jni$_.internal
  const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneId;';

  @jni$_.internal
  @core$_.override
  ZoneId? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ZoneId.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneId?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZoneId$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ZoneId$NullableType) &&
      other is $ZoneId$NullableType;
}

final class $ZoneId$Type extends jni$_.JObjType<ZoneId> {
  @jni$_.internal
  const $ZoneId$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneId;';

  @jni$_.internal
  @core$_.override
  ZoneId fromReference(jni$_.JReference reference) =>
      ZoneId.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneId?> get nullableType => const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZoneId$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ZoneId$Type) && other is $ZoneId$Type;
}

/// from: `java.time.OffsetDateTime`
class OffsetDateTime extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OffsetDateTime> $type;

  @jni$_.internal
  OffsetDateTime.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/OffsetDateTime');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OffsetDateTime$NullableType();
  static const type = $OffsetDateTime$Type();
  static final _id_MIN = _class.staticFieldId(
    r'MIN',
    r'Ljava/time/OffsetDateTime;',
  );

  /// from: `static public final java.time.OffsetDateTime MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? get MIN =>
      _id_MIN.get(_class, const $OffsetDateTime$NullableType());

  static final _id_MAX = _class.staticFieldId(
    r'MAX',
    r'Ljava/time/OffsetDateTime;',
  );

  /// from: `static public final java.time.OffsetDateTime MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? get MAX =>
      _id_MAX.get(_class, const $OffsetDateTime$NullableType());

  static final _id_timeLineOrder = _class.staticMethodId(
    r'timeLineOrder',
    r'()Ljava/util/Comparator;',
  );

  static final _timeLineOrder =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Comparator<java.time.OffsetDateTime> timeLineOrder()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? timeLineOrder() => _timeLineOrder(
    _class.reference.pointer,
    _id_timeLineOrder as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/OffsetDateTime;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.OffsetDateTime now()`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? now() => _now(
    _class.reference.pointer,
    _id_now as jni$_.JMethodIDPtr,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/OffsetDateTime;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/OffsetDateTime;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDate;Ljava/time/LocalTime;Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime of(java.time.LocalDate localDate, java.time.LocalTime localTime, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? of(
    LocalDate? localDate,
    LocalTime? localTime,
    ZoneOffset? zoneOffset,
  ) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$localDate.pointer,
      _$localTime.pointer,
      _$zoneOffset.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime of(java.time.LocalDateTime localDateTime, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? of$1(
    LocalDateTime? localDateTime,
    ZoneOffset? zoneOffset,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$zoneOffset.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(IIIIIIILjava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _of$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime of(int i, int i1, int i2, int i3, int i4, int i5, int i6, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? of$2(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
    ZoneOffset? zoneOffset,
  ) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _of$2(
      _class.reference.pointer,
      _id_of$2 as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
      i4,
      i5,
      i6,
      _$zoneOffset.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/OffsetDateTime;',
  );

  static final _ofInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime ofInstant(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? ofInstant(Instant? instant, ZoneId? zoneId) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant(
      _class.reference.pointer,
      _id_ofInstant as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zoneId.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/OffsetDateTime;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/OffsetDateTime;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/OffsetDateTime;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.OffsetDateTime parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static OffsetDateTime? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getOffset = _class.instanceMethodId(
    r'getOffset',
    r'()Ljava/time/ZoneOffset;',
  );

  static final _getOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZoneOffset getOffset()`
  /// The returned object must be released after use, by calling the [release] method.
  ZoneOffset? getOffset() => _getOffset(
    reference.pointer,
    _id_getOffset as jni$_.JMethodIDPtr,
  ).object<ZoneOffset?>(const $ZoneOffset$NullableType());

  static final _id_withOffsetSameLocal = _class.instanceMethodId(
    r'withOffsetSameLocal',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _withOffsetSameLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime withOffsetSameLocal(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withOffsetSameLocal(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _withOffsetSameLocal(
      reference.pointer,
      _id_withOffsetSameLocal as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_withOffsetSameInstant = _class.instanceMethodId(
    r'withOffsetSameInstant',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _withOffsetSameInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime withOffsetSameInstant(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withOffsetSameInstant(ZoneOffset? zoneOffset) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _withOffsetSameInstant(
      reference.pointer,
      _id_withOffsetSameInstant as jni$_.JMethodIDPtr,
      _$zoneOffset.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_toLocalDateTime = _class.instanceMethodId(
    r'toLocalDateTime',
    r'()Ljava/time/LocalDateTime;',
  );

  static final _toLocalDateTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDateTime toLocalDateTime()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? toLocalDateTime() => _toLocalDateTime(
    reference.pointer,
    _id_toLocalDateTime as jni$_.JMethodIDPtr,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_toLocalDate = _class.instanceMethodId(
    r'toLocalDate',
    r'()Ljava/time/LocalDate;',
  );

  static final _toLocalDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDate toLocalDate()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? toLocalDate() => _toLocalDate(
    reference.pointer,
    _id_toLocalDate as jni$_.JMethodIDPtr,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_getYear = _class.instanceMethodId(r'getYear', r'()I');

  static final _getYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getYear()`
  int getYear() =>
      _getYear(reference.pointer, _id_getYear as jni$_.JMethodIDPtr).integer;

  static final _id_getMonthValue = _class.instanceMethodId(
    r'getMonthValue',
    r'()I',
  );

  static final _getMonthValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMonthValue()`
  int getMonthValue() =>
      _getMonthValue(
        reference.pointer,
        _id_getMonthValue as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()Ljava/time/Month;',
  );

  static final _getMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  Month? getMonth() => _getMonth(
    reference.pointer,
    _id_getMonth as jni$_.JMethodIDPtr,
  ).object<Month?>(const $Month$NullableType());

  static final _id_getDayOfMonth = _class.instanceMethodId(
    r'getDayOfMonth',
    r'()I',
  );

  static final _getDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfMonth()`
  int getDayOfMonth() =>
      _getDayOfMonth(
        reference.pointer,
        _id_getDayOfMonth as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getDayOfYear = _class.instanceMethodId(
    r'getDayOfYear',
    r'()I',
  );

  static final _getDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfYear()`
  int getDayOfYear() =>
      _getDayOfYear(
        reference.pointer,
        _id_getDayOfYear as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getDayOfWeek = _class.instanceMethodId(
    r'getDayOfWeek',
    r'()Ljava/time/DayOfWeek;',
  );

  static final _getDayOfWeek =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.DayOfWeek getDayOfWeek()`
  /// The returned object must be released after use, by calling the [release] method.
  DayOfWeek? getDayOfWeek() => _getDayOfWeek(
    reference.pointer,
    _id_getDayOfWeek as jni$_.JMethodIDPtr,
  ).object<DayOfWeek?>(const $DayOfWeek$NullableType());

  static final _id_toLocalTime = _class.instanceMethodId(
    r'toLocalTime',
    r'()Ljava/time/LocalTime;',
  );

  static final _toLocalTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalTime toLocalTime()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalTime? toLocalTime() => _toLocalTime(
    reference.pointer,
    _id_toLocalTime as jni$_.JMethodIDPtr,
  ).object<LocalTime?>(const $LocalTime$NullableType());

  static final _id_getHour = _class.instanceMethodId(r'getHour', r'()I');

  static final _getHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getHour()`
  int getHour() =>
      _getHour(reference.pointer, _id_getHour as jni$_.JMethodIDPtr).integer;

  static final _id_getMinute = _class.instanceMethodId(r'getMinute', r'()I');

  static final _getMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMinute()`
  int getMinute() =>
      _getMinute(
        reference.pointer,
        _id_getMinute as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getSecond = _class.instanceMethodId(r'getSecond', r'()I');

  static final _getSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSecond()`
  int getSecond() =>
      _getSecond(
        reference.pointer,
        _id_getSecond as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getNano()`
  int getNano() =>
      _getNano(reference.pointer, _id_getNano as jni$_.JMethodIDPtr).integer;

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/OffsetDateTime;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/OffsetDateTime;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_withYear = _class.instanceMethodId(
    r'withYear',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withYear(int i) => _withYear(
    reference.pointer,
    _id_withYear as jni$_.JMethodIDPtr,
    i,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_withMonth = _class.instanceMethodId(
    r'withMonth',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withMonth(int i) => _withMonth(
    reference.pointer,
    _id_withMonth as jni$_.JMethodIDPtr,
    i,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_withDayOfMonth = _class.instanceMethodId(
    r'withDayOfMonth',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withDayOfMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withDayOfMonth(int i) => _withDayOfMonth(
    reference.pointer,
    _id_withDayOfMonth as jni$_.JMethodIDPtr,
    i,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_withDayOfYear = _class.instanceMethodId(
    r'withDayOfYear',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withDayOfYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withDayOfYear(int i) => _withDayOfYear(
    reference.pointer,
    _id_withDayOfYear as jni$_.JMethodIDPtr,
    i,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_withHour = _class.instanceMethodId(
    r'withHour',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withHour =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withHour(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withHour(int i) => _withHour(
    reference.pointer,
    _id_withHour as jni$_.JMethodIDPtr,
    i,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_withMinute = _class.instanceMethodId(
    r'withMinute',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withMinute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withMinute(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withMinute(int i) => _withMinute(
    reference.pointer,
    _id_withMinute as jni$_.JMethodIDPtr,
    i,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_withSecond = _class.instanceMethodId(
    r'withSecond',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withSecond(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withSecond(int i) => _withSecond(
    reference.pointer,
    _id_withSecond as jni$_.JMethodIDPtr,
    i,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_withNano = _class.instanceMethodId(
    r'withNano',
    r'(I)Ljava/time/OffsetDateTime;',
  );

  static final _withNano =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime withNano(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? withNano(int i) => _withNano(
    reference.pointer,
    _id_withNano as jni$_.JMethodIDPtr,
    i,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/OffsetDateTime;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? truncatedTo(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/OffsetDateTime;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/OffsetDateTime;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusYears(int j) => _plusYears(
    reference.pointer,
    _id_plusYears as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_plusMonths = _class.instanceMethodId(
    r'plusMonths',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusMonths(int j) => _plusMonths(
    reference.pointer,
    _id_plusMonths as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_plusWeeks = _class.instanceMethodId(
    r'plusWeeks',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusWeeks(int j) => _plusWeeks(
    reference.pointer,
    _id_plusWeeks as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_plusDays = _class.instanceMethodId(
    r'plusDays',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusDays(int j) => _plusDays(
    reference.pointer,
    _id_plusDays as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_plusHours = _class.instanceMethodId(
    r'plusHours',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusHours(int j) => _plusHours(
    reference.pointer,
    _id_plusHours as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_plusMinutes = _class.instanceMethodId(
    r'plusMinutes',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusMinutes(int j) => _plusMinutes(
    reference.pointer,
    _id_plusMinutes as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusSeconds(int j) => _plusSeconds(
    reference.pointer,
    _id_plusSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? plusNanos(int j) => _plusNanos(
    reference.pointer,
    _id_plusNanos as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/OffsetDateTime;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/OffsetDateTime;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusYears(int j) => _minusYears(
    reference.pointer,
    _id_minusYears as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_minusMonths = _class.instanceMethodId(
    r'minusMonths',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusMonths(int j) => _minusMonths(
    reference.pointer,
    _id_minusMonths as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_minusWeeks = _class.instanceMethodId(
    r'minusWeeks',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusWeeks(int j) => _minusWeeks(
    reference.pointer,
    _id_minusWeeks as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_minusDays = _class.instanceMethodId(
    r'minusDays',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusDays(int j) => _minusDays(
    reference.pointer,
    _id_minusDays as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_minusHours = _class.instanceMethodId(
    r'minusHours',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusHours =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusHours(int j) => _minusHours(
    reference.pointer,
    _id_minusHours as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_minusMinutes = _class.instanceMethodId(
    r'minusMinutes',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusMinutes(int j) => _minusMinutes(
    reference.pointer,
    _id_minusMinutes as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusSeconds(int j) => _minusSeconds(
    reference.pointer,
    _id_minusSeconds as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/OffsetDateTime;',
  );

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.OffsetDateTime minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? minusNanos(int j) => _minusNanos(
    reference.pointer,
    _id_minusNanos as jni$_.JMethodIDPtr,
    j,
  ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atZoneSameInstant = _class.instanceMethodId(
    r'atZoneSameInstant',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _atZoneSameInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime atZoneSameInstant(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? atZoneSameInstant(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _atZoneSameInstant(
      reference.pointer,
      _id_atZoneSameInstant as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_atZoneSimilarLocal = _class.instanceMethodId(
    r'atZoneSimilarLocal',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _atZoneSimilarLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime atZoneSimilarLocal(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? atZoneSimilarLocal(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _atZoneSimilarLocal(
      reference.pointer,
      _id_atZoneSimilarLocal as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_toOffsetTime = _class.instanceMethodId(
    r'toOffsetTime',
    r'()Ljava/time/OffsetTime;',
  );

  static final _toOffsetTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.OffsetTime toOffsetTime()`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetTime? toOffsetTime() => _toOffsetTime(
    reference.pointer,
    _id_toOffsetTime as jni$_.JMethodIDPtr,
  ).object<OffsetTime?>(const $OffsetTime$NullableType());

  static final _id_toZonedDateTime = _class.instanceMethodId(
    r'toZonedDateTime',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _toZonedDateTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZonedDateTime toZonedDateTime()`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? toZonedDateTime() => _toZonedDateTime(
    reference.pointer,
    _id_toZonedDateTime as jni$_.JMethodIDPtr,
  ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());

  static final _id_toInstant = _class.instanceMethodId(
    r'toInstant',
    r'()Ljava/time/Instant;',
  );

  static final _toInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Instant toInstant()`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? toInstant() => _toInstant(
    reference.pointer,
    _id_toInstant as jni$_.JMethodIDPtr,
  ).object<Instant?>(const $Instant$NullableType());

  static final _id_toEpochSecond = _class.instanceMethodId(
    r'toEpochSecond',
    r'()J',
  );

  static final _toEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toEpochSecond()`
  int toEpochSecond() =>
      _toEpochSecond(
        reference.pointer,
        _id_toEpochSecond as jni$_.JMethodIDPtr,
      ).long;

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/OffsetDateTime;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.OffsetDateTime offsetDateTime)`
  int compareTo(OffsetDateTime? offsetDateTime) {
    final _$offsetDateTime = offsetDateTime?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$offsetDateTime.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/OffsetDateTime;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.OffsetDateTime offsetDateTime)`
  bool isAfter(OffsetDateTime? offsetDateTime) {
    final _$offsetDateTime = offsetDateTime?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$offsetDateTime.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/OffsetDateTime;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.OffsetDateTime offsetDateTime)`
  bool isBefore(OffsetDateTime? offsetDateTime) {
    final _$offsetDateTime = offsetDateTime?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$offsetDateTime.pointer,
    ).boolean;
  }

  static final _id_isEqual = _class.instanceMethodId(
    r'isEqual',
    r'(Ljava/time/OffsetDateTime;)Z',
  );

  static final _isEqual =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isEqual(java.time.OffsetDateTime offsetDateTime)`
  bool isEqual(OffsetDateTime? offsetDateTime) {
    final _$offsetDateTime = offsetDateTime?.reference ?? jni$_.jNullReference;
    return _isEqual(
      reference.pointer,
      _id_isEqual as jni$_.JMethodIDPtr,
      _$offsetDateTime.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  bool operator <(OffsetDateTime? offsetDateTime) =>
      compareTo(offsetDateTime) < 0;

  bool operator <=(OffsetDateTime? offsetDateTime) =>
      compareTo(offsetDateTime) <= 0;

  bool operator >(OffsetDateTime? offsetDateTime) =>
      compareTo(offsetDateTime) > 0;

  bool operator >=(OffsetDateTime? offsetDateTime) =>
      compareTo(offsetDateTime) >= 0;
}

final class $OffsetDateTime$NullableType
    extends jni$_.JObjType<OffsetDateTime?> {
  @jni$_.internal
  const $OffsetDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/OffsetDateTime;';

  @jni$_.internal
  @core$_.override
  OffsetDateTime? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : OffsetDateTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OffsetDateTime?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OffsetDateTime$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($OffsetDateTime$NullableType) &&
      other is $OffsetDateTime$NullableType;
}

final class $OffsetDateTime$Type extends jni$_.JObjType<OffsetDateTime> {
  @jni$_.internal
  const $OffsetDateTime$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/OffsetDateTime;';

  @jni$_.internal
  @core$_.override
  OffsetDateTime fromReference(jni$_.JReference reference) =>
      OffsetDateTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OffsetDateTime?> get nullableType =>
      const $OffsetDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OffsetDateTime$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($OffsetDateTime$Type) &&
      other is $OffsetDateTime$Type;
}

/// from: `java.time.Year`
class Year extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Year> $type;

  @jni$_.internal
  Year.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Year');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Year$NullableType();
  static const type = $Year$Type();

  /// from: `static public final int MIN_VALUE`
  static const MIN_VALUE = -999999999;

  /// from: `static public final int MAX_VALUE`
  static const MAX_VALUE = 999999999;
  static final _id_now = _class.staticMethodId(r'now', r'()Ljava/time/Year;');

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.Year now()`
  /// The returned object must be released after use, by calling the [release] method.
  static Year? now() => _now(
    _class.reference.pointer,
    _id_now as jni$_.JMethodIDPtr,
  ).object<Year?>(const $Year$NullableType());

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/Year;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Year now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static Year? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/Year;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Year now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static Year? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_of = _class.staticMethodId(r'of', r'(I)Ljava/time/Year;');

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.Year of(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Year? of(int i) => _of(
    _class.reference.pointer,
    _id_of as jni$_.JMethodIDPtr,
    i,
  ).object<Year?>(const $Year$NullableType());

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/Year;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Year from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static Year? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/Year;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Year parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static Year? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/Year;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Year parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static Year? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_isLeap = _class.staticMethodId(r'isLeap', r'(J)Z');

  static final _isLeap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public boolean isLeap(long j)`
  static bool isLeap(int j) =>
      _isLeap(
        _class.reference.pointer,
        _id_isLeap as jni$_.JMethodIDPtr,
        j,
      ).boolean;

  static final _id_getValue = _class.instanceMethodId(r'getValue', r'()I');

  static final _getValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getValue()`
  int getValue() =>
      _getValue(reference.pointer, _id_getValue as jni$_.JMethodIDPtr).integer;

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_isLeap$1 = _class.instanceMethodId(r'isLeap', r'()Z');

  static final _isLeap$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLeap()`
  bool isLeap$1() =>
      _isLeap$1(reference.pointer, _id_isLeap$1 as jni$_.JMethodIDPtr).boolean;

  static final _id_isValidMonthDay = _class.instanceMethodId(
    r'isValidMonthDay',
    r'(Ljava/time/MonthDay;)Z',
  );

  static final _isValidMonthDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isValidMonthDay(java.time.MonthDay monthDay)`
  bool isValidMonthDay(MonthDay? monthDay) {
    final _$monthDay = monthDay?.reference ?? jni$_.jNullReference;
    return _isValidMonthDay(
      reference.pointer,
      _id_isValidMonthDay as jni$_.JMethodIDPtr,
      _$monthDay.pointer,
    ).boolean;
  }

  static final _id_length = _class.instanceMethodId(r'length', r'()I');

  static final _length =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int length()`
  int length() =>
      _length(reference.pointer, _id_length as jni$_.JMethodIDPtr).integer;

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/Year;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Year with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/Year;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.Year with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Year;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Year plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Year;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Year plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/Year;',
  );

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Year plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? plusYears(int j) => _plusYears(
    reference.pointer,
    _id_plusYears as jni$_.JMethodIDPtr,
    j,
  ).object<Year?>(const $Year$NullableType());

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Year;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Year minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Year;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Year minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<Year?>(const $Year$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/Year;',
  );

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.Year minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Year? minusYears(int j) => _minusYears(
    reference.pointer,
    _id_minusYears as jni$_.JMethodIDPtr,
    j,
  ).object<Year?>(const $Year$NullableType());

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atDay = _class.instanceMethodId(
    r'atDay',
    r'(I)Ljava/time/LocalDate;',
  );

  static final _atDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate atDay(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? atDay(int i) => _atDay(
    reference.pointer,
    _id_atDay as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_atMonth = _class.instanceMethodId(
    r'atMonth',
    r'(Ljava/time/Month;)Ljava/time/YearMonth;',
  );

  static final _atMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.YearMonth atMonth(java.time.Month month)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? atMonth(Month? month) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _atMonth(
      reference.pointer,
      _id_atMonth as jni$_.JMethodIDPtr,
      _$month.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_atMonth$1 = _class.instanceMethodId(
    r'atMonth',
    r'(I)Ljava/time/YearMonth;',
  );

  static final _atMonth$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.YearMonth atMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? atMonth$1(int i) => _atMonth$1(
    reference.pointer,
    _id_atMonth$1 as jni$_.JMethodIDPtr,
    i,
  ).object<YearMonth?>(const $YearMonth$NullableType());

  static final _id_atMonthDay = _class.instanceMethodId(
    r'atMonthDay',
    r'(Ljava/time/MonthDay;)Ljava/time/LocalDate;',
  );

  static final _atMonthDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDate atMonthDay(java.time.MonthDay monthDay)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? atMonthDay(MonthDay? monthDay) {
    final _$monthDay = monthDay?.reference ?? jni$_.jNullReference;
    return _atMonthDay(
      reference.pointer,
      _id_atMonthDay as jni$_.JMethodIDPtr,
      _$monthDay.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/Year;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.Year year)`
  int compareTo(Year? year) {
    final _$year = year?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$year.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/Year;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.Year year)`
  bool isAfter(Year? year) {
    final _$year = year?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$year.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/Year;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.Year year)`
  bool isBefore(Year? year) {
    final _$year = year?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$year.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  bool operator <(Year? year) => compareTo(year) < 0;

  bool operator <=(Year? year) => compareTo(year) <= 0;

  bool operator >(Year? year) => compareTo(year) > 0;

  bool operator >=(Year? year) => compareTo(year) >= 0;
}

final class $Year$NullableType extends jni$_.JObjType<Year?> {
  @jni$_.internal
  const $Year$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Year;';

  @jni$_.internal
  @core$_.override
  Year? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Year.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Year?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Year$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Year$NullableType) && other is $Year$NullableType;
}

final class $Year$Type extends jni$_.JObjType<Year> {
  @jni$_.internal
  const $Year$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Year;';

  @jni$_.internal
  @core$_.override
  Year fromReference(jni$_.JReference reference) =>
      Year.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Year?> get nullableType => const $Year$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Year$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Year$Type) && other is $Year$Type;
}

/// from: `java.time.DayOfWeek`
class DayOfWeek extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DayOfWeek> $type;

  @jni$_.internal
  DayOfWeek.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/DayOfWeek');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DayOfWeek$NullableType();
  static const type = $DayOfWeek$Type();
  static final _id_MONDAY = _class.staticFieldId(
    r'MONDAY',
    r'Ljava/time/DayOfWeek;',
  );

  /// from: `static public final java.time.DayOfWeek MONDAY`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek get MONDAY =>
      _id_MONDAY.get(_class, const $DayOfWeek$Type());

  static final _id_TUESDAY = _class.staticFieldId(
    r'TUESDAY',
    r'Ljava/time/DayOfWeek;',
  );

  /// from: `static public final java.time.DayOfWeek TUESDAY`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek get TUESDAY =>
      _id_TUESDAY.get(_class, const $DayOfWeek$Type());

  static final _id_WEDNESDAY = _class.staticFieldId(
    r'WEDNESDAY',
    r'Ljava/time/DayOfWeek;',
  );

  /// from: `static public final java.time.DayOfWeek WEDNESDAY`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek get WEDNESDAY =>
      _id_WEDNESDAY.get(_class, const $DayOfWeek$Type());

  static final _id_THURSDAY = _class.staticFieldId(
    r'THURSDAY',
    r'Ljava/time/DayOfWeek;',
  );

  /// from: `static public final java.time.DayOfWeek THURSDAY`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek get THURSDAY =>
      _id_THURSDAY.get(_class, const $DayOfWeek$Type());

  static final _id_FRIDAY = _class.staticFieldId(
    r'FRIDAY',
    r'Ljava/time/DayOfWeek;',
  );

  /// from: `static public final java.time.DayOfWeek FRIDAY`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek get FRIDAY =>
      _id_FRIDAY.get(_class, const $DayOfWeek$Type());

  static final _id_SATURDAY = _class.staticFieldId(
    r'SATURDAY',
    r'Ljava/time/DayOfWeek;',
  );

  /// from: `static public final java.time.DayOfWeek SATURDAY`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek get SATURDAY =>
      _id_SATURDAY.get(_class, const $DayOfWeek$Type());

  static final _id_SUNDAY = _class.staticFieldId(
    r'SUNDAY',
    r'Ljava/time/DayOfWeek;',
  );

  /// from: `static public final java.time.DayOfWeek SUNDAY`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek get SUNDAY =>
      _id_SUNDAY.get(_class, const $DayOfWeek$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/time/DayOfWeek;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.DayOfWeek[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<DayOfWeek?>? values() => _values(
    _class.reference.pointer,
    _id_values as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<DayOfWeek?>?>(
    const jni$_.JArrayNullableType<DayOfWeek?>($DayOfWeek$NullableType()),
  );

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/time/DayOfWeek;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.DayOfWeek valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<DayOfWeek?>(const $DayOfWeek$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(I)Ljava/time/DayOfWeek;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.DayOfWeek of(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek? of(int i) => _of(
    _class.reference.pointer,
    _id_of as jni$_.JMethodIDPtr,
    i,
  ).object<DayOfWeek?>(const $DayOfWeek$NullableType());

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/DayOfWeek;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.DayOfWeek from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static DayOfWeek? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<DayOfWeek?>(const $DayOfWeek$NullableType());
  }

  static final _id_getValue = _class.instanceMethodId(r'getValue', r'()I');

  static final _getValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getValue()`
  int getValue() =>
      _getValue(reference.pointer, _id_getValue as jni$_.JMethodIDPtr).integer;

  static final _id_getDisplayName = _class.instanceMethodId(
    r'getDisplayName',
    r'(Ljava/time/format/TextStyle;Ljava/util/Locale;)Ljava/lang/String;',
  );

  static final _getDisplayName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getDisplayName(java.time.format.TextStyle textStyle, java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayName(
    jni$_.JObject? textStyle,
    jni$_.JObject? locale,
  ) {
    final _$textStyle = textStyle?.reference ?? jni$_.jNullReference;
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDisplayName(
      reference.pointer,
      _id_getDisplayName as jni$_.JMethodIDPtr,
      _$textStyle.pointer,
      _$locale.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(J)Ljava/time/DayOfWeek;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.DayOfWeek plus(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  DayOfWeek? plus(int j) => _plus(
    reference.pointer,
    _id_plus as jni$_.JMethodIDPtr,
    j,
  ).object<DayOfWeek?>(const $DayOfWeek$NullableType());

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(J)Ljava/time/DayOfWeek;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.DayOfWeek minus(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  DayOfWeek? minus(int j) => _minus(
    reference.pointer,
    _id_minus as jni$_.JMethodIDPtr,
    j,
  ).object<DayOfWeek?>(const $DayOfWeek$NullableType());

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $DayOfWeek$NullableType extends jni$_.JObjType<DayOfWeek?> {
  @jni$_.internal
  const $DayOfWeek$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/DayOfWeek;';

  @jni$_.internal
  @core$_.override
  DayOfWeek? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DayOfWeek.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DayOfWeek?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DayOfWeek$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DayOfWeek$NullableType) &&
      other is $DayOfWeek$NullableType;
}

final class $DayOfWeek$Type extends jni$_.JObjType<DayOfWeek> {
  @jni$_.internal
  const $DayOfWeek$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/DayOfWeek;';

  @jni$_.internal
  @core$_.override
  DayOfWeek fromReference(jni$_.JReference reference) =>
      DayOfWeek.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DayOfWeek?> get nullableType =>
      const $DayOfWeek$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DayOfWeek$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DayOfWeek$Type) && other is $DayOfWeek$Type;
}

/// from: `java.time.LocalDate`
class LocalDate extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<LocalDate> $type;

  @jni$_.internal
  LocalDate.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/LocalDate');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $LocalDate$NullableType();
  static const type = $LocalDate$Type();
  static final _id_MIN = _class.staticFieldId(r'MIN', r'Ljava/time/LocalDate;');

  /// from: `static public final java.time.LocalDate MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? get MIN =>
      _id_MIN.get(_class, const $LocalDate$NullableType());

  static final _id_MAX = _class.staticFieldId(r'MAX', r'Ljava/time/LocalDate;');

  /// from: `static public final java.time.LocalDate MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? get MAX =>
      _id_MAX.get(_class, const $LocalDate$NullableType());

  static final _id_EPOCH = _class.staticFieldId(
    r'EPOCH',
    r'Ljava/time/LocalDate;',
  );

  /// from: `static public final java.time.LocalDate EPOCH`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? get EPOCH =>
      _id_EPOCH.get(_class, const $LocalDate$NullableType());

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/LocalDate;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.LocalDate now()`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? now() => _now(
    _class.reference.pointer,
    _id_now as jni$_.JMethodIDPtr,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/LocalDate;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDate now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/LocalDate;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDate now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(ILjava/time/Month;I)Ljava/time/LocalDate;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Pointer<jni$_.Void>, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public java.time.LocalDate of(int i, java.time.Month month, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? of(int i, Month? month, int i1) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      i,
      _$month.pointer,
      i1,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(III)Ljava/time/LocalDate;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDate of(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? of$1(int i, int i1, int i2) => _of$1(
    _class.reference.pointer,
    _id_of$1 as jni$_.JMethodIDPtr,
    i,
    i1,
    i2,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_ofYearDay = _class.staticMethodId(
    r'ofYearDay',
    r'(II)Ljava/time/LocalDate;',
  );

  static final _ofYearDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.LocalDate ofYearDay(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? ofYearDay(int i, int i1) => _ofYearDay(
    _class.reference.pointer,
    _id_ofYearDay as jni$_.JMethodIDPtr,
    i,
    i1,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/LocalDate;',
  );

  static final _ofInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDate ofInstant(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? ofInstant(Instant? instant, ZoneId? zoneId) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant(
      _class.reference.pointer,
      _id_ofInstant as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zoneId.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_ofEpochDay = _class.staticMethodId(
    r'ofEpochDay',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _ofEpochDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.time.LocalDate ofEpochDay(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? ofEpochDay(int j) => _ofEpochDay(
    _class.reference.pointer,
    _id_ofEpochDay as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/LocalDate;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDate from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/LocalDate;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDate parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/LocalDate;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.LocalDate parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static LocalDate? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getChronology = _class.instanceMethodId(
    r'getChronology',
    r'()Ljava/time/chrono/IsoChronology;',
  );

  static final _getChronology =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.chrono.IsoChronology getChronology()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChronology() => _getChronology(
    reference.pointer,
    _id_getChronology as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getEra = _class.instanceMethodId(
    r'getEra',
    r'()Ljava/time/chrono/IsoEra;',
  );

  static final _getEra =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.chrono.IsoEra getEra()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getEra() => _getEra(
    reference.pointer,
    _id_getEra as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getYear = _class.instanceMethodId(r'getYear', r'()I');

  static final _getYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getYear()`
  int getYear() =>
      _getYear(reference.pointer, _id_getYear as jni$_.JMethodIDPtr).integer;

  static final _id_getMonthValue = _class.instanceMethodId(
    r'getMonthValue',
    r'()I',
  );

  static final _getMonthValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMonthValue()`
  int getMonthValue() =>
      _getMonthValue(
        reference.pointer,
        _id_getMonthValue as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()Ljava/time/Month;',
  );

  static final _getMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  Month? getMonth() => _getMonth(
    reference.pointer,
    _id_getMonth as jni$_.JMethodIDPtr,
  ).object<Month?>(const $Month$NullableType());

  static final _id_getDayOfMonth = _class.instanceMethodId(
    r'getDayOfMonth',
    r'()I',
  );

  static final _getDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfMonth()`
  int getDayOfMonth() =>
      _getDayOfMonth(
        reference.pointer,
        _id_getDayOfMonth as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getDayOfYear = _class.instanceMethodId(
    r'getDayOfYear',
    r'()I',
  );

  static final _getDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDayOfYear()`
  int getDayOfYear() =>
      _getDayOfYear(
        reference.pointer,
        _id_getDayOfYear as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getDayOfWeek = _class.instanceMethodId(
    r'getDayOfWeek',
    r'()Ljava/time/DayOfWeek;',
  );

  static final _getDayOfWeek =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.DayOfWeek getDayOfWeek()`
  /// The returned object must be released after use, by calling the [release] method.
  DayOfWeek? getDayOfWeek() => _getDayOfWeek(
    reference.pointer,
    _id_getDayOfWeek as jni$_.JMethodIDPtr,
  ).object<DayOfWeek?>(const $DayOfWeek$NullableType());

  static final _id_isLeapYear = _class.instanceMethodId(r'isLeapYear', r'()Z');

  static final _isLeapYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLeapYear()`
  bool isLeapYear() =>
      _isLeapYear(
        reference.pointer,
        _id_isLeapYear as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_lengthOfMonth = _class.instanceMethodId(
    r'lengthOfMonth',
    r'()I',
  );

  static final _lengthOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int lengthOfMonth()`
  int lengthOfMonth() =>
      _lengthOfMonth(
        reference.pointer,
        _id_lengthOfMonth as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_lengthOfYear = _class.instanceMethodId(
    r'lengthOfYear',
    r'()I',
  );

  static final _lengthOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int lengthOfYear()`
  int lengthOfYear() =>
      _lengthOfYear(
        reference.pointer,
        _id_lengthOfYear as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/LocalDate;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDate with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/LocalDate;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.LocalDate with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_withYear = _class.instanceMethodId(
    r'withYear',
    r'(I)Ljava/time/LocalDate;',
  );

  static final _withYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate withYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? withYear(int i) => _withYear(
    reference.pointer,
    _id_withYear as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_withMonth = _class.instanceMethodId(
    r'withMonth',
    r'(I)Ljava/time/LocalDate;',
  );

  static final _withMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate withMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? withMonth(int i) => _withMonth(
    reference.pointer,
    _id_withMonth as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_withDayOfMonth = _class.instanceMethodId(
    r'withDayOfMonth',
    r'(I)Ljava/time/LocalDate;',
  );

  static final _withDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate withDayOfMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? withDayOfMonth(int i) => _withDayOfMonth(
    reference.pointer,
    _id_withDayOfMonth as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_withDayOfYear = _class.instanceMethodId(
    r'withDayOfYear',
    r'(I)Ljava/time/LocalDate;',
  );

  static final _withDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate withDayOfYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? withDayOfYear(int i) => _withDayOfYear(
    reference.pointer,
    _id_withDayOfYear as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/LocalDate;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDate plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/LocalDate;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDate plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? plusYears(int j) => _plusYears(
    reference.pointer,
    _id_plusYears as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_plusMonths = _class.instanceMethodId(
    r'plusMonths',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _plusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate plusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? plusMonths(int j) => _plusMonths(
    reference.pointer,
    _id_plusMonths as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_plusWeeks = _class.instanceMethodId(
    r'plusWeeks',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _plusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate plusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? plusWeeks(int j) => _plusWeeks(
    reference.pointer,
    _id_plusWeeks as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_plusDays = _class.instanceMethodId(
    r'plusDays',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _plusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate plusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? plusDays(int j) => _plusDays(
    reference.pointer,
    _id_plusDays as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/LocalDate;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDate minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/LocalDate;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDate minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<LocalDate?>(const $LocalDate$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? minusYears(int j) => _minusYears(
    reference.pointer,
    _id_minusYears as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_minusMonths = _class.instanceMethodId(
    r'minusMonths',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _minusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate minusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? minusMonths(int j) => _minusMonths(
    reference.pointer,
    _id_minusMonths as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_minusWeeks = _class.instanceMethodId(
    r'minusWeeks',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _minusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate minusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? minusWeeks(int j) => _minusWeeks(
    reference.pointer,
    _id_minusWeeks as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_minusDays = _class.instanceMethodId(
    r'minusDays',
    r'(J)Ljava/time/LocalDate;',
  );

  static final _minusDays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate minusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? minusDays(int j) => _minusDays(
    reference.pointer,
    _id_minusDays as jni$_.JMethodIDPtr,
    j,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_until$1 = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/chrono/ChronoLocalDate;)Ljava/time/Period;',
  );

  static final _until$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.Period until(java.time.chrono.ChronoLocalDate chronoLocalDate)`
  /// The returned object must be released after use, by calling the [release] method.
  Period? until$1(jni$_.JObject? chronoLocalDate) {
    final _$chronoLocalDate =
        chronoLocalDate?.reference ?? jni$_.jNullReference;
    return _until$1(
      reference.pointer,
      _id_until$1 as jni$_.JMethodIDPtr,
      _$chronoLocalDate.pointer,
    ).object<Period?>(const $Period$NullableType());
  }

  static final _id_datesUntil = _class.instanceMethodId(
    r'datesUntil',
    r'(Ljava/time/LocalDate;)Ljava/util/stream/Stream;',
  );

  static final _datesUntil =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.stream.Stream<java.time.LocalDate> datesUntil(java.time.LocalDate localDate)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? datesUntil(LocalDate? localDate) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    return _datesUntil(
      reference.pointer,
      _id_datesUntil as jni$_.JMethodIDPtr,
      _$localDate.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_datesUntil$1 = _class.instanceMethodId(
    r'datesUntil',
    r'(Ljava/time/LocalDate;Ljava/time/Period;)Ljava/util/stream/Stream;',
  );

  static final _datesUntil$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.stream.Stream<java.time.LocalDate> datesUntil(java.time.LocalDate localDate, java.time.Period period)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? datesUntil$1(LocalDate? localDate, Period? period) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    final _$period = period?.reference ?? jni$_.jNullReference;
    return _datesUntil$1(
      reference.pointer,
      _id_datesUntil$1 as jni$_.JMethodIDPtr,
      _$localDate.pointer,
      _$period.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atTime = _class.instanceMethodId(
    r'atTime',
    r'(Ljava/time/LocalTime;)Ljava/time/LocalDateTime;',
  );

  static final _atTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.LocalDateTime atTime(java.time.LocalTime localTime)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? atTime(LocalTime? localTime) {
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    return _atTime(
      reference.pointer,
      _id_atTime as jni$_.JMethodIDPtr,
      _$localTime.pointer,
    ).object<LocalDateTime?>(const $LocalDateTime$NullableType());
  }

  static final _id_atTime$1 = _class.instanceMethodId(
    r'atTime',
    r'(II)Ljava/time/LocalDateTime;',
  );

  static final _atTime$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime atTime(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? atTime$1(int i, int i1) => _atTime$1(
    reference.pointer,
    _id_atTime$1 as jni$_.JMethodIDPtr,
    i,
    i1,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_atTime$2 = _class.instanceMethodId(
    r'atTime',
    r'(III)Ljava/time/LocalDateTime;',
  );

  static final _atTime$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime atTime(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? atTime$2(int i, int i1, int i2) => _atTime$2(
    reference.pointer,
    _id_atTime$2 as jni$_.JMethodIDPtr,
    i,
    i1,
    i2,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_atTime$3 = _class.instanceMethodId(
    r'atTime',
    r'(IIII)Ljava/time/LocalDateTime;',
  );

  static final _atTime$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `public java.time.LocalDateTime atTime(int i, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? atTime$3(int i, int i1, int i2, int i3) => _atTime$3(
    reference.pointer,
    _id_atTime$3 as jni$_.JMethodIDPtr,
    i,
    i1,
    i2,
    i3,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_atTime$4 = _class.instanceMethodId(
    r'atTime',
    r'(Ljava/time/OffsetTime;)Ljava/time/OffsetDateTime;',
  );

  static final _atTime$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.OffsetDateTime atTime(java.time.OffsetTime offsetTime)`
  /// The returned object must be released after use, by calling the [release] method.
  OffsetDateTime? atTime$4(OffsetTime? offsetTime) {
    final _$offsetTime = offsetTime?.reference ?? jni$_.jNullReference;
    return _atTime$4(
      reference.pointer,
      _id_atTime$4 as jni$_.JMethodIDPtr,
      _$offsetTime.pointer,
    ).object<OffsetDateTime?>(const $OffsetDateTime$NullableType());
  }

  static final _id_atStartOfDay = _class.instanceMethodId(
    r'atStartOfDay',
    r'()Ljava/time/LocalDateTime;',
  );

  static final _atStartOfDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDateTime atStartOfDay()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDateTime? atStartOfDay() => _atStartOfDay(
    reference.pointer,
    _id_atStartOfDay as jni$_.JMethodIDPtr,
  ).object<LocalDateTime?>(const $LocalDateTime$NullableType());

  static final _id_atStartOfDay$1 = _class.instanceMethodId(
    r'atStartOfDay',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _atStartOfDay$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.ZonedDateTime atStartOfDay(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? atStartOfDay$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _atStartOfDay$1(
      reference.pointer,
      _id_atStartOfDay$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_toEpochDay = _class.instanceMethodId(r'toEpochDay', r'()J');

  static final _toEpochDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long toEpochDay()`
  int toEpochDay() =>
      _toEpochDay(reference.pointer, _id_toEpochDay as jni$_.JMethodIDPtr).long;

  static final _id_toEpochSecond = _class.instanceMethodId(
    r'toEpochSecond',
    r'(Ljava/time/LocalTime;Ljava/time/ZoneOffset;)J',
  );

  static final _toEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long toEpochSecond(java.time.LocalTime localTime, java.time.ZoneOffset zoneOffset)`
  int toEpochSecond(LocalTime? localTime, ZoneOffset? zoneOffset) {
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _toEpochSecond(
      reference.pointer,
      _id_toEpochSecond as jni$_.JMethodIDPtr,
      _$localTime.pointer,
      _$zoneOffset.pointer,
    ).long;
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/chrono/ChronoLocalDate;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.chrono.ChronoLocalDate chronoLocalDate)`
  int compareTo(jni$_.JObject? chronoLocalDate) {
    final _$chronoLocalDate =
        chronoLocalDate?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$chronoLocalDate.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/chrono/ChronoLocalDate;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.chrono.ChronoLocalDate chronoLocalDate)`
  bool isAfter(jni$_.JObject? chronoLocalDate) {
    final _$chronoLocalDate =
        chronoLocalDate?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$chronoLocalDate.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/chrono/ChronoLocalDate;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.chrono.ChronoLocalDate chronoLocalDate)`
  bool isBefore(jni$_.JObject? chronoLocalDate) {
    final _$chronoLocalDate =
        chronoLocalDate?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$chronoLocalDate.pointer,
    ).boolean;
  }

  static final _id_isEqual = _class.instanceMethodId(
    r'isEqual',
    r'(Ljava/time/chrono/ChronoLocalDate;)Z',
  );

  static final _isEqual =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isEqual(java.time.chrono.ChronoLocalDate chronoLocalDate)`
  bool isEqual(jni$_.JObject? chronoLocalDate) {
    final _$chronoLocalDate =
        chronoLocalDate?.reference ?? jni$_.jNullReference;
    return _isEqual(
      reference.pointer,
      _id_isEqual as jni$_.JMethodIDPtr,
      _$chronoLocalDate.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $LocalDate$NullableType extends jni$_.JObjType<LocalDate?> {
  @jni$_.internal
  const $LocalDate$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/LocalDate;';

  @jni$_.internal
  @core$_.override
  LocalDate? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : LocalDate.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LocalDate?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($LocalDate$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($LocalDate$NullableType) &&
      other is $LocalDate$NullableType;
}

final class $LocalDate$Type extends jni$_.JObjType<LocalDate> {
  @jni$_.internal
  const $LocalDate$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/LocalDate;';

  @jni$_.internal
  @core$_.override
  LocalDate fromReference(jni$_.JReference reference) =>
      LocalDate.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LocalDate?> get nullableType =>
      const $LocalDate$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($LocalDate$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($LocalDate$Type) && other is $LocalDate$Type;
}

/// from: `java.time.YearMonth`
class YearMonth extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<YearMonth> $type;

  @jni$_.internal
  YearMonth.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/YearMonth');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $YearMonth$NullableType();
  static const type = $YearMonth$Type();
  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/YearMonth;',
  );

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.YearMonth now()`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? now() => _now(
    _class.reference.pointer,
    _id_now as jni$_.JMethodIDPtr,
  ).object<YearMonth?>(const $YearMonth$NullableType());

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/YearMonth;',
  );

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.YearMonth now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? now$1(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/YearMonth;',
  );

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.YearMonth now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? now$2(Clock? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(ILjava/time/Month;)Ljava/time/YearMonth;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.YearMonth of(int i, java.time.Month month)`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? of(int i, Month? month) {
    final _$month = month?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      i,
      _$month.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(II)Ljava/time/YearMonth;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public java.time.YearMonth of(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? of$1(int i, int i1) => _of$1(
    _class.reference.pointer,
    _id_of$1 as jni$_.JMethodIDPtr,
    i,
    i1,
  ).object<YearMonth?>(const $YearMonth$NullableType());

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/YearMonth;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.YearMonth from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? from(jni$_.JObject? temporalAccessor) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporalAccessor.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/YearMonth;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.YearMonth parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? parse(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/YearMonth;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.YearMonth parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static YearMonth? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$dateTimeFormatter.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(
      reference.pointer,
      _id_isSupported as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(
      reference.pointer,
      _id_isSupported$1 as jni$_.JMethodIDPtr,
      _$temporalUnit.pointer,
    ).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(jni$_.JObject? temporalField) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(
      reference.pointer,
      _id_getLong as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
    ).long;
  }

  static final _id_getYear = _class.instanceMethodId(r'getYear', r'()I');

  static final _getYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getYear()`
  int getYear() =>
      _getYear(reference.pointer, _id_getYear as jni$_.JMethodIDPtr).integer;

  static final _id_getMonthValue = _class.instanceMethodId(
    r'getMonthValue',
    r'()I',
  );

  static final _getMonthValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMonthValue()`
  int getMonthValue() =>
      _getMonthValue(
        reference.pointer,
        _id_getMonthValue as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()Ljava/time/Month;',
  );

  static final _getMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  Month? getMonth() => _getMonth(
    reference.pointer,
    _id_getMonth as jni$_.JMethodIDPtr,
  ).object<Month?>(const $Month$NullableType());

  static final _id_isLeapYear = _class.instanceMethodId(r'isLeapYear', r'()Z');

  static final _isLeapYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLeapYear()`
  bool isLeapYear() =>
      _isLeapYear(
        reference.pointer,
        _id_isLeapYear as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isValidDay = _class.instanceMethodId(r'isValidDay', r'(I)Z');

  static final _isValidDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean isValidDay(int i)`
  bool isValidDay(int i) =>
      _isValidDay(
        reference.pointer,
        _id_isValidDay as jni$_.JMethodIDPtr,
        i,
      ).boolean;

  static final _id_lengthOfMonth = _class.instanceMethodId(
    r'lengthOfMonth',
    r'()I',
  );

  static final _lengthOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int lengthOfMonth()`
  int lengthOfMonth() =>
      _lengthOfMonth(
        reference.pointer,
        _id_lengthOfMonth as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_lengthOfYear = _class.instanceMethodId(
    r'lengthOfYear',
    r'()I',
  );

  static final _lengthOfYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int lengthOfYear()`
  int lengthOfYear() =>
      _lengthOfYear(
        reference.pointer,
        _id_lengthOfYear as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/YearMonth;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.YearMonth with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? with$(jni$_.JObject? temporalAdjuster) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$temporalAdjuster.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/YearMonth;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public java.time.YearMonth with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? with$1(jni$_.JObject? temporalField, int j) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$temporalField.pointer,
      j,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_withYear = _class.instanceMethodId(
    r'withYear',
    r'(I)Ljava/time/YearMonth;',
  );

  static final _withYear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.YearMonth withYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? withYear(int i) => _withYear(
    reference.pointer,
    _id_withYear as jni$_.JMethodIDPtr,
    i,
  ).object<YearMonth?>(const $YearMonth$NullableType());

  static final _id_withMonth = _class.instanceMethodId(
    r'withMonth',
    r'(I)Ljava/time/YearMonth;',
  );

  static final _withMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.YearMonth withMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? withMonth(int i) => _withMonth(
    reference.pointer,
    _id_withMonth as jni$_.JMethodIDPtr,
    i,
  ).object<YearMonth?>(const $YearMonth$NullableType());

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/YearMonth;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.YearMonth plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? plus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/YearMonth;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.YearMonth plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? plus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/YearMonth;',
  );

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.YearMonth plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? plusYears(int j) => _plusYears(
    reference.pointer,
    _id_plusYears as jni$_.JMethodIDPtr,
    j,
  ).object<YearMonth?>(const $YearMonth$NullableType());

  static final _id_plusMonths = _class.instanceMethodId(
    r'plusMonths',
    r'(J)Ljava/time/YearMonth;',
  );

  static final _plusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.YearMonth plusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? plusMonths(int j) => _plusMonths(
    reference.pointer,
    _id_plusMonths as jni$_.JMethodIDPtr,
    j,
  ).object<YearMonth?>(const $YearMonth$NullableType());

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/YearMonth;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.YearMonth minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? minus(jni$_.JObject? temporalAmount) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$temporalAmount.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/YearMonth;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.YearMonth minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? minus$1(int j, jni$_.JObject? temporalUnit) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      j,
      _$temporalUnit.pointer,
    ).object<YearMonth?>(const $YearMonth$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/YearMonth;',
  );

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.YearMonth minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? minusYears(int j) => _minusYears(
    reference.pointer,
    _id_minusYears as jni$_.JMethodIDPtr,
    j,
  ).object<YearMonth?>(const $YearMonth$NullableType());

  static final _id_minusMonths = _class.instanceMethodId(
    r'minusMonths',
    r'(J)Ljava/time/YearMonth;',
  );

  static final _minusMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.YearMonth minusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  YearMonth? minusMonths(int j) => _minusMonths(
    reference.pointer,
    _id_minusMonths as jni$_.JMethodIDPtr,
    j,
  ).object<YearMonth?>(const $YearMonth$NullableType());

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(
      reference.pointer,
      _id_query as jni$_.JMethodIDPtr,
      _$temporalQuery.pointer,
    ).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(jni$_.JObject? temporal, jni$_.JObject? temporalUnit) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(
      reference.pointer,
      _id_until as jni$_.JMethodIDPtr,
      _$temporal.pointer,
      _$temporalUnit.pointer,
    ).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? dateTimeFormatter) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$dateTimeFormatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_atDay = _class.instanceMethodId(
    r'atDay',
    r'(I)Ljava/time/LocalDate;',
  );

  static final _atDay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.time.LocalDate atDay(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? atDay(int i) => _atDay(
    reference.pointer,
    _id_atDay as jni$_.JMethodIDPtr,
    i,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_atEndOfMonth = _class.instanceMethodId(
    r'atEndOfMonth',
    r'()Ljava/time/LocalDate;',
  );

  static final _atEndOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDate atEndOfMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  LocalDate? atEndOfMonth() => _atEndOfMonth(
    reference.pointer,
    _id_atEndOfMonth as jni$_.JMethodIDPtr,
  ).object<LocalDate?>(const $LocalDate$NullableType());

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/YearMonth;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.time.YearMonth yearMonth)`
  int compareTo(YearMonth? yearMonth) {
    final _$yearMonth = yearMonth?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$yearMonth.pointer,
    ).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/YearMonth;)Z',
  );

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isAfter(java.time.YearMonth yearMonth)`
  bool isAfter(YearMonth? yearMonth) {
    final _$yearMonth = yearMonth?.reference ?? jni$_.jNullReference;
    return _isAfter(
      reference.pointer,
      _id_isAfter as jni$_.JMethodIDPtr,
      _$yearMonth.pointer,
    ).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/YearMonth;)Z',
  );

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isBefore(java.time.YearMonth yearMonth)`
  bool isBefore(YearMonth? yearMonth) {
    final _$yearMonth = yearMonth?.reference ?? jni$_.jNullReference;
    return _isBefore(
      reference.pointer,
      _id_isBefore as jni$_.JMethodIDPtr,
      _$yearMonth.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  bool operator <(YearMonth? yearMonth) => compareTo(yearMonth) < 0;

  bool operator <=(YearMonth? yearMonth) => compareTo(yearMonth) <= 0;

  bool operator >(YearMonth? yearMonth) => compareTo(yearMonth) > 0;

  bool operator >=(YearMonth? yearMonth) => compareTo(yearMonth) >= 0;
}

final class $YearMonth$NullableType extends jni$_.JObjType<YearMonth?> {
  @jni$_.internal
  const $YearMonth$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/YearMonth;';

  @jni$_.internal
  @core$_.override
  YearMonth? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : YearMonth.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<YearMonth?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($YearMonth$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($YearMonth$NullableType) &&
      other is $YearMonth$NullableType;
}

final class $YearMonth$Type extends jni$_.JObjType<YearMonth> {
  @jni$_.internal
  const $YearMonth$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/YearMonth;';

  @jni$_.internal
  @core$_.override
  YearMonth fromReference(jni$_.JReference reference) =>
      YearMonth.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<YearMonth?> get nullableType =>
      const $YearMonth$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($YearMonth$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($YearMonth$Type) && other is $YearMonth$Type;
}

/// from: `java.time.Clock`
class Clock extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Clock> $type;

  @jni$_.internal
  Clock.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Clock');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Clock$NullableType();
  static const type = $Clock$Type();
  static final _id_systemUTC = _class.staticMethodId(
    r'systemUTC',
    r'()Ljava/time/Clock;',
  );

  static final _systemUTC =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.Clock systemUTC()`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? systemUTC() => _systemUTC(
    _class.reference.pointer,
    _id_systemUTC as jni$_.JMethodIDPtr,
  ).object<Clock?>(const $Clock$NullableType());

  static final _id_systemDefaultZone = _class.staticMethodId(
    r'systemDefaultZone',
    r'()Ljava/time/Clock;',
  );

  static final _systemDefaultZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.Clock systemDefaultZone()`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? systemDefaultZone() => _systemDefaultZone(
    _class.reference.pointer,
    _id_systemDefaultZone as jni$_.JMethodIDPtr,
  ).object<Clock?>(const $Clock$NullableType());

  static final _id_system = _class.staticMethodId(
    r'system',
    r'(Ljava/time/ZoneId;)Ljava/time/Clock;',
  );

  static final _system =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Clock system(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? system(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _system(
      _class.reference.pointer,
      _id_system as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_tickMillis = _class.staticMethodId(
    r'tickMillis',
    r'(Ljava/time/ZoneId;)Ljava/time/Clock;',
  );

  static final _tickMillis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Clock tickMillis(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? tickMillis(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _tickMillis(
      _class.reference.pointer,
      _id_tickMillis as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_tickSeconds = _class.staticMethodId(
    r'tickSeconds',
    r'(Ljava/time/ZoneId;)Ljava/time/Clock;',
  );

  static final _tickSeconds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Clock tickSeconds(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? tickSeconds(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _tickSeconds(
      _class.reference.pointer,
      _id_tickSeconds as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_tickMinutes = _class.staticMethodId(
    r'tickMinutes',
    r'(Ljava/time/ZoneId;)Ljava/time/Clock;',
  );

  static final _tickMinutes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Clock tickMinutes(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? tickMinutes(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _tickMinutes(
      _class.reference.pointer,
      _id_tickMinutes as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_tick = _class.staticMethodId(
    r'tick',
    r'(Ljava/time/Clock;Ljava/time/Duration;)Ljava/time/Clock;',
  );

  static final _tick =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Clock tick(java.time.Clock clock, java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? tick(Clock? clock, Duration? duration) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _tick(
      _class.reference.pointer,
      _id_tick as jni$_.JMethodIDPtr,
      _$clock.pointer,
      _$duration.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_fixed = _class.staticMethodId(
    r'fixed',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/Clock;',
  );

  static final _fixed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Clock fixed(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? fixed(Instant? instant, ZoneId? zoneId) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _fixed(
      _class.reference.pointer,
      _id_fixed as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zoneId.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_offset = _class.staticMethodId(
    r'offset',
    r'(Ljava/time/Clock;Ljava/time/Duration;)Ljava/time/Clock;',
  );

  static final _offset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.Clock offset(java.time.Clock clock, java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  static Clock? offset(Clock? clock, Duration? duration) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _offset(
      _class.reference.pointer,
      _id_offset as jni$_.JMethodIDPtr,
      _$clock.pointer,
      _$duration.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_getZone = _class.instanceMethodId(
    r'getZone',
    r'()Ljava/time/ZoneId;',
  );

  static final _getZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.time.ZoneId getZone()`
  /// The returned object must be released after use, by calling the [release] method.
  ZoneId? getZone() => _getZone(
    reference.pointer,
    _id_getZone as jni$_.JMethodIDPtr,
  ).object<ZoneId?>(const $ZoneId$NullableType());

  static final _id_withZone = _class.instanceMethodId(
    r'withZone',
    r'(Ljava/time/ZoneId;)Ljava/time/Clock;',
  );

  static final _withZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.time.Clock withZone(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  Clock? withZone(ZoneId? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _withZone(
      reference.pointer,
      _id_withZone as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<Clock?>(const $Clock$NullableType());
  }

  static final _id_millis = _class.instanceMethodId(r'millis', r'()J');

  static final _millis =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long millis()`
  int millis() =>
      _millis(reference.pointer, _id_millis as jni$_.JMethodIDPtr).long;

  static final _id_instant = _class.instanceMethodId(
    r'instant',
    r'()Ljava/time/Instant;',
  );

  static final _instant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.time.Instant instant()`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? instant() => _instant(
    reference.pointer,
    _id_instant as jni$_.JMethodIDPtr,
  ).object<Instant?>(const $Instant$NullableType());

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_system$1 = _class.staticMethodId(
    r'system',
    r'()Ljava/time/InstantSource;',
  );

  static final _system$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.time.InstantSource system()`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? system$1() => _system$1(
    _class.reference.pointer,
    _id_system$1 as jni$_.JMethodIDPtr,
  ).object<InstantSource?>(const $InstantSource$NullableType());

  static final _id_tick$1 = _class.staticMethodId(
    r'tick',
    r'(Ljava/time/InstantSource;Ljava/time/Duration;)Ljava/time/InstantSource;',
  );

  static final _tick$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.InstantSource tick(java.time.InstantSource instantSource, java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? tick$1(
    InstantSource? instantSource,
    Duration? duration,
  ) {
    final _$instantSource = instantSource?.reference ?? jni$_.jNullReference;
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _tick$1(
      _class.reference.pointer,
      _id_tick$1 as jni$_.JMethodIDPtr,
      _$instantSource.pointer,
      _$duration.pointer,
    ).object<InstantSource?>(const $InstantSource$NullableType());
  }

  static final _id_fixed$1 = _class.staticMethodId(
    r'fixed',
    r'(Ljava/time/Instant;)Ljava/time/InstantSource;',
  );

  static final _fixed$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.InstantSource fixed(java.time.Instant instant)`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? fixed$1(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _fixed$1(
      _class.reference.pointer,
      _id_fixed$1 as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).object<InstantSource?>(const $InstantSource$NullableType());
  }

  static final _id_offset$1 = _class.staticMethodId(
    r'offset',
    r'(Ljava/time/InstantSource;Ljava/time/Duration;)Ljava/time/InstantSource;',
  );

  static final _offset$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.InstantSource offset(java.time.InstantSource instantSource, java.time.Duration duration)`
  /// The returned object must be released after use, by calling the [release] method.
  static InstantSource? offset$1(
    InstantSource? instantSource,
    Duration? duration,
  ) {
    final _$instantSource = instantSource?.reference ?? jni$_.jNullReference;
    final _$duration = duration?.reference ?? jni$_.jNullReference;
    return _offset$1(
      _class.reference.pointer,
      _id_offset$1 as jni$_.JMethodIDPtr,
      _$instantSource.pointer,
      _$duration.pointer,
    ).object<InstantSource?>(const $InstantSource$NullableType());
  }
}

final class $Clock$NullableType extends jni$_.JObjType<Clock?> {
  @jni$_.internal
  const $Clock$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Clock;';

  @jni$_.internal
  @core$_.override
  Clock? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Clock.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Clock?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Clock$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Clock$NullableType) &&
      other is $Clock$NullableType;
}

final class $Clock$Type extends jni$_.JObjType<Clock> {
  @jni$_.internal
  const $Clock$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Clock;';

  @jni$_.internal
  @core$_.override
  Clock fromReference(jni$_.JReference reference) =>
      Clock.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Clock?> get nullableType => const $Clock$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Clock$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Clock$Type) && other is $Clock$Type;
}

/// from: `java.net.HttpURLConnection`
class HttpURLConnection extends URLConnection {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<HttpURLConnection> $type;

  @jni$_.internal
  HttpURLConnection.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/HttpURLConnection');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $HttpURLConnection$NullableType();
  static const type = $HttpURLConnection$Type();

  /// from: `static public final int HTTP_OK`
  static const HTTP_OK = 200;

  /// from: `static public final int HTTP_CREATED`
  static const HTTP_CREATED = 201;

  /// from: `static public final int HTTP_ACCEPTED`
  static const HTTP_ACCEPTED = 202;

  /// from: `static public final int HTTP_NOT_AUTHORITATIVE`
  static const HTTP_NOT_AUTHORITATIVE = 203;

  /// from: `static public final int HTTP_NO_CONTENT`
  static const HTTP_NO_CONTENT = 204;

  /// from: `static public final int HTTP_RESET`
  static const HTTP_RESET = 205;

  /// from: `static public final int HTTP_PARTIAL`
  static const HTTP_PARTIAL = 206;

  /// from: `static public final int HTTP_MULT_CHOICE`
  static const HTTP_MULT_CHOICE = 300;

  /// from: `static public final int HTTP_MOVED_PERM`
  static const HTTP_MOVED_PERM = 301;

  /// from: `static public final int HTTP_MOVED_TEMP`
  static const HTTP_MOVED_TEMP = 302;

  /// from: `static public final int HTTP_SEE_OTHER`
  static const HTTP_SEE_OTHER = 303;

  /// from: `static public final int HTTP_NOT_MODIFIED`
  static const HTTP_NOT_MODIFIED = 304;

  /// from: `static public final int HTTP_USE_PROXY`
  static const HTTP_USE_PROXY = 305;

  /// from: `static public final int HTTP_BAD_REQUEST`
  static const HTTP_BAD_REQUEST = 400;

  /// from: `static public final int HTTP_UNAUTHORIZED`
  static const HTTP_UNAUTHORIZED = 401;

  /// from: `static public final int HTTP_PAYMENT_REQUIRED`
  static const HTTP_PAYMENT_REQUIRED = 402;

  /// from: `static public final int HTTP_FORBIDDEN`
  static const HTTP_FORBIDDEN = 403;

  /// from: `static public final int HTTP_NOT_FOUND`
  static const HTTP_NOT_FOUND = 404;

  /// from: `static public final int HTTP_BAD_METHOD`
  static const HTTP_BAD_METHOD = 405;

  /// from: `static public final int HTTP_NOT_ACCEPTABLE`
  static const HTTP_NOT_ACCEPTABLE = 406;

  /// from: `static public final int HTTP_PROXY_AUTH`
  static const HTTP_PROXY_AUTH = 407;

  /// from: `static public final int HTTP_CLIENT_TIMEOUT`
  static const HTTP_CLIENT_TIMEOUT = 408;

  /// from: `static public final int HTTP_CONFLICT`
  static const HTTP_CONFLICT = 409;

  /// from: `static public final int HTTP_GONE`
  static const HTTP_GONE = 410;

  /// from: `static public final int HTTP_LENGTH_REQUIRED`
  static const HTTP_LENGTH_REQUIRED = 411;

  /// from: `static public final int HTTP_PRECON_FAILED`
  static const HTTP_PRECON_FAILED = 412;

  /// from: `static public final int HTTP_ENTITY_TOO_LARGE`
  static const HTTP_ENTITY_TOO_LARGE = 413;

  /// from: `static public final int HTTP_REQ_TOO_LONG`
  static const HTTP_REQ_TOO_LONG = 414;

  /// from: `static public final int HTTP_UNSUPPORTED_TYPE`
  static const HTTP_UNSUPPORTED_TYPE = 415;

  /// from: `static public final int HTTP_SERVER_ERROR`
  static const HTTP_SERVER_ERROR = 500;

  /// from: `static public final int HTTP_INTERNAL_ERROR`
  static const HTTP_INTERNAL_ERROR = 500;

  /// from: `static public final int HTTP_NOT_IMPLEMENTED`
  static const HTTP_NOT_IMPLEMENTED = 501;

  /// from: `static public final int HTTP_BAD_GATEWAY`
  static const HTTP_BAD_GATEWAY = 502;

  /// from: `static public final int HTTP_UNAVAILABLE`
  static const HTTP_UNAVAILABLE = 503;

  /// from: `static public final int HTTP_GATEWAY_TIMEOUT`
  static const HTTP_GATEWAY_TIMEOUT = 504;

  /// from: `static public final int HTTP_VERSION`
  static const HTTP_VERSION = 505;
  static final _id_setAuthenticator = _class.instanceMethodId(
    r'setAuthenticator',
    r'(Ljava/net/Authenticator;)V',
  );

  static final _setAuthenticator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setAuthenticator(java.net.Authenticator authenticator)`
  void setAuthenticator(Authenticator? authenticator) {
    final _$authenticator = authenticator?.reference ?? jni$_.jNullReference;
    _setAuthenticator(
      reference.pointer,
      _id_setAuthenticator as jni$_.JMethodIDPtr,
      _$authenticator.pointer,
    ).check();
  }

  static final _id_getHeaderFieldKey = _class.instanceMethodId(
    r'getHeaderFieldKey',
    r'(I)Ljava/lang/String;',
  );

  static final _getHeaderFieldKey =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.lang.String getHeaderFieldKey(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHeaderFieldKey(int i) => _getHeaderFieldKey(
    reference.pointer,
    _id_getHeaderFieldKey as jni$_.JMethodIDPtr,
    i,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setFixedLengthStreamingMode = _class.instanceMethodId(
    r'setFixedLengthStreamingMode',
    r'(I)V',
  );

  static final _setFixedLengthStreamingMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setFixedLengthStreamingMode(int i)`
  void setFixedLengthStreamingMode(int i) {
    _setFixedLengthStreamingMode(
      reference.pointer,
      _id_setFixedLengthStreamingMode as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setFixedLengthStreamingMode$1 = _class.instanceMethodId(
    r'setFixedLengthStreamingMode',
    r'(J)V',
  );

  static final _setFixedLengthStreamingMode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setFixedLengthStreamingMode(long j)`
  void setFixedLengthStreamingMode$1(int j) {
    _setFixedLengthStreamingMode$1(
      reference.pointer,
      _id_setFixedLengthStreamingMode$1 as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_setChunkedStreamingMode = _class.instanceMethodId(
    r'setChunkedStreamingMode',
    r'(I)V',
  );

  static final _setChunkedStreamingMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setChunkedStreamingMode(int i)`
  void setChunkedStreamingMode(int i) {
    _setChunkedStreamingMode(
      reference.pointer,
      _id_setChunkedStreamingMode as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getHeaderField1 = _class.instanceMethodId(
    r'getHeaderField',
    r'(I)Ljava/lang/String;',
  );

  static final _getHeaderField1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.lang.String getHeaderField(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHeaderField1(int i) => _getHeaderField1(
    reference.pointer,
    _id_getHeaderField1 as jni$_.JMethodIDPtr,
    i,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setFollowRedirects = _class.staticMethodId(
    r'setFollowRedirects',
    r'(Z)V',
  );

  static final _setFollowRedirects =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public void setFollowRedirects(boolean z)`
  static void setFollowRedirects(bool z) {
    _setFollowRedirects(
      _class.reference.pointer,
      _id_setFollowRedirects as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getFollowRedirects = _class.staticMethodId(
    r'getFollowRedirects',
    r'()Z',
  );

  static final _getFollowRedirects =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public boolean getFollowRedirects()`
  static bool getFollowRedirects() =>
      _getFollowRedirects(
        _class.reference.pointer,
        _id_getFollowRedirects as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setInstanceFollowRedirects = _class.instanceMethodId(
    r'setInstanceFollowRedirects',
    r'(Z)V',
  );

  static final _setInstanceFollowRedirects =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setInstanceFollowRedirects(boolean z)`
  void setInstanceFollowRedirects(bool z) {
    _setInstanceFollowRedirects(
      reference.pointer,
      _id_setInstanceFollowRedirects as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getInstanceFollowRedirects = _class.instanceMethodId(
    r'getInstanceFollowRedirects',
    r'()Z',
  );

  static final _getInstanceFollowRedirects =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getInstanceFollowRedirects()`
  bool getInstanceFollowRedirects() =>
      _getInstanceFollowRedirects(
        reference.pointer,
        _id_getInstanceFollowRedirects as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setRequestMethod = _class.instanceMethodId(
    r'setRequestMethod',
    r'(Ljava/lang/String;)V',
  );

  static final _setRequestMethod =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setRequestMethod(java.lang.String string)`
  void setRequestMethod(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setRequestMethod(
      reference.pointer,
      _id_setRequestMethod as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getRequestMethod = _class.instanceMethodId(
    r'getRequestMethod',
    r'()Ljava/lang/String;',
  );

  static final _getRequestMethod =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getRequestMethod()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRequestMethod() => _getRequestMethod(
    reference.pointer,
    _id_getRequestMethod as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getResponseCode = _class.instanceMethodId(
    r'getResponseCode',
    r'()I',
  );

  static final _getResponseCode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getResponseCode()`
  int getResponseCode() =>
      _getResponseCode(
        reference.pointer,
        _id_getResponseCode as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getResponseMessage = _class.instanceMethodId(
    r'getResponseMessage',
    r'()Ljava/lang/String;',
  );

  static final _getResponseMessage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getResponseMessage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getResponseMessage() => _getResponseMessage(
    reference.pointer,
    _id_getResponseMessage as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getHeaderFieldDate = _class.instanceMethodId(
    r'getHeaderFieldDate',
    r'(Ljava/lang/String;J)J',
  );

  static final _getHeaderFieldDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public long getHeaderFieldDate(java.lang.String string, long j)`
  int getHeaderFieldDate(jni$_.JString? string, int j) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getHeaderFieldDate(
      reference.pointer,
      _id_getHeaderFieldDate as jni$_.JMethodIDPtr,
      _$string.pointer,
      j,
    ).long;
  }

  static final _id_disconnect = _class.instanceMethodId(r'disconnect', r'()V');

  static final _disconnect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void disconnect()`
  void disconnect() {
    _disconnect(
      reference.pointer,
      _id_disconnect as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_usingProxy = _class.instanceMethodId(r'usingProxy', r'()Z');

  static final _usingProxy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract boolean usingProxy()`
  bool usingProxy() =>
      _usingProxy(
        reference.pointer,
        _id_usingProxy as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_getPermission = _class.instanceMethodId(
    r'getPermission',
    r'()Ljava/security/Permission;',
  );

  static final _getPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.security.Permission getPermission()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getPermission() => _getPermission(
    reference.pointer,
    _id_getPermission as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getErrorStream = _class.instanceMethodId(
    r'getErrorStream',
    r'()Ljava/io/InputStream;',
  );

  static final _getErrorStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.InputStream getErrorStream()`
  /// The returned object must be released after use, by calling the [release] method.
  InputStream? getErrorStream() => _getErrorStream(
    reference.pointer,
    _id_getErrorStream as jni$_.JMethodIDPtr,
  ).object<InputStream?>(const $InputStream$NullableType());
}

final class $HttpURLConnection$NullableType
    extends jni$_.JObjType<HttpURLConnection?> {
  @jni$_.internal
  const $HttpURLConnection$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/HttpURLConnection;';

  @jni$_.internal
  @core$_.override
  HttpURLConnection? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : HttpURLConnection.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $URLConnection$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HttpURLConnection?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($HttpURLConnection$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($HttpURLConnection$NullableType) &&
      other is $HttpURLConnection$NullableType;
}

final class $HttpURLConnection$Type extends jni$_.JObjType<HttpURLConnection> {
  @jni$_.internal
  const $HttpURLConnection$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/HttpURLConnection;';

  @jni$_.internal
  @core$_.override
  HttpURLConnection fromReference(jni$_.JReference reference) =>
      HttpURLConnection.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $URLConnection$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HttpURLConnection?> get nullableType =>
      const $HttpURLConnection$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($HttpURLConnection$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($HttpURLConnection$Type) &&
      other is $HttpURLConnection$Type;
}

/// from: `java.net.InetAddress`
class InetAddress extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InetAddress> $type;

  @jni$_.internal
  InetAddress.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/InetAddress');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InetAddress$NullableType();
  static const type = $InetAddress$Type();
  static final _id_isMulticastAddress = _class.instanceMethodId(
    r'isMulticastAddress',
    r'()Z',
  );

  static final _isMulticastAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMulticastAddress()`
  bool isMulticastAddress() =>
      _isMulticastAddress(
        reference.pointer,
        _id_isMulticastAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isAnyLocalAddress = _class.instanceMethodId(
    r'isAnyLocalAddress',
    r'()Z',
  );

  static final _isAnyLocalAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isAnyLocalAddress()`
  bool isAnyLocalAddress() =>
      _isAnyLocalAddress(
        reference.pointer,
        _id_isAnyLocalAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isLoopbackAddress = _class.instanceMethodId(
    r'isLoopbackAddress',
    r'()Z',
  );

  static final _isLoopbackAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLoopbackAddress()`
  bool isLoopbackAddress() =>
      _isLoopbackAddress(
        reference.pointer,
        _id_isLoopbackAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isLinkLocalAddress = _class.instanceMethodId(
    r'isLinkLocalAddress',
    r'()Z',
  );

  static final _isLinkLocalAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLinkLocalAddress()`
  bool isLinkLocalAddress() =>
      _isLinkLocalAddress(
        reference.pointer,
        _id_isLinkLocalAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isSiteLocalAddress = _class.instanceMethodId(
    r'isSiteLocalAddress',
    r'()Z',
  );

  static final _isSiteLocalAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isSiteLocalAddress()`
  bool isSiteLocalAddress() =>
      _isSiteLocalAddress(
        reference.pointer,
        _id_isSiteLocalAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCGlobal = _class.instanceMethodId(r'isMCGlobal', r'()Z');

  static final _isMCGlobal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCGlobal()`
  bool isMCGlobal() =>
      _isMCGlobal(
        reference.pointer,
        _id_isMCGlobal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCNodeLocal = _class.instanceMethodId(
    r'isMCNodeLocal',
    r'()Z',
  );

  static final _isMCNodeLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCNodeLocal()`
  bool isMCNodeLocal() =>
      _isMCNodeLocal(
        reference.pointer,
        _id_isMCNodeLocal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCLinkLocal = _class.instanceMethodId(
    r'isMCLinkLocal',
    r'()Z',
  );

  static final _isMCLinkLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCLinkLocal()`
  bool isMCLinkLocal() =>
      _isMCLinkLocal(
        reference.pointer,
        _id_isMCLinkLocal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCSiteLocal = _class.instanceMethodId(
    r'isMCSiteLocal',
    r'()Z',
  );

  static final _isMCSiteLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCSiteLocal()`
  bool isMCSiteLocal() =>
      _isMCSiteLocal(
        reference.pointer,
        _id_isMCSiteLocal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCOrgLocal = _class.instanceMethodId(
    r'isMCOrgLocal',
    r'()Z',
  );

  static final _isMCOrgLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCOrgLocal()`
  bool isMCOrgLocal() =>
      _isMCOrgLocal(
        reference.pointer,
        _id_isMCOrgLocal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isReachable = _class.instanceMethodId(
    r'isReachable',
    r'(I)Z',
  );

  static final _isReachable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean isReachable(int i)`
  bool isReachable(int i) =>
      _isReachable(
        reference.pointer,
        _id_isReachable as jni$_.JMethodIDPtr,
        i,
      ).boolean;

  static final _id_isReachable$1 = _class.instanceMethodId(
    r'isReachable',
    r'(Ljava/net/NetworkInterface;II)Z',
  );

  static final _isReachable$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public boolean isReachable(java.net.NetworkInterface networkInterface, int i, int i1)`
  bool isReachable$1(NetworkInterface? networkInterface, int i, int i1) {
    final _$networkInterface =
        networkInterface?.reference ?? jni$_.jNullReference;
    return _isReachable$1(
      reference.pointer,
      _id_isReachable$1 as jni$_.JMethodIDPtr,
      _$networkInterface.pointer,
      i,
      i1,
    ).boolean;
  }

  static final _id_getHostName = _class.instanceMethodId(
    r'getHostName',
    r'()Ljava/lang/String;',
  );

  static final _getHostName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getHostName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHostName() => _getHostName(
    reference.pointer,
    _id_getHostName as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getCanonicalHostName = _class.instanceMethodId(
    r'getCanonicalHostName',
    r'()Ljava/lang/String;',
  );

  static final _getCanonicalHostName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getCanonicalHostName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCanonicalHostName() => _getCanonicalHostName(
    reference.pointer,
    _id_getCanonicalHostName as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getAddress = _class.instanceMethodId(r'getAddress', r'()[B');

  static final _getAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] getAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getAddress() => _getAddress(
    reference.pointer,
    _id_getAddress as jni$_.JMethodIDPtr,
  ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());

  static final _id_getHostAddress = _class.instanceMethodId(
    r'getHostAddress',
    r'()Ljava/lang/String;',
  );

  static final _getHostAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getHostAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHostAddress() => _getHostAddress(
    reference.pointer,
    _id_getHostAddress as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getByAddress = _class.staticMethodId(
    r'getByAddress',
    r'(Ljava/lang/String;[B)Ljava/net/InetAddress;',
  );

  static final _getByAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.InetAddress getByAddress(java.lang.String string, byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  static InetAddress? getByAddress(
    jni$_.JString? string,
    jni$_.JByteArray? bs,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _getByAddress(
      _class.reference.pointer,
      _id_getByAddress as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bs.pointer,
    ).object<InetAddress?>(const $InetAddress$NullableType());
  }

  static final _id_getByName = _class.staticMethodId(
    r'getByName',
    r'(Ljava/lang/String;)Ljava/net/InetAddress;',
  );

  static final _getByName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.InetAddress getByName(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static InetAddress? getByName(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getByName(
      _class.reference.pointer,
      _id_getByName as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<InetAddress?>(const $InetAddress$NullableType());
  }

  static final _id_getAllByName = _class.staticMethodId(
    r'getAllByName',
    r'(Ljava/lang/String;)[Ljava/net/InetAddress;',
  );

  static final _getAllByName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.InetAddress[] getAllByName(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<InetAddress?>? getAllByName(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getAllByName(
      _class.reference.pointer,
      _id_getAllByName as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JArray<InetAddress?>?>(
      const jni$_.JArrayNullableType<InetAddress?>($InetAddress$NullableType()),
    );
  }

  static final _id_getLoopbackAddress = _class.staticMethodId(
    r'getLoopbackAddress',
    r'()Ljava/net/InetAddress;',
  );

  static final _getLoopbackAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.net.InetAddress getLoopbackAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  static InetAddress? getLoopbackAddress() => _getLoopbackAddress(
    _class.reference.pointer,
    _id_getLoopbackAddress as jni$_.JMethodIDPtr,
  ).object<InetAddress?>(const $InetAddress$NullableType());

  static final _id_getByAddress$1 = _class.staticMethodId(
    r'getByAddress',
    r'([B)Ljava/net/InetAddress;',
  );

  static final _getByAddress$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.InetAddress getByAddress(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  static InetAddress? getByAddress$1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _getByAddress$1(
      _class.reference.pointer,
      _id_getByAddress$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).object<InetAddress?>(const $InetAddress$NullableType());
  }

  static final _id_getLocalHost = _class.staticMethodId(
    r'getLocalHost',
    r'()Ljava/net/InetAddress;',
  );

  static final _getLocalHost =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.net.InetAddress getLocalHost()`
  /// The returned object must be released after use, by calling the [release] method.
  static InetAddress? getLocalHost() => _getLocalHost(
    _class.reference.pointer,
    _id_getLocalHost as jni$_.JMethodIDPtr,
  ).object<InetAddress?>(const $InetAddress$NullableType());
}

final class $InetAddress$NullableType extends jni$_.JObjType<InetAddress?> {
  @jni$_.internal
  const $InetAddress$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/InetAddress;';

  @jni$_.internal
  @core$_.override
  InetAddress? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InetAddress.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InetAddress?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InetAddress$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InetAddress$NullableType) &&
      other is $InetAddress$NullableType;
}

final class $InetAddress$Type extends jni$_.JObjType<InetAddress> {
  @jni$_.internal
  const $InetAddress$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/InetAddress;';

  @jni$_.internal
  @core$_.override
  InetAddress fromReference(jni$_.JReference reference) =>
      InetAddress.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InetAddress?> get nullableType =>
      const $InetAddress$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InetAddress$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InetAddress$Type) && other is $InetAddress$Type;
}

/// from: `java.net.ServerSocket`
class ServerSocket extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ServerSocket> $type;

  @jni$_.internal
  ServerSocket.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/ServerSocket');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ServerSocket$NullableType();
  static const type = $ServerSocket$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ServerSocket() => ServerSocket.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$1 = _class.constructorId(r'(I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ServerSocket.new$1(int i) => ServerSocket.fromReference(
    _new$1(
      _class.reference.pointer,
      _id_new$1 as jni$_.JMethodIDPtr,
      i,
    ).reference,
  );

  static final _id_new$2 = _class.constructorId(r'(II)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void <init>(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ServerSocket.new$2(int i, int i1) => ServerSocket.fromReference(
    _new$2(
      _class.reference.pointer,
      _id_new$2 as jni$_.JMethodIDPtr,
      i,
      i1,
    ).reference,
  );

  static final _id_new$3 = _class.constructorId(r'(IILjava/net/InetAddress;)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(int i, int i1, java.net.InetAddress inetAddress)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ServerSocket.new$3(int i, int i1, InetAddress? inetAddress) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    return ServerSocket.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        i,
        i1,
        _$inetAddress.pointer,
      ).reference,
    );
  }

  static final _id_bind = _class.instanceMethodId(
    r'bind',
    r'(Ljava/net/SocketAddress;)V',
  );

  static final _bind =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void bind(java.net.SocketAddress socketAddress)`
  void bind(SocketAddress? socketAddress) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    _bind(
      reference.pointer,
      _id_bind as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
    ).check();
  }

  static final _id_bind$1 = _class.instanceMethodId(
    r'bind',
    r'(Ljava/net/SocketAddress;I)V',
  );

  static final _bind$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void bind(java.net.SocketAddress socketAddress, int i)`
  void bind$1(SocketAddress? socketAddress, int i) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    _bind$1(
      reference.pointer,
      _id_bind$1 as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
      i,
    ).check();
  }

  static final _id_getInetAddress = _class.instanceMethodId(
    r'getInetAddress',
    r'()Ljava/net/InetAddress;',
  );

  static final _getInetAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.InetAddress getInetAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  InetAddress? getInetAddress() => _getInetAddress(
    reference.pointer,
    _id_getInetAddress as jni$_.JMethodIDPtr,
  ).object<InetAddress?>(const $InetAddress$NullableType());

  static final _id_getLocalPort = _class.instanceMethodId(
    r'getLocalPort',
    r'()I',
  );

  static final _getLocalPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLocalPort()`
  int getLocalPort() =>
      _getLocalPort(
        reference.pointer,
        _id_getLocalPort as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getLocalSocketAddress = _class.instanceMethodId(
    r'getLocalSocketAddress',
    r'()Ljava/net/SocketAddress;',
  );

  static final _getLocalSocketAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.SocketAddress getLocalSocketAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  SocketAddress? getLocalSocketAddress() => _getLocalSocketAddress(
    reference.pointer,
    _id_getLocalSocketAddress as jni$_.JMethodIDPtr,
  ).object<SocketAddress?>(const $SocketAddress$NullableType());

  static final _id_accept = _class.instanceMethodId(
    r'accept',
    r'()Ljava/net/Socket;',
  );

  static final _accept =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.Socket accept()`
  /// The returned object must be released after use, by calling the [release] method.
  Socket? accept() => _accept(
    reference.pointer,
    _id_accept as jni$_.JMethodIDPtr,
  ).object<Socket?>(const $Socket$NullableType());

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_getChannel = _class.instanceMethodId(
    r'getChannel',
    r'()Ljava/nio/channels/ServerSocketChannel;',
  );

  static final _getChannel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.channels.ServerSocketChannel getChannel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChannel() => _getChannel(
    reference.pointer,
    _id_getChannel as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_isBound = _class.instanceMethodId(r'isBound', r'()Z');

  static final _isBound =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isBound()`
  bool isBound() =>
      _isBound(reference.pointer, _id_isBound as jni$_.JMethodIDPtr).boolean;

  static final _id_isClosed = _class.instanceMethodId(r'isClosed', r'()Z');

  static final _isClosed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isClosed()`
  bool isClosed() =>
      _isClosed(reference.pointer, _id_isClosed as jni$_.JMethodIDPtr).boolean;

  static final _id_setSoTimeout = _class.instanceMethodId(
    r'setSoTimeout',
    r'(I)V',
  );

  static final _setSoTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setSoTimeout(int i)`
  void setSoTimeout(int i) {
    _setSoTimeout(
      reference.pointer,
      _id_setSoTimeout as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getSoTimeout = _class.instanceMethodId(
    r'getSoTimeout',
    r'()I',
  );

  static final _getSoTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSoTimeout()`
  int getSoTimeout() =>
      _getSoTimeout(
        reference.pointer,
        _id_getSoTimeout as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setReuseAddress = _class.instanceMethodId(
    r'setReuseAddress',
    r'(Z)V',
  );

  static final _setReuseAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReuseAddress(boolean z)`
  void setReuseAddress(bool z) {
    _setReuseAddress(
      reference.pointer,
      _id_setReuseAddress as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getReuseAddress = _class.instanceMethodId(
    r'getReuseAddress',
    r'()Z',
  );

  static final _getReuseAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getReuseAddress()`
  bool getReuseAddress() =>
      _getReuseAddress(
        reference.pointer,
        _id_getReuseAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setSocketFactory = _class.staticMethodId(
    r'setSocketFactory',
    r'(Ljava/net/SocketImplFactory;)V',
  );

  static final _setSocketFactory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setSocketFactory(java.net.SocketImplFactory socketImplFactory)`
  static void setSocketFactory(SocketImplFactory? socketImplFactory) {
    final _$socketImplFactory =
        socketImplFactory?.reference ?? jni$_.jNullReference;
    _setSocketFactory(
      _class.reference.pointer,
      _id_setSocketFactory as jni$_.JMethodIDPtr,
      _$socketImplFactory.pointer,
    ).check();
  }

  static final _id_setReceiveBufferSize = _class.instanceMethodId(
    r'setReceiveBufferSize',
    r'(I)V',
  );

  static final _setReceiveBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReceiveBufferSize(int i)`
  void setReceiveBufferSize(int i) {
    _setReceiveBufferSize(
      reference.pointer,
      _id_setReceiveBufferSize as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getReceiveBufferSize = _class.instanceMethodId(
    r'getReceiveBufferSize',
    r'()I',
  );

  static final _getReceiveBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getReceiveBufferSize()`
  int getReceiveBufferSize() =>
      _getReceiveBufferSize(
        reference.pointer,
        _id_getReceiveBufferSize as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setPerformancePreferences = _class.instanceMethodId(
    r'setPerformancePreferences',
    r'(III)V',
  );

  static final _setPerformancePreferences =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public void setPerformancePreferences(int i, int i1, int i2)`
  void setPerformancePreferences(int i, int i1, int i2) {
    _setPerformancePreferences(
      reference.pointer,
      _id_setPerformancePreferences as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
    ).check();
  }

  static final _id_setOption = _class.instanceMethodId(
    r'setOption',
    r'(Ljava/net/SocketOption;Ljava/lang/Object;)Ljava/net/ServerSocket;',
  );

  static final _setOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.net.ServerSocket setOption(java.net.SocketOption<T> socketOption, T object)`
  /// The returned object must be released after use, by calling the [release] method.
  ServerSocket? setOption<$T extends jni$_.JObject?>(
    SocketOption<$T?>? socketOption,
    $T? object, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$socketOption = socketOption?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _setOption(
      reference.pointer,
      _id_setOption as jni$_.JMethodIDPtr,
      _$socketOption.pointer,
      _$object.pointer,
    ).object<ServerSocket?>(const $ServerSocket$NullableType());
  }

  static final _id_getOption = _class.instanceMethodId(
    r'getOption',
    r'(Ljava/net/SocketOption;)Ljava/lang/Object;',
  );

  static final _getOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public T getOption(java.net.SocketOption<T> socketOption)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? getOption<$T extends jni$_.JObject?>(
    SocketOption<$T?>? socketOption, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$socketOption = socketOption?.reference ?? jni$_.jNullReference;
    return _getOption(
      reference.pointer,
      _id_getOption as jni$_.JMethodIDPtr,
      _$socketOption.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_supportedOptions = _class.instanceMethodId(
    r'supportedOptions',
    r'()Ljava/util/Set;',
  );

  static final _supportedOptions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<java.net.SocketOption<?>> supportedOptions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<SocketOption<jni$_.JObject?>?>? supportedOptions() =>
      _supportedOptions(
        reference.pointer,
        _id_supportedOptions as jni$_.JMethodIDPtr,
      ).object<jni$_.JSet<SocketOption<jni$_.JObject?>?>?>(
        const jni$_.JSetNullableType<SocketOption<jni$_.JObject?>?>(
          $SocketOption$NullableType<jni$_.JObject?>(
            jni$_.JObjectNullableType(),
          ),
        ),
      );
}

final class $ServerSocket$NullableType extends jni$_.JObjType<ServerSocket?> {
  @jni$_.internal
  const $ServerSocket$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ServerSocket;';

  @jni$_.internal
  @core$_.override
  ServerSocket? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ServerSocket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ServerSocket?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ServerSocket$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ServerSocket$NullableType) &&
      other is $ServerSocket$NullableType;
}

final class $ServerSocket$Type extends jni$_.JObjType<ServerSocket> {
  @jni$_.internal
  const $ServerSocket$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ServerSocket;';

  @jni$_.internal
  @core$_.override
  ServerSocket fromReference(jni$_.JReference reference) =>
      ServerSocket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ServerSocket?> get nullableType =>
      const $ServerSocket$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ServerSocket$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ServerSocket$Type) && other is $ServerSocket$Type;
}

/// from: `java.net.HttpCookie`
class HttpCookie extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<HttpCookie> $type;

  @jni$_.internal
  HttpCookie.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/HttpCookie');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $HttpCookie$NullableType();
  static const type = $HttpCookie$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HttpCookie(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return HttpCookie.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/String;)Ljava/util/List;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.util.List<java.net.HttpCookie> parse(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JList<HttpCookie?>? parse(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JList<HttpCookie?>?>(
      const jni$_.JListNullableType<HttpCookie?>($HttpCookie$NullableType()),
    );
  }

  static final _id_hasExpired = _class.instanceMethodId(r'hasExpired', r'()Z');

  static final _hasExpired =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasExpired()`
  bool hasExpired() =>
      _hasExpired(
        reference.pointer,
        _id_hasExpired as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setComment = _class.instanceMethodId(
    r'setComment',
    r'(Ljava/lang/String;)V',
  );

  static final _setComment =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setComment(java.lang.String string)`
  void setComment(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setComment(
      reference.pointer,
      _id_setComment as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getComment = _class.instanceMethodId(
    r'getComment',
    r'()Ljava/lang/String;',
  );

  static final _getComment =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getComment()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getComment() => _getComment(
    reference.pointer,
    _id_getComment as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setCommentURL = _class.instanceMethodId(
    r'setCommentURL',
    r'(Ljava/lang/String;)V',
  );

  static final _setCommentURL =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setCommentURL(java.lang.String string)`
  void setCommentURL(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setCommentURL(
      reference.pointer,
      _id_setCommentURL as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getCommentURL = _class.instanceMethodId(
    r'getCommentURL',
    r'()Ljava/lang/String;',
  );

  static final _getCommentURL =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getCommentURL()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCommentURL() => _getCommentURL(
    reference.pointer,
    _id_getCommentURL as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setDiscard = _class.instanceMethodId(r'setDiscard', r'(Z)V');

  static final _setDiscard =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setDiscard(boolean z)`
  void setDiscard(bool z) {
    _setDiscard(
      reference.pointer,
      _id_setDiscard as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getDiscard = _class.instanceMethodId(r'getDiscard', r'()Z');

  static final _getDiscard =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getDiscard()`
  bool getDiscard() =>
      _getDiscard(
        reference.pointer,
        _id_getDiscard as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setPortlist = _class.instanceMethodId(
    r'setPortlist',
    r'(Ljava/lang/String;)V',
  );

  static final _setPortlist =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setPortlist(java.lang.String string)`
  void setPortlist(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setPortlist(
      reference.pointer,
      _id_setPortlist as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getPortlist = _class.instanceMethodId(
    r'getPortlist',
    r'()Ljava/lang/String;',
  );

  static final _getPortlist =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getPortlist()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPortlist() => _getPortlist(
    reference.pointer,
    _id_getPortlist as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setDomain = _class.instanceMethodId(
    r'setDomain',
    r'(Ljava/lang/String;)V',
  );

  static final _setDomain =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setDomain(java.lang.String string)`
  void setDomain(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDomain(
      reference.pointer,
      _id_setDomain as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getDomain = _class.instanceMethodId(
    r'getDomain',
    r'()Ljava/lang/String;',
  );

  static final _getDomain =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getDomain()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDomain() => _getDomain(
    reference.pointer,
    _id_getDomain as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setMaxAge = _class.instanceMethodId(r'setMaxAge', r'(J)V');

  static final _setMaxAge =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMaxAge(long j)`
  void setMaxAge(int j) {
    _setMaxAge(
      reference.pointer,
      _id_setMaxAge as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_getMaxAge = _class.instanceMethodId(r'getMaxAge', r'()J');

  static final _getMaxAge =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getMaxAge()`
  int getMaxAge() =>
      _getMaxAge(reference.pointer, _id_getMaxAge as jni$_.JMethodIDPtr).long;

  static final _id_setPath = _class.instanceMethodId(
    r'setPath',
    r'(Ljava/lang/String;)V',
  );

  static final _setPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setPath(java.lang.String string)`
  void setPath(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setPath(
      reference.pointer,
      _id_setPath as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getPath = _class.instanceMethodId(
    r'getPath',
    r'()Ljava/lang/String;',
  );

  static final _getPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPath() => _getPath(
    reference.pointer,
    _id_getPath as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setSecure = _class.instanceMethodId(r'setSecure', r'(Z)V');

  static final _setSecure =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setSecure(boolean z)`
  void setSecure(bool z) {
    _setSecure(
      reference.pointer,
      _id_setSecure as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getSecure = _class.instanceMethodId(r'getSecure', r'()Z');

  static final _getSecure =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getSecure()`
  bool getSecure() =>
      _getSecure(
        reference.pointer,
        _id_getSecure as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() => _getName(
    reference.pointer,
    _id_getName as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setValue = _class.instanceMethodId(
    r'setValue',
    r'(Ljava/lang/String;)V',
  );

  static final _setValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setValue(java.lang.String string)`
  void setValue(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setValue(
      reference.pointer,
      _id_setValue as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getValue = _class.instanceMethodId(
    r'getValue',
    r'()Ljava/lang/String;',
  );

  static final _getValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getValue()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getValue() => _getValue(
    reference.pointer,
    _id_getValue as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getVersion = _class.instanceMethodId(r'getVersion', r'()I');

  static final _getVersion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getVersion()`
  int getVersion() =>
      _getVersion(
        reference.pointer,
        _id_getVersion as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setVersion = _class.instanceMethodId(r'setVersion', r'(I)V');

  static final _setVersion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setVersion(int i)`
  void setVersion(int i) {
    _setVersion(
      reference.pointer,
      _id_setVersion as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_isHttpOnly = _class.instanceMethodId(r'isHttpOnly', r'()Z');

  static final _isHttpOnly =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isHttpOnly()`
  bool isHttpOnly() =>
      _isHttpOnly(
        reference.pointer,
        _id_isHttpOnly as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setHttpOnly = _class.instanceMethodId(
    r'setHttpOnly',
    r'(Z)V',
  );

  static final _setHttpOnly =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setHttpOnly(boolean z)`
  void setHttpOnly(bool z) {
    _setHttpOnly(
      reference.pointer,
      _id_setHttpOnly as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_domainMatches = _class.staticMethodId(
    r'domainMatches',
    r'(Ljava/lang/String;Ljava/lang/String;)Z',
  );

  static final _domainMatches =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public boolean domainMatches(java.lang.String string, java.lang.String string1)`
  static bool domainMatches(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _domainMatches(
      _class.reference.pointer,
      _id_domainMatches as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).boolean;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
}

final class $HttpCookie$NullableType extends jni$_.JObjType<HttpCookie?> {
  @jni$_.internal
  const $HttpCookie$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/HttpCookie;';

  @jni$_.internal
  @core$_.override
  HttpCookie? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : HttpCookie.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HttpCookie?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($HttpCookie$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($HttpCookie$NullableType) &&
      other is $HttpCookie$NullableType;
}

final class $HttpCookie$Type extends jni$_.JObjType<HttpCookie> {
  @jni$_.internal
  const $HttpCookie$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/HttpCookie;';

  @jni$_.internal
  @core$_.override
  HttpCookie fromReference(jni$_.JReference reference) =>
      HttpCookie.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HttpCookie?> get nullableType =>
      const $HttpCookie$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($HttpCookie$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($HttpCookie$Type) && other is $HttpCookie$Type;
}

/// from: `java.net.URLClassLoader`
class URLClassLoader extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<URLClassLoader> $type;

  @jni$_.internal
  URLClassLoader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/URLClassLoader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $URLClassLoader$NullableType();
  static const type = $URLClassLoader$Type();
  static final _id_new$ = _class.constructorId(
    r'([Ljava/net/URL;Ljava/lang/ClassLoader;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.URL[] uRLs, java.lang.ClassLoader classLoader)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URLClassLoader(jni$_.JArray<URL?>? uRLs, jni$_.JObject? classLoader) {
    final _$uRLs = uRLs?.reference ?? jni$_.jNullReference;
    final _$classLoader = classLoader?.reference ?? jni$_.jNullReference;
    return URLClassLoader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$uRLs.pointer,
        _$classLoader.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'([Ljava/net/URL;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.URL[] uRLs)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URLClassLoader.new$1(jni$_.JArray<URL?>? uRLs) {
    final _$uRLs = uRLs?.reference ?? jni$_.jNullReference;
    return URLClassLoader.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$uRLs.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'([Ljava/net/URL;Ljava/lang/ClassLoader;Ljava/net/URLStreamHandlerFactory;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.URL[] uRLs, java.lang.ClassLoader classLoader, java.net.URLStreamHandlerFactory uRLStreamHandlerFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URLClassLoader.new$2(
    jni$_.JArray<URL?>? uRLs,
    jni$_.JObject? classLoader,
    URLStreamHandlerFactory? uRLStreamHandlerFactory,
  ) {
    final _$uRLs = uRLs?.reference ?? jni$_.jNullReference;
    final _$classLoader = classLoader?.reference ?? jni$_.jNullReference;
    final _$uRLStreamHandlerFactory =
        uRLStreamHandlerFactory?.reference ?? jni$_.jNullReference;
    return URLClassLoader.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$uRLs.pointer,
        _$classLoader.pointer,
        _$uRLStreamHandlerFactory.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/lang/String;[Ljava/net/URL;Ljava/lang/ClassLoader;)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.net.URL[] uRLs, java.lang.ClassLoader classLoader)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URLClassLoader.new$3(
    jni$_.JString? string,
    jni$_.JArray<URL?>? uRLs,
    jni$_.JObject? classLoader,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$uRLs = uRLs?.reference ?? jni$_.jNullReference;
    final _$classLoader = classLoader?.reference ?? jni$_.jNullReference;
    return URLClassLoader.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$uRLs.pointer,
        _$classLoader.pointer,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(
    r'(Ljava/lang/String;[Ljava/net/URL;Ljava/lang/ClassLoader;Ljava/net/URLStreamHandlerFactory;)V',
  );

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.net.URL[] uRLs, java.lang.ClassLoader classLoader, java.net.URLStreamHandlerFactory uRLStreamHandlerFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URLClassLoader.new$4(
    jni$_.JString? string,
    jni$_.JArray<URL?>? uRLs,
    jni$_.JObject? classLoader,
    URLStreamHandlerFactory? uRLStreamHandlerFactory,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$uRLs = uRLs?.reference ?? jni$_.jNullReference;
    final _$classLoader = classLoader?.reference ?? jni$_.jNullReference;
    final _$uRLStreamHandlerFactory =
        uRLStreamHandlerFactory?.reference ?? jni$_.jNullReference;
    return URLClassLoader.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$uRLs.pointer,
        _$classLoader.pointer,
        _$uRLStreamHandlerFactory.pointer,
      ).reference,
    );
  }

  static final _id_getResourceAsStream = _class.instanceMethodId(
    r'getResourceAsStream',
    r'(Ljava/lang/String;)Ljava/io/InputStream;',
  );

  static final _getResourceAsStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.InputStream getResourceAsStream(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  InputStream? getResourceAsStream(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getResourceAsStream(
      reference.pointer,
      _id_getResourceAsStream as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<InputStream?>(const $InputStream$NullableType());
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_getURLs = _class.instanceMethodId(
    r'getURLs',
    r'()[Ljava/net/URL;',
  );

  static final _getURLs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URL[] getURLs()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<URL?>? getURLs() => _getURLs(
    reference.pointer,
    _id_getURLs as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<URL?>?>(
    const jni$_.JArrayNullableType<URL?>($URL$NullableType()),
  );

  static final _id_findResource = _class.instanceMethodId(
    r'findResource',
    r'(Ljava/lang/String;)Ljava/net/URL;',
  );

  static final _findResource =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.net.URL findResource(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  URL? findResource(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _findResource(
      reference.pointer,
      _id_findResource as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<URL?>(const $URL$NullableType());
  }

  static final _id_findResources = _class.instanceMethodId(
    r'findResources',
    r'(Ljava/lang/String;)Ljava/util/Enumeration;',
  );

  static final _findResources =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.Enumeration<java.net.URL> findResources(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? findResources(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _findResources(
      reference.pointer,
      _id_findResources as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_newInstance = _class.staticMethodId(
    r'newInstance',
    r'([Ljava/net/URL;Ljava/lang/ClassLoader;)Ljava/net/URLClassLoader;',
  );

  static final _newInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.URLClassLoader newInstance(java.net.URL[] uRLs, java.lang.ClassLoader classLoader)`
  /// The returned object must be released after use, by calling the [release] method.
  static URLClassLoader? newInstance(
    jni$_.JArray<URL?>? uRLs,
    jni$_.JObject? classLoader,
  ) {
    final _$uRLs = uRLs?.reference ?? jni$_.jNullReference;
    final _$classLoader = classLoader?.reference ?? jni$_.jNullReference;
    return _newInstance(
      _class.reference.pointer,
      _id_newInstance as jni$_.JMethodIDPtr,
      _$uRLs.pointer,
      _$classLoader.pointer,
    ).object<URLClassLoader?>(const $URLClassLoader$NullableType());
  }

  static final _id_newInstance$1 = _class.staticMethodId(
    r'newInstance',
    r'([Ljava/net/URL;)Ljava/net/URLClassLoader;',
  );

  static final _newInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.URLClassLoader newInstance(java.net.URL[] uRLs)`
  /// The returned object must be released after use, by calling the [release] method.
  static URLClassLoader? newInstance$1(jni$_.JArray<URL?>? uRLs) {
    final _$uRLs = uRLs?.reference ?? jni$_.jNullReference;
    return _newInstance$1(
      _class.reference.pointer,
      _id_newInstance$1 as jni$_.JMethodIDPtr,
      _$uRLs.pointer,
    ).object<URLClassLoader?>(const $URLClassLoader$NullableType());
  }
}

final class $URLClassLoader$NullableType
    extends jni$_.JObjType<URLClassLoader?> {
  @jni$_.internal
  const $URLClassLoader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLClassLoader;';

  @jni$_.internal
  @core$_.override
  URLClassLoader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : URLClassLoader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URLClassLoader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLClassLoader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URLClassLoader$NullableType) &&
      other is $URLClassLoader$NullableType;
}

final class $URLClassLoader$Type extends jni$_.JObjType<URLClassLoader> {
  @jni$_.internal
  const $URLClassLoader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLClassLoader;';

  @jni$_.internal
  @core$_.override
  URLClassLoader fromReference(jni$_.JReference reference) =>
      URLClassLoader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URLClassLoader?> get nullableType =>
      const $URLClassLoader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLClassLoader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URLClassLoader$Type) &&
      other is $URLClassLoader$Type;
}

/// from: `java.net.Proxy`
class Proxy extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Proxy> $type;

  @jni$_.internal
  Proxy.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/Proxy');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Proxy$NullableType();
  static const type = $Proxy$Type();
  static final _id_NO_PROXY = _class.staticFieldId(
    r'NO_PROXY',
    r'Ljava/net/Proxy;',
  );

  /// from: `static public final java.net.Proxy NO_PROXY`
  /// The returned object must be released after use, by calling the [release] method.
  static Proxy? get NO_PROXY =>
      _id_NO_PROXY.get(_class, const $Proxy$NullableType());

  static final _id_new$ = _class.constructorId(
    r'(Ljava/net/Proxy$Type;Ljava/net/SocketAddress;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.Proxy$Type type, java.net.SocketAddress socketAddress)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Proxy(Proxy$Type? type, SocketAddress? socketAddress) {
    final _$type = type?.reference ?? jni$_.jNullReference;
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    return Proxy.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$type.pointer,
        _$socketAddress.pointer,
      ).reference,
    );
  }

  static final _id_type$1 = _class.instanceMethodId(
    r'type',
    r'()Ljava/net/Proxy$Type;',
  );

  static final _type$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.Proxy$Type type()`
  /// The returned object must be released after use, by calling the [release] method.
  Proxy$Type? type$1() => _type$1(
    reference.pointer,
    _id_type$1 as jni$_.JMethodIDPtr,
  ).object<Proxy$Type?>(const $Proxy$Type$NullableType());

  static final _id_address = _class.instanceMethodId(
    r'address',
    r'()Ljava/net/SocketAddress;',
  );

  static final _address =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.SocketAddress address()`
  /// The returned object must be released after use, by calling the [release] method.
  SocketAddress? address() => _address(
    reference.pointer,
    _id_address as jni$_.JMethodIDPtr,
  ).object<SocketAddress?>(const $SocketAddress$NullableType());

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;
}

final class $Proxy$NullableType extends jni$_.JObjType<Proxy?> {
  @jni$_.internal
  const $Proxy$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Proxy;';

  @jni$_.internal
  @core$_.override
  Proxy? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Proxy.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Proxy?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Proxy$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Proxy$NullableType) &&
      other is $Proxy$NullableType;
}

final class $Proxy$Type extends jni$_.JObjType<Proxy> {
  @jni$_.internal
  const $Proxy$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Proxy;';

  @jni$_.internal
  @core$_.override
  Proxy fromReference(jni$_.JReference reference) =>
      Proxy.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Proxy?> get nullableType => const $Proxy$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Proxy$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Proxy$Type) && other is $Proxy$Type;
}

/// from: `java.net.PortUnreachableException`
class PortUnreachableException extends SocketException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PortUnreachableException> $type;

  @jni$_.internal
  PortUnreachableException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/net/PortUnreachableException',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PortUnreachableException$NullableType();
  static const type = $PortUnreachableException$Type();
  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PortUnreachableException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return PortUnreachableException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory PortUnreachableException() => PortUnreachableException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );
}

final class $PortUnreachableException$NullableType
    extends jni$_.JObjType<PortUnreachableException?> {
  @jni$_.internal
  const $PortUnreachableException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/PortUnreachableException;';

  @jni$_.internal
  @core$_.override
  PortUnreachableException? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : PortUnreachableException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SocketException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PortUnreachableException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($PortUnreachableException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PortUnreachableException$NullableType) &&
      other is $PortUnreachableException$NullableType;
}

final class $PortUnreachableException$Type
    extends jni$_.JObjType<PortUnreachableException> {
  @jni$_.internal
  const $PortUnreachableException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/PortUnreachableException;';

  @jni$_.internal
  @core$_.override
  PortUnreachableException fromReference(jni$_.JReference reference) =>
      PortUnreachableException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SocketException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PortUnreachableException?> get nullableType =>
      const $PortUnreachableException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($PortUnreachableException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PortUnreachableException$Type) &&
      other is $PortUnreachableException$Type;
}

/// from: `java.net.StandardProtocolFamily`
class StandardProtocolFamily extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StandardProtocolFamily> $type;

  @jni$_.internal
  StandardProtocolFamily.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/net/StandardProtocolFamily',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StandardProtocolFamily$NullableType();
  static const type = $StandardProtocolFamily$Type();
  static final _id_INET = _class.staticFieldId(
    r'INET',
    r'Ljava/net/StandardProtocolFamily;',
  );

  /// from: `static public final java.net.StandardProtocolFamily INET`
  /// The returned object must be released after use, by calling the [release] method.
  static StandardProtocolFamily get INET =>
      _id_INET.get(_class, const $StandardProtocolFamily$Type());

  static final _id_INET6 = _class.staticFieldId(
    r'INET6',
    r'Ljava/net/StandardProtocolFamily;',
  );

  /// from: `static public final java.net.StandardProtocolFamily INET6`
  /// The returned object must be released after use, by calling the [release] method.
  static StandardProtocolFamily get INET6 =>
      _id_INET6.get(_class, const $StandardProtocolFamily$Type());

  static final _id_UNIX = _class.staticFieldId(
    r'UNIX',
    r'Ljava/net/StandardProtocolFamily;',
  );

  /// from: `static public final java.net.StandardProtocolFamily UNIX`
  /// The returned object must be released after use, by calling the [release] method.
  static StandardProtocolFamily get UNIX =>
      _id_UNIX.get(_class, const $StandardProtocolFamily$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/net/StandardProtocolFamily;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.net.StandardProtocolFamily[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<StandardProtocolFamily?>? values() => _values(
    _class.reference.pointer,
    _id_values as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<StandardProtocolFamily?>?>(
    const jni$_.JArrayNullableType<StandardProtocolFamily?>(
      $StandardProtocolFamily$NullableType(),
    ),
  );

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/net/StandardProtocolFamily;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.StandardProtocolFamily valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static StandardProtocolFamily? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<StandardProtocolFamily?>(
      const $StandardProtocolFamily$NullableType(),
    );
  }

  static final _id_name = _class.instanceMethodId(
    r'name',
    r'()Ljava/lang/String;',
  );

  static final _name =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String name()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? name() => _name(
    reference.pointer,
    _id_name as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $StandardProtocolFamily$NullableType
    extends jni$_.JObjType<StandardProtocolFamily?> {
  @jni$_.internal
  const $StandardProtocolFamily$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/StandardProtocolFamily;';

  @jni$_.internal
  @core$_.override
  StandardProtocolFamily? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : StandardProtocolFamily.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StandardProtocolFamily?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StandardProtocolFamily$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StandardProtocolFamily$NullableType) &&
      other is $StandardProtocolFamily$NullableType;
}

final class $StandardProtocolFamily$Type
    extends jni$_.JObjType<StandardProtocolFamily> {
  @jni$_.internal
  const $StandardProtocolFamily$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/StandardProtocolFamily;';

  @jni$_.internal
  @core$_.override
  StandardProtocolFamily fromReference(jni$_.JReference reference) =>
      StandardProtocolFamily.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StandardProtocolFamily?> get nullableType =>
      const $StandardProtocolFamily$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StandardProtocolFamily$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StandardProtocolFamily$Type) &&
      other is $StandardProtocolFamily$Type;
}

/// from: `java.net.JarURLConnection`
class JarURLConnection extends URLConnection {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<JarURLConnection> $type;

  @jni$_.internal
  JarURLConnection.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/JarURLConnection');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $JarURLConnection$NullableType();
  static const type = $JarURLConnection$Type();
  static final _id_getJarFileURL = _class.instanceMethodId(
    r'getJarFileURL',
    r'()Ljava/net/URL;',
  );

  static final _getJarFileURL =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URL getJarFileURL()`
  /// The returned object must be released after use, by calling the [release] method.
  URL? getJarFileURL() => _getJarFileURL(
    reference.pointer,
    _id_getJarFileURL as jni$_.JMethodIDPtr,
  ).object<URL?>(const $URL$NullableType());

  static final _id_getEntryName = _class.instanceMethodId(
    r'getEntryName',
    r'()Ljava/lang/String;',
  );

  static final _getEntryName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getEntryName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getEntryName() => _getEntryName(
    reference.pointer,
    _id_getEntryName as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getJarFile = _class.instanceMethodId(
    r'getJarFile',
    r'()Ljava/util/jar/JarFile;',
  );

  static final _getJarFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.util.jar.JarFile getJarFile()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getJarFile() => _getJarFile(
    reference.pointer,
    _id_getJarFile as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getManifest = _class.instanceMethodId(
    r'getManifest',
    r'()Ljava/util/jar/Manifest;',
  );

  static final _getManifest =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.jar.Manifest getManifest()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getManifest() => _getManifest(
    reference.pointer,
    _id_getManifest as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getJarEntry = _class.instanceMethodId(
    r'getJarEntry',
    r'()Ljava/util/jar/JarEntry;',
  );

  static final _getJarEntry =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.jar.JarEntry getJarEntry()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getJarEntry() => _getJarEntry(
    reference.pointer,
    _id_getJarEntry as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getAttributes = _class.instanceMethodId(
    r'getAttributes',
    r'()Ljava/util/jar/Attributes;',
  );

  static final _getAttributes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.jar.Attributes getAttributes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getAttributes() => _getAttributes(
    reference.pointer,
    _id_getAttributes as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getMainAttributes = _class.instanceMethodId(
    r'getMainAttributes',
    r'()Ljava/util/jar/Attributes;',
  );

  static final _getMainAttributes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.jar.Attributes getMainAttributes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getMainAttributes() => _getMainAttributes(
    reference.pointer,
    _id_getMainAttributes as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getCertificates = _class.instanceMethodId(
    r'getCertificates',
    r'()[Ljava/security/cert/Certificate;',
  );

  static final _getCertificates =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.security.cert.Certificate[] getCertificates()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? getCertificates() => _getCertificates(
    reference.pointer,
    _id_getCertificates as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<jni$_.JObject?>?>(
    const jni$_.JArrayNullableType<jni$_.JObject?>(jni$_.JObjectNullableType()),
  );
}

final class $JarURLConnection$NullableType
    extends jni$_.JObjType<JarURLConnection?> {
  @jni$_.internal
  const $JarURLConnection$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/JarURLConnection;';

  @jni$_.internal
  @core$_.override
  JarURLConnection? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : JarURLConnection.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $URLConnection$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JarURLConnection?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($JarURLConnection$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($JarURLConnection$NullableType) &&
      other is $JarURLConnection$NullableType;
}

final class $JarURLConnection$Type extends jni$_.JObjType<JarURLConnection> {
  @jni$_.internal
  const $JarURLConnection$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/JarURLConnection;';

  @jni$_.internal
  @core$_.override
  JarURLConnection fromReference(jni$_.JReference reference) =>
      JarURLConnection.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $URLConnection$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<JarURLConnection?> get nullableType =>
      const $JarURLConnection$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($JarURLConnection$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($JarURLConnection$Type) &&
      other is $JarURLConnection$Type;
}

/// from: `java.net.StandardSocketOptions`
class StandardSocketOptions extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StandardSocketOptions> $type;

  @jni$_.internal
  StandardSocketOptions.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/StandardSocketOptions');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StandardSocketOptions$NullableType();
  static const type = $StandardSocketOptions$Type();
  static final _id_SO_BROADCAST = _class.staticFieldId(
    r'SO_BROADCAST',
    r'Ljava/net/SocketOption;',
  );

  /// from: `static public final java.net.SocketOption<java.lang.Boolean> SO_BROADCAST`
  /// The returned object must be released after use, by calling the [release] method.
  static SocketOption<jni$_.JBoolean?>? get SO_BROADCAST =>
      _id_SO_BROADCAST.get(
        _class,
        const $SocketOption$NullableType<jni$_.JBoolean?>(
          jni$_.JBooleanNullableType(),
        ),
      );

  static final _id_SO_KEEPALIVE = _class.staticFieldId(
    r'SO_KEEPALIVE',
    r'Ljava/net/SocketOption;',
  );

  /// from: `static public final java.net.SocketOption<java.lang.Boolean> SO_KEEPALIVE`
  /// The returned object must be released after use, by calling the [release] method.
  static SocketOption<jni$_.JBoolean?>? get SO_KEEPALIVE =>
      _id_SO_KEEPALIVE.get(
        _class,
        const $SocketOption$NullableType<jni$_.JBoolean?>(
          jni$_.JBooleanNullableType(),
        ),
      );

  static final _id_SO_SNDBUF = _class.staticFieldId(
    r'SO_SNDBUF',
    r'Ljava/net/SocketOption;',
  );

  /// from: `static public final java.net.SocketOption<java.lang.Integer> SO_SNDBUF`
  /// The returned object must be released after use, by calling the [release] method.
  static SocketOption<jni$_.JInteger?>? get SO_SNDBUF => _id_SO_SNDBUF.get(
    _class,
    const $SocketOption$NullableType<jni$_.JInteger?>(
      jni$_.JIntegerNullableType(),
    ),
  );

  static final _id_SO_RCVBUF = _class.staticFieldId(
    r'SO_RCVBUF',
    r'Ljava/net/SocketOption;',
  );

  /// from: `static public final java.net.SocketOption<java.lang.Integer> SO_RCVBUF`
  /// The returned object must be released after use, by calling the [release] method.
  static SocketOption<jni$_.JInteger?>? get SO_RCVBUF => _id_SO_RCVBUF.get(
    _class,
    const $SocketOption$NullableType<jni$_.JInteger?>(
      jni$_.JIntegerNullableType(),
    ),
  );

  static final _id_SO_REUSEADDR = _class.staticFieldId(
    r'SO_REUSEADDR',
    r'Ljava/net/SocketOption;',
  );

  /// from: `static public final java.net.SocketOption<java.lang.Boolean> SO_REUSEADDR`
  /// The returned object must be released after use, by calling the [release] method.
  static SocketOption<jni$_.JBoolean?>? get SO_REUSEADDR =>
      _id_SO_REUSEADDR.get(
        _class,
        const $SocketOption$NullableType<jni$_.JBoolean?>(
          jni$_.JBooleanNullableType(),
        ),
      );

  static final _id_SO_REUSEPORT = _class.staticFieldId(
    r'SO_REUSEPORT',
    r'Ljava/net/SocketOption;',
  );

  /// from: `static public final java.net.SocketOption<java.lang.Boolean> SO_REUSEPORT`
  /// The returned object must be released after use, by calling the [release] method.
  static SocketOption<jni$_.JBoolean?>? get SO_REUSEPORT =>
      _id_SO_REUSEPORT.get(
        _class,
        const $SocketOption$NullableType<jni$_.JBoolean?>(
          jni$_.JBooleanNullableType(),
        ),
      );

  static final _id_SO_LINGER = _class.staticFieldId(
    r'SO_LINGER',
    r'Ljava/net/SocketOption;',
  );

  /// from: `static public final java.net.SocketOption<java.lang.Integer> SO_LINGER`
  /// The returned object must be released after use, by calling the [release] method.
  static SocketOption<jni$_.JInteger?>? get SO_LINGER => _id_SO_LINGER.get(
    _class,
    const $SocketOption$NullableType<jni$_.JInteger?>(
      jni$_.JIntegerNullableType(),
    ),
  );

  static final _id_IP_TOS = _class.staticFieldId(
    r'IP_TOS',
    r'Ljava/net/SocketOption;',
  );

  /// from: `static public final java.net.SocketOption<java.lang.Integer> IP_TOS`
  /// The returned object must be released after use, by calling the [release] method.
  static SocketOption<jni$_.JInteger?>? get IP_TOS => _id_IP_TOS.get(
    _class,
    const $SocketOption$NullableType<jni$_.JInteger?>(
      jni$_.JIntegerNullableType(),
    ),
  );

  static final _id_IP_MULTICAST_IF = _class.staticFieldId(
    r'IP_MULTICAST_IF',
    r'Ljava/net/SocketOption;',
  );

  /// from: `static public final java.net.SocketOption<java.net.NetworkInterface> IP_MULTICAST_IF`
  /// The returned object must be released after use, by calling the [release] method.
  static SocketOption<NetworkInterface?>? get IP_MULTICAST_IF =>
      _id_IP_MULTICAST_IF.get(
        _class,
        const $SocketOption$NullableType<NetworkInterface?>(
          $NetworkInterface$NullableType(),
        ),
      );

  static final _id_IP_MULTICAST_TTL = _class.staticFieldId(
    r'IP_MULTICAST_TTL',
    r'Ljava/net/SocketOption;',
  );

  /// from: `static public final java.net.SocketOption<java.lang.Integer> IP_MULTICAST_TTL`
  /// The returned object must be released after use, by calling the [release] method.
  static SocketOption<jni$_.JInteger?>? get IP_MULTICAST_TTL =>
      _id_IP_MULTICAST_TTL.get(
        _class,
        const $SocketOption$NullableType<jni$_.JInteger?>(
          jni$_.JIntegerNullableType(),
        ),
      );

  static final _id_IP_MULTICAST_LOOP = _class.staticFieldId(
    r'IP_MULTICAST_LOOP',
    r'Ljava/net/SocketOption;',
  );

  /// from: `static public final java.net.SocketOption<java.lang.Boolean> IP_MULTICAST_LOOP`
  /// The returned object must be released after use, by calling the [release] method.
  static SocketOption<jni$_.JBoolean?>? get IP_MULTICAST_LOOP =>
      _id_IP_MULTICAST_LOOP.get(
        _class,
        const $SocketOption$NullableType<jni$_.JBoolean?>(
          jni$_.JBooleanNullableType(),
        ),
      );

  static final _id_TCP_NODELAY = _class.staticFieldId(
    r'TCP_NODELAY',
    r'Ljava/net/SocketOption;',
  );

  /// from: `static public final java.net.SocketOption<java.lang.Boolean> TCP_NODELAY`
  /// The returned object must be released after use, by calling the [release] method.
  static SocketOption<jni$_.JBoolean?>? get TCP_NODELAY => _id_TCP_NODELAY.get(
    _class,
    const $SocketOption$NullableType<jni$_.JBoolean?>(
      jni$_.JBooleanNullableType(),
    ),
  );
}

final class $StandardSocketOptions$NullableType
    extends jni$_.JObjType<StandardSocketOptions?> {
  @jni$_.internal
  const $StandardSocketOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/StandardSocketOptions;';

  @jni$_.internal
  @core$_.override
  StandardSocketOptions? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : StandardSocketOptions.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StandardSocketOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StandardSocketOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StandardSocketOptions$NullableType) &&
      other is $StandardSocketOptions$NullableType;
}

final class $StandardSocketOptions$Type
    extends jni$_.JObjType<StandardSocketOptions> {
  @jni$_.internal
  const $StandardSocketOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/StandardSocketOptions;';

  @jni$_.internal
  @core$_.override
  StandardSocketOptions fromReference(jni$_.JReference reference) =>
      StandardSocketOptions.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StandardSocketOptions?> get nullableType =>
      const $StandardSocketOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StandardSocketOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StandardSocketOptions$Type) &&
      other is $StandardSocketOptions$Type;
}

/// from: `java.net.InterfaceAddress`
class InterfaceAddress extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InterfaceAddress> $type;

  @jni$_.internal
  InterfaceAddress.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/InterfaceAddress');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InterfaceAddress$NullableType();
  static const type = $InterfaceAddress$Type();
  static final _id_getAddress = _class.instanceMethodId(
    r'getAddress',
    r'()Ljava/net/InetAddress;',
  );

  static final _getAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.InetAddress getAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  InetAddress? getAddress() => _getAddress(
    reference.pointer,
    _id_getAddress as jni$_.JMethodIDPtr,
  ).object<InetAddress?>(const $InetAddress$NullableType());

  static final _id_getBroadcast = _class.instanceMethodId(
    r'getBroadcast',
    r'()Ljava/net/InetAddress;',
  );

  static final _getBroadcast =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.InetAddress getBroadcast()`
  /// The returned object must be released after use, by calling the [release] method.
  InetAddress? getBroadcast() => _getBroadcast(
    reference.pointer,
    _id_getBroadcast as jni$_.JMethodIDPtr,
  ).object<InetAddress?>(const $InetAddress$NullableType());

  static final _id_getNetworkPrefixLength = _class.instanceMethodId(
    r'getNetworkPrefixLength',
    r'()S',
  );

  static final _getNetworkPrefixLength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public short getNetworkPrefixLength()`
  int getNetworkPrefixLength() =>
      _getNetworkPrefixLength(
        reference.pointer,
        _id_getNetworkPrefixLength as jni$_.JMethodIDPtr,
      ).short;

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $InterfaceAddress$NullableType
    extends jni$_.JObjType<InterfaceAddress?> {
  @jni$_.internal
  const $InterfaceAddress$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/InterfaceAddress;';

  @jni$_.internal
  @core$_.override
  InterfaceAddress? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InterfaceAddress.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InterfaceAddress?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InterfaceAddress$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InterfaceAddress$NullableType) &&
      other is $InterfaceAddress$NullableType;
}

final class $InterfaceAddress$Type extends jni$_.JObjType<InterfaceAddress> {
  @jni$_.internal
  const $InterfaceAddress$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/InterfaceAddress;';

  @jni$_.internal
  @core$_.override
  InterfaceAddress fromReference(jni$_.JReference reference) =>
      InterfaceAddress.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InterfaceAddress?> get nullableType =>
      const $InterfaceAddress$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InterfaceAddress$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InterfaceAddress$Type) &&
      other is $InterfaceAddress$Type;
}

/// from: `java.net.NetworkInterface`
class NetworkInterface extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NetworkInterface> $type;

  @jni$_.internal
  NetworkInterface.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/NetworkInterface');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NetworkInterface$NullableType();
  static const type = $NetworkInterface$Type();
  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() => _getName(
    reference.pointer,
    _id_getName as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getInetAddresses = _class.instanceMethodId(
    r'getInetAddresses',
    r'()Ljava/util/Enumeration;',
  );

  static final _getInetAddresses =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Enumeration<java.net.InetAddress> getInetAddresses()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getInetAddresses() => _getInetAddresses(
    reference.pointer,
    _id_getInetAddresses as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_inetAddresses = _class.instanceMethodId(
    r'inetAddresses',
    r'()Ljava/util/stream/Stream;',
  );

  static final _inetAddresses =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.stream.Stream<java.net.InetAddress> inetAddresses()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? inetAddresses() => _inetAddresses(
    reference.pointer,
    _id_inetAddresses as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getInterfaceAddresses = _class.instanceMethodId(
    r'getInterfaceAddresses',
    r'()Ljava/util/List;',
  );

  static final _getInterfaceAddresses =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<java.net.InterfaceAddress> getInterfaceAddresses()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<InterfaceAddress?>? getInterfaceAddresses() =>
      _getInterfaceAddresses(
        reference.pointer,
        _id_getInterfaceAddresses as jni$_.JMethodIDPtr,
      ).object<jni$_.JList<InterfaceAddress?>?>(
        const jni$_.JListNullableType<InterfaceAddress?>(
          $InterfaceAddress$NullableType(),
        ),
      );

  static final _id_getSubInterfaces = _class.instanceMethodId(
    r'getSubInterfaces',
    r'()Ljava/util/Enumeration;',
  );

  static final _getSubInterfaces =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Enumeration<java.net.NetworkInterface> getSubInterfaces()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSubInterfaces() => _getSubInterfaces(
    reference.pointer,
    _id_getSubInterfaces as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_subInterfaces = _class.instanceMethodId(
    r'subInterfaces',
    r'()Ljava/util/stream/Stream;',
  );

  static final _subInterfaces =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.stream.Stream<java.net.NetworkInterface> subInterfaces()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? subInterfaces() => _subInterfaces(
    reference.pointer,
    _id_subInterfaces as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getParent = _class.instanceMethodId(
    r'getParent',
    r'()Ljava/net/NetworkInterface;',
  );

  static final _getParent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.NetworkInterface getParent()`
  /// The returned object must be released after use, by calling the [release] method.
  NetworkInterface? getParent() => _getParent(
    reference.pointer,
    _id_getParent as jni$_.JMethodIDPtr,
  ).object<NetworkInterface?>(const $NetworkInterface$NullableType());

  static final _id_getIndex = _class.instanceMethodId(r'getIndex', r'()I');

  static final _getIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getIndex()`
  int getIndex() =>
      _getIndex(reference.pointer, _id_getIndex as jni$_.JMethodIDPtr).integer;

  static final _id_getDisplayName = _class.instanceMethodId(
    r'getDisplayName',
    r'()Ljava/lang/String;',
  );

  static final _getDisplayName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getDisplayName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDisplayName() => _getDisplayName(
    reference.pointer,
    _id_getDisplayName as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getByName = _class.staticMethodId(
    r'getByName',
    r'(Ljava/lang/String;)Ljava/net/NetworkInterface;',
  );

  static final _getByName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.NetworkInterface getByName(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static NetworkInterface? getByName(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getByName(
      _class.reference.pointer,
      _id_getByName as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<NetworkInterface?>(const $NetworkInterface$NullableType());
  }

  static final _id_getByIndex = _class.staticMethodId(
    r'getByIndex',
    r'(I)Ljava/net/NetworkInterface;',
  );

  static final _getByIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.net.NetworkInterface getByIndex(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static NetworkInterface? getByIndex(int i) => _getByIndex(
    _class.reference.pointer,
    _id_getByIndex as jni$_.JMethodIDPtr,
    i,
  ).object<NetworkInterface?>(const $NetworkInterface$NullableType());

  static final _id_getByInetAddress = _class.staticMethodId(
    r'getByInetAddress',
    r'(Ljava/net/InetAddress;)Ljava/net/NetworkInterface;',
  );

  static final _getByInetAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.NetworkInterface getByInetAddress(java.net.InetAddress inetAddress)`
  /// The returned object must be released after use, by calling the [release] method.
  static NetworkInterface? getByInetAddress(InetAddress? inetAddress) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    return _getByInetAddress(
      _class.reference.pointer,
      _id_getByInetAddress as jni$_.JMethodIDPtr,
      _$inetAddress.pointer,
    ).object<NetworkInterface?>(const $NetworkInterface$NullableType());
  }

  static final _id_getNetworkInterfaces = _class.staticMethodId(
    r'getNetworkInterfaces',
    r'()Ljava/util/Enumeration;',
  );

  static final _getNetworkInterfaces =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Enumeration<java.net.NetworkInterface> getNetworkInterfaces()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getNetworkInterfaces() => _getNetworkInterfaces(
    _class.reference.pointer,
    _id_getNetworkInterfaces as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_networkInterfaces = _class.staticMethodId(
    r'networkInterfaces',
    r'()Ljava/util/stream/Stream;',
  );

  static final _networkInterfaces =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.stream.Stream<java.net.NetworkInterface> networkInterfaces()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? networkInterfaces() => _networkInterfaces(
    _class.reference.pointer,
    _id_networkInterfaces as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_isUp = _class.instanceMethodId(r'isUp', r'()Z');

  static final _isUp =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isUp()`
  bool isUp() =>
      _isUp(reference.pointer, _id_isUp as jni$_.JMethodIDPtr).boolean;

  static final _id_isLoopback = _class.instanceMethodId(r'isLoopback', r'()Z');

  static final _isLoopback =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLoopback()`
  bool isLoopback() =>
      _isLoopback(
        reference.pointer,
        _id_isLoopback as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isPointToPoint = _class.instanceMethodId(
    r'isPointToPoint',
    r'()Z',
  );

  static final _isPointToPoint =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isPointToPoint()`
  bool isPointToPoint() =>
      _isPointToPoint(
        reference.pointer,
        _id_isPointToPoint as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_supportsMulticast = _class.instanceMethodId(
    r'supportsMulticast',
    r'()Z',
  );

  static final _supportsMulticast =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean supportsMulticast()`
  bool supportsMulticast() =>
      _supportsMulticast(
        reference.pointer,
        _id_supportsMulticast as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_getHardwareAddress = _class.instanceMethodId(
    r'getHardwareAddress',
    r'()[B',
  );

  static final _getHardwareAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] getHardwareAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getHardwareAddress() => _getHardwareAddress(
    reference.pointer,
    _id_getHardwareAddress as jni$_.JMethodIDPtr,
  ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());

  static final _id_getMTU = _class.instanceMethodId(r'getMTU', r'()I');

  static final _getMTU =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMTU()`
  int getMTU() =>
      _getMTU(reference.pointer, _id_getMTU as jni$_.JMethodIDPtr).integer;

  static final _id_isVirtual = _class.instanceMethodId(r'isVirtual', r'()Z');

  static final _isVirtual =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isVirtual()`
  bool isVirtual() =>
      _isVirtual(
        reference.pointer,
        _id_isVirtual as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $NetworkInterface$NullableType
    extends jni$_.JObjType<NetworkInterface?> {
  @jni$_.internal
  const $NetworkInterface$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/NetworkInterface;';

  @jni$_.internal
  @core$_.override
  NetworkInterface? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NetworkInterface.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NetworkInterface?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NetworkInterface$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NetworkInterface$NullableType) &&
      other is $NetworkInterface$NullableType;
}

final class $NetworkInterface$Type extends jni$_.JObjType<NetworkInterface> {
  @jni$_.internal
  const $NetworkInterface$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/NetworkInterface;';

  @jni$_.internal
  @core$_.override
  NetworkInterface fromReference(jni$_.JReference reference) =>
      NetworkInterface.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NetworkInterface?> get nullableType =>
      const $NetworkInterface$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NetworkInterface$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NetworkInterface$Type) &&
      other is $NetworkInterface$Type;
}

/// from: `java.net.Authenticator$RequestorType`
class Authenticator$RequestorType extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Authenticator$RequestorType> $type;

  @jni$_.internal
  Authenticator$RequestorType.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/net/Authenticator$RequestorType',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Authenticator$RequestorType$NullableType();
  static const type = $Authenticator$RequestorType$Type();
  static final _id_PROXY = _class.staticFieldId(
    r'PROXY',
    r'Ljava/net/Authenticator$RequestorType;',
  );

  /// from: `static public final java.net.Authenticator$RequestorType PROXY`
  /// The returned object must be released after use, by calling the [release] method.
  static Authenticator$RequestorType get PROXY =>
      _id_PROXY.get(_class, const $Authenticator$RequestorType$Type());

  static final _id_SERVER = _class.staticFieldId(
    r'SERVER',
    r'Ljava/net/Authenticator$RequestorType;',
  );

  /// from: `static public final java.net.Authenticator$RequestorType SERVER`
  /// The returned object must be released after use, by calling the [release] method.
  static Authenticator$RequestorType get SERVER =>
      _id_SERVER.get(_class, const $Authenticator$RequestorType$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/net/Authenticator$RequestorType;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.net.Authenticator$RequestorType[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Authenticator$RequestorType?>? values() => _values(
    _class.reference.pointer,
    _id_values as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<Authenticator$RequestorType?>?>(
    const jni$_.JArrayNullableType<Authenticator$RequestorType?>(
      $Authenticator$RequestorType$NullableType(),
    ),
  );

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/net/Authenticator$RequestorType;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.Authenticator$RequestorType valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Authenticator$RequestorType? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Authenticator$RequestorType?>(
      const $Authenticator$RequestorType$NullableType(),
    );
  }
}

final class $Authenticator$RequestorType$NullableType
    extends jni$_.JObjType<Authenticator$RequestorType?> {
  @jni$_.internal
  const $Authenticator$RequestorType$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Authenticator$RequestorType;';

  @jni$_.internal
  @core$_.override
  Authenticator$RequestorType? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : Authenticator$RequestorType.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Authenticator$RequestorType?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Authenticator$RequestorType$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Authenticator$RequestorType$NullableType) &&
      other is $Authenticator$RequestorType$NullableType;
}

final class $Authenticator$RequestorType$Type
    extends jni$_.JObjType<Authenticator$RequestorType> {
  @jni$_.internal
  const $Authenticator$RequestorType$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Authenticator$RequestorType;';

  @jni$_.internal
  @core$_.override
  Authenticator$RequestorType fromReference(jni$_.JReference reference) =>
      Authenticator$RequestorType.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Authenticator$RequestorType?> get nullableType =>
      const $Authenticator$RequestorType$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Authenticator$RequestorType$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Authenticator$RequestorType$Type) &&
      other is $Authenticator$RequestorType$Type;
}

/// from: `java.net.SocketImplFactory`
class SocketImplFactory extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SocketImplFactory> $type;

  @jni$_.internal
  SocketImplFactory.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/SocketImplFactory');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SocketImplFactory$NullableType();
  static const type = $SocketImplFactory$Type();
  static final _id_createSocketImpl = _class.instanceMethodId(
    r'createSocketImpl',
    r'()Ljava/net/SocketImpl;',
  );

  static final _createSocketImpl =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.net.SocketImpl createSocketImpl()`
  /// The returned object must be released after use, by calling the [release] method.
  SocketImpl? createSocketImpl() => _createSocketImpl(
    reference.pointer,
    _id_createSocketImpl as jni$_.JMethodIDPtr,
  ).object<SocketImpl?>(const $SocketImpl$NullableType());

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SocketImplFactory> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'createSocketImpl()Ljava/net/SocketImpl;') {
        final $r = _$impls[$p]!.createSocketImpl();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SocketImplFactory $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.net.SocketImplFactory', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SocketImplFactory.implement($SocketImplFactory $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SocketImplFactory.fromReference($i.implementReference());
  }
}

abstract base mixin class $SocketImplFactory {
  factory $SocketImplFactory({
    required SocketImpl? Function() createSocketImpl,
  }) = _$SocketImplFactory;

  SocketImpl? createSocketImpl();
}

final class _$SocketImplFactory with $SocketImplFactory {
  _$SocketImplFactory({required SocketImpl? Function() createSocketImpl})
    : _createSocketImpl = createSocketImpl;

  final SocketImpl? Function() _createSocketImpl;

  SocketImpl? createSocketImpl() => _createSocketImpl();
}

final class $SocketImplFactory$NullableType
    extends jni$_.JObjType<SocketImplFactory?> {
  @jni$_.internal
  const $SocketImplFactory$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketImplFactory;';

  @jni$_.internal
  @core$_.override
  SocketImplFactory? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SocketImplFactory.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketImplFactory?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SocketImplFactory$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketImplFactory$NullableType) &&
      other is $SocketImplFactory$NullableType;
}

final class $SocketImplFactory$Type extends jni$_.JObjType<SocketImplFactory> {
  @jni$_.internal
  const $SocketImplFactory$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketImplFactory;';

  @jni$_.internal
  @core$_.override
  SocketImplFactory fromReference(jni$_.JReference reference) =>
      SocketImplFactory.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketImplFactory?> get nullableType =>
      const $SocketImplFactory$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SocketImplFactory$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketImplFactory$Type) &&
      other is $SocketImplFactory$Type;
}

/// from: `java.net.DatagramSocketImplFactory`
class DatagramSocketImplFactory extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DatagramSocketImplFactory> $type;

  @jni$_.internal
  DatagramSocketImplFactory.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/net/DatagramSocketImplFactory',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DatagramSocketImplFactory$NullableType();
  static const type = $DatagramSocketImplFactory$Type();
  static final _id_createDatagramSocketImpl = _class.instanceMethodId(
    r'createDatagramSocketImpl',
    r'()Ljava/net/DatagramSocketImpl;',
  );

  static final _createDatagramSocketImpl =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.net.DatagramSocketImpl createDatagramSocketImpl()`
  /// The returned object must be released after use, by calling the [release] method.
  DatagramSocketImpl? createDatagramSocketImpl() => _createDatagramSocketImpl(
    reference.pointer,
    _id_createDatagramSocketImpl as jni$_.JMethodIDPtr,
  ).object<DatagramSocketImpl?>(const $DatagramSocketImpl$NullableType());

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $DatagramSocketImplFactory> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'createDatagramSocketImpl()Ljava/net/DatagramSocketImpl;') {
        final $r = _$impls[$p]!.createDatagramSocketImpl();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $DatagramSocketImplFactory $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'java.net.DatagramSocketImplFactory',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory DatagramSocketImplFactory.implement(
    $DatagramSocketImplFactory $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return DatagramSocketImplFactory.fromReference($i.implementReference());
  }
}

abstract base mixin class $DatagramSocketImplFactory {
  factory $DatagramSocketImplFactory({
    required DatagramSocketImpl? Function() createDatagramSocketImpl,
  }) = _$DatagramSocketImplFactory;

  DatagramSocketImpl? createDatagramSocketImpl();
}

final class _$DatagramSocketImplFactory with $DatagramSocketImplFactory {
  _$DatagramSocketImplFactory({
    required DatagramSocketImpl? Function() createDatagramSocketImpl,
  }) : _createDatagramSocketImpl = createDatagramSocketImpl;

  final DatagramSocketImpl? Function() _createDatagramSocketImpl;

  DatagramSocketImpl? createDatagramSocketImpl() => _createDatagramSocketImpl();
}

final class $DatagramSocketImplFactory$NullableType
    extends jni$_.JObjType<DatagramSocketImplFactory?> {
  @jni$_.internal
  const $DatagramSocketImplFactory$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/DatagramSocketImplFactory;';

  @jni$_.internal
  @core$_.override
  DatagramSocketImplFactory? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : DatagramSocketImplFactory.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DatagramSocketImplFactory?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DatagramSocketImplFactory$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DatagramSocketImplFactory$NullableType) &&
      other is $DatagramSocketImplFactory$NullableType;
}

final class $DatagramSocketImplFactory$Type
    extends jni$_.JObjType<DatagramSocketImplFactory> {
  @jni$_.internal
  const $DatagramSocketImplFactory$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/DatagramSocketImplFactory;';

  @jni$_.internal
  @core$_.override
  DatagramSocketImplFactory fromReference(jni$_.JReference reference) =>
      DatagramSocketImplFactory.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DatagramSocketImplFactory?> get nullableType =>
      const $DatagramSocketImplFactory$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DatagramSocketImplFactory$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DatagramSocketImplFactory$Type) &&
      other is $DatagramSocketImplFactory$Type;
}

/// from: `java.net.CacheRequest`
class CacheRequest extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CacheRequest> $type;

  @jni$_.internal
  CacheRequest.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/CacheRequest');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CacheRequest$NullableType();
  static const type = $CacheRequest$Type();
  static final _id_getBody = _class.instanceMethodId(
    r'getBody',
    r'()Ljava/io/OutputStream;',
  );

  static final _getBody =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.io.OutputStream getBody()`
  /// The returned object must be released after use, by calling the [release] method.
  OutputStream? getBody() => _getBody(
    reference.pointer,
    _id_getBody as jni$_.JMethodIDPtr,
  ).object<OutputStream?>(const $OutputStream$NullableType());

  static final _id_abort = _class.instanceMethodId(r'abort', r'()V');

  static final _abort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void abort()`
  void abort() {
    _abort(reference.pointer, _id_abort as jni$_.JMethodIDPtr).check();
  }
}

final class $CacheRequest$NullableType extends jni$_.JObjType<CacheRequest?> {
  @jni$_.internal
  const $CacheRequest$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/CacheRequest;';

  @jni$_.internal
  @core$_.override
  CacheRequest? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CacheRequest.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CacheRequest?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CacheRequest$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CacheRequest$NullableType) &&
      other is $CacheRequest$NullableType;
}

final class $CacheRequest$Type extends jni$_.JObjType<CacheRequest> {
  @jni$_.internal
  const $CacheRequest$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/CacheRequest;';

  @jni$_.internal
  @core$_.override
  CacheRequest fromReference(jni$_.JReference reference) =>
      CacheRequest.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CacheRequest?> get nullableType =>
      const $CacheRequest$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CacheRequest$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CacheRequest$Type) && other is $CacheRequest$Type;
}

/// from: `java.net.DatagramPacket`
class DatagramPacket extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DatagramPacket> $type;

  @jni$_.internal
  DatagramPacket.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/DatagramPacket');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DatagramPacket$NullableType();
  static const type = $DatagramPacket$Type();
  static final _id_new$ = _class.constructorId(r'([BII)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void <init>(byte[] bs, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatagramPacket(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return DatagramPacket.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$bs.pointer,
        i,
        i1,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'([BI)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(byte[] bs, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatagramPacket.new$1(jni$_.JByteArray? bs, int i) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return DatagramPacket.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$bs.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'([BIILjava/net/InetAddress;I)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(byte[] bs, int i, int i1, java.net.InetAddress inetAddress, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatagramPacket.new$2(
    jni$_.JByteArray? bs,
    int i,
    int i1,
    InetAddress? inetAddress,
    int i2,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    return DatagramPacket.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$bs.pointer,
        i,
        i1,
        _$inetAddress.pointer,
        i2,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'([BIILjava/net/SocketAddress;)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(byte[] bs, int i, int i1, java.net.SocketAddress socketAddress)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatagramPacket.new$3(
    jni$_.JByteArray? bs,
    int i,
    int i1,
    SocketAddress? socketAddress,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    return DatagramPacket.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$bs.pointer,
        i,
        i1,
        _$socketAddress.pointer,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(
    r'([BILjava/net/InetAddress;I)V',
  );

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(byte[] bs, int i, java.net.InetAddress inetAddress, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatagramPacket.new$4(
    jni$_.JByteArray? bs,
    int i,
    InetAddress? inetAddress,
    int i1,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    return DatagramPacket.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$bs.pointer,
        i,
        _$inetAddress.pointer,
        i1,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(
    r'([BILjava/net/SocketAddress;)V',
  );

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(byte[] bs, int i, java.net.SocketAddress socketAddress)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatagramPacket.new$5(
    jni$_.JByteArray? bs,
    int i,
    SocketAddress? socketAddress,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    return DatagramPacket.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$bs.pointer,
        i,
        _$socketAddress.pointer,
      ).reference,
    );
  }

  static final _id_getAddress = _class.instanceMethodId(
    r'getAddress',
    r'()Ljava/net/InetAddress;',
  );

  static final _getAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.InetAddress getAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  InetAddress? getAddress() => _getAddress(
    reference.pointer,
    _id_getAddress as jni$_.JMethodIDPtr,
  ).object<InetAddress?>(const $InetAddress$NullableType());

  static final _id_getPort = _class.instanceMethodId(r'getPort', r'()I');

  static final _getPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getPort()`
  int getPort() =>
      _getPort(reference.pointer, _id_getPort as jni$_.JMethodIDPtr).integer;

  static final _id_getData = _class.instanceMethodId(r'getData', r'()[B');

  static final _getData =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] getData()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getData() => _getData(
    reference.pointer,
    _id_getData as jni$_.JMethodIDPtr,
  ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());

  static final _id_getOffset = _class.instanceMethodId(r'getOffset', r'()I');

  static final _getOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getOffset()`
  int getOffset() =>
      _getOffset(
        reference.pointer,
        _id_getOffset as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getLength = _class.instanceMethodId(r'getLength', r'()I');

  static final _getLength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLength()`
  int getLength() =>
      _getLength(
        reference.pointer,
        _id_getLength as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setData = _class.instanceMethodId(r'setData', r'([BII)V');

  static final _setData =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void setData(byte[] bs, int i, int i1)`
  void setData(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _setData(
      reference.pointer,
      _id_setData as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_setAddress = _class.instanceMethodId(
    r'setAddress',
    r'(Ljava/net/InetAddress;)V',
  );

  static final _setAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setAddress(java.net.InetAddress inetAddress)`
  void setAddress(InetAddress? inetAddress) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    _setAddress(
      reference.pointer,
      _id_setAddress as jni$_.JMethodIDPtr,
      _$inetAddress.pointer,
    ).check();
  }

  static final _id_setPort = _class.instanceMethodId(r'setPort', r'(I)V');

  static final _setPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setPort(int i)`
  void setPort(int i) {
    _setPort(reference.pointer, _id_setPort as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_setSocketAddress = _class.instanceMethodId(
    r'setSocketAddress',
    r'(Ljava/net/SocketAddress;)V',
  );

  static final _setSocketAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setSocketAddress(java.net.SocketAddress socketAddress)`
  void setSocketAddress(SocketAddress? socketAddress) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    _setSocketAddress(
      reference.pointer,
      _id_setSocketAddress as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
    ).check();
  }

  static final _id_getSocketAddress = _class.instanceMethodId(
    r'getSocketAddress',
    r'()Ljava/net/SocketAddress;',
  );

  static final _getSocketAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.SocketAddress getSocketAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  SocketAddress? getSocketAddress() => _getSocketAddress(
    reference.pointer,
    _id_getSocketAddress as jni$_.JMethodIDPtr,
  ).object<SocketAddress?>(const $SocketAddress$NullableType());

  static final _id_setData$1 = _class.instanceMethodId(r'setData', r'([B)V');

  static final _setData$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setData(byte[] bs)`
  void setData$1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _setData$1(
      reference.pointer,
      _id_setData$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_setLength = _class.instanceMethodId(r'setLength', r'(I)V');

  static final _setLength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setLength(int i)`
  void setLength(int i) {
    _setLength(
      reference.pointer,
      _id_setLength as jni$_.JMethodIDPtr,
      i,
    ).check();
  }
}

final class $DatagramPacket$NullableType
    extends jni$_.JObjType<DatagramPacket?> {
  @jni$_.internal
  const $DatagramPacket$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/DatagramPacket;';

  @jni$_.internal
  @core$_.override
  DatagramPacket? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DatagramPacket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DatagramPacket?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DatagramPacket$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DatagramPacket$NullableType) &&
      other is $DatagramPacket$NullableType;
}

final class $DatagramPacket$Type extends jni$_.JObjType<DatagramPacket> {
  @jni$_.internal
  const $DatagramPacket$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/DatagramPacket;';

  @jni$_.internal
  @core$_.override
  DatagramPacket fromReference(jni$_.JReference reference) =>
      DatagramPacket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DatagramPacket?> get nullableType =>
      const $DatagramPacket$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DatagramPacket$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DatagramPacket$Type) &&
      other is $DatagramPacket$Type;
}

/// from: `java.net.UnknownServiceException`
class UnknownServiceException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<UnknownServiceException> $type;

  @jni$_.internal
  UnknownServiceException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/net/UnknownServiceException',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $UnknownServiceException$NullableType();
  static const type = $UnknownServiceException$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory UnknownServiceException() => UnknownServiceException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory UnknownServiceException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return UnknownServiceException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $UnknownServiceException$NullableType
    extends jni$_.JObjType<UnknownServiceException?> {
  @jni$_.internal
  const $UnknownServiceException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/UnknownServiceException;';

  @jni$_.internal
  @core$_.override
  UnknownServiceException? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : UnknownServiceException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UnknownServiceException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UnknownServiceException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($UnknownServiceException$NullableType) &&
      other is $UnknownServiceException$NullableType;
}

final class $UnknownServiceException$Type
    extends jni$_.JObjType<UnknownServiceException> {
  @jni$_.internal
  const $UnknownServiceException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/UnknownServiceException;';

  @jni$_.internal
  @core$_.override
  UnknownServiceException fromReference(jni$_.JReference reference) =>
      UnknownServiceException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UnknownServiceException?> get nullableType =>
      const $UnknownServiceException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UnknownServiceException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($UnknownServiceException$Type) &&
      other is $UnknownServiceException$Type;
}

/// from: `java.net.DatagramSocket`
class DatagramSocket extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DatagramSocket> $type;

  @jni$_.internal
  DatagramSocket.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/DatagramSocket');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DatagramSocket$NullableType();
  static const type = $DatagramSocket$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatagramSocket() => DatagramSocket.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$1 = _class.constructorId(r'(Ljava/net/SocketAddress;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.SocketAddress socketAddress)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatagramSocket.new$1(SocketAddress? socketAddress) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    return DatagramSocket.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$socketAddress.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(I)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatagramSocket.new$2(int i) => DatagramSocket.fromReference(
    _new$2(
      _class.reference.pointer,
      _id_new$2 as jni$_.JMethodIDPtr,
      i,
    ).reference,
  );

  static final _id_new$3 = _class.constructorId(r'(ILjava/net/InetAddress;)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(int i, java.net.InetAddress inetAddress)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DatagramSocket.new$3(int i, InetAddress? inetAddress) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    return DatagramSocket.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        i,
        _$inetAddress.pointer,
      ).reference,
    );
  }

  static final _id_bind = _class.instanceMethodId(
    r'bind',
    r'(Ljava/net/SocketAddress;)V',
  );

  static final _bind =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void bind(java.net.SocketAddress socketAddress)`
  void bind(SocketAddress? socketAddress) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    _bind(
      reference.pointer,
      _id_bind as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
    ).check();
  }

  static final _id_connect = _class.instanceMethodId(
    r'connect',
    r'(Ljava/net/InetAddress;I)V',
  );

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void connect(java.net.InetAddress inetAddress, int i)`
  void connect(InetAddress? inetAddress, int i) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    _connect(
      reference.pointer,
      _id_connect as jni$_.JMethodIDPtr,
      _$inetAddress.pointer,
      i,
    ).check();
  }

  static final _id_connect$1 = _class.instanceMethodId(
    r'connect',
    r'(Ljava/net/SocketAddress;)V',
  );

  static final _connect$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void connect(java.net.SocketAddress socketAddress)`
  void connect$1(SocketAddress? socketAddress) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    _connect$1(
      reference.pointer,
      _id_connect$1 as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
    ).check();
  }

  static final _id_disconnect = _class.instanceMethodId(r'disconnect', r'()V');

  static final _disconnect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void disconnect()`
  void disconnect() {
    _disconnect(
      reference.pointer,
      _id_disconnect as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_isBound = _class.instanceMethodId(r'isBound', r'()Z');

  static final _isBound =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isBound()`
  bool isBound() =>
      _isBound(reference.pointer, _id_isBound as jni$_.JMethodIDPtr).boolean;

  static final _id_isConnected = _class.instanceMethodId(
    r'isConnected',
    r'()Z',
  );

  static final _isConnected =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isConnected()`
  bool isConnected() =>
      _isConnected(
        reference.pointer,
        _id_isConnected as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_getInetAddress = _class.instanceMethodId(
    r'getInetAddress',
    r'()Ljava/net/InetAddress;',
  );

  static final _getInetAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.InetAddress getInetAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  InetAddress? getInetAddress() => _getInetAddress(
    reference.pointer,
    _id_getInetAddress as jni$_.JMethodIDPtr,
  ).object<InetAddress?>(const $InetAddress$NullableType());

  static final _id_getPort = _class.instanceMethodId(r'getPort', r'()I');

  static final _getPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getPort()`
  int getPort() =>
      _getPort(reference.pointer, _id_getPort as jni$_.JMethodIDPtr).integer;

  static final _id_getRemoteSocketAddress = _class.instanceMethodId(
    r'getRemoteSocketAddress',
    r'()Ljava/net/SocketAddress;',
  );

  static final _getRemoteSocketAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.SocketAddress getRemoteSocketAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  SocketAddress? getRemoteSocketAddress() => _getRemoteSocketAddress(
    reference.pointer,
    _id_getRemoteSocketAddress as jni$_.JMethodIDPtr,
  ).object<SocketAddress?>(const $SocketAddress$NullableType());

  static final _id_getLocalSocketAddress = _class.instanceMethodId(
    r'getLocalSocketAddress',
    r'()Ljava/net/SocketAddress;',
  );

  static final _getLocalSocketAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.SocketAddress getLocalSocketAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  SocketAddress? getLocalSocketAddress() => _getLocalSocketAddress(
    reference.pointer,
    _id_getLocalSocketAddress as jni$_.JMethodIDPtr,
  ).object<SocketAddress?>(const $SocketAddress$NullableType());

  static final _id_send = _class.instanceMethodId(
    r'send',
    r'(Ljava/net/DatagramPacket;)V',
  );

  static final _send =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void send(java.net.DatagramPacket datagramPacket)`
  void send(DatagramPacket? datagramPacket) {
    final _$datagramPacket = datagramPacket?.reference ?? jni$_.jNullReference;
    _send(
      reference.pointer,
      _id_send as jni$_.JMethodIDPtr,
      _$datagramPacket.pointer,
    ).check();
  }

  static final _id_receive = _class.instanceMethodId(
    r'receive',
    r'(Ljava/net/DatagramPacket;)V',
  );

  static final _receive =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void receive(java.net.DatagramPacket datagramPacket)`
  void receive(DatagramPacket? datagramPacket) {
    final _$datagramPacket = datagramPacket?.reference ?? jni$_.jNullReference;
    _receive(
      reference.pointer,
      _id_receive as jni$_.JMethodIDPtr,
      _$datagramPacket.pointer,
    ).check();
  }

  static final _id_getLocalAddress = _class.instanceMethodId(
    r'getLocalAddress',
    r'()Ljava/net/InetAddress;',
  );

  static final _getLocalAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.InetAddress getLocalAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  InetAddress? getLocalAddress() => _getLocalAddress(
    reference.pointer,
    _id_getLocalAddress as jni$_.JMethodIDPtr,
  ).object<InetAddress?>(const $InetAddress$NullableType());

  static final _id_getLocalPort = _class.instanceMethodId(
    r'getLocalPort',
    r'()I',
  );

  static final _getLocalPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLocalPort()`
  int getLocalPort() =>
      _getLocalPort(
        reference.pointer,
        _id_getLocalPort as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setSoTimeout = _class.instanceMethodId(
    r'setSoTimeout',
    r'(I)V',
  );

  static final _setSoTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setSoTimeout(int i)`
  void setSoTimeout(int i) {
    _setSoTimeout(
      reference.pointer,
      _id_setSoTimeout as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getSoTimeout = _class.instanceMethodId(
    r'getSoTimeout',
    r'()I',
  );

  static final _getSoTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSoTimeout()`
  int getSoTimeout() =>
      _getSoTimeout(
        reference.pointer,
        _id_getSoTimeout as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setSendBufferSize = _class.instanceMethodId(
    r'setSendBufferSize',
    r'(I)V',
  );

  static final _setSendBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setSendBufferSize(int i)`
  void setSendBufferSize(int i) {
    _setSendBufferSize(
      reference.pointer,
      _id_setSendBufferSize as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getSendBufferSize = _class.instanceMethodId(
    r'getSendBufferSize',
    r'()I',
  );

  static final _getSendBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSendBufferSize()`
  int getSendBufferSize() =>
      _getSendBufferSize(
        reference.pointer,
        _id_getSendBufferSize as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setReceiveBufferSize = _class.instanceMethodId(
    r'setReceiveBufferSize',
    r'(I)V',
  );

  static final _setReceiveBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReceiveBufferSize(int i)`
  void setReceiveBufferSize(int i) {
    _setReceiveBufferSize(
      reference.pointer,
      _id_setReceiveBufferSize as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getReceiveBufferSize = _class.instanceMethodId(
    r'getReceiveBufferSize',
    r'()I',
  );

  static final _getReceiveBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getReceiveBufferSize()`
  int getReceiveBufferSize() =>
      _getReceiveBufferSize(
        reference.pointer,
        _id_getReceiveBufferSize as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setReuseAddress = _class.instanceMethodId(
    r'setReuseAddress',
    r'(Z)V',
  );

  static final _setReuseAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReuseAddress(boolean z)`
  void setReuseAddress(bool z) {
    _setReuseAddress(
      reference.pointer,
      _id_setReuseAddress as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getReuseAddress = _class.instanceMethodId(
    r'getReuseAddress',
    r'()Z',
  );

  static final _getReuseAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getReuseAddress()`
  bool getReuseAddress() =>
      _getReuseAddress(
        reference.pointer,
        _id_getReuseAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setBroadcast = _class.instanceMethodId(
    r'setBroadcast',
    r'(Z)V',
  );

  static final _setBroadcast =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setBroadcast(boolean z)`
  void setBroadcast(bool z) {
    _setBroadcast(
      reference.pointer,
      _id_setBroadcast as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getBroadcast = _class.instanceMethodId(
    r'getBroadcast',
    r'()Z',
  );

  static final _getBroadcast =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getBroadcast()`
  bool getBroadcast() =>
      _getBroadcast(
        reference.pointer,
        _id_getBroadcast as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setTrafficClass = _class.instanceMethodId(
    r'setTrafficClass',
    r'(I)V',
  );

  static final _setTrafficClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setTrafficClass(int i)`
  void setTrafficClass(int i) {
    _setTrafficClass(
      reference.pointer,
      _id_setTrafficClass as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getTrafficClass = _class.instanceMethodId(
    r'getTrafficClass',
    r'()I',
  );

  static final _getTrafficClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getTrafficClass()`
  int getTrafficClass() =>
      _getTrafficClass(
        reference.pointer,
        _id_getTrafficClass as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_isClosed = _class.instanceMethodId(r'isClosed', r'()Z');

  static final _isClosed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isClosed()`
  bool isClosed() =>
      _isClosed(reference.pointer, _id_isClosed as jni$_.JMethodIDPtr).boolean;

  static final _id_getChannel = _class.instanceMethodId(
    r'getChannel',
    r'()Ljava/nio/channels/DatagramChannel;',
  );

  static final _getChannel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.channels.DatagramChannel getChannel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChannel() => _getChannel(
    reference.pointer,
    _id_getChannel as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_setDatagramSocketImplFactory = _class.staticMethodId(
    r'setDatagramSocketImplFactory',
    r'(Ljava/net/DatagramSocketImplFactory;)V',
  );

  static final _setDatagramSocketImplFactory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setDatagramSocketImplFactory(java.net.DatagramSocketImplFactory datagramSocketImplFactory)`
  static void setDatagramSocketImplFactory(
    DatagramSocketImplFactory? datagramSocketImplFactory,
  ) {
    final _$datagramSocketImplFactory =
        datagramSocketImplFactory?.reference ?? jni$_.jNullReference;
    _setDatagramSocketImplFactory(
      _class.reference.pointer,
      _id_setDatagramSocketImplFactory as jni$_.JMethodIDPtr,
      _$datagramSocketImplFactory.pointer,
    ).check();
  }

  static final _id_setOption = _class.instanceMethodId(
    r'setOption',
    r'(Ljava/net/SocketOption;Ljava/lang/Object;)Ljava/net/DatagramSocket;',
  );

  static final _setOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.net.DatagramSocket setOption(java.net.SocketOption<T> socketOption, T object)`
  /// The returned object must be released after use, by calling the [release] method.
  DatagramSocket? setOption<$T extends jni$_.JObject?>(
    SocketOption<$T?>? socketOption,
    $T? object, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$socketOption = socketOption?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _setOption(
      reference.pointer,
      _id_setOption as jni$_.JMethodIDPtr,
      _$socketOption.pointer,
      _$object.pointer,
    ).object<DatagramSocket?>(const $DatagramSocket$NullableType());
  }

  static final _id_getOption = _class.instanceMethodId(
    r'getOption',
    r'(Ljava/net/SocketOption;)Ljava/lang/Object;',
  );

  static final _getOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public T getOption(java.net.SocketOption<T> socketOption)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? getOption<$T extends jni$_.JObject?>(
    SocketOption<$T?>? socketOption, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$socketOption = socketOption?.reference ?? jni$_.jNullReference;
    return _getOption(
      reference.pointer,
      _id_getOption as jni$_.JMethodIDPtr,
      _$socketOption.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_supportedOptions = _class.instanceMethodId(
    r'supportedOptions',
    r'()Ljava/util/Set;',
  );

  static final _supportedOptions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<java.net.SocketOption<?>> supportedOptions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<SocketOption<jni$_.JObject?>?>? supportedOptions() =>
      _supportedOptions(
        reference.pointer,
        _id_supportedOptions as jni$_.JMethodIDPtr,
      ).object<jni$_.JSet<SocketOption<jni$_.JObject?>?>?>(
        const jni$_.JSetNullableType<SocketOption<jni$_.JObject?>?>(
          $SocketOption$NullableType<jni$_.JObject?>(
            jni$_.JObjectNullableType(),
          ),
        ),
      );

  static final _id_joinGroup = _class.instanceMethodId(
    r'joinGroup',
    r'(Ljava/net/SocketAddress;Ljava/net/NetworkInterface;)V',
  );

  static final _joinGroup =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void joinGroup(java.net.SocketAddress socketAddress, java.net.NetworkInterface networkInterface)`
  void joinGroup(
    SocketAddress? socketAddress,
    NetworkInterface? networkInterface,
  ) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    final _$networkInterface =
        networkInterface?.reference ?? jni$_.jNullReference;
    _joinGroup(
      reference.pointer,
      _id_joinGroup as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
      _$networkInterface.pointer,
    ).check();
  }

  static final _id_leaveGroup = _class.instanceMethodId(
    r'leaveGroup',
    r'(Ljava/net/SocketAddress;Ljava/net/NetworkInterface;)V',
  );

  static final _leaveGroup =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void leaveGroup(java.net.SocketAddress socketAddress, java.net.NetworkInterface networkInterface)`
  void leaveGroup(
    SocketAddress? socketAddress,
    NetworkInterface? networkInterface,
  ) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    final _$networkInterface =
        networkInterface?.reference ?? jni$_.jNullReference;
    _leaveGroup(
      reference.pointer,
      _id_leaveGroup as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
      _$networkInterface.pointer,
    ).check();
  }
}

final class $DatagramSocket$NullableType
    extends jni$_.JObjType<DatagramSocket?> {
  @jni$_.internal
  const $DatagramSocket$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/DatagramSocket;';

  @jni$_.internal
  @core$_.override
  DatagramSocket? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DatagramSocket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DatagramSocket?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DatagramSocket$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DatagramSocket$NullableType) &&
      other is $DatagramSocket$NullableType;
}

final class $DatagramSocket$Type extends jni$_.JObjType<DatagramSocket> {
  @jni$_.internal
  const $DatagramSocket$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/DatagramSocket;';

  @jni$_.internal
  @core$_.override
  DatagramSocket fromReference(jni$_.JReference reference) =>
      DatagramSocket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DatagramSocket?> get nullableType =>
      const $DatagramSocket$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DatagramSocket$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DatagramSocket$Type) &&
      other is $DatagramSocket$Type;
}

/// from: `java.net.SocketException`
class SocketException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SocketException> $type;

  @jni$_.internal
  SocketException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/SocketException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SocketException$NullableType();
  static const type = $SocketException$Type();
  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SocketException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return SocketException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SocketException() => SocketException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );
}

final class $SocketException$NullableType
    extends jni$_.JObjType<SocketException?> {
  @jni$_.internal
  const $SocketException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketException;';

  @jni$_.internal
  @core$_.override
  SocketException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SocketException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SocketException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketException$NullableType) &&
      other is $SocketException$NullableType;
}

final class $SocketException$Type extends jni$_.JObjType<SocketException> {
  @jni$_.internal
  const $SocketException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketException;';

  @jni$_.internal
  @core$_.override
  SocketException fromReference(jni$_.JReference reference) =>
      SocketException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketException?> get nullableType =>
      const $SocketException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SocketException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketException$Type) &&
      other is $SocketException$Type;
}

/// from: `java.net.PasswordAuthentication`
class PasswordAuthentication extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PasswordAuthentication> $type;

  @jni$_.internal
  PasswordAuthentication.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/net/PasswordAuthentication',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PasswordAuthentication$NullableType();
  static const type = $PasswordAuthentication$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;[C)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, char[] cs)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PasswordAuthentication(jni$_.JString? string, jni$_.JCharArray? cs) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return PasswordAuthentication.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$cs.pointer,
      ).reference,
    );
  }

  static final _id_getUserName = _class.instanceMethodId(
    r'getUserName',
    r'()Ljava/lang/String;',
  );

  static final _getUserName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getUserName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getUserName() => _getUserName(
    reference.pointer,
    _id_getUserName as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getPassword = _class.instanceMethodId(
    r'getPassword',
    r'()[C',
  );

  static final _getPassword =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char[] getPassword()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JCharArray? getPassword() => _getPassword(
    reference.pointer,
    _id_getPassword as jni$_.JMethodIDPtr,
  ).object<jni$_.JCharArray?>(const jni$_.JCharArrayNullableType());
}

final class $PasswordAuthentication$NullableType
    extends jni$_.JObjType<PasswordAuthentication?> {
  @jni$_.internal
  const $PasswordAuthentication$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/PasswordAuthentication;';

  @jni$_.internal
  @core$_.override
  PasswordAuthentication? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PasswordAuthentication.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PasswordAuthentication?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PasswordAuthentication$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PasswordAuthentication$NullableType) &&
      other is $PasswordAuthentication$NullableType;
}

final class $PasswordAuthentication$Type
    extends jni$_.JObjType<PasswordAuthentication> {
  @jni$_.internal
  const $PasswordAuthentication$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/PasswordAuthentication;';

  @jni$_.internal
  @core$_.override
  PasswordAuthentication fromReference(jni$_.JReference reference) =>
      PasswordAuthentication.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PasswordAuthentication?> get nullableType =>
      const $PasswordAuthentication$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PasswordAuthentication$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($PasswordAuthentication$Type) &&
      other is $PasswordAuthentication$Type;
}

/// from: `java.net.FileNameMap`
class FileNameMap extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileNameMap> $type;

  @jni$_.internal
  FileNameMap.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/FileNameMap');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileNameMap$NullableType();
  static const type = $FileNameMap$Type();
  static final _id_getContentTypeFor = _class.instanceMethodId(
    r'getContentTypeFor',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getContentTypeFor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.String getContentTypeFor(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getContentTypeFor(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getContentTypeFor(
      reference.pointer,
      _id_getContentTypeFor as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $FileNameMap> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'getContentTypeFor(Ljava/lang/String;)Ljava/lang/String;') {
        final $r = _$impls[$p]!.getContentTypeFor(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $FileNameMap $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.net.FileNameMap', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory FileNameMap.implement($FileNameMap $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return FileNameMap.fromReference($i.implementReference());
  }
}

abstract base mixin class $FileNameMap {
  factory $FileNameMap({
    required jni$_.JString? Function(jni$_.JString? string) getContentTypeFor,
  }) = _$FileNameMap;

  jni$_.JString? getContentTypeFor(jni$_.JString? string);
}

final class _$FileNameMap with $FileNameMap {
  _$FileNameMap({
    required jni$_.JString? Function(jni$_.JString? string) getContentTypeFor,
  }) : _getContentTypeFor = getContentTypeFor;

  final jni$_.JString? Function(jni$_.JString? string) _getContentTypeFor;

  jni$_.JString? getContentTypeFor(jni$_.JString? string) =>
      _getContentTypeFor(string);
}

final class $FileNameMap$NullableType extends jni$_.JObjType<FileNameMap?> {
  @jni$_.internal
  const $FileNameMap$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/FileNameMap;';

  @jni$_.internal
  @core$_.override
  FileNameMap? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileNameMap.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileNameMap?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FileNameMap$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileNameMap$NullableType) &&
      other is $FileNameMap$NullableType;
}

final class $FileNameMap$Type extends jni$_.JObjType<FileNameMap> {
  @jni$_.internal
  const $FileNameMap$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/FileNameMap;';

  @jni$_.internal
  @core$_.override
  FileNameMap fromReference(jni$_.JReference reference) =>
      FileNameMap.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileNameMap?> get nullableType =>
      const $FileNameMap$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FileNameMap$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FileNameMap$Type) && other is $FileNameMap$Type;
}

/// from: `java.net.URLConnection`
class URLConnection extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<URLConnection> $type;

  @jni$_.internal
  URLConnection.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/URLConnection');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $URLConnection$NullableType();
  static const type = $URLConnection$Type();
  static final _id_getFileNameMap = _class.staticMethodId(
    r'getFileNameMap',
    r'()Ljava/net/FileNameMap;',
  );

  static final _getFileNameMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.net.FileNameMap getFileNameMap()`
  /// The returned object must be released after use, by calling the [release] method.
  static FileNameMap? getFileNameMap() => _getFileNameMap(
    _class.reference.pointer,
    _id_getFileNameMap as jni$_.JMethodIDPtr,
  ).object<FileNameMap?>(const $FileNameMap$NullableType());

  static final _id_setFileNameMap = _class.staticMethodId(
    r'setFileNameMap',
    r'(Ljava/net/FileNameMap;)V',
  );

  static final _setFileNameMap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setFileNameMap(java.net.FileNameMap fileNameMap)`
  static void setFileNameMap(FileNameMap? fileNameMap) {
    final _$fileNameMap = fileNameMap?.reference ?? jni$_.jNullReference;
    _setFileNameMap(
      _class.reference.pointer,
      _id_setFileNameMap as jni$_.JMethodIDPtr,
      _$fileNameMap.pointer,
    ).check();
  }

  static final _id_connect = _class.instanceMethodId(r'connect', r'()V');

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void connect()`
  void connect() {
    _connect(reference.pointer, _id_connect as jni$_.JMethodIDPtr).check();
  }

  static final _id_setConnectTimeout = _class.instanceMethodId(
    r'setConnectTimeout',
    r'(I)V',
  );

  static final _setConnectTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setConnectTimeout(int i)`
  void setConnectTimeout(int i) {
    _setConnectTimeout(
      reference.pointer,
      _id_setConnectTimeout as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getConnectTimeout = _class.instanceMethodId(
    r'getConnectTimeout',
    r'()I',
  );

  static final _getConnectTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getConnectTimeout()`
  int getConnectTimeout() =>
      _getConnectTimeout(
        reference.pointer,
        _id_getConnectTimeout as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setReadTimeout = _class.instanceMethodId(
    r'setReadTimeout',
    r'(I)V',
  );

  static final _setReadTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReadTimeout(int i)`
  void setReadTimeout(int i) {
    _setReadTimeout(
      reference.pointer,
      _id_setReadTimeout as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getReadTimeout = _class.instanceMethodId(
    r'getReadTimeout',
    r'()I',
  );

  static final _getReadTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getReadTimeout()`
  int getReadTimeout() =>
      _getReadTimeout(
        reference.pointer,
        _id_getReadTimeout as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getURL = _class.instanceMethodId(
    r'getURL',
    r'()Ljava/net/URL;',
  );

  static final _getURL =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URL getURL()`
  /// The returned object must be released after use, by calling the [release] method.
  URL? getURL() => _getURL(
    reference.pointer,
    _id_getURL as jni$_.JMethodIDPtr,
  ).object<URL?>(const $URL$NullableType());

  static final _id_getContentLength = _class.instanceMethodId(
    r'getContentLength',
    r'()I',
  );

  static final _getContentLength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getContentLength()`
  int getContentLength() =>
      _getContentLength(
        reference.pointer,
        _id_getContentLength as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getContentLengthLong = _class.instanceMethodId(
    r'getContentLengthLong',
    r'()J',
  );

  static final _getContentLengthLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getContentLengthLong()`
  int getContentLengthLong() =>
      _getContentLengthLong(
        reference.pointer,
        _id_getContentLengthLong as jni$_.JMethodIDPtr,
      ).long;

  static final _id_getContentType = _class.instanceMethodId(
    r'getContentType',
    r'()Ljava/lang/String;',
  );

  static final _getContentType =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getContentType()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getContentType() => _getContentType(
    reference.pointer,
    _id_getContentType as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getContentEncoding = _class.instanceMethodId(
    r'getContentEncoding',
    r'()Ljava/lang/String;',
  );

  static final _getContentEncoding =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getContentEncoding()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getContentEncoding() => _getContentEncoding(
    reference.pointer,
    _id_getContentEncoding as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getExpiration = _class.instanceMethodId(
    r'getExpiration',
    r'()J',
  );

  static final _getExpiration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getExpiration()`
  int getExpiration() =>
      _getExpiration(
        reference.pointer,
        _id_getExpiration as jni$_.JMethodIDPtr,
      ).long;

  static final _id_getDate = _class.instanceMethodId(r'getDate', r'()J');

  static final _getDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getDate()`
  int getDate() =>
      _getDate(reference.pointer, _id_getDate as jni$_.JMethodIDPtr).long;

  static final _id_getLastModified = _class.instanceMethodId(
    r'getLastModified',
    r'()J',
  );

  static final _getLastModified =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getLastModified()`
  int getLastModified() =>
      _getLastModified(
        reference.pointer,
        _id_getLastModified as jni$_.JMethodIDPtr,
      ).long;

  static final _id_getHeaderField = _class.instanceMethodId(
    r'getHeaderField',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getHeaderField =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getHeaderField(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHeaderField(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getHeaderField(
      reference.pointer,
      _id_getHeaderField as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getHeaderFields = _class.instanceMethodId(
    r'getHeaderFields',
    r'()Ljava/util/Map;',
  );

  static final _getHeaderFields =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Map<java.lang.String, java.util.List<java.lang.String>> getHeaderFields()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>?
  getHeaderFields() => _getHeaderFields(
    reference.pointer,
    _id_getHeaderFields as jni$_.JMethodIDPtr,
  ).object<jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>?>(
    const jni$_.JMapNullableType<jni$_.JString?, jni$_.JList<jni$_.JString?>?>(
      jni$_.JStringNullableType(),
      jni$_.JListNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
    ),
  );

  static final _id_getHeaderFieldInt = _class.instanceMethodId(
    r'getHeaderFieldInt',
    r'(Ljava/lang/String;I)I',
  );

  static final _getHeaderFieldInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public int getHeaderFieldInt(java.lang.String string, int i)`
  int getHeaderFieldInt(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getHeaderFieldInt(
      reference.pointer,
      _id_getHeaderFieldInt as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
    ).integer;
  }

  static final _id_getHeaderFieldLong = _class.instanceMethodId(
    r'getHeaderFieldLong',
    r'(Ljava/lang/String;J)J',
  );

  static final _getHeaderFieldLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public long getHeaderFieldLong(java.lang.String string, long j)`
  int getHeaderFieldLong(jni$_.JString? string, int j) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getHeaderFieldLong(
      reference.pointer,
      _id_getHeaderFieldLong as jni$_.JMethodIDPtr,
      _$string.pointer,
      j,
    ).long;
  }

  static final _id_getHeaderFieldDate = _class.instanceMethodId(
    r'getHeaderFieldDate',
    r'(Ljava/lang/String;J)J',
  );

  static final _getHeaderFieldDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public long getHeaderFieldDate(java.lang.String string, long j)`
  int getHeaderFieldDate(jni$_.JString? string, int j) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getHeaderFieldDate(
      reference.pointer,
      _id_getHeaderFieldDate as jni$_.JMethodIDPtr,
      _$string.pointer,
      j,
    ).long;
  }

  static final _id_getHeaderFieldKey = _class.instanceMethodId(
    r'getHeaderFieldKey',
    r'(I)Ljava/lang/String;',
  );

  static final _getHeaderFieldKey =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.lang.String getHeaderFieldKey(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHeaderFieldKey(int i) => _getHeaderFieldKey(
    reference.pointer,
    _id_getHeaderFieldKey as jni$_.JMethodIDPtr,
    i,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getHeaderField$1 = _class.instanceMethodId(
    r'getHeaderField',
    r'(I)Ljava/lang/String;',
  );

  static final _getHeaderField$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.lang.String getHeaderField(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHeaderField$1(int i) => _getHeaderField$1(
    reference.pointer,
    _id_getHeaderField$1 as jni$_.JMethodIDPtr,
    i,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getContent = _class.instanceMethodId(
    r'getContent',
    r'()Ljava/lang/Object;',
  );

  static final _getContent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object getContent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContent() => _getContent(
    reference.pointer,
    _id_getContent as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getContent$1 = _class.instanceMethodId(
    r'getContent',
    r'([Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _getContent$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object getContent(java.lang.Class[] classs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContent$1(jni$_.JArray<jni$_.JObject?>? classs) {
    final _$classs = classs?.reference ?? jni$_.jNullReference;
    return _getContent$1(
      reference.pointer,
      _id_getContent$1 as jni$_.JMethodIDPtr,
      _$classs.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getPermission = _class.instanceMethodId(
    r'getPermission',
    r'()Ljava/security/Permission;',
  );

  static final _getPermission =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.security.Permission getPermission()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getPermission() => _getPermission(
    reference.pointer,
    _id_getPermission as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getInputStream = _class.instanceMethodId(
    r'getInputStream',
    r'()Ljava/io/InputStream;',
  );

  static final _getInputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.InputStream getInputStream()`
  /// The returned object must be released after use, by calling the [release] method.
  InputStream? getInputStream() => _getInputStream(
    reference.pointer,
    _id_getInputStream as jni$_.JMethodIDPtr,
  ).object<InputStream?>(const $InputStream$NullableType());

  static final _id_getOutputStream = _class.instanceMethodId(
    r'getOutputStream',
    r'()Ljava/io/OutputStream;',
  );

  static final _getOutputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.OutputStream getOutputStream()`
  /// The returned object must be released after use, by calling the [release] method.
  OutputStream? getOutputStream() => _getOutputStream(
    reference.pointer,
    _id_getOutputStream as jni$_.JMethodIDPtr,
  ).object<OutputStream?>(const $OutputStream$NullableType());

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setDoInput = _class.instanceMethodId(r'setDoInput', r'(Z)V');

  static final _setDoInput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setDoInput(boolean z)`
  void setDoInput(bool z) {
    _setDoInput(
      reference.pointer,
      _id_setDoInput as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getDoInput = _class.instanceMethodId(r'getDoInput', r'()Z');

  static final _getDoInput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getDoInput()`
  bool getDoInput() =>
      _getDoInput(
        reference.pointer,
        _id_getDoInput as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setDoOutput = _class.instanceMethodId(
    r'setDoOutput',
    r'(Z)V',
  );

  static final _setDoOutput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setDoOutput(boolean z)`
  void setDoOutput(bool z) {
    _setDoOutput(
      reference.pointer,
      _id_setDoOutput as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getDoOutput = _class.instanceMethodId(
    r'getDoOutput',
    r'()Z',
  );

  static final _getDoOutput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getDoOutput()`
  bool getDoOutput() =>
      _getDoOutput(
        reference.pointer,
        _id_getDoOutput as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setAllowUserInteraction = _class.instanceMethodId(
    r'setAllowUserInteraction',
    r'(Z)V',
  );

  static final _setAllowUserInteraction =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setAllowUserInteraction(boolean z)`
  void setAllowUserInteraction(bool z) {
    _setAllowUserInteraction(
      reference.pointer,
      _id_setAllowUserInteraction as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getAllowUserInteraction = _class.instanceMethodId(
    r'getAllowUserInteraction',
    r'()Z',
  );

  static final _getAllowUserInteraction =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getAllowUserInteraction()`
  bool getAllowUserInteraction() =>
      _getAllowUserInteraction(
        reference.pointer,
        _id_getAllowUserInteraction as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setDefaultAllowUserInteraction = _class.staticMethodId(
    r'setDefaultAllowUserInteraction',
    r'(Z)V',
  );

  static final _setDefaultAllowUserInteraction =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public void setDefaultAllowUserInteraction(boolean z)`
  static void setDefaultAllowUserInteraction(bool z) {
    _setDefaultAllowUserInteraction(
      _class.reference.pointer,
      _id_setDefaultAllowUserInteraction as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getDefaultAllowUserInteraction = _class.staticMethodId(
    r'getDefaultAllowUserInteraction',
    r'()Z',
  );

  static final _getDefaultAllowUserInteraction =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public boolean getDefaultAllowUserInteraction()`
  static bool getDefaultAllowUserInteraction() =>
      _getDefaultAllowUserInteraction(
        _class.reference.pointer,
        _id_getDefaultAllowUserInteraction as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setUseCaches = _class.instanceMethodId(
    r'setUseCaches',
    r'(Z)V',
  );

  static final _setUseCaches =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setUseCaches(boolean z)`
  void setUseCaches(bool z) {
    _setUseCaches(
      reference.pointer,
      _id_setUseCaches as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getUseCaches = _class.instanceMethodId(
    r'getUseCaches',
    r'()Z',
  );

  static final _getUseCaches =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getUseCaches()`
  bool getUseCaches() =>
      _getUseCaches(
        reference.pointer,
        _id_getUseCaches as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setIfModifiedSince = _class.instanceMethodId(
    r'setIfModifiedSince',
    r'(J)V',
  );

  static final _setIfModifiedSince =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setIfModifiedSince(long j)`
  void setIfModifiedSince(int j) {
    _setIfModifiedSince(
      reference.pointer,
      _id_setIfModifiedSince as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_getIfModifiedSince = _class.instanceMethodId(
    r'getIfModifiedSince',
    r'()J',
  );

  static final _getIfModifiedSince =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getIfModifiedSince()`
  int getIfModifiedSince() =>
      _getIfModifiedSince(
        reference.pointer,
        _id_getIfModifiedSince as jni$_.JMethodIDPtr,
      ).long;

  static final _id_getDefaultUseCaches = _class.instanceMethodId(
    r'getDefaultUseCaches',
    r'()Z',
  );

  static final _getDefaultUseCaches =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getDefaultUseCaches()`
  bool getDefaultUseCaches() =>
      _getDefaultUseCaches(
        reference.pointer,
        _id_getDefaultUseCaches as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setDefaultUseCaches = _class.instanceMethodId(
    r'setDefaultUseCaches',
    r'(Z)V',
  );

  static final _setDefaultUseCaches =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setDefaultUseCaches(boolean z)`
  void setDefaultUseCaches(bool z) {
    _setDefaultUseCaches(
      reference.pointer,
      _id_setDefaultUseCaches as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setDefaultUseCaches$1 = _class.staticMethodId(
    r'setDefaultUseCaches',
    r'(Ljava/lang/String;Z)V',
  );

  static final _setDefaultUseCaches$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public void setDefaultUseCaches(java.lang.String string, boolean z)`
  static void setDefaultUseCaches$1(jni$_.JString? string, bool z) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setDefaultUseCaches$1(
      _class.reference.pointer,
      _id_setDefaultUseCaches$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getDefaultUseCaches$1 = _class.staticMethodId(
    r'getDefaultUseCaches',
    r'(Ljava/lang/String;)Z',
  );

  static final _getDefaultUseCaches$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public boolean getDefaultUseCaches(java.lang.String string)`
  static bool getDefaultUseCaches$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getDefaultUseCaches$1(
      _class.reference.pointer,
      _id_getDefaultUseCaches$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).boolean;
  }

  static final _id_setRequestProperty = _class.instanceMethodId(
    r'setRequestProperty',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setRequestProperty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setRequestProperty(java.lang.String string, java.lang.String string1)`
  void setRequestProperty(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setRequestProperty(
      reference.pointer,
      _id_setRequestProperty as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).check();
  }

  static final _id_addRequestProperty = _class.instanceMethodId(
    r'addRequestProperty',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _addRequestProperty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addRequestProperty(java.lang.String string, java.lang.String string1)`
  void addRequestProperty(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _addRequestProperty(
      reference.pointer,
      _id_addRequestProperty as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).check();
  }

  static final _id_getRequestProperty = _class.instanceMethodId(
    r'getRequestProperty',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getRequestProperty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getRequestProperty(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRequestProperty(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getRequestProperty(
      reference.pointer,
      _id_getRequestProperty as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getRequestProperties = _class.instanceMethodId(
    r'getRequestProperties',
    r'()Ljava/util/Map;',
  );

  static final _getRequestProperties =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Map<java.lang.String, java.util.List<java.lang.String>> getRequestProperties()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>?
  getRequestProperties() => _getRequestProperties(
    reference.pointer,
    _id_getRequestProperties as jni$_.JMethodIDPtr,
  ).object<jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>?>(
    const jni$_.JMapNullableType<jni$_.JString?, jni$_.JList<jni$_.JString?>?>(
      jni$_.JStringNullableType(),
      jni$_.JListNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
    ),
  );

  static final _id_setDefaultRequestProperty = _class.staticMethodId(
    r'setDefaultRequestProperty',
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _setDefaultRequestProperty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setDefaultRequestProperty(java.lang.String string, java.lang.String string1)`
  static void setDefaultRequestProperty(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    _setDefaultRequestProperty(
      _class.reference.pointer,
      _id_setDefaultRequestProperty as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).check();
  }

  static final _id_getDefaultRequestProperty = _class.staticMethodId(
    r'getDefaultRequestProperty',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _getDefaultRequestProperty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String getDefaultRequestProperty(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? getDefaultRequestProperty(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getDefaultRequestProperty(
      _class.reference.pointer,
      _id_getDefaultRequestProperty as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_setContentHandlerFactory = _class.staticMethodId(
    r'setContentHandlerFactory',
    r'(Ljava/net/ContentHandlerFactory;)V',
  );

  static final _setContentHandlerFactory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setContentHandlerFactory(java.net.ContentHandlerFactory contentHandlerFactory)`
  static void setContentHandlerFactory(
    ContentHandlerFactory? contentHandlerFactory,
  ) {
    final _$contentHandlerFactory =
        contentHandlerFactory?.reference ?? jni$_.jNullReference;
    _setContentHandlerFactory(
      _class.reference.pointer,
      _id_setContentHandlerFactory as jni$_.JMethodIDPtr,
      _$contentHandlerFactory.pointer,
    ).check();
  }

  static final _id_guessContentTypeFromName = _class.staticMethodId(
    r'guessContentTypeFromName',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _guessContentTypeFromName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String guessContentTypeFromName(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? guessContentTypeFromName(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _guessContentTypeFromName(
      _class.reference.pointer,
      _id_guessContentTypeFromName as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_guessContentTypeFromStream = _class.staticMethodId(
    r'guessContentTypeFromStream',
    r'(Ljava/io/InputStream;)Ljava/lang/String;',
  );

  static final _guessContentTypeFromStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String guessContentTypeFromStream(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? guessContentTypeFromStream(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return _guessContentTypeFromStream(
      _class.reference.pointer,
      _id_guessContentTypeFromStream as jni$_.JMethodIDPtr,
      _$inputStream.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $URLConnection$NullableType extends jni$_.JObjType<URLConnection?> {
  @jni$_.internal
  const $URLConnection$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLConnection;';

  @jni$_.internal
  @core$_.override
  URLConnection? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : URLConnection.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URLConnection?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLConnection$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URLConnection$NullableType) &&
      other is $URLConnection$NullableType;
}

final class $URLConnection$Type extends jni$_.JObjType<URLConnection> {
  @jni$_.internal
  const $URLConnection$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLConnection;';

  @jni$_.internal
  @core$_.override
  URLConnection fromReference(jni$_.JReference reference) =>
      URLConnection.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URLConnection?> get nullableType =>
      const $URLConnection$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLConnection$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URLConnection$Type) &&
      other is $URLConnection$Type;
}

/// from: `java.net.SocketTimeoutException`
class SocketTimeoutException extends InterruptedIOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SocketTimeoutException> $type;

  @jni$_.internal
  SocketTimeoutException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/net/SocketTimeoutException',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SocketTimeoutException$NullableType();
  static const type = $SocketTimeoutException$Type();
  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SocketTimeoutException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return SocketTimeoutException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SocketTimeoutException() => SocketTimeoutException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );
}

final class $SocketTimeoutException$NullableType
    extends jni$_.JObjType<SocketTimeoutException?> {
  @jni$_.internal
  const $SocketTimeoutException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketTimeoutException;';

  @jni$_.internal
  @core$_.override
  SocketTimeoutException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SocketTimeoutException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InterruptedIOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketTimeoutException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($SocketTimeoutException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketTimeoutException$NullableType) &&
      other is $SocketTimeoutException$NullableType;
}

final class $SocketTimeoutException$Type
    extends jni$_.JObjType<SocketTimeoutException> {
  @jni$_.internal
  const $SocketTimeoutException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketTimeoutException;';

  @jni$_.internal
  @core$_.override
  SocketTimeoutException fromReference(jni$_.JReference reference) =>
      SocketTimeoutException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InterruptedIOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketTimeoutException?> get nullableType =>
      const $SocketTimeoutException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($SocketTimeoutException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketTimeoutException$Type) &&
      other is $SocketTimeoutException$Type;
}

/// from: `java.net.ConnectException`
class ConnectException extends SocketException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ConnectException> $type;

  @jni$_.internal
  ConnectException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/ConnectException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ConnectException$NullableType();
  static const type = $ConnectException$Type();
  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ConnectException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return ConnectException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ConnectException() => ConnectException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );
}

final class $ConnectException$NullableType
    extends jni$_.JObjType<ConnectException?> {
  @jni$_.internal
  const $ConnectException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ConnectException;';

  @jni$_.internal
  @core$_.override
  ConnectException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ConnectException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SocketException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ConnectException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($ConnectException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ConnectException$NullableType) &&
      other is $ConnectException$NullableType;
}

final class $ConnectException$Type extends jni$_.JObjType<ConnectException> {
  @jni$_.internal
  const $ConnectException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ConnectException;';

  @jni$_.internal
  @core$_.override
  ConnectException fromReference(jni$_.JReference reference) =>
      ConnectException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SocketException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ConnectException?> get nullableType =>
      const $ConnectException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($ConnectException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ConnectException$Type) &&
      other is $ConnectException$Type;
}

/// from: `java.net.Inet4Address`
class Inet4Address extends InetAddress {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Inet4Address> $type;

  @jni$_.internal
  Inet4Address.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/Inet4Address');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Inet4Address$NullableType();
  static const type = $Inet4Address$Type();
  static final _id_isMulticastAddress = _class.instanceMethodId(
    r'isMulticastAddress',
    r'()Z',
  );

  static final _isMulticastAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMulticastAddress()`
  bool isMulticastAddress() =>
      _isMulticastAddress(
        reference.pointer,
        _id_isMulticastAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isAnyLocalAddress = _class.instanceMethodId(
    r'isAnyLocalAddress',
    r'()Z',
  );

  static final _isAnyLocalAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isAnyLocalAddress()`
  bool isAnyLocalAddress() =>
      _isAnyLocalAddress(
        reference.pointer,
        _id_isAnyLocalAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isLoopbackAddress = _class.instanceMethodId(
    r'isLoopbackAddress',
    r'()Z',
  );

  static final _isLoopbackAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLoopbackAddress()`
  bool isLoopbackAddress() =>
      _isLoopbackAddress(
        reference.pointer,
        _id_isLoopbackAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isLinkLocalAddress = _class.instanceMethodId(
    r'isLinkLocalAddress',
    r'()Z',
  );

  static final _isLinkLocalAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLinkLocalAddress()`
  bool isLinkLocalAddress() =>
      _isLinkLocalAddress(
        reference.pointer,
        _id_isLinkLocalAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isSiteLocalAddress = _class.instanceMethodId(
    r'isSiteLocalAddress',
    r'()Z',
  );

  static final _isSiteLocalAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isSiteLocalAddress()`
  bool isSiteLocalAddress() =>
      _isSiteLocalAddress(
        reference.pointer,
        _id_isSiteLocalAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCGlobal = _class.instanceMethodId(r'isMCGlobal', r'()Z');

  static final _isMCGlobal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCGlobal()`
  bool isMCGlobal() =>
      _isMCGlobal(
        reference.pointer,
        _id_isMCGlobal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCNodeLocal = _class.instanceMethodId(
    r'isMCNodeLocal',
    r'()Z',
  );

  static final _isMCNodeLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCNodeLocal()`
  bool isMCNodeLocal() =>
      _isMCNodeLocal(
        reference.pointer,
        _id_isMCNodeLocal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCLinkLocal = _class.instanceMethodId(
    r'isMCLinkLocal',
    r'()Z',
  );

  static final _isMCLinkLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCLinkLocal()`
  bool isMCLinkLocal() =>
      _isMCLinkLocal(
        reference.pointer,
        _id_isMCLinkLocal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCSiteLocal = _class.instanceMethodId(
    r'isMCSiteLocal',
    r'()Z',
  );

  static final _isMCSiteLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCSiteLocal()`
  bool isMCSiteLocal() =>
      _isMCSiteLocal(
        reference.pointer,
        _id_isMCSiteLocal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCOrgLocal = _class.instanceMethodId(
    r'isMCOrgLocal',
    r'()Z',
  );

  static final _isMCOrgLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCOrgLocal()`
  bool isMCOrgLocal() =>
      _isMCOrgLocal(
        reference.pointer,
        _id_isMCOrgLocal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_getAddress = _class.instanceMethodId(r'getAddress', r'()[B');

  static final _getAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] getAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getAddress() => _getAddress(
    reference.pointer,
    _id_getAddress as jni$_.JMethodIDPtr,
  ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());

  static final _id_getHostAddress = _class.instanceMethodId(
    r'getHostAddress',
    r'()Ljava/lang/String;',
  );

  static final _getHostAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getHostAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHostAddress() => _getHostAddress(
    reference.pointer,
    _id_getHostAddress as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_hashCode1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode1() =>
      _hashCode1(
        reference.pointer,
        _id_hashCode1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }
}

final class $Inet4Address$NullableType extends jni$_.JObjType<Inet4Address?> {
  @jni$_.internal
  const $Inet4Address$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Inet4Address;';

  @jni$_.internal
  @core$_.override
  Inet4Address? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Inet4Address.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InetAddress$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Inet4Address?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($Inet4Address$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Inet4Address$NullableType) &&
      other is $Inet4Address$NullableType;
}

final class $Inet4Address$Type extends jni$_.JObjType<Inet4Address> {
  @jni$_.internal
  const $Inet4Address$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Inet4Address;';

  @jni$_.internal
  @core$_.override
  Inet4Address fromReference(jni$_.JReference reference) =>
      Inet4Address.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InetAddress$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Inet4Address?> get nullableType =>
      const $Inet4Address$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($Inet4Address$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Inet4Address$Type) && other is $Inet4Address$Type;
}

/// from: `java.net.UnknownHostException`
class UnknownHostException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<UnknownHostException> $type;

  @jni$_.internal
  UnknownHostException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/UnknownHostException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $UnknownHostException$NullableType();
  static const type = $UnknownHostException$Type();
  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory UnknownHostException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return UnknownHostException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory UnknownHostException() => UnknownHostException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );
}

final class $UnknownHostException$NullableType
    extends jni$_.JObjType<UnknownHostException?> {
  @jni$_.internal
  const $UnknownHostException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/UnknownHostException;';

  @jni$_.internal
  @core$_.override
  UnknownHostException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : UnknownHostException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UnknownHostException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UnknownHostException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($UnknownHostException$NullableType) &&
      other is $UnknownHostException$NullableType;
}

final class $UnknownHostException$Type
    extends jni$_.JObjType<UnknownHostException> {
  @jni$_.internal
  const $UnknownHostException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/UnknownHostException;';

  @jni$_.internal
  @core$_.override
  UnknownHostException fromReference(jni$_.JReference reference) =>
      UnknownHostException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UnknownHostException?> get nullableType =>
      const $UnknownHostException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UnknownHostException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($UnknownHostException$Type) &&
      other is $UnknownHostException$Type;
}

/// from: `java.net.ProtocolException`
class ProtocolException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ProtocolException> $type;

  @jni$_.internal
  ProtocolException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/ProtocolException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ProtocolException$NullableType();
  static const type = $ProtocolException$Type();
  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ProtocolException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return ProtocolException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ProtocolException() => ProtocolException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );
}

final class $ProtocolException$NullableType
    extends jni$_.JObjType<ProtocolException?> {
  @jni$_.internal
  const $ProtocolException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ProtocolException;';

  @jni$_.internal
  @core$_.override
  ProtocolException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ProtocolException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ProtocolException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ProtocolException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ProtocolException$NullableType) &&
      other is $ProtocolException$NullableType;
}

final class $ProtocolException$Type extends jni$_.JObjType<ProtocolException> {
  @jni$_.internal
  const $ProtocolException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ProtocolException;';

  @jni$_.internal
  @core$_.override
  ProtocolException fromReference(jni$_.JReference reference) =>
      ProtocolException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ProtocolException?> get nullableType =>
      const $ProtocolException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ProtocolException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ProtocolException$Type) &&
      other is $ProtocolException$Type;
}

/// from: `java.net.UnixDomainSocketAddress`
class UnixDomainSocketAddress extends SocketAddress {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<UnixDomainSocketAddress> $type;

  @jni$_.internal
  UnixDomainSocketAddress.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/net/UnixDomainSocketAddress',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $UnixDomainSocketAddress$NullableType();
  static const type = $UnixDomainSocketAddress$Type();
  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/String;)Ljava/net/UnixDomainSocketAddress;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.UnixDomainSocketAddress of(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static UnixDomainSocketAddress? of(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<UnixDomainSocketAddress?>(
      const $UnixDomainSocketAddress$NullableType(),
    );
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/nio/file/Path;)Ljava/net/UnixDomainSocketAddress;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.UnixDomainSocketAddress of(java.nio.file.Path path)`
  /// The returned object must be released after use, by calling the [release] method.
  static UnixDomainSocketAddress? of$1(jni$_.JObject? path) {
    final _$path = path?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      _$path.pointer,
    ).object<UnixDomainSocketAddress?>(
      const $UnixDomainSocketAddress$NullableType(),
    );
  }

  static final _id_getPath = _class.instanceMethodId(
    r'getPath',
    r'()Ljava/nio/file/Path;',
  );

  static final _getPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.file.Path getPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getPath() => _getPath(
    reference.pointer,
    _id_getPath as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $UnixDomainSocketAddress$NullableType
    extends jni$_.JObjType<UnixDomainSocketAddress?> {
  @jni$_.internal
  const $UnixDomainSocketAddress$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/UnixDomainSocketAddress;';

  @jni$_.internal
  @core$_.override
  UnixDomainSocketAddress? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : UnixDomainSocketAddress.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SocketAddress$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UnixDomainSocketAddress?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UnixDomainSocketAddress$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($UnixDomainSocketAddress$NullableType) &&
      other is $UnixDomainSocketAddress$NullableType;
}

final class $UnixDomainSocketAddress$Type
    extends jni$_.JObjType<UnixDomainSocketAddress> {
  @jni$_.internal
  const $UnixDomainSocketAddress$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/UnixDomainSocketAddress;';

  @jni$_.internal
  @core$_.override
  UnixDomainSocketAddress fromReference(jni$_.JReference reference) =>
      UnixDomainSocketAddress.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SocketAddress$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UnixDomainSocketAddress?> get nullableType =>
      const $UnixDomainSocketAddress$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UnixDomainSocketAddress$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($UnixDomainSocketAddress$Type) &&
      other is $UnixDomainSocketAddress$Type;
}

/// from: `java.net.SocketImpl`
class SocketImpl extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SocketImpl> $type;

  @jni$_.internal
  SocketImpl.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/SocketImpl');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SocketImpl$NullableType();
  static const type = $SocketImpl$Type();
  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setOption = _class.instanceMethodId(
    r'setOption',
    r'(ILjava/lang/Object;)V',
  );

  static final _setOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void setOption(int i, java.lang.Object object)`
  void setOption(int i, jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _setOption(
      reference.pointer,
      _id_setOption as jni$_.JMethodIDPtr,
      i,
      _$object.pointer,
    ).check();
  }

  static final _id_getOption = _class.instanceMethodId(
    r'getOption',
    r'(I)Ljava/lang/Object;',
  );

  static final _getOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract java.lang.Object getOption(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getOption(int i) => _getOption(
    reference.pointer,
    _id_getOption as jni$_.JMethodIDPtr,
    i,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
}

final class $SocketImpl$NullableType extends jni$_.JObjType<SocketImpl?> {
  @jni$_.internal
  const $SocketImpl$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketImpl;';

  @jni$_.internal
  @core$_.override
  SocketImpl? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SocketImpl.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketImpl?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SocketImpl$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketImpl$NullableType) &&
      other is $SocketImpl$NullableType;
}

final class $SocketImpl$Type extends jni$_.JObjType<SocketImpl> {
  @jni$_.internal
  const $SocketImpl$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketImpl;';

  @jni$_.internal
  @core$_.override
  SocketImpl fromReference(jni$_.JReference reference) =>
      SocketImpl.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketImpl?> get nullableType =>
      const $SocketImpl$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SocketImpl$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketImpl$Type) && other is $SocketImpl$Type;
}

/// from: `java.net.SocketAddress`
class SocketAddress extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SocketAddress> $type;

  @jni$_.internal
  SocketAddress.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/SocketAddress');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SocketAddress$NullableType();
  static const type = $SocketAddress$Type();
}

final class $SocketAddress$NullableType extends jni$_.JObjType<SocketAddress?> {
  @jni$_.internal
  const $SocketAddress$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketAddress;';

  @jni$_.internal
  @core$_.override
  SocketAddress? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SocketAddress.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketAddress?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SocketAddress$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketAddress$NullableType) &&
      other is $SocketAddress$NullableType;
}

final class $SocketAddress$Type extends jni$_.JObjType<SocketAddress> {
  @jni$_.internal
  const $SocketAddress$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketAddress;';

  @jni$_.internal
  @core$_.override
  SocketAddress fromReference(jni$_.JReference reference) =>
      SocketAddress.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketAddress?> get nullableType =>
      const $SocketAddress$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SocketAddress$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketAddress$Type) &&
      other is $SocketAddress$Type;
}

/// from: `java.net.URLDecoder`
class URLDecoder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<URLDecoder> $type;

  @jni$_.internal
  URLDecoder.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/URLDecoder');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $URLDecoder$NullableType();
  static const type = $URLDecoder$Type();
  static final _id_decode = _class.staticMethodId(
    r'decode',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _decode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String decode(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? decode(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _decode(
      _class.reference.pointer,
      _id_decode as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_decode$1 = _class.staticMethodId(
    r'decode',
    r'(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _decode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String decode(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? decode$1(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _decode$1(
      _class.reference.pointer,
      _id_decode$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_decode$2 = _class.staticMethodId(
    r'decode',
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;)Ljava/lang/String;',
  );

  static final _decode$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String decode(java.lang.String string, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? decode$2(
    jni$_.JString? string,
    jni$_.JObject? charset,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return _decode$2(
      _class.reference.pointer,
      _id_decode$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$charset.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $URLDecoder$NullableType extends jni$_.JObjType<URLDecoder?> {
  @jni$_.internal
  const $URLDecoder$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLDecoder;';

  @jni$_.internal
  @core$_.override
  URLDecoder? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : URLDecoder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URLDecoder?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLDecoder$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URLDecoder$NullableType) &&
      other is $URLDecoder$NullableType;
}

final class $URLDecoder$Type extends jni$_.JObjType<URLDecoder> {
  @jni$_.internal
  const $URLDecoder$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLDecoder;';

  @jni$_.internal
  @core$_.override
  URLDecoder fromReference(jni$_.JReference reference) =>
      URLDecoder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URLDecoder?> get nullableType =>
      const $URLDecoder$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLDecoder$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URLDecoder$Type) && other is $URLDecoder$Type;
}

/// from: `java.net.URL`
class URL extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<URL> $type;

  @jni$_.internal
  URL.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/URL');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $URL$NullableType();
  static const type = $URL$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, int i, java.lang.String string2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URL(
    jni$_.JString? string,
    jni$_.JString? string1,
    int i,
    jni$_.JString? string2,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    return URL.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
        i,
        _$string2.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new$1(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    return URL.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
        _$string2.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;Ljava/net/URLStreamHandler;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, int i, java.lang.String string2, java.net.URLStreamHandler uRLStreamHandler)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new$2(
    jni$_.JString? string,
    jni$_.JString? string1,
    int i,
    jni$_.JString? string2,
    URLStreamHandler? uRLStreamHandler,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$uRLStreamHandler =
        uRLStreamHandler?.reference ?? jni$_.jNullReference;
    return URL.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
        i,
        _$string2.pointer,
        _$uRLStreamHandler.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new$3(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return URL.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(
    r'(Ljava/net/URL;Ljava/lang/String;)V',
  );

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.URL uRL, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new$4(URL? uRL, jni$_.JString? string) {
    final _$uRL = uRL?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return URL.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$uRL.pointer,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(
    r'(Ljava/net/URL;Ljava/lang/String;Ljava/net/URLStreamHandler;)V',
  );

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.URL uRL, java.lang.String string, java.net.URLStreamHandler uRLStreamHandler)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new$5(
    URL? uRL,
    jni$_.JString? string,
    URLStreamHandler? uRLStreamHandler,
  ) {
    final _$uRL = uRL?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$uRLStreamHandler =
        uRLStreamHandler?.reference ?? jni$_.jNullReference;
    return URL.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$uRL.pointer,
        _$string.pointer,
        _$uRLStreamHandler.pointer,
      ).reference,
    );
  }

  static final _id_getQuery = _class.instanceMethodId(
    r'getQuery',
    r'()Ljava/lang/String;',
  );

  static final _getQuery =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getQuery()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getQuery() => _getQuery(
    reference.pointer,
    _id_getQuery as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getPath = _class.instanceMethodId(
    r'getPath',
    r'()Ljava/lang/String;',
  );

  static final _getPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPath() => _getPath(
    reference.pointer,
    _id_getPath as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getUserInfo = _class.instanceMethodId(
    r'getUserInfo',
    r'()Ljava/lang/String;',
  );

  static final _getUserInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getUserInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getUserInfo() => _getUserInfo(
    reference.pointer,
    _id_getUserInfo as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getAuthority = _class.instanceMethodId(
    r'getAuthority',
    r'()Ljava/lang/String;',
  );

  static final _getAuthority =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getAuthority()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAuthority() => _getAuthority(
    reference.pointer,
    _id_getAuthority as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getPort = _class.instanceMethodId(r'getPort', r'()I');

  static final _getPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getPort()`
  int getPort() =>
      _getPort(reference.pointer, _id_getPort as jni$_.JMethodIDPtr).integer;

  static final _id_getDefaultPort = _class.instanceMethodId(
    r'getDefaultPort',
    r'()I',
  );

  static final _getDefaultPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDefaultPort()`
  int getDefaultPort() =>
      _getDefaultPort(
        reference.pointer,
        _id_getDefaultPort as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getProtocol = _class.instanceMethodId(
    r'getProtocol',
    r'()Ljava/lang/String;',
  );

  static final _getProtocol =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getProtocol()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getProtocol() => _getProtocol(
    reference.pointer,
    _id_getProtocol as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getHost = _class.instanceMethodId(
    r'getHost',
    r'()Ljava/lang/String;',
  );

  static final _getHost =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getHost()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHost() => _getHost(
    reference.pointer,
    _id_getHost as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getFile = _class.instanceMethodId(
    r'getFile',
    r'()Ljava/lang/String;',
  );

  static final _getFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getFile()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getFile() => _getFile(
    reference.pointer,
    _id_getFile as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getRef = _class.instanceMethodId(
    r'getRef',
    r'()Ljava/lang/String;',
  );

  static final _getRef =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getRef()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRef() => _getRef(
    reference.pointer,
    _id_getRef as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_sameFile = _class.instanceMethodId(
    r'sameFile',
    r'(Ljava/net/URL;)Z',
  );

  static final _sameFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean sameFile(java.net.URL uRL)`
  bool sameFile(URL? uRL) {
    final _$uRL = uRL?.reference ?? jni$_.jNullReference;
    return _sameFile(
      reference.pointer,
      _id_sameFile as jni$_.JMethodIDPtr,
      _$uRL.pointer,
    ).boolean;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_toExternalForm = _class.instanceMethodId(
    r'toExternalForm',
    r'()Ljava/lang/String;',
  );

  static final _toExternalForm =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toExternalForm()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toExternalForm() => _toExternalForm(
    reference.pointer,
    _id_toExternalForm as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_toURI = _class.instanceMethodId(
    r'toURI',
    r'()Ljava/net/URI;',
  );

  static final _toURI =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URI toURI()`
  /// The returned object must be released after use, by calling the [release] method.
  URI? toURI() => _toURI(
    reference.pointer,
    _id_toURI as jni$_.JMethodIDPtr,
  ).object<URI?>(const $URI$NullableType());

  static final _id_openConnection = _class.instanceMethodId(
    r'openConnection',
    r'()Ljava/net/URLConnection;',
  );

  static final _openConnection =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URLConnection openConnection()`
  /// The returned object must be released after use, by calling the [release] method.
  URLConnection? openConnection() => _openConnection(
    reference.pointer,
    _id_openConnection as jni$_.JMethodIDPtr,
  ).object<URLConnection?>(const $URLConnection$NullableType());

  static final _id_openConnection$1 = _class.instanceMethodId(
    r'openConnection',
    r'(Ljava/net/Proxy;)Ljava/net/URLConnection;',
  );

  static final _openConnection$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.net.URLConnection openConnection(java.net.Proxy proxy)`
  /// The returned object must be released after use, by calling the [release] method.
  URLConnection? openConnection$1(Proxy? proxy) {
    final _$proxy = proxy?.reference ?? jni$_.jNullReference;
    return _openConnection$1(
      reference.pointer,
      _id_openConnection$1 as jni$_.JMethodIDPtr,
      _$proxy.pointer,
    ).object<URLConnection?>(const $URLConnection$NullableType());
  }

  static final _id_openStream = _class.instanceMethodId(
    r'openStream',
    r'()Ljava/io/InputStream;',
  );

  static final _openStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.io.InputStream openStream()`
  /// The returned object must be released after use, by calling the [release] method.
  InputStream? openStream() => _openStream(
    reference.pointer,
    _id_openStream as jni$_.JMethodIDPtr,
  ).object<InputStream?>(const $InputStream$NullableType());

  static final _id_getContent = _class.instanceMethodId(
    r'getContent',
    r'()Ljava/lang/Object;',
  );

  static final _getContent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Object getContent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContent() => _getContent(
    reference.pointer,
    _id_getContent as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getContent$1 = _class.instanceMethodId(
    r'getContent',
    r'([Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _getContent$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final java.lang.Object getContent(java.lang.Class[] classs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContent$1(jni$_.JArray<jni$_.JObject?>? classs) {
    final _$classs = classs?.reference ?? jni$_.jNullReference;
    return _getContent$1(
      reference.pointer,
      _id_getContent$1 as jni$_.JMethodIDPtr,
      _$classs.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setURLStreamHandlerFactory = _class.staticMethodId(
    r'setURLStreamHandlerFactory',
    r'(Ljava/net/URLStreamHandlerFactory;)V',
  );

  static final _setURLStreamHandlerFactory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setURLStreamHandlerFactory(java.net.URLStreamHandlerFactory uRLStreamHandlerFactory)`
  static void setURLStreamHandlerFactory(
    URLStreamHandlerFactory? uRLStreamHandlerFactory,
  ) {
    final _$uRLStreamHandlerFactory =
        uRLStreamHandlerFactory?.reference ?? jni$_.jNullReference;
    _setURLStreamHandlerFactory(
      _class.reference.pointer,
      _id_setURLStreamHandlerFactory as jni$_.JMethodIDPtr,
      _$uRLStreamHandlerFactory.pointer,
    ).check();
  }
}

final class $URL$NullableType extends jni$_.JObjType<URL?> {
  @jni$_.internal
  const $URL$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URL;';

  @jni$_.internal
  @core$_.override
  URL? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : URL.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URL?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URL$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URL$NullableType) && other is $URL$NullableType;
}

final class $URL$Type extends jni$_.JObjType<URL> {
  @jni$_.internal
  const $URL$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URL;';

  @jni$_.internal
  @core$_.override
  URL fromReference(jni$_.JReference reference) => URL.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URL?> get nullableType => const $URL$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URL$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URL$Type) && other is $URL$Type;
}

/// from: `java.net.SocketOption`
class SocketOption<$T extends jni$_.JObject?> extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SocketOption<$T>> $type;

  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  SocketOption.fromReference(this.T, jni$_.JReference reference)
    : $type = type<$T>(T),
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/SocketOption');

  /// The type which includes information such as the signature of this class.
  static $SocketOption$NullableType<$T> nullableType<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) => $SocketOption$NullableType<$T>(T);

  static $SocketOption$Type<$T> type<$T extends jni$_.JObject?>(
    jni$_.JObjType<$T> T,
  ) => $SocketOption$Type<$T>(T);

  static final _id_name = _class.instanceMethodId(
    r'name',
    r'()Ljava/lang/String;',
  );

  static final _name =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String name()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? name() => _name(
    reference.pointer,
    _id_name as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_type$1 = _class.instanceMethodId(
    r'type',
    r'()Ljava/lang/Class;',
  );

  static final _type$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.Class<T> type()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? type$1() => _type$1(
    reference.pointer,
    _id_type$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SocketOption> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'name()Ljava/lang/String;') {
        final $r = _$impls[$p]!.name();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'type()Ljava/lang/Class;') {
        final $r = _$impls[$p]!.type$1();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn<$T extends jni$_.JObject?>(
    jni$_.JImplementer implementer,
    $SocketOption<$T> $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.net.SocketOption', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SocketOption.implement($SocketOption<$T> $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SocketOption<$T>.fromReference($impl.T, $i.implementReference());
  }
}

abstract base mixin class $SocketOption<$T extends jni$_.JObject?> {
  factory $SocketOption({
    required jni$_.JObjType<$T> T,
    required jni$_.JString? Function() name,
    required jni$_.JObject? Function() type$1,
  }) = _$SocketOption<$T>;

  jni$_.JObjType<$T> get T;

  jni$_.JString? name();
  jni$_.JObject? type$1();
}

final class _$SocketOption<$T extends jni$_.JObject?> with $SocketOption<$T> {
  _$SocketOption({
    required this.T,
    required jni$_.JString? Function() name,
    required jni$_.JObject? Function() type$1,
  }) : _name = name,
       _type$1 = type$1;

  @core$_.override
  final jni$_.JObjType<$T> T;

  final jni$_.JString? Function() _name;
  final jni$_.JObject? Function() _type$1;

  jni$_.JString? name() => _name();

  jni$_.JObject? type$1() => _type$1();
}

final class $SocketOption$NullableType<$T extends jni$_.JObject?>
    extends jni$_.JObjType<SocketOption<$T>?> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $SocketOption$NullableType(this.T);

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketOption;';

  @jni$_.internal
  @core$_.override
  SocketOption<$T>? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SocketOption<$T>.fromReference(T, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketOption<$T>?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($SocketOption$NullableType, T);

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketOption$NullableType<$T>) &&
      other is $SocketOption$NullableType<$T> &&
      T == other.T;
}

final class $SocketOption$Type<$T extends jni$_.JObject?>
    extends jni$_.JObjType<SocketOption<$T>> {
  @jni$_.internal
  final jni$_.JObjType<$T> T;

  @jni$_.internal
  const $SocketOption$Type(this.T);

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketOption;';

  @jni$_.internal
  @core$_.override
  SocketOption<$T> fromReference(jni$_.JReference reference) =>
      SocketOption<$T>.fromReference(T, reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketOption<$T>?> get nullableType =>
      $SocketOption$NullableType<$T>(T);

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => Object.hash($SocketOption$Type, T);

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketOption$Type<$T>) &&
      other is $SocketOption$Type<$T> &&
      T == other.T;
}

/// from: `java.net.URISyntaxException`
class URISyntaxException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<URISyntaxException> $type;

  @jni$_.internal
  URISyntaxException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/URISyntaxException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $URISyntaxException$NullableType();
  static const type = $URISyntaxException$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;I)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URISyntaxException(
    jni$_.JString? string,
    jni$_.JString? string1,
    int i,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return URISyntaxException.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URISyntaxException.new$1(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return URISyntaxException.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_getInput = _class.instanceMethodId(
    r'getInput',
    r'()Ljava/lang/String;',
  );

  static final _getInput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getInput()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getInput() => _getInput(
    reference.pointer,
    _id_getInput as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getReason = _class.instanceMethodId(
    r'getReason',
    r'()Ljava/lang/String;',
  );

  static final _getReason =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getReason()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getReason() => _getReason(
    reference.pointer,
    _id_getReason as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getIndex = _class.instanceMethodId(r'getIndex', r'()I');

  static final _getIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getIndex()`
  int getIndex() =>
      _getIndex(reference.pointer, _id_getIndex as jni$_.JMethodIDPtr).integer;

  static final _id_getMessage = _class.instanceMethodId(
    r'getMessage',
    r'()Ljava/lang/String;',
  );

  static final _getMessage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getMessage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getMessage() => _getMessage(
    reference.pointer,
    _id_getMessage as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $URISyntaxException$NullableType
    extends jni$_.JObjType<URISyntaxException?> {
  @jni$_.internal
  const $URISyntaxException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URISyntaxException;';

  @jni$_.internal
  @core$_.override
  URISyntaxException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : URISyntaxException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URISyntaxException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URISyntaxException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URISyntaxException$NullableType) &&
      other is $URISyntaxException$NullableType;
}

final class $URISyntaxException$Type
    extends jni$_.JObjType<URISyntaxException> {
  @jni$_.internal
  const $URISyntaxException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URISyntaxException;';

  @jni$_.internal
  @core$_.override
  URISyntaxException fromReference(jni$_.JReference reference) =>
      URISyntaxException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URISyntaxException?> get nullableType =>
      const $URISyntaxException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URISyntaxException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URISyntaxException$Type) &&
      other is $URISyntaxException$Type;
}

/// from: `java.net.ProxySelector`
class ProxySelector extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ProxySelector> $type;

  @jni$_.internal
  ProxySelector.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/ProxySelector');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ProxySelector$NullableType();
  static const type = $ProxySelector$Type();
  static final _id_getDefault = _class.staticMethodId(
    r'getDefault',
    r'()Ljava/net/ProxySelector;',
  );

  static final _getDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.net.ProxySelector getDefault()`
  /// The returned object must be released after use, by calling the [release] method.
  static ProxySelector? getDefault() => _getDefault(
    _class.reference.pointer,
    _id_getDefault as jni$_.JMethodIDPtr,
  ).object<ProxySelector?>(const $ProxySelector$NullableType());

  static final _id_setDefault = _class.staticMethodId(
    r'setDefault',
    r'(Ljava/net/ProxySelector;)V',
  );

  static final _setDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setDefault(java.net.ProxySelector proxySelector)`
  static void setDefault(ProxySelector? proxySelector) {
    final _$proxySelector = proxySelector?.reference ?? jni$_.jNullReference;
    _setDefault(
      _class.reference.pointer,
      _id_setDefault as jni$_.JMethodIDPtr,
      _$proxySelector.pointer,
    ).check();
  }

  static final _id_select = _class.instanceMethodId(
    r'select',
    r'(Ljava/net/URI;)Ljava/util/List;',
  );

  static final _select =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.util.List<java.net.Proxy> select(java.net.URI uRI)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<Proxy?>? select(URI? uRI) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    return _select(
      reference.pointer,
      _id_select as jni$_.JMethodIDPtr,
      _$uRI.pointer,
    ).object<jni$_.JList<Proxy?>?>(
      const jni$_.JListNullableType<Proxy?>($Proxy$NullableType()),
    );
  }

  static final _id_connectFailed = _class.instanceMethodId(
    r'connectFailed',
    r'(Ljava/net/URI;Ljava/net/SocketAddress;Ljava/io/IOException;)V',
  );

  static final _connectFailed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void connectFailed(java.net.URI uRI, java.net.SocketAddress socketAddress, java.io.IOException iOException)`
  void connectFailed(
    URI? uRI,
    SocketAddress? socketAddress,
    IOException? iOException,
  ) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    final _$iOException = iOException?.reference ?? jni$_.jNullReference;
    _connectFailed(
      reference.pointer,
      _id_connectFailed as jni$_.JMethodIDPtr,
      _$uRI.pointer,
      _$socketAddress.pointer,
      _$iOException.pointer,
    ).check();
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/net/InetSocketAddress;)Ljava/net/ProxySelector;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.ProxySelector of(java.net.InetSocketAddress inetSocketAddress)`
  /// The returned object must be released after use, by calling the [release] method.
  static ProxySelector? of(InetSocketAddress? inetSocketAddress) {
    final _$inetSocketAddress =
        inetSocketAddress?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$inetSocketAddress.pointer,
    ).object<ProxySelector?>(const $ProxySelector$NullableType());
  }
}

final class $ProxySelector$NullableType extends jni$_.JObjType<ProxySelector?> {
  @jni$_.internal
  const $ProxySelector$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ProxySelector;';

  @jni$_.internal
  @core$_.override
  ProxySelector? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ProxySelector.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ProxySelector?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ProxySelector$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ProxySelector$NullableType) &&
      other is $ProxySelector$NullableType;
}

final class $ProxySelector$Type extends jni$_.JObjType<ProxySelector> {
  @jni$_.internal
  const $ProxySelector$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ProxySelector;';

  @jni$_.internal
  @core$_.override
  ProxySelector fromReference(jni$_.JReference reference) =>
      ProxySelector.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ProxySelector?> get nullableType =>
      const $ProxySelector$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ProxySelector$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ProxySelector$Type) &&
      other is $ProxySelector$Type;
}

/// from: `java.net.CacheResponse`
class CacheResponse extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CacheResponse> $type;

  @jni$_.internal
  CacheResponse.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/CacheResponse');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CacheResponse$NullableType();
  static const type = $CacheResponse$Type();
  static final _id_getHeaders = _class.instanceMethodId(
    r'getHeaders',
    r'()Ljava/util/Map;',
  );

  static final _getHeaders =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.util.Map<java.lang.String, java.util.List<java.lang.String>> getHeaders()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>?
  getHeaders() => _getHeaders(
    reference.pointer,
    _id_getHeaders as jni$_.JMethodIDPtr,
  ).object<jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>?>(
    const jni$_.JMapNullableType<jni$_.JString?, jni$_.JList<jni$_.JString?>?>(
      jni$_.JStringNullableType(),
      jni$_.JListNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
    ),
  );

  static final _id_getBody = _class.instanceMethodId(
    r'getBody',
    r'()Ljava/io/InputStream;',
  );

  static final _getBody =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.io.InputStream getBody()`
  /// The returned object must be released after use, by calling the [release] method.
  InputStream? getBody() => _getBody(
    reference.pointer,
    _id_getBody as jni$_.JMethodIDPtr,
  ).object<InputStream?>(const $InputStream$NullableType());
}

final class $CacheResponse$NullableType extends jni$_.JObjType<CacheResponse?> {
  @jni$_.internal
  const $CacheResponse$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/CacheResponse;';

  @jni$_.internal
  @core$_.override
  CacheResponse? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CacheResponse.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CacheResponse?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CacheResponse$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CacheResponse$NullableType) &&
      other is $CacheResponse$NullableType;
}

final class $CacheResponse$Type extends jni$_.JObjType<CacheResponse> {
  @jni$_.internal
  const $CacheResponse$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/CacheResponse;';

  @jni$_.internal
  @core$_.override
  CacheResponse fromReference(jni$_.JReference reference) =>
      CacheResponse.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CacheResponse?> get nullableType =>
      const $CacheResponse$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CacheResponse$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CacheResponse$Type) &&
      other is $CacheResponse$Type;
}

/// from: `java.net.SocketPermission`
class SocketPermission extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SocketPermission> $type;

  @jni$_.internal
  SocketPermission.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/SocketPermission');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SocketPermission$NullableType();
  static const type = $SocketPermission$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SocketPermission(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return SocketPermission.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_implies = _class.instanceMethodId(
    r'implies',
    r'(Ljava/security/Permission;)Z',
  );

  static final _implies =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean implies(java.security.Permission permission)`
  bool implies(jni$_.JObject? permission) {
    final _$permission = permission?.reference ?? jni$_.jNullReference;
    return _implies(
      reference.pointer,
      _id_implies as jni$_.JMethodIDPtr,
      _$permission.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getActions = _class.instanceMethodId(
    r'getActions',
    r'()Ljava/lang/String;',
  );

  static final _getActions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getActions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getActions() => _getActions(
    reference.pointer,
    _id_getActions as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_newPermissionCollection = _class.instanceMethodId(
    r'newPermissionCollection',
    r'()Ljava/security/PermissionCollection;',
  );

  static final _newPermissionCollection =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.security.PermissionCollection newPermissionCollection()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? newPermissionCollection() => _newPermissionCollection(
    reference.pointer,
    _id_newPermissionCollection as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
}

final class $SocketPermission$NullableType
    extends jni$_.JObjType<SocketPermission?> {
  @jni$_.internal
  const $SocketPermission$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketPermission;';

  @jni$_.internal
  @core$_.override
  SocketPermission? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SocketPermission.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketPermission?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SocketPermission$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketPermission$NullableType) &&
      other is $SocketPermission$NullableType;
}

final class $SocketPermission$Type extends jni$_.JObjType<SocketPermission> {
  @jni$_.internal
  const $SocketPermission$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketPermission;';

  @jni$_.internal
  @core$_.override
  SocketPermission fromReference(jni$_.JReference reference) =>
      SocketPermission.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketPermission?> get nullableType =>
      const $SocketPermission$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SocketPermission$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketPermission$Type) &&
      other is $SocketPermission$Type;
}

/// from: `java.net.URI`
class URI extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<URI> $type;

  @jni$_.internal
  URI.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/URI');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $URI$NullableType();
  static const type = $URI$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URI(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return URI.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, int i, java.lang.String string3, java.lang.String string4, java.lang.String string5)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URI.new$1(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
    int i,
    jni$_.JString? string3,
    jni$_.JString? string4,
    jni$_.JString? string5,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    final _$string4 = string4?.reference ?? jni$_.jNullReference;
    final _$string5 = string5?.reference ?? jni$_.jNullReference;
    return URI.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
        _$string2.pointer,
        i,
        _$string3.pointer,
        _$string4.pointer,
        _$string5.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URI.new$2(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JString? string3,
    jni$_.JString? string4,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    final _$string4 = string4?.reference ?? jni$_.jNullReference;
    return URI.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
        _$string2.pointer,
        _$string3.pointer,
        _$string4.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URI.new$3(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JString? string3,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    return URI.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
        _$string2.pointer,
        _$string3.pointer,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URI.new$4(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    return URI.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
        _$string2.pointer,
      ).reference,
    );
  }

  static final _id_create = _class.staticMethodId(
    r'create',
    r'(Ljava/lang/String;)Ljava/net/URI;',
  );

  static final _create =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.URI create(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static URI? create(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _create(
      _class.reference.pointer,
      _id_create as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<URI?>(const $URI$NullableType());
  }

  static final _id_parseServerAuthority = _class.instanceMethodId(
    r'parseServerAuthority',
    r'()Ljava/net/URI;',
  );

  static final _parseServerAuthority =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URI parseServerAuthority()`
  /// The returned object must be released after use, by calling the [release] method.
  URI? parseServerAuthority() => _parseServerAuthority(
    reference.pointer,
    _id_parseServerAuthority as jni$_.JMethodIDPtr,
  ).object<URI?>(const $URI$NullableType());

  static final _id_normalize = _class.instanceMethodId(
    r'normalize',
    r'()Ljava/net/URI;',
  );

  static final _normalize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URI normalize()`
  /// The returned object must be released after use, by calling the [release] method.
  URI? normalize() => _normalize(
    reference.pointer,
    _id_normalize as jni$_.JMethodIDPtr,
  ).object<URI?>(const $URI$NullableType());

  static final _id_resolve = _class.instanceMethodId(
    r'resolve',
    r'(Ljava/net/URI;)Ljava/net/URI;',
  );

  static final _resolve =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.net.URI resolve(java.net.URI uRI)`
  /// The returned object must be released after use, by calling the [release] method.
  URI? resolve(URI? uRI) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    return _resolve(
      reference.pointer,
      _id_resolve as jni$_.JMethodIDPtr,
      _$uRI.pointer,
    ).object<URI?>(const $URI$NullableType());
  }

  static final _id_resolve$1 = _class.instanceMethodId(
    r'resolve',
    r'(Ljava/lang/String;)Ljava/net/URI;',
  );

  static final _resolve$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.net.URI resolve(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  URI? resolve$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _resolve$1(
      reference.pointer,
      _id_resolve$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<URI?>(const $URI$NullableType());
  }

  static final _id_relativize = _class.instanceMethodId(
    r'relativize',
    r'(Ljava/net/URI;)Ljava/net/URI;',
  );

  static final _relativize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.net.URI relativize(java.net.URI uRI)`
  /// The returned object must be released after use, by calling the [release] method.
  URI? relativize(URI? uRI) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    return _relativize(
      reference.pointer,
      _id_relativize as jni$_.JMethodIDPtr,
      _$uRI.pointer,
    ).object<URI?>(const $URI$NullableType());
  }

  static final _id_toURL = _class.instanceMethodId(
    r'toURL',
    r'()Ljava/net/URL;',
  );

  static final _toURL =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URL toURL()`
  /// The returned object must be released after use, by calling the [release] method.
  URL? toURL() => _toURL(
    reference.pointer,
    _id_toURL as jni$_.JMethodIDPtr,
  ).object<URL?>(const $URL$NullableType());

  static final _id_getScheme = _class.instanceMethodId(
    r'getScheme',
    r'()Ljava/lang/String;',
  );

  static final _getScheme =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getScheme()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getScheme() => _getScheme(
    reference.pointer,
    _id_getScheme as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_isAbsolute = _class.instanceMethodId(r'isAbsolute', r'()Z');

  static final _isAbsolute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isAbsolute()`
  bool isAbsolute() =>
      _isAbsolute(
        reference.pointer,
        _id_isAbsolute as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isOpaque = _class.instanceMethodId(r'isOpaque', r'()Z');

  static final _isOpaque =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isOpaque()`
  bool isOpaque() =>
      _isOpaque(reference.pointer, _id_isOpaque as jni$_.JMethodIDPtr).boolean;

  static final _id_getRawSchemeSpecificPart = _class.instanceMethodId(
    r'getRawSchemeSpecificPart',
    r'()Ljava/lang/String;',
  );

  static final _getRawSchemeSpecificPart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getRawSchemeSpecificPart()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRawSchemeSpecificPart() => _getRawSchemeSpecificPart(
    reference.pointer,
    _id_getRawSchemeSpecificPart as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getSchemeSpecificPart = _class.instanceMethodId(
    r'getSchemeSpecificPart',
    r'()Ljava/lang/String;',
  );

  static final _getSchemeSpecificPart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getSchemeSpecificPart()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getSchemeSpecificPart() => _getSchemeSpecificPart(
    reference.pointer,
    _id_getSchemeSpecificPart as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getRawAuthority = _class.instanceMethodId(
    r'getRawAuthority',
    r'()Ljava/lang/String;',
  );

  static final _getRawAuthority =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getRawAuthority()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRawAuthority() => _getRawAuthority(
    reference.pointer,
    _id_getRawAuthority as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getAuthority = _class.instanceMethodId(
    r'getAuthority',
    r'()Ljava/lang/String;',
  );

  static final _getAuthority =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getAuthority()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAuthority() => _getAuthority(
    reference.pointer,
    _id_getAuthority as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getRawUserInfo = _class.instanceMethodId(
    r'getRawUserInfo',
    r'()Ljava/lang/String;',
  );

  static final _getRawUserInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getRawUserInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRawUserInfo() => _getRawUserInfo(
    reference.pointer,
    _id_getRawUserInfo as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getUserInfo = _class.instanceMethodId(
    r'getUserInfo',
    r'()Ljava/lang/String;',
  );

  static final _getUserInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getUserInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getUserInfo() => _getUserInfo(
    reference.pointer,
    _id_getUserInfo as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getHost = _class.instanceMethodId(
    r'getHost',
    r'()Ljava/lang/String;',
  );

  static final _getHost =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getHost()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHost() => _getHost(
    reference.pointer,
    _id_getHost as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getPort = _class.instanceMethodId(r'getPort', r'()I');

  static final _getPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getPort()`
  int getPort() =>
      _getPort(reference.pointer, _id_getPort as jni$_.JMethodIDPtr).integer;

  static final _id_getRawPath = _class.instanceMethodId(
    r'getRawPath',
    r'()Ljava/lang/String;',
  );

  static final _getRawPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getRawPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRawPath() => _getRawPath(
    reference.pointer,
    _id_getRawPath as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getPath = _class.instanceMethodId(
    r'getPath',
    r'()Ljava/lang/String;',
  );

  static final _getPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPath() => _getPath(
    reference.pointer,
    _id_getPath as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getRawQuery = _class.instanceMethodId(
    r'getRawQuery',
    r'()Ljava/lang/String;',
  );

  static final _getRawQuery =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getRawQuery()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRawQuery() => _getRawQuery(
    reference.pointer,
    _id_getRawQuery as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getQuery = _class.instanceMethodId(
    r'getQuery',
    r'()Ljava/lang/String;',
  );

  static final _getQuery =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getQuery()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getQuery() => _getQuery(
    reference.pointer,
    _id_getQuery as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getRawFragment = _class.instanceMethodId(
    r'getRawFragment',
    r'()Ljava/lang/String;',
  );

  static final _getRawFragment =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getRawFragment()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRawFragment() => _getRawFragment(
    reference.pointer,
    _id_getRawFragment as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getFragment = _class.instanceMethodId(
    r'getFragment',
    r'()Ljava/lang/String;',
  );

  static final _getFragment =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getFragment()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getFragment() => _getFragment(
    reference.pointer,
    _id_getFragment as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/net/URI;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.net.URI uRI)`
  int compareTo(URI? uRI) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$uRI.pointer,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_toASCIIString = _class.instanceMethodId(
    r'toASCIIString',
    r'()Ljava/lang/String;',
  );

  static final _toASCIIString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toASCIIString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toASCIIString() => _toASCIIString(
    reference.pointer,
    _id_toASCIIString as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  bool operator <(URI? uRI) => compareTo(uRI) < 0;

  bool operator <=(URI? uRI) => compareTo(uRI) <= 0;

  bool operator >(URI? uRI) => compareTo(uRI) > 0;

  bool operator >=(URI? uRI) => compareTo(uRI) >= 0;
}

final class $URI$NullableType extends jni$_.JObjType<URI?> {
  @jni$_.internal
  const $URI$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URI;';

  @jni$_.internal
  @core$_.override
  URI? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : URI.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URI?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URI$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URI$NullableType) && other is $URI$NullableType;
}

final class $URI$Type extends jni$_.JObjType<URI> {
  @jni$_.internal
  const $URI$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URI;';

  @jni$_.internal
  @core$_.override
  URI fromReference(jni$_.JReference reference) => URI.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URI?> get nullableType => const $URI$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URI$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URI$Type) && other is $URI$Type;
}

/// from: `java.net.HttpRetryException`
class HttpRetryException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<HttpRetryException> $type;

  @jni$_.internal
  HttpRetryException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/HttpRetryException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $HttpRetryException$NullableType();
  static const type = $HttpRetryException$Type();
  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;I)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HttpRetryException.new$4(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return HttpRetryException.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(
    r'(Ljava/lang/String;ILjava/lang/String;)V',
  );

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory HttpRetryException.new$5(
    jni$_.JString? string,
    int i,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return HttpRetryException.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_responseCode = _class.instanceMethodId(
    r'responseCode',
    r'()I',
  );

  static final _responseCode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int responseCode()`
  int responseCode() =>
      _responseCode(
        reference.pointer,
        _id_responseCode as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getReason = _class.instanceMethodId(
    r'getReason',
    r'()Ljava/lang/String;',
  );

  static final _getReason =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getReason()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getReason() => _getReason(
    reference.pointer,
    _id_getReason as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getLocation = _class.instanceMethodId(
    r'getLocation',
    r'()Ljava/lang/String;',
  );

  static final _getLocation =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getLocation()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getLocation() => _getLocation(
    reference.pointer,
    _id_getLocation as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $HttpRetryException$NullableType
    extends jni$_.JObjType<HttpRetryException?> {
  @jni$_.internal
  const $HttpRetryException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/HttpRetryException;';

  @jni$_.internal
  @core$_.override
  HttpRetryException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : HttpRetryException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HttpRetryException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($HttpRetryException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($HttpRetryException$NullableType) &&
      other is $HttpRetryException$NullableType;
}

final class $HttpRetryException$Type
    extends jni$_.JObjType<HttpRetryException> {
  @jni$_.internal
  const $HttpRetryException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/HttpRetryException;';

  @jni$_.internal
  @core$_.override
  HttpRetryException fromReference(jni$_.JReference reference) =>
      HttpRetryException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<HttpRetryException?> get nullableType =>
      const $HttpRetryException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($HttpRetryException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($HttpRetryException$Type) &&
      other is $HttpRetryException$Type;
}

/// from: `java.net.CookieStore`
class CookieStore extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CookieStore> $type;

  @jni$_.internal
  CookieStore.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/CookieStore');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CookieStore$NullableType();
  static const type = $CookieStore$Type();
  static final _id_add = _class.instanceMethodId(
    r'add',
    r'(Ljava/net/URI;Ljava/net/HttpCookie;)V',
  );

  static final _add =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void add(java.net.URI uRI, java.net.HttpCookie httpCookie)`
  void add(URI? uRI, HttpCookie? httpCookie) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    final _$httpCookie = httpCookie?.reference ?? jni$_.jNullReference;
    _add(
      reference.pointer,
      _id_add as jni$_.JMethodIDPtr,
      _$uRI.pointer,
      _$httpCookie.pointer,
    ).check();
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/net/URI;)Ljava/util/List;',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.util.List<java.net.HttpCookie> get(java.net.URI uRI)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<HttpCookie?>? get(URI? uRI) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$uRI.pointer,
    ).object<jni$_.JList<HttpCookie?>?>(
      const jni$_.JListNullableType<HttpCookie?>($HttpCookie$NullableType()),
    );
  }

  static final _id_getCookies = _class.instanceMethodId(
    r'getCookies',
    r'()Ljava/util/List;',
  );

  static final _getCookies =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.util.List<java.net.HttpCookie> getCookies()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<HttpCookie?>? getCookies() => _getCookies(
    reference.pointer,
    _id_getCookies as jni$_.JMethodIDPtr,
  ).object<jni$_.JList<HttpCookie?>?>(
    const jni$_.JListNullableType<HttpCookie?>($HttpCookie$NullableType()),
  );

  static final _id_getURIs = _class.instanceMethodId(
    r'getURIs',
    r'()Ljava/util/List;',
  );

  static final _getURIs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.util.List<java.net.URI> getURIs()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<URI?>? getURIs() => _getURIs(
    reference.pointer,
    _id_getURIs as jni$_.JMethodIDPtr,
  ).object<jni$_.JList<URI?>?>(
    const jni$_.JListNullableType<URI?>($URI$NullableType()),
  );

  static final _id_remove = _class.instanceMethodId(
    r'remove',
    r'(Ljava/net/URI;Ljava/net/HttpCookie;)Z',
  );

  static final _remove =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean remove(java.net.URI uRI, java.net.HttpCookie httpCookie)`
  bool remove(URI? uRI, HttpCookie? httpCookie) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    final _$httpCookie = httpCookie?.reference ?? jni$_.jNullReference;
    return _remove(
      reference.pointer,
      _id_remove as jni$_.JMethodIDPtr,
      _$uRI.pointer,
      _$httpCookie.pointer,
    ).boolean;
  }

  static final _id_removeAll = _class.instanceMethodId(r'removeAll', r'()Z');

  static final _removeAll =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract boolean removeAll()`
  bool removeAll() =>
      _removeAll(
        reference.pointer,
        _id_removeAll as jni$_.JMethodIDPtr,
      ).boolean;

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $CookieStore> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'add(Ljava/net/URI;Ljava/net/HttpCookie;)V') {
        _$impls[$p]!.add(
          $a![0]?.as(const $URI$Type(), releaseOriginal: true),
          $a![1]?.as(const $HttpCookie$Type(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'get(Ljava/net/URI;)Ljava/util/List;') {
        final $r = _$impls[$p]!.get(
          $a![0]?.as(const $URI$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'getCookies()Ljava/util/List;') {
        final $r = _$impls[$p]!.getCookies();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'getURIs()Ljava/util/List;') {
        final $r = _$impls[$p]!.getURIs();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'remove(Ljava/net/URI;Ljava/net/HttpCookie;)Z') {
        final $r = _$impls[$p]!.remove(
          $a![0]?.as(const $URI$Type(), releaseOriginal: true),
          $a![1]?.as(const $HttpCookie$Type(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'removeAll()Z') {
        final $r = _$impls[$p]!.removeAll();
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $CookieStore $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.net.CookieStore', $p, _$invokePointer, [
      if ($impl.add$async) r'add(Ljava/net/URI;Ljava/net/HttpCookie;)V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory CookieStore.implement($CookieStore $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return CookieStore.fromReference($i.implementReference());
  }
}

abstract base mixin class $CookieStore {
  factory $CookieStore({
    required void Function(URI? uRI, HttpCookie? httpCookie) add,
    bool add$async,
    required jni$_.JList<HttpCookie?>? Function(URI? uRI) get,
    required jni$_.JList<HttpCookie?>? Function() getCookies,
    required jni$_.JList<URI?>? Function() getURIs,
    required bool Function(URI? uRI, HttpCookie? httpCookie) remove,
    required bool Function() removeAll,
  }) = _$CookieStore;

  void add(URI? uRI, HttpCookie? httpCookie);
  bool get add$async => false;
  jni$_.JList<HttpCookie?>? get(URI? uRI);
  jni$_.JList<HttpCookie?>? getCookies();
  jni$_.JList<URI?>? getURIs();
  bool remove(URI? uRI, HttpCookie? httpCookie);
  bool removeAll();
}

final class _$CookieStore with $CookieStore {
  _$CookieStore({
    required void Function(URI? uRI, HttpCookie? httpCookie) add,
    this.add$async = false,
    required jni$_.JList<HttpCookie?>? Function(URI? uRI) get,
    required jni$_.JList<HttpCookie?>? Function() getCookies,
    required jni$_.JList<URI?>? Function() getURIs,
    required bool Function(URI? uRI, HttpCookie? httpCookie) remove,
    required bool Function() removeAll,
  }) : _add = add,
       _get = get,
       _getCookies = getCookies,
       _getURIs = getURIs,
       _remove = remove,
       _removeAll = removeAll;

  final void Function(URI? uRI, HttpCookie? httpCookie) _add;
  final bool add$async;
  final jni$_.JList<HttpCookie?>? Function(URI? uRI) _get;
  final jni$_.JList<HttpCookie?>? Function() _getCookies;
  final jni$_.JList<URI?>? Function() _getURIs;
  final bool Function(URI? uRI, HttpCookie? httpCookie) _remove;
  final bool Function() _removeAll;

  void add(URI? uRI, HttpCookie? httpCookie) => _add(uRI, httpCookie);

  jni$_.JList<HttpCookie?>? get(URI? uRI) => _get(uRI);

  jni$_.JList<HttpCookie?>? getCookies() => _getCookies();

  jni$_.JList<URI?>? getURIs() => _getURIs();

  bool remove(URI? uRI, HttpCookie? httpCookie) => _remove(uRI, httpCookie);

  bool removeAll() => _removeAll();
}

final class $CookieStore$NullableType extends jni$_.JObjType<CookieStore?> {
  @jni$_.internal
  const $CookieStore$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/CookieStore;';

  @jni$_.internal
  @core$_.override
  CookieStore? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CookieStore.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CookieStore?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CookieStore$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CookieStore$NullableType) &&
      other is $CookieStore$NullableType;
}

final class $CookieStore$Type extends jni$_.JObjType<CookieStore> {
  @jni$_.internal
  const $CookieStore$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/CookieStore;';

  @jni$_.internal
  @core$_.override
  CookieStore fromReference(jni$_.JReference reference) =>
      CookieStore.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CookieStore?> get nullableType =>
      const $CookieStore$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CookieStore$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CookieStore$Type) && other is $CookieStore$Type;
}

/// from: `java.net.SecureCacheResponse`
class SecureCacheResponse extends CacheResponse {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SecureCacheResponse> $type;

  @jni$_.internal
  SecureCacheResponse.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/SecureCacheResponse');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SecureCacheResponse$NullableType();
  static const type = $SecureCacheResponse$Type();
  static final _id_getCipherSuite = _class.instanceMethodId(
    r'getCipherSuite',
    r'()Ljava/lang/String;',
  );

  static final _getCipherSuite =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String getCipherSuite()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCipherSuite() => _getCipherSuite(
    reference.pointer,
    _id_getCipherSuite as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getLocalCertificateChain = _class.instanceMethodId(
    r'getLocalCertificateChain',
    r'()Ljava/util/List;',
  );

  static final _getLocalCertificateChain =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.util.List<java.security.cert.Certificate> getLocalCertificateChain()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getLocalCertificateChain() =>
      _getLocalCertificateChain(
        reference.pointer,
        _id_getLocalCertificateChain as jni$_.JMethodIDPtr,
      ).object<jni$_.JList<jni$_.JObject?>?>(
        const jni$_.JListNullableType<jni$_.JObject?>(
          jni$_.JObjectNullableType(),
        ),
      );

  static final _id_getServerCertificateChain = _class.instanceMethodId(
    r'getServerCertificateChain',
    r'()Ljava/util/List;',
  );

  static final _getServerCertificateChain =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.util.List<java.security.cert.Certificate> getServerCertificateChain()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getServerCertificateChain() =>
      _getServerCertificateChain(
        reference.pointer,
        _id_getServerCertificateChain as jni$_.JMethodIDPtr,
      ).object<jni$_.JList<jni$_.JObject?>?>(
        const jni$_.JListNullableType<jni$_.JObject?>(
          jni$_.JObjectNullableType(),
        ),
      );

  static final _id_getPeerPrincipal = _class.instanceMethodId(
    r'getPeerPrincipal',
    r'()Ljava/security/Principal;',
  );

  static final _getPeerPrincipal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.security.Principal getPeerPrincipal()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getPeerPrincipal() => _getPeerPrincipal(
    reference.pointer,
    _id_getPeerPrincipal as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getLocalPrincipal = _class.instanceMethodId(
    r'getLocalPrincipal',
    r'()Ljava/security/Principal;',
  );

  static final _getLocalPrincipal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.security.Principal getLocalPrincipal()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getLocalPrincipal() => _getLocalPrincipal(
    reference.pointer,
    _id_getLocalPrincipal as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getSSLSession = _class.instanceMethodId(
    r'getSSLSession',
    r'()Ljava/util/Optional;',
  );

  static final _getSSLSession =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Optional<javax.net.ssl.SSLSession> getSSLSession()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSSLSession() => _getSSLSession(
    reference.pointer,
    _id_getSSLSession as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
}

final class $SecureCacheResponse$NullableType
    extends jni$_.JObjType<SecureCacheResponse?> {
  @jni$_.internal
  const $SecureCacheResponse$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SecureCacheResponse;';

  @jni$_.internal
  @core$_.override
  SecureCacheResponse? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SecureCacheResponse.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $CacheResponse$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SecureCacheResponse?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SecureCacheResponse$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SecureCacheResponse$NullableType) &&
      other is $SecureCacheResponse$NullableType;
}

final class $SecureCacheResponse$Type
    extends jni$_.JObjType<SecureCacheResponse> {
  @jni$_.internal
  const $SecureCacheResponse$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SecureCacheResponse;';

  @jni$_.internal
  @core$_.override
  SecureCacheResponse fromReference(jni$_.JReference reference) =>
      SecureCacheResponse.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $CacheResponse$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SecureCacheResponse?> get nullableType =>
      const $SecureCacheResponse$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SecureCacheResponse$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SecureCacheResponse$Type) &&
      other is $SecureCacheResponse$Type;
}

/// from: `java.net.Authenticator`
class Authenticator extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Authenticator> $type;

  @jni$_.internal
  Authenticator.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/Authenticator');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Authenticator$NullableType();
  static const type = $Authenticator$Type();
  static final _id_setDefault = _class.staticMethodId(
    r'setDefault',
    r'(Ljava/net/Authenticator;)V',
  );

  static final _setDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setDefault(java.net.Authenticator authenticator)`
  static void setDefault(Authenticator? authenticator) {
    final _$authenticator = authenticator?.reference ?? jni$_.jNullReference;
    _setDefault(
      _class.reference.pointer,
      _id_setDefault as jni$_.JMethodIDPtr,
      _$authenticator.pointer,
    ).check();
  }

  static final _id_getDefault = _class.staticMethodId(
    r'getDefault',
    r'()Ljava/net/Authenticator;',
  );

  static final _getDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.net.Authenticator getDefault()`
  /// The returned object must be released after use, by calling the [release] method.
  static Authenticator? getDefault() => _getDefault(
    _class.reference.pointer,
    _id_getDefault as jni$_.JMethodIDPtr,
  ).object<Authenticator?>(const $Authenticator$NullableType());

  static final _id_requestPasswordAuthentication = _class.staticMethodId(
    r'requestPasswordAuthentication',
    r'(Ljava/net/InetAddress;ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/net/PasswordAuthentication;',
  );

  static final _requestPasswordAuthentication =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.PasswordAuthentication requestPasswordAuthentication(java.net.InetAddress inetAddress, int i, java.lang.String string, java.lang.String string1, java.lang.String string2)`
  /// The returned object must be released after use, by calling the [release] method.
  static PasswordAuthentication? requestPasswordAuthentication(
    InetAddress? inetAddress,
    int i,
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
  ) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    return _requestPasswordAuthentication(
      _class.reference.pointer,
      _id_requestPasswordAuthentication as jni$_.JMethodIDPtr,
      _$inetAddress.pointer,
      i,
      _$string.pointer,
      _$string1.pointer,
      _$string2.pointer,
    ).object<PasswordAuthentication?>(
      const $PasswordAuthentication$NullableType(),
    );
  }

  static final _id_requestPasswordAuthentication$1 = _class.staticMethodId(
    r'requestPasswordAuthentication',
    r'(Ljava/lang/String;Ljava/net/InetAddress;ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/net/PasswordAuthentication;',
  );

  static final _requestPasswordAuthentication$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.PasswordAuthentication requestPasswordAuthentication(java.lang.String string, java.net.InetAddress inetAddress, int i, java.lang.String string1, java.lang.String string2, java.lang.String string3)`
  /// The returned object must be released after use, by calling the [release] method.
  static PasswordAuthentication? requestPasswordAuthentication$1(
    jni$_.JString? string,
    InetAddress? inetAddress,
    int i,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JString? string3,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    return _requestPasswordAuthentication$1(
      _class.reference.pointer,
      _id_requestPasswordAuthentication$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$inetAddress.pointer,
      i,
      _$string1.pointer,
      _$string2.pointer,
      _$string3.pointer,
    ).object<PasswordAuthentication?>(
      const $PasswordAuthentication$NullableType(),
    );
  }

  static final _id_requestPasswordAuthentication$2 = _class.staticMethodId(
    r'requestPasswordAuthentication',
    r'(Ljava/lang/String;Ljava/net/InetAddress;ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/net/URL;Ljava/net/Authenticator$RequestorType;)Ljava/net/PasswordAuthentication;',
  );

  static final _requestPasswordAuthentication$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.PasswordAuthentication requestPasswordAuthentication(java.lang.String string, java.net.InetAddress inetAddress, int i, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.net.URL uRL, java.net.Authenticator$RequestorType requestorType)`
  /// The returned object must be released after use, by calling the [release] method.
  static PasswordAuthentication? requestPasswordAuthentication$2(
    jni$_.JString? string,
    InetAddress? inetAddress,
    int i,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JString? string3,
    URL? uRL,
    Authenticator$RequestorType? requestorType,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    final _$uRL = uRL?.reference ?? jni$_.jNullReference;
    final _$requestorType = requestorType?.reference ?? jni$_.jNullReference;
    return _requestPasswordAuthentication$2(
      _class.reference.pointer,
      _id_requestPasswordAuthentication$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$inetAddress.pointer,
      i,
      _$string1.pointer,
      _$string2.pointer,
      _$string3.pointer,
      _$uRL.pointer,
      _$requestorType.pointer,
    ).object<PasswordAuthentication?>(
      const $PasswordAuthentication$NullableType(),
    );
  }

  static final _id_requestPasswordAuthentication$3 = _class.staticMethodId(
    r'requestPasswordAuthentication',
    r'(Ljava/net/Authenticator;Ljava/lang/String;Ljava/net/InetAddress;ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/net/URL;Ljava/net/Authenticator$RequestorType;)Ljava/net/PasswordAuthentication;',
  );

  static final _requestPasswordAuthentication$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.PasswordAuthentication requestPasswordAuthentication(java.net.Authenticator authenticator, java.lang.String string, java.net.InetAddress inetAddress, int i, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.net.URL uRL, java.net.Authenticator$RequestorType requestorType)`
  /// The returned object must be released after use, by calling the [release] method.
  static PasswordAuthentication? requestPasswordAuthentication$3(
    Authenticator? authenticator,
    jni$_.JString? string,
    InetAddress? inetAddress,
    int i,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JString? string3,
    URL? uRL,
    Authenticator$RequestorType? requestorType,
  ) {
    final _$authenticator = authenticator?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    final _$uRL = uRL?.reference ?? jni$_.jNullReference;
    final _$requestorType = requestorType?.reference ?? jni$_.jNullReference;
    return _requestPasswordAuthentication$3(
      _class.reference.pointer,
      _id_requestPasswordAuthentication$3 as jni$_.JMethodIDPtr,
      _$authenticator.pointer,
      _$string.pointer,
      _$inetAddress.pointer,
      i,
      _$string1.pointer,
      _$string2.pointer,
      _$string3.pointer,
      _$uRL.pointer,
      _$requestorType.pointer,
    ).object<PasswordAuthentication?>(
      const $PasswordAuthentication$NullableType(),
    );
  }

  static final _id_requestPasswordAuthenticationInstance = _class.instanceMethodId(
    r'requestPasswordAuthenticationInstance',
    r'(Ljava/lang/String;Ljava/net/InetAddress;ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/net/URL;Ljava/net/Authenticator$RequestorType;)Ljava/net/PasswordAuthentication;',
  );

  static final _requestPasswordAuthenticationInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.net.PasswordAuthentication requestPasswordAuthenticationInstance(java.lang.String string, java.net.InetAddress inetAddress, int i, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.net.URL uRL, java.net.Authenticator$RequestorType requestorType)`
  /// The returned object must be released after use, by calling the [release] method.
  PasswordAuthentication? requestPasswordAuthenticationInstance(
    jni$_.JString? string,
    InetAddress? inetAddress,
    int i,
    jni$_.JString? string1,
    jni$_.JString? string2,
    jni$_.JString? string3,
    URL? uRL,
    Authenticator$RequestorType? requestorType,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$string3 = string3?.reference ?? jni$_.jNullReference;
    final _$uRL = uRL?.reference ?? jni$_.jNullReference;
    final _$requestorType = requestorType?.reference ?? jni$_.jNullReference;
    return _requestPasswordAuthenticationInstance(
      reference.pointer,
      _id_requestPasswordAuthenticationInstance as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$inetAddress.pointer,
      i,
      _$string1.pointer,
      _$string2.pointer,
      _$string3.pointer,
      _$uRL.pointer,
      _$requestorType.pointer,
    ).object<PasswordAuthentication?>(
      const $PasswordAuthentication$NullableType(),
    );
  }
}

final class $Authenticator$NullableType extends jni$_.JObjType<Authenticator?> {
  @jni$_.internal
  const $Authenticator$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Authenticator;';

  @jni$_.internal
  @core$_.override
  Authenticator? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Authenticator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Authenticator?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Authenticator$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Authenticator$NullableType) &&
      other is $Authenticator$NullableType;
}

final class $Authenticator$Type extends jni$_.JObjType<Authenticator> {
  @jni$_.internal
  const $Authenticator$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Authenticator;';

  @jni$_.internal
  @core$_.override
  Authenticator fromReference(jni$_.JReference reference) =>
      Authenticator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Authenticator?> get nullableType =>
      const $Authenticator$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Authenticator$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Authenticator$Type) &&
      other is $Authenticator$Type;
}

/// from: `java.net.URLStreamHandlerFactory`
class URLStreamHandlerFactory extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<URLStreamHandlerFactory> $type;

  @jni$_.internal
  URLStreamHandlerFactory.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/net/URLStreamHandlerFactory',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $URLStreamHandlerFactory$NullableType();
  static const type = $URLStreamHandlerFactory$Type();
  static final _id_createURLStreamHandler = _class.instanceMethodId(
    r'createURLStreamHandler',
    r'(Ljava/lang/String;)Ljava/net/URLStreamHandler;',
  );

  static final _createURLStreamHandler =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.net.URLStreamHandler createURLStreamHandler(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  URLStreamHandler? createURLStreamHandler(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createURLStreamHandler(
      reference.pointer,
      _id_createURLStreamHandler as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<URLStreamHandler?>(const $URLStreamHandler$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $URLStreamHandlerFactory> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'createURLStreamHandler(Ljava/lang/String;)Ljava/net/URLStreamHandler;') {
        final $r = _$impls[$p]!.createURLStreamHandler(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $URLStreamHandlerFactory $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'java.net.URLStreamHandlerFactory',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory URLStreamHandlerFactory.implement($URLStreamHandlerFactory $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return URLStreamHandlerFactory.fromReference($i.implementReference());
  }
}

abstract base mixin class $URLStreamHandlerFactory {
  factory $URLStreamHandlerFactory({
    required URLStreamHandler? Function(jni$_.JString? string)
    createURLStreamHandler,
  }) = _$URLStreamHandlerFactory;

  URLStreamHandler? createURLStreamHandler(jni$_.JString? string);
}

final class _$URLStreamHandlerFactory with $URLStreamHandlerFactory {
  _$URLStreamHandlerFactory({
    required URLStreamHandler? Function(jni$_.JString? string)
    createURLStreamHandler,
  }) : _createURLStreamHandler = createURLStreamHandler;

  final URLStreamHandler? Function(jni$_.JString? string)
  _createURLStreamHandler;

  URLStreamHandler? createURLStreamHandler(jni$_.JString? string) =>
      _createURLStreamHandler(string);
}

final class $URLStreamHandlerFactory$NullableType
    extends jni$_.JObjType<URLStreamHandlerFactory?> {
  @jni$_.internal
  const $URLStreamHandlerFactory$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLStreamHandlerFactory;';

  @jni$_.internal
  @core$_.override
  URLStreamHandlerFactory? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : URLStreamHandlerFactory.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URLStreamHandlerFactory?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLStreamHandlerFactory$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URLStreamHandlerFactory$NullableType) &&
      other is $URLStreamHandlerFactory$NullableType;
}

final class $URLStreamHandlerFactory$Type
    extends jni$_.JObjType<URLStreamHandlerFactory> {
  @jni$_.internal
  const $URLStreamHandlerFactory$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLStreamHandlerFactory;';

  @jni$_.internal
  @core$_.override
  URLStreamHandlerFactory fromReference(jni$_.JReference reference) =>
      URLStreamHandlerFactory.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URLStreamHandlerFactory?> get nullableType =>
      const $URLStreamHandlerFactory$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLStreamHandlerFactory$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URLStreamHandlerFactory$Type) &&
      other is $URLStreamHandlerFactory$Type;
}

/// from: `java.net.InetSocketAddress`
class InetSocketAddress extends SocketAddress {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InetSocketAddress> $type;

  @jni$_.internal
  InetSocketAddress.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/InetSocketAddress');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InetSocketAddress$NullableType();
  static const type = $InetSocketAddress$Type();
  static final _id_new$ = _class.constructorId(r'(I)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InetSocketAddress(int i) => InetSocketAddress.fromReference(
    _new$(
      _class.reference.pointer,
      _id_new$ as jni$_.JMethodIDPtr,
      i,
    ).reference,
  );

  static final _id_new$1 = _class.constructorId(r'(Ljava/net/InetAddress;I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.net.InetAddress inetAddress, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InetSocketAddress.new$1(InetAddress? inetAddress, int i) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    return InetSocketAddress.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$inetAddress.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Ljava/lang/String;I)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InetSocketAddress.new$2(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return InetSocketAddress.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
      ).reference,
    );
  }

  static final _id_createUnresolved = _class.staticMethodId(
    r'createUnresolved',
    r'(Ljava/lang/String;I)Ljava/net/InetSocketAddress;',
  );

  static final _createUnresolved =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public java.net.InetSocketAddress createUnresolved(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static InetSocketAddress? createUnresolved(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createUnresolved(
      _class.reference.pointer,
      _id_createUnresolved as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
    ).object<InetSocketAddress?>(const $InetSocketAddress$NullableType());
  }

  static final _id_getPort = _class.instanceMethodId(r'getPort', r'()I');

  static final _getPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int getPort()`
  int getPort() =>
      _getPort(reference.pointer, _id_getPort as jni$_.JMethodIDPtr).integer;

  static final _id_getAddress = _class.instanceMethodId(
    r'getAddress',
    r'()Ljava/net/InetAddress;',
  );

  static final _getAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.net.InetAddress getAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  InetAddress? getAddress() => _getAddress(
    reference.pointer,
    _id_getAddress as jni$_.JMethodIDPtr,
  ).object<InetAddress?>(const $InetAddress$NullableType());

  static final _id_getHostName = _class.instanceMethodId(
    r'getHostName',
    r'()Ljava/lang/String;',
  );

  static final _getHostName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getHostName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHostName() => _getHostName(
    reference.pointer,
    _id_getHostName as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getHostString = _class.instanceMethodId(
    r'getHostString',
    r'()Ljava/lang/String;',
  );

  static final _getHostString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String getHostString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHostString() => _getHostString(
    reference.pointer,
    _id_getHostString as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_isUnresolved = _class.instanceMethodId(
    r'isUnresolved',
    r'()Z',
  );

  static final _isUnresolved =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean isUnresolved()`
  bool isUnresolved() =>
      _isUnresolved(
        reference.pointer,
        _id_isUnresolved as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;
}

final class $InetSocketAddress$NullableType
    extends jni$_.JObjType<InetSocketAddress?> {
  @jni$_.internal
  const $InetSocketAddress$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/InetSocketAddress;';

  @jni$_.internal
  @core$_.override
  InetSocketAddress? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InetSocketAddress.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SocketAddress$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InetSocketAddress?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($InetSocketAddress$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InetSocketAddress$NullableType) &&
      other is $InetSocketAddress$NullableType;
}

final class $InetSocketAddress$Type extends jni$_.JObjType<InetSocketAddress> {
  @jni$_.internal
  const $InetSocketAddress$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/InetSocketAddress;';

  @jni$_.internal
  @core$_.override
  InetSocketAddress fromReference(jni$_.JReference reference) =>
      InetSocketAddress.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SocketAddress$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InetSocketAddress?> get nullableType =>
      const $InetSocketAddress$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($InetSocketAddress$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($InetSocketAddress$Type) &&
      other is $InetSocketAddress$Type;
}

/// from: `java.net.CookiePolicy`
class CookiePolicy extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CookiePolicy> $type;

  @jni$_.internal
  CookiePolicy.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/CookiePolicy');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CookiePolicy$NullableType();
  static const type = $CookiePolicy$Type();
  static final _id_ACCEPT_ALL = _class.staticFieldId(
    r'ACCEPT_ALL',
    r'Ljava/net/CookiePolicy;',
  );

  /// from: `static public final java.net.CookiePolicy ACCEPT_ALL`
  /// The returned object must be released after use, by calling the [release] method.
  static CookiePolicy? get ACCEPT_ALL =>
      _id_ACCEPT_ALL.get(_class, const $CookiePolicy$NullableType());

  static final _id_ACCEPT_NONE = _class.staticFieldId(
    r'ACCEPT_NONE',
    r'Ljava/net/CookiePolicy;',
  );

  /// from: `static public final java.net.CookiePolicy ACCEPT_NONE`
  /// The returned object must be released after use, by calling the [release] method.
  static CookiePolicy? get ACCEPT_NONE =>
      _id_ACCEPT_NONE.get(_class, const $CookiePolicy$NullableType());

  static final _id_ACCEPT_ORIGINAL_SERVER = _class.staticFieldId(
    r'ACCEPT_ORIGINAL_SERVER',
    r'Ljava/net/CookiePolicy;',
  );

  /// from: `static public final java.net.CookiePolicy ACCEPT_ORIGINAL_SERVER`
  /// The returned object must be released after use, by calling the [release] method.
  static CookiePolicy? get ACCEPT_ORIGINAL_SERVER => _id_ACCEPT_ORIGINAL_SERVER
      .get(_class, const $CookiePolicy$NullableType());

  static final _id_shouldAccept = _class.instanceMethodId(
    r'shouldAccept',
    r'(Ljava/net/URI;Ljava/net/HttpCookie;)Z',
  );

  static final _shouldAccept =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean shouldAccept(java.net.URI uRI, java.net.HttpCookie httpCookie)`
  bool shouldAccept(URI? uRI, HttpCookie? httpCookie) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    final _$httpCookie = httpCookie?.reference ?? jni$_.jNullReference;
    return _shouldAccept(
      reference.pointer,
      _id_shouldAccept as jni$_.JMethodIDPtr,
      _$uRI.pointer,
      _$httpCookie.pointer,
    ).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $CookiePolicy> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'shouldAccept(Ljava/net/URI;Ljava/net/HttpCookie;)Z') {
        final $r = _$impls[$p]!.shouldAccept(
          $a![0]?.as(const $URI$Type(), releaseOriginal: true),
          $a![1]?.as(const $HttpCookie$Type(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $CookiePolicy $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.net.CookiePolicy', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory CookiePolicy.implement($CookiePolicy $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return CookiePolicy.fromReference($i.implementReference());
  }
}

abstract base mixin class $CookiePolicy {
  factory $CookiePolicy({
    required bool Function(URI? uRI, HttpCookie? httpCookie) shouldAccept,
  }) = _$CookiePolicy;

  bool shouldAccept(URI? uRI, HttpCookie? httpCookie);
}

final class _$CookiePolicy with $CookiePolicy {
  _$CookiePolicy({
    required bool Function(URI? uRI, HttpCookie? httpCookie) shouldAccept,
  }) : _shouldAccept = shouldAccept;

  final bool Function(URI? uRI, HttpCookie? httpCookie) _shouldAccept;

  bool shouldAccept(URI? uRI, HttpCookie? httpCookie) =>
      _shouldAccept(uRI, httpCookie);
}

final class $CookiePolicy$NullableType extends jni$_.JObjType<CookiePolicy?> {
  @jni$_.internal
  const $CookiePolicy$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/CookiePolicy;';

  @jni$_.internal
  @core$_.override
  CookiePolicy? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CookiePolicy.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CookiePolicy?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CookiePolicy$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CookiePolicy$NullableType) &&
      other is $CookiePolicy$NullableType;
}

final class $CookiePolicy$Type extends jni$_.JObjType<CookiePolicy> {
  @jni$_.internal
  const $CookiePolicy$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/CookiePolicy;';

  @jni$_.internal
  @core$_.override
  CookiePolicy fromReference(jni$_.JReference reference) =>
      CookiePolicy.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CookiePolicy?> get nullableType =>
      const $CookiePolicy$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CookiePolicy$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CookiePolicy$Type) && other is $CookiePolicy$Type;
}

/// from: `java.net.URLStreamHandler`
class URLStreamHandler extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<URLStreamHandler> $type;

  @jni$_.internal
  URLStreamHandler.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/URLStreamHandler');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $URLStreamHandler$NullableType();
  static const type = $URLStreamHandler$Type();
}

final class $URLStreamHandler$NullableType
    extends jni$_.JObjType<URLStreamHandler?> {
  @jni$_.internal
  const $URLStreamHandler$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLStreamHandler;';

  @jni$_.internal
  @core$_.override
  URLStreamHandler? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : URLStreamHandler.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URLStreamHandler?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLStreamHandler$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URLStreamHandler$NullableType) &&
      other is $URLStreamHandler$NullableType;
}

final class $URLStreamHandler$Type extends jni$_.JObjType<URLStreamHandler> {
  @jni$_.internal
  const $URLStreamHandler$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLStreamHandler;';

  @jni$_.internal
  @core$_.override
  URLStreamHandler fromReference(jni$_.JReference reference) =>
      URLStreamHandler.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URLStreamHandler?> get nullableType =>
      const $URLStreamHandler$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLStreamHandler$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URLStreamHandler$Type) &&
      other is $URLStreamHandler$Type;
}

/// from: `java.net.CookieManager`
class CookieManager extends CookieHandler {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CookieManager> $type;

  @jni$_.internal
  CookieManager.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/CookieManager');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CookieManager$NullableType();
  static const type = $CookieManager$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory CookieManager() => CookieManager.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/net/CookieStore;Ljava/net/CookiePolicy;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.CookieStore cookieStore, java.net.CookiePolicy cookiePolicy)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CookieManager.new$1(
    CookieStore? cookieStore,
    CookiePolicy? cookiePolicy,
  ) {
    final _$cookieStore = cookieStore?.reference ?? jni$_.jNullReference;
    final _$cookiePolicy = cookiePolicy?.reference ?? jni$_.jNullReference;
    return CookieManager.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$cookieStore.pointer,
        _$cookiePolicy.pointer,
      ).reference,
    );
  }

  static final _id_setCookiePolicy = _class.instanceMethodId(
    r'setCookiePolicy',
    r'(Ljava/net/CookiePolicy;)V',
  );

  static final _setCookiePolicy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setCookiePolicy(java.net.CookiePolicy cookiePolicy)`
  void setCookiePolicy(CookiePolicy? cookiePolicy) {
    final _$cookiePolicy = cookiePolicy?.reference ?? jni$_.jNullReference;
    _setCookiePolicy(
      reference.pointer,
      _id_setCookiePolicy as jni$_.JMethodIDPtr,
      _$cookiePolicy.pointer,
    ).check();
  }

  static final _id_getCookieStore = _class.instanceMethodId(
    r'getCookieStore',
    r'()Ljava/net/CookieStore;',
  );

  static final _getCookieStore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.CookieStore getCookieStore()`
  /// The returned object must be released after use, by calling the [release] method.
  CookieStore? getCookieStore() => _getCookieStore(
    reference.pointer,
    _id_getCookieStore as jni$_.JMethodIDPtr,
  ).object<CookieStore?>(const $CookieStore$NullableType());

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/net/URI;Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.Map<java.lang.String, java.util.List<java.lang.String>> get(java.net.URI uRI, java.util.Map<java.lang.String, java.util.List<java.lang.String>> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>? get(
    URI? uRI,
    jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>? map,
  ) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$uRI.pointer,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>?>(
      const jni$_.JMapNullableType<
        jni$_.JString?,
        jni$_.JList<jni$_.JString?>?
      >(
        jni$_.JStringNullableType(),
        jni$_.JListNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
      ),
    );
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/net/URI;Ljava/util/Map;)V',
  );

  static final _put =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void put(java.net.URI uRI, java.util.Map<java.lang.String, java.util.List<java.lang.String>> map)`
  void put(
    URI? uRI,
    jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>? map,
  ) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    _put(
      reference.pointer,
      _id_put as jni$_.JMethodIDPtr,
      _$uRI.pointer,
      _$map.pointer,
    ).check();
  }
}

final class $CookieManager$NullableType extends jni$_.JObjType<CookieManager?> {
  @jni$_.internal
  const $CookieManager$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/CookieManager;';

  @jni$_.internal
  @core$_.override
  CookieManager? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CookieManager.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $CookieHandler$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CookieManager?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($CookieManager$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CookieManager$NullableType) &&
      other is $CookieManager$NullableType;
}

final class $CookieManager$Type extends jni$_.JObjType<CookieManager> {
  @jni$_.internal
  const $CookieManager$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/CookieManager;';

  @jni$_.internal
  @core$_.override
  CookieManager fromReference(jni$_.JReference reference) =>
      CookieManager.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $CookieHandler$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CookieManager?> get nullableType =>
      const $CookieManager$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($CookieManager$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CookieManager$Type) &&
      other is $CookieManager$Type;
}

/// from: `java.net.NoRouteToHostException`
class NoRouteToHostException extends SocketException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NoRouteToHostException> $type;

  @jni$_.internal
  NoRouteToHostException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/net/NoRouteToHostException',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NoRouteToHostException$NullableType();
  static const type = $NoRouteToHostException$Type();
  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NoRouteToHostException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return NoRouteToHostException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NoRouteToHostException() => NoRouteToHostException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );
}

final class $NoRouteToHostException$NullableType
    extends jni$_.JObjType<NoRouteToHostException?> {
  @jni$_.internal
  const $NoRouteToHostException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/NoRouteToHostException;';

  @jni$_.internal
  @core$_.override
  NoRouteToHostException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NoRouteToHostException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SocketException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NoRouteToHostException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($NoRouteToHostException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NoRouteToHostException$NullableType) &&
      other is $NoRouteToHostException$NullableType;
}

final class $NoRouteToHostException$Type
    extends jni$_.JObjType<NoRouteToHostException> {
  @jni$_.internal
  const $NoRouteToHostException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/NoRouteToHostException;';

  @jni$_.internal
  @core$_.override
  NoRouteToHostException fromReference(jni$_.JReference reference) =>
      NoRouteToHostException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SocketException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NoRouteToHostException?> get nullableType =>
      const $NoRouteToHostException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($NoRouteToHostException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NoRouteToHostException$Type) &&
      other is $NoRouteToHostException$Type;
}

/// from: `java.net.SocketOptions`
class SocketOptions extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SocketOptions> $type;

  @jni$_.internal
  SocketOptions.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/SocketOptions');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SocketOptions$NullableType();
  static const type = $SocketOptions$Type();

  /// from: `static public final int TCP_NODELAY`
  static const TCP_NODELAY = 1;

  /// from: `static public final int SO_BINDADDR`
  static const SO_BINDADDR = 15;

  /// from: `static public final int SO_REUSEADDR`
  static const SO_REUSEADDR = 4;

  /// from: `static public final int SO_REUSEPORT`
  static const SO_REUSEPORT = 14;

  /// from: `static public final int SO_BROADCAST`
  static const SO_BROADCAST = 32;

  /// from: `static public final int IP_MULTICAST_IF`
  static const IP_MULTICAST_IF = 16;

  /// from: `static public final int IP_MULTICAST_IF2`
  static const IP_MULTICAST_IF2 = 31;

  /// from: `static public final int IP_MULTICAST_LOOP`
  static const IP_MULTICAST_LOOP = 18;

  /// from: `static public final int IP_TOS`
  static const IP_TOS = 3;

  /// from: `static public final int SO_LINGER`
  static const SO_LINGER = 128;

  /// from: `static public final int SO_TIMEOUT`
  static const SO_TIMEOUT = 4102;

  /// from: `static public final int SO_SNDBUF`
  static const SO_SNDBUF = 4097;

  /// from: `static public final int SO_RCVBUF`
  static const SO_RCVBUF = 4098;

  /// from: `static public final int SO_KEEPALIVE`
  static const SO_KEEPALIVE = 8;

  /// from: `static public final int SO_OOBINLINE`
  static const SO_OOBINLINE = 4099;
  static final _id_setOption = _class.instanceMethodId(
    r'setOption',
    r'(ILjava/lang/Object;)V',
  );

  static final _setOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void setOption(int i, java.lang.Object object)`
  void setOption(int i, jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _setOption(
      reference.pointer,
      _id_setOption as jni$_.JMethodIDPtr,
      i,
      _$object.pointer,
    ).check();
  }

  static final _id_getOption = _class.instanceMethodId(
    r'getOption',
    r'(I)Ljava/lang/Object;',
  );

  static final _getOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract java.lang.Object getOption(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getOption(int i) => _getOption(
    reference.pointer,
    _id_getOption as jni$_.JMethodIDPtr,
    i,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $SocketOptions> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'setOption(ILjava/lang/Object;)V') {
        _$impls[$p]!.setOption(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![1]?.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'getOption(I)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.getOption(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $SocketOptions $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.net.SocketOptions', $p, _$invokePointer, [
      if ($impl.setOption$async) r'setOption(ILjava/lang/Object;)V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory SocketOptions.implement($SocketOptions $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return SocketOptions.fromReference($i.implementReference());
  }
}

abstract base mixin class $SocketOptions {
  factory $SocketOptions({
    required void Function(int i, jni$_.JObject? object) setOption,
    bool setOption$async,
    required jni$_.JObject? Function(int i) getOption,
  }) = _$SocketOptions;

  void setOption(int i, jni$_.JObject? object);
  bool get setOption$async => false;
  jni$_.JObject? getOption(int i);
}

final class _$SocketOptions with $SocketOptions {
  _$SocketOptions({
    required void Function(int i, jni$_.JObject? object) setOption,
    this.setOption$async = false,
    required jni$_.JObject? Function(int i) getOption,
  }) : _setOption = setOption,
       _getOption = getOption;

  final void Function(int i, jni$_.JObject? object) _setOption;
  final bool setOption$async;
  final jni$_.JObject? Function(int i) _getOption;

  void setOption(int i, jni$_.JObject? object) => _setOption(i, object);

  jni$_.JObject? getOption(int i) => _getOption(i);
}

final class $SocketOptions$NullableType extends jni$_.JObjType<SocketOptions?> {
  @jni$_.internal
  const $SocketOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketOptions;';

  @jni$_.internal
  @core$_.override
  SocketOptions? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SocketOptions.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SocketOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketOptions$NullableType) &&
      other is $SocketOptions$NullableType;
}

final class $SocketOptions$Type extends jni$_.JObjType<SocketOptions> {
  @jni$_.internal
  const $SocketOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/SocketOptions;';

  @jni$_.internal
  @core$_.override
  SocketOptions fromReference(jni$_.JReference reference) =>
      SocketOptions.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SocketOptions?> get nullableType =>
      const $SocketOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SocketOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SocketOptions$Type) &&
      other is $SocketOptions$Type;
}

/// from: `java.net.IDN`
class IDN extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<IDN> $type;

  @jni$_.internal
  IDN.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/IDN');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $IDN$NullableType();
  static const type = $IDN$Type();

  /// from: `static public final int ALLOW_UNASSIGNED`
  static const ALLOW_UNASSIGNED = 1;

  /// from: `static public final int USE_STD3_ASCII_RULES`
  static const USE_STD3_ASCII_RULES = 2;
  static final _id_toASCII = _class.staticMethodId(
    r'toASCII',
    r'(Ljava/lang/String;I)Ljava/lang/String;',
  );

  static final _toASCII =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public java.lang.String toASCII(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? toASCII(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _toASCII(
      _class.reference.pointer,
      _id_toASCII as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toASCII$1 = _class.staticMethodId(
    r'toASCII',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _toASCII$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String toASCII(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? toASCII$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _toASCII$1(
      _class.reference.pointer,
      _id_toASCII$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toUnicode = _class.staticMethodId(
    r'toUnicode',
    r'(Ljava/lang/String;I)Ljava/lang/String;',
  );

  static final _toUnicode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public java.lang.String toUnicode(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? toUnicode(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _toUnicode(
      _class.reference.pointer,
      _id_toUnicode as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toUnicode$1 = _class.staticMethodId(
    r'toUnicode',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _toUnicode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String toUnicode(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? toUnicode$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _toUnicode$1(
      _class.reference.pointer,
      _id_toUnicode$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $IDN$NullableType extends jni$_.JObjType<IDN?> {
  @jni$_.internal
  const $IDN$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/IDN;';

  @jni$_.internal
  @core$_.override
  IDN? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : IDN.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IDN?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IDN$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($IDN$NullableType) && other is $IDN$NullableType;
}

final class $IDN$Type extends jni$_.JObjType<IDN> {
  @jni$_.internal
  const $IDN$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/IDN;';

  @jni$_.internal
  @core$_.override
  IDN fromReference(jni$_.JReference reference) => IDN.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IDN?> get nullableType => const $IDN$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IDN$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($IDN$Type) && other is $IDN$Type;
}

/// from: `java.net.Socket`
class Socket extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Socket> $type;

  @jni$_.internal
  Socket.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/Socket');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Socket$NullableType();
  static const type = $Socket$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket() => Socket.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$1 = _class.constructorId(r'(Ljava/net/Proxy;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.Proxy proxy)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket.new$1(Proxy? proxy) {
    final _$proxy = proxy?.reference ?? jni$_.jNullReference;
    return Socket.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$proxy.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Ljava/lang/String;I)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket.new$2(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return Socket.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(Ljava/net/InetAddress;I)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.net.InetAddress inetAddress, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket.new$3(InetAddress? inetAddress, int i) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    return Socket.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$inetAddress.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(
    r'(Ljava/lang/String;ILjava/net/InetAddress;I)V',
  );

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i, java.net.InetAddress inetAddress, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket.new$4(
    jni$_.JString? string,
    int i,
    InetAddress? inetAddress,
    int i1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    return Socket.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
        _$inetAddress.pointer,
        i1,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(
    r'(Ljava/net/InetAddress;ILjava/net/InetAddress;I)V',
  );

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.net.InetAddress inetAddress, int i, java.net.InetAddress inetAddress1, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket.new$5(
    InetAddress? inetAddress,
    int i,
    InetAddress? inetAddress1,
    int i1,
  ) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    final _$inetAddress1 = inetAddress1?.reference ?? jni$_.jNullReference;
    return Socket.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$inetAddress.pointer,
        i,
        _$inetAddress1.pointer,
        i1,
      ).reference,
    );
  }

  static final _id_new$6 = _class.constructorId(r'(Ljava/lang/String;IZ)V');

  static final _new$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket.new$6(jni$_.JString? string, int i, bool z) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return Socket.fromReference(
      _new$6(
        _class.reference.pointer,
        _id_new$6 as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$7 = _class.constructorId(r'(Ljava/net/InetAddress;IZ)V');

  static final _new$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void <init>(java.net.InetAddress inetAddress, int i, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Socket.new$7(InetAddress? inetAddress, int i, bool z) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    return Socket.fromReference(
      _new$7(
        _class.reference.pointer,
        _id_new$7 as jni$_.JMethodIDPtr,
        _$inetAddress.pointer,
        i,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_connect = _class.instanceMethodId(
    r'connect',
    r'(Ljava/net/SocketAddress;)V',
  );

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void connect(java.net.SocketAddress socketAddress)`
  void connect(SocketAddress? socketAddress) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    _connect(
      reference.pointer,
      _id_connect as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
    ).check();
  }

  static final _id_connect$1 = _class.instanceMethodId(
    r'connect',
    r'(Ljava/net/SocketAddress;I)V',
  );

  static final _connect$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void connect(java.net.SocketAddress socketAddress, int i)`
  void connect$1(SocketAddress? socketAddress, int i) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    _connect$1(
      reference.pointer,
      _id_connect$1 as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
      i,
    ).check();
  }

  static final _id_bind = _class.instanceMethodId(
    r'bind',
    r'(Ljava/net/SocketAddress;)V',
  );

  static final _bind =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void bind(java.net.SocketAddress socketAddress)`
  void bind(SocketAddress? socketAddress) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    _bind(
      reference.pointer,
      _id_bind as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
    ).check();
  }

  static final _id_getInetAddress = _class.instanceMethodId(
    r'getInetAddress',
    r'()Ljava/net/InetAddress;',
  );

  static final _getInetAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.InetAddress getInetAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  InetAddress? getInetAddress() => _getInetAddress(
    reference.pointer,
    _id_getInetAddress as jni$_.JMethodIDPtr,
  ).object<InetAddress?>(const $InetAddress$NullableType());

  static final _id_getLocalAddress = _class.instanceMethodId(
    r'getLocalAddress',
    r'()Ljava/net/InetAddress;',
  );

  static final _getLocalAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.InetAddress getLocalAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  InetAddress? getLocalAddress() => _getLocalAddress(
    reference.pointer,
    _id_getLocalAddress as jni$_.JMethodIDPtr,
  ).object<InetAddress?>(const $InetAddress$NullableType());

  static final _id_getPort = _class.instanceMethodId(r'getPort', r'()I');

  static final _getPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getPort()`
  int getPort() =>
      _getPort(reference.pointer, _id_getPort as jni$_.JMethodIDPtr).integer;

  static final _id_getLocalPort = _class.instanceMethodId(
    r'getLocalPort',
    r'()I',
  );

  static final _getLocalPort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLocalPort()`
  int getLocalPort() =>
      _getLocalPort(
        reference.pointer,
        _id_getLocalPort as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getRemoteSocketAddress = _class.instanceMethodId(
    r'getRemoteSocketAddress',
    r'()Ljava/net/SocketAddress;',
  );

  static final _getRemoteSocketAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.SocketAddress getRemoteSocketAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  SocketAddress? getRemoteSocketAddress() => _getRemoteSocketAddress(
    reference.pointer,
    _id_getRemoteSocketAddress as jni$_.JMethodIDPtr,
  ).object<SocketAddress?>(const $SocketAddress$NullableType());

  static final _id_getLocalSocketAddress = _class.instanceMethodId(
    r'getLocalSocketAddress',
    r'()Ljava/net/SocketAddress;',
  );

  static final _getLocalSocketAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.SocketAddress getLocalSocketAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  SocketAddress? getLocalSocketAddress() => _getLocalSocketAddress(
    reference.pointer,
    _id_getLocalSocketAddress as jni$_.JMethodIDPtr,
  ).object<SocketAddress?>(const $SocketAddress$NullableType());

  static final _id_getChannel = _class.instanceMethodId(
    r'getChannel',
    r'()Ljava/nio/channels/SocketChannel;',
  );

  static final _getChannel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.channels.SocketChannel getChannel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChannel() => _getChannel(
    reference.pointer,
    _id_getChannel as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_getInputStream = _class.instanceMethodId(
    r'getInputStream',
    r'()Ljava/io/InputStream;',
  );

  static final _getInputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.InputStream getInputStream()`
  /// The returned object must be released after use, by calling the [release] method.
  InputStream? getInputStream() => _getInputStream(
    reference.pointer,
    _id_getInputStream as jni$_.JMethodIDPtr,
  ).object<InputStream?>(const $InputStream$NullableType());

  static final _id_getOutputStream = _class.instanceMethodId(
    r'getOutputStream',
    r'()Ljava/io/OutputStream;',
  );

  static final _getOutputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.OutputStream getOutputStream()`
  /// The returned object must be released after use, by calling the [release] method.
  OutputStream? getOutputStream() => _getOutputStream(
    reference.pointer,
    _id_getOutputStream as jni$_.JMethodIDPtr,
  ).object<OutputStream?>(const $OutputStream$NullableType());

  static final _id_setTcpNoDelay = _class.instanceMethodId(
    r'setTcpNoDelay',
    r'(Z)V',
  );

  static final _setTcpNoDelay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setTcpNoDelay(boolean z)`
  void setTcpNoDelay(bool z) {
    _setTcpNoDelay(
      reference.pointer,
      _id_setTcpNoDelay as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getTcpNoDelay = _class.instanceMethodId(
    r'getTcpNoDelay',
    r'()Z',
  );

  static final _getTcpNoDelay =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getTcpNoDelay()`
  bool getTcpNoDelay() =>
      _getTcpNoDelay(
        reference.pointer,
        _id_getTcpNoDelay as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setSoLinger = _class.instanceMethodId(
    r'setSoLinger',
    r'(ZI)V',
  );

  static final _setSoLinger =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void setSoLinger(boolean z, int i)`
  void setSoLinger(bool z, int i) {
    _setSoLinger(
      reference.pointer,
      _id_setSoLinger as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      i,
    ).check();
  }

  static final _id_getSoLinger = _class.instanceMethodId(
    r'getSoLinger',
    r'()I',
  );

  static final _getSoLinger =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSoLinger()`
  int getSoLinger() =>
      _getSoLinger(
        reference.pointer,
        _id_getSoLinger as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_sendUrgentData = _class.instanceMethodId(
    r'sendUrgentData',
    r'(I)V',
  );

  static final _sendUrgentData =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void sendUrgentData(int i)`
  void sendUrgentData(int i) {
    _sendUrgentData(
      reference.pointer,
      _id_sendUrgentData as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setOOBInline = _class.instanceMethodId(
    r'setOOBInline',
    r'(Z)V',
  );

  static final _setOOBInline =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setOOBInline(boolean z)`
  void setOOBInline(bool z) {
    _setOOBInline(
      reference.pointer,
      _id_setOOBInline as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getOOBInline = _class.instanceMethodId(
    r'getOOBInline',
    r'()Z',
  );

  static final _getOOBInline =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getOOBInline()`
  bool getOOBInline() =>
      _getOOBInline(
        reference.pointer,
        _id_getOOBInline as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setSoTimeout = _class.instanceMethodId(
    r'setSoTimeout',
    r'(I)V',
  );

  static final _setSoTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setSoTimeout(int i)`
  void setSoTimeout(int i) {
    _setSoTimeout(
      reference.pointer,
      _id_setSoTimeout as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getSoTimeout = _class.instanceMethodId(
    r'getSoTimeout',
    r'()I',
  );

  static final _getSoTimeout =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSoTimeout()`
  int getSoTimeout() =>
      _getSoTimeout(
        reference.pointer,
        _id_getSoTimeout as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setSendBufferSize = _class.instanceMethodId(
    r'setSendBufferSize',
    r'(I)V',
  );

  static final _setSendBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setSendBufferSize(int i)`
  void setSendBufferSize(int i) {
    _setSendBufferSize(
      reference.pointer,
      _id_setSendBufferSize as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getSendBufferSize = _class.instanceMethodId(
    r'getSendBufferSize',
    r'()I',
  );

  static final _getSendBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getSendBufferSize()`
  int getSendBufferSize() =>
      _getSendBufferSize(
        reference.pointer,
        _id_getSendBufferSize as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setReceiveBufferSize = _class.instanceMethodId(
    r'setReceiveBufferSize',
    r'(I)V',
  );

  static final _setReceiveBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReceiveBufferSize(int i)`
  void setReceiveBufferSize(int i) {
    _setReceiveBufferSize(
      reference.pointer,
      _id_setReceiveBufferSize as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getReceiveBufferSize = _class.instanceMethodId(
    r'getReceiveBufferSize',
    r'()I',
  );

  static final _getReceiveBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getReceiveBufferSize()`
  int getReceiveBufferSize() =>
      _getReceiveBufferSize(
        reference.pointer,
        _id_getReceiveBufferSize as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setKeepAlive = _class.instanceMethodId(
    r'setKeepAlive',
    r'(Z)V',
  );

  static final _setKeepAlive =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setKeepAlive(boolean z)`
  void setKeepAlive(bool z) {
    _setKeepAlive(
      reference.pointer,
      _id_setKeepAlive as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getKeepAlive = _class.instanceMethodId(
    r'getKeepAlive',
    r'()Z',
  );

  static final _getKeepAlive =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getKeepAlive()`
  bool getKeepAlive() =>
      _getKeepAlive(
        reference.pointer,
        _id_getKeepAlive as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setTrafficClass = _class.instanceMethodId(
    r'setTrafficClass',
    r'(I)V',
  );

  static final _setTrafficClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setTrafficClass(int i)`
  void setTrafficClass(int i) {
    _setTrafficClass(
      reference.pointer,
      _id_setTrafficClass as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getTrafficClass = _class.instanceMethodId(
    r'getTrafficClass',
    r'()I',
  );

  static final _getTrafficClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getTrafficClass()`
  int getTrafficClass() =>
      _getTrafficClass(
        reference.pointer,
        _id_getTrafficClass as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setReuseAddress = _class.instanceMethodId(
    r'setReuseAddress',
    r'(Z)V',
  );

  static final _setReuseAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReuseAddress(boolean z)`
  void setReuseAddress(bool z) {
    _setReuseAddress(
      reference.pointer,
      _id_setReuseAddress as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getReuseAddress = _class.instanceMethodId(
    r'getReuseAddress',
    r'()Z',
  );

  static final _getReuseAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getReuseAddress()`
  bool getReuseAddress() =>
      _getReuseAddress(
        reference.pointer,
        _id_getReuseAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_shutdownInput = _class.instanceMethodId(
    r'shutdownInput',
    r'()V',
  );

  static final _shutdownInput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void shutdownInput()`
  void shutdownInput() {
    _shutdownInput(
      reference.pointer,
      _id_shutdownInput as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_shutdownOutput = _class.instanceMethodId(
    r'shutdownOutput',
    r'()V',
  );

  static final _shutdownOutput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void shutdownOutput()`
  void shutdownOutput() {
    _shutdownOutput(
      reference.pointer,
      _id_shutdownOutput as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_isConnected = _class.instanceMethodId(
    r'isConnected',
    r'()Z',
  );

  static final _isConnected =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isConnected()`
  bool isConnected() =>
      _isConnected(
        reference.pointer,
        _id_isConnected as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isBound = _class.instanceMethodId(r'isBound', r'()Z');

  static final _isBound =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isBound()`
  bool isBound() =>
      _isBound(reference.pointer, _id_isBound as jni$_.JMethodIDPtr).boolean;

  static final _id_isClosed = _class.instanceMethodId(r'isClosed', r'()Z');

  static final _isClosed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isClosed()`
  bool isClosed() =>
      _isClosed(reference.pointer, _id_isClosed as jni$_.JMethodIDPtr).boolean;

  static final _id_isInputShutdown = _class.instanceMethodId(
    r'isInputShutdown',
    r'()Z',
  );

  static final _isInputShutdown =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isInputShutdown()`
  bool isInputShutdown() =>
      _isInputShutdown(
        reference.pointer,
        _id_isInputShutdown as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isOutputShutdown = _class.instanceMethodId(
    r'isOutputShutdown',
    r'()Z',
  );

  static final _isOutputShutdown =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isOutputShutdown()`
  bool isOutputShutdown() =>
      _isOutputShutdown(
        reference.pointer,
        _id_isOutputShutdown as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setSocketImplFactory = _class.staticMethodId(
    r'setSocketImplFactory',
    r'(Ljava/net/SocketImplFactory;)V',
  );

  static final _setSocketImplFactory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setSocketImplFactory(java.net.SocketImplFactory socketImplFactory)`
  static void setSocketImplFactory(SocketImplFactory? socketImplFactory) {
    final _$socketImplFactory =
        socketImplFactory?.reference ?? jni$_.jNullReference;
    _setSocketImplFactory(
      _class.reference.pointer,
      _id_setSocketImplFactory as jni$_.JMethodIDPtr,
      _$socketImplFactory.pointer,
    ).check();
  }

  static final _id_setPerformancePreferences = _class.instanceMethodId(
    r'setPerformancePreferences',
    r'(III)V',
  );

  static final _setPerformancePreferences =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public void setPerformancePreferences(int i, int i1, int i2)`
  void setPerformancePreferences(int i, int i1, int i2) {
    _setPerformancePreferences(
      reference.pointer,
      _id_setPerformancePreferences as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
    ).check();
  }

  static final _id_setOption = _class.instanceMethodId(
    r'setOption',
    r'(Ljava/net/SocketOption;Ljava/lang/Object;)Ljava/net/Socket;',
  );

  static final _setOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.net.Socket setOption(java.net.SocketOption<T> socketOption, T object)`
  /// The returned object must be released after use, by calling the [release] method.
  Socket? setOption<$T extends jni$_.JObject?>(
    SocketOption<$T?>? socketOption,
    $T? object, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$socketOption = socketOption?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _setOption(
      reference.pointer,
      _id_setOption as jni$_.JMethodIDPtr,
      _$socketOption.pointer,
      _$object.pointer,
    ).object<Socket?>(const $Socket$NullableType());
  }

  static final _id_getOption = _class.instanceMethodId(
    r'getOption',
    r'(Ljava/net/SocketOption;)Ljava/lang/Object;',
  );

  static final _getOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public T getOption(java.net.SocketOption<T> socketOption)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? getOption<$T extends jni$_.JObject?>(
    SocketOption<$T?>? socketOption, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$socketOption = socketOption?.reference ?? jni$_.jNullReference;
    return _getOption(
      reference.pointer,
      _id_getOption as jni$_.JMethodIDPtr,
      _$socketOption.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_supportedOptions = _class.instanceMethodId(
    r'supportedOptions',
    r'()Ljava/util/Set;',
  );

  static final _supportedOptions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<java.net.SocketOption<?>> supportedOptions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<SocketOption<jni$_.JObject?>?>? supportedOptions() =>
      _supportedOptions(
        reference.pointer,
        _id_supportedOptions as jni$_.JMethodIDPtr,
      ).object<jni$_.JSet<SocketOption<jni$_.JObject?>?>?>(
        const jni$_.JSetNullableType<SocketOption<jni$_.JObject?>?>(
          $SocketOption$NullableType<jni$_.JObject?>(
            jni$_.JObjectNullableType(),
          ),
        ),
      );
}

final class $Socket$NullableType extends jni$_.JObjType<Socket?> {
  @jni$_.internal
  const $Socket$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Socket;';

  @jni$_.internal
  @core$_.override
  Socket? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Socket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Socket?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Socket$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Socket$NullableType) &&
      other is $Socket$NullableType;
}

final class $Socket$Type extends jni$_.JObjType<Socket> {
  @jni$_.internal
  const $Socket$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Socket;';

  @jni$_.internal
  @core$_.override
  Socket fromReference(jni$_.JReference reference) =>
      Socket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Socket?> get nullableType => const $Socket$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Socket$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Socket$Type) && other is $Socket$Type;
}

/// from: `java.net.ResponseCache`
class ResponseCache extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ResponseCache> $type;

  @jni$_.internal
  ResponseCache.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/ResponseCache');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ResponseCache$NullableType();
  static const type = $ResponseCache$Type();
  static final _id_getDefault = _class.staticMethodId(
    r'getDefault',
    r'()Ljava/net/ResponseCache;',
  );

  static final _getDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.net.ResponseCache getDefault()`
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseCache? getDefault() => _getDefault(
    _class.reference.pointer,
    _id_getDefault as jni$_.JMethodIDPtr,
  ).object<ResponseCache?>(const $ResponseCache$NullableType());

  static final _id_setDefault = _class.staticMethodId(
    r'setDefault',
    r'(Ljava/net/ResponseCache;)V',
  );

  static final _setDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setDefault(java.net.ResponseCache responseCache)`
  static void setDefault(ResponseCache? responseCache) {
    final _$responseCache = responseCache?.reference ?? jni$_.jNullReference;
    _setDefault(
      _class.reference.pointer,
      _id_setDefault as jni$_.JMethodIDPtr,
      _$responseCache.pointer,
    ).check();
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/net/URI;Ljava/lang/String;Ljava/util/Map;)Ljava/net/CacheResponse;',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.net.CacheResponse get(java.net.URI uRI, java.lang.String string, java.util.Map<java.lang.String, java.util.List<java.lang.String>> map)`
  /// The returned object must be released after use, by calling the [release] method.
  CacheResponse? get(
    URI? uRI,
    jni$_.JString? string,
    jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>? map,
  ) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$uRI.pointer,
      _$string.pointer,
      _$map.pointer,
    ).object<CacheResponse?>(const $CacheResponse$NullableType());
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/net/URI;Ljava/net/URLConnection;)Ljava/net/CacheRequest;',
  );

  static final _put =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.net.CacheRequest put(java.net.URI uRI, java.net.URLConnection uRLConnection)`
  /// The returned object must be released after use, by calling the [release] method.
  CacheRequest? put(URI? uRI, URLConnection? uRLConnection) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    final _$uRLConnection = uRLConnection?.reference ?? jni$_.jNullReference;
    return _put(
      reference.pointer,
      _id_put as jni$_.JMethodIDPtr,
      _$uRI.pointer,
      _$uRLConnection.pointer,
    ).object<CacheRequest?>(const $CacheRequest$NullableType());
  }
}

final class $ResponseCache$NullableType extends jni$_.JObjType<ResponseCache?> {
  @jni$_.internal
  const $ResponseCache$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ResponseCache;';

  @jni$_.internal
  @core$_.override
  ResponseCache? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ResponseCache.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ResponseCache?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ResponseCache$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ResponseCache$NullableType) &&
      other is $ResponseCache$NullableType;
}

final class $ResponseCache$Type extends jni$_.JObjType<ResponseCache> {
  @jni$_.internal
  const $ResponseCache$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ResponseCache;';

  @jni$_.internal
  @core$_.override
  ResponseCache fromReference(jni$_.JReference reference) =>
      ResponseCache.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ResponseCache?> get nullableType =>
      const $ResponseCache$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ResponseCache$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ResponseCache$Type) &&
      other is $ResponseCache$Type;
}

/// from: `java.net.ContentHandlerFactory`
class ContentHandlerFactory extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ContentHandlerFactory> $type;

  @jni$_.internal
  ContentHandlerFactory.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/ContentHandlerFactory');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ContentHandlerFactory$NullableType();
  static const type = $ContentHandlerFactory$Type();
  static final _id_createContentHandler = _class.instanceMethodId(
    r'createContentHandler',
    r'(Ljava/lang/String;)Ljava/net/ContentHandler;',
  );

  static final _createContentHandler =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.net.ContentHandler createContentHandler(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  ContentHandler? createContentHandler(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createContentHandler(
      reference.pointer,
      _id_createContentHandler as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<ContentHandler?>(const $ContentHandler$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ContentHandlerFactory> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'createContentHandler(Ljava/lang/String;)Ljava/net/ContentHandler;') {
        final $r = _$impls[$p]!.createContentHandler(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ContentHandlerFactory $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.net.ContentHandlerFactory', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ContentHandlerFactory.implement($ContentHandlerFactory $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ContentHandlerFactory.fromReference($i.implementReference());
  }
}

abstract base mixin class $ContentHandlerFactory {
  factory $ContentHandlerFactory({
    required ContentHandler? Function(jni$_.JString? string)
    createContentHandler,
  }) = _$ContentHandlerFactory;

  ContentHandler? createContentHandler(jni$_.JString? string);
}

final class _$ContentHandlerFactory with $ContentHandlerFactory {
  _$ContentHandlerFactory({
    required ContentHandler? Function(jni$_.JString? string)
    createContentHandler,
  }) : _createContentHandler = createContentHandler;

  final ContentHandler? Function(jni$_.JString? string) _createContentHandler;

  ContentHandler? createContentHandler(jni$_.JString? string) =>
      _createContentHandler(string);
}

final class $ContentHandlerFactory$NullableType
    extends jni$_.JObjType<ContentHandlerFactory?> {
  @jni$_.internal
  const $ContentHandlerFactory$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ContentHandlerFactory;';

  @jni$_.internal
  @core$_.override
  ContentHandlerFactory? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ContentHandlerFactory.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ContentHandlerFactory?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ContentHandlerFactory$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ContentHandlerFactory$NullableType) &&
      other is $ContentHandlerFactory$NullableType;
}

final class $ContentHandlerFactory$Type
    extends jni$_.JObjType<ContentHandlerFactory> {
  @jni$_.internal
  const $ContentHandlerFactory$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ContentHandlerFactory;';

  @jni$_.internal
  @core$_.override
  ContentHandlerFactory fromReference(jni$_.JReference reference) =>
      ContentHandlerFactory.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ContentHandlerFactory?> get nullableType =>
      const $ContentHandlerFactory$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ContentHandlerFactory$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ContentHandlerFactory$Type) &&
      other is $ContentHandlerFactory$Type;
}

/// from: `java.net.DatagramSocketImpl`
class DatagramSocketImpl extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DatagramSocketImpl> $type;

  @jni$_.internal
  DatagramSocketImpl.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/DatagramSocketImpl');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DatagramSocketImpl$NullableType();
  static const type = $DatagramSocketImpl$Type();
  static final _id_setOption = _class.instanceMethodId(
    r'setOption',
    r'(ILjava/lang/Object;)V',
  );

  static final _setOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void setOption(int i, java.lang.Object object)`
  void setOption(int i, jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _setOption(
      reference.pointer,
      _id_setOption as jni$_.JMethodIDPtr,
      i,
      _$object.pointer,
    ).check();
  }

  static final _id_getOption = _class.instanceMethodId(
    r'getOption',
    r'(I)Ljava/lang/Object;',
  );

  static final _getOption =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract java.lang.Object getOption(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getOption(int i) => _getOption(
    reference.pointer,
    _id_getOption as jni$_.JMethodIDPtr,
    i,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
}

final class $DatagramSocketImpl$NullableType
    extends jni$_.JObjType<DatagramSocketImpl?> {
  @jni$_.internal
  const $DatagramSocketImpl$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/DatagramSocketImpl;';

  @jni$_.internal
  @core$_.override
  DatagramSocketImpl? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DatagramSocketImpl.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DatagramSocketImpl?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DatagramSocketImpl$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DatagramSocketImpl$NullableType) &&
      other is $DatagramSocketImpl$NullableType;
}

final class $DatagramSocketImpl$Type
    extends jni$_.JObjType<DatagramSocketImpl> {
  @jni$_.internal
  const $DatagramSocketImpl$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/DatagramSocketImpl;';

  @jni$_.internal
  @core$_.override
  DatagramSocketImpl fromReference(jni$_.JReference reference) =>
      DatagramSocketImpl.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DatagramSocketImpl?> get nullableType =>
      const $DatagramSocketImpl$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DatagramSocketImpl$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DatagramSocketImpl$Type) &&
      other is $DatagramSocketImpl$Type;
}

/// from: `java.net.ProtocolFamily`
class ProtocolFamily extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ProtocolFamily> $type;

  @jni$_.internal
  ProtocolFamily.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/ProtocolFamily');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ProtocolFamily$NullableType();
  static const type = $ProtocolFamily$Type();
  static final _id_name = _class.instanceMethodId(
    r'name',
    r'()Ljava/lang/String;',
  );

  static final _name =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String name()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? name() => _name(
    reference.pointer,
    _id_name as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ProtocolFamily> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'name()Ljava/lang/String;') {
        final $r = _$impls[$p]!.name();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ProtocolFamily $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.net.ProtocolFamily', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ProtocolFamily.implement($ProtocolFamily $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ProtocolFamily.fromReference($i.implementReference());
  }
}

abstract base mixin class $ProtocolFamily {
  factory $ProtocolFamily({required jni$_.JString? Function() name}) =
      _$ProtocolFamily;

  jni$_.JString? name();
}

final class _$ProtocolFamily with $ProtocolFamily {
  _$ProtocolFamily({required jni$_.JString? Function() name}) : _name = name;

  final jni$_.JString? Function() _name;

  jni$_.JString? name() => _name();
}

final class $ProtocolFamily$NullableType
    extends jni$_.JObjType<ProtocolFamily?> {
  @jni$_.internal
  const $ProtocolFamily$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ProtocolFamily;';

  @jni$_.internal
  @core$_.override
  ProtocolFamily? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ProtocolFamily.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ProtocolFamily?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ProtocolFamily$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ProtocolFamily$NullableType) &&
      other is $ProtocolFamily$NullableType;
}

final class $ProtocolFamily$Type extends jni$_.JObjType<ProtocolFamily> {
  @jni$_.internal
  const $ProtocolFamily$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ProtocolFamily;';

  @jni$_.internal
  @core$_.override
  ProtocolFamily fromReference(jni$_.JReference reference) =>
      ProtocolFamily.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ProtocolFamily?> get nullableType =>
      const $ProtocolFamily$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ProtocolFamily$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ProtocolFamily$Type) &&
      other is $ProtocolFamily$Type;
}

/// from: `java.net.BindException`
class BindException extends SocketException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<BindException> $type;

  @jni$_.internal
  BindException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/BindException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $BindException$NullableType();
  static const type = $BindException$Type();
  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BindException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return BindException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory BindException() => BindException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );
}

final class $BindException$NullableType extends jni$_.JObjType<BindException?> {
  @jni$_.internal
  const $BindException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/BindException;';

  @jni$_.internal
  @core$_.override
  BindException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : BindException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SocketException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BindException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($BindException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($BindException$NullableType) &&
      other is $BindException$NullableType;
}

final class $BindException$Type extends jni$_.JObjType<BindException> {
  @jni$_.internal
  const $BindException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/BindException;';

  @jni$_.internal
  @core$_.override
  BindException fromReference(jni$_.JReference reference) =>
      BindException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $SocketException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BindException?> get nullableType =>
      const $BindException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($BindException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($BindException$Type) &&
      other is $BindException$Type;
}

/// from: `java.net.NetPermission`
class NetPermission extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NetPermission> $type;

  @jni$_.internal
  NetPermission.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/NetPermission');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NetPermission$NullableType();
  static const type = $NetPermission$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NetPermission(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return NetPermission.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NetPermission.new$1(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return NetPermission.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }
}

final class $NetPermission$NullableType extends jni$_.JObjType<NetPermission?> {
  @jni$_.internal
  const $NetPermission$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/NetPermission;';

  @jni$_.internal
  @core$_.override
  NetPermission? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NetPermission.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NetPermission?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NetPermission$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NetPermission$NullableType) &&
      other is $NetPermission$NullableType;
}

final class $NetPermission$Type extends jni$_.JObjType<NetPermission> {
  @jni$_.internal
  const $NetPermission$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/NetPermission;';

  @jni$_.internal
  @core$_.override
  NetPermission fromReference(jni$_.JReference reference) =>
      NetPermission.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NetPermission?> get nullableType =>
      const $NetPermission$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NetPermission$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NetPermission$Type) &&
      other is $NetPermission$Type;
}

/// from: `java.net.Proxy$Type`
class Proxy$Type extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Proxy$Type> $type;

  @jni$_.internal
  Proxy$Type.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/Proxy$Type');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Proxy$Type$NullableType();
  static const type = $Proxy$Type$Type();
  static final _id_DIRECT = _class.staticFieldId(
    r'DIRECT',
    r'Ljava/net/Proxy$Type;',
  );

  /// from: `static public final java.net.Proxy$Type DIRECT`
  /// The returned object must be released after use, by calling the [release] method.
  static Proxy$Type get DIRECT =>
      _id_DIRECT.get(_class, const $Proxy$Type$Type());

  static final _id_HTTP = _class.staticFieldId(
    r'HTTP',
    r'Ljava/net/Proxy$Type;',
  );

  /// from: `static public final java.net.Proxy$Type HTTP`
  /// The returned object must be released after use, by calling the [release] method.
  static Proxy$Type get HTTP => _id_HTTP.get(_class, const $Proxy$Type$Type());

  static final _id_SOCKS = _class.staticFieldId(
    r'SOCKS',
    r'Ljava/net/Proxy$Type;',
  );

  /// from: `static public final java.net.Proxy$Type SOCKS`
  /// The returned object must be released after use, by calling the [release] method.
  static Proxy$Type get SOCKS =>
      _id_SOCKS.get(_class, const $Proxy$Type$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/net/Proxy$Type;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.net.Proxy$Type[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Proxy$Type?>? values() => _values(
    _class.reference.pointer,
    _id_values as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<Proxy$Type?>?>(
    const jni$_.JArrayNullableType<Proxy$Type?>($Proxy$Type$NullableType()),
  );

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/net/Proxy$Type;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.Proxy$Type valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Proxy$Type? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Proxy$Type?>(const $Proxy$Type$NullableType());
  }
}

final class $Proxy$Type$NullableType extends jni$_.JObjType<Proxy$Type?> {
  @jni$_.internal
  const $Proxy$Type$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Proxy$Type;';

  @jni$_.internal
  @core$_.override
  Proxy$Type? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Proxy$Type.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Proxy$Type?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Proxy$Type$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Proxy$Type$NullableType) &&
      other is $Proxy$Type$NullableType;
}

final class $Proxy$Type$Type extends jni$_.JObjType<Proxy$Type> {
  @jni$_.internal
  const $Proxy$Type$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Proxy$Type;';

  @jni$_.internal
  @core$_.override
  Proxy$Type fromReference(jni$_.JReference reference) =>
      Proxy$Type.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Proxy$Type?> get nullableType =>
      const $Proxy$Type$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Proxy$Type$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Proxy$Type$Type) && other is $Proxy$Type$Type;
}

/// from: `java.net.CookieHandler`
class CookieHandler extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CookieHandler> $type;

  @jni$_.internal
  CookieHandler.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/CookieHandler');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CookieHandler$NullableType();
  static const type = $CookieHandler$Type();
  static final _id_getDefault = _class.staticMethodId(
    r'getDefault',
    r'()Ljava/net/CookieHandler;',
  );

  static final _getDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.net.CookieHandler getDefault()`
  /// The returned object must be released after use, by calling the [release] method.
  static CookieHandler? getDefault() => _getDefault(
    _class.reference.pointer,
    _id_getDefault as jni$_.JMethodIDPtr,
  ).object<CookieHandler?>(const $CookieHandler$NullableType());

  static final _id_setDefault = _class.staticMethodId(
    r'setDefault',
    r'(Ljava/net/CookieHandler;)V',
  );

  static final _setDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setDefault(java.net.CookieHandler cookieHandler)`
  static void setDefault(CookieHandler? cookieHandler) {
    final _$cookieHandler = cookieHandler?.reference ?? jni$_.jNullReference;
    _setDefault(
      _class.reference.pointer,
      _id_setDefault as jni$_.JMethodIDPtr,
      _$cookieHandler.pointer,
    ).check();
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/net/URI;Ljava/util/Map;)Ljava/util/Map;',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.util.Map<java.lang.String, java.util.List<java.lang.String>> get(java.net.URI uRI, java.util.Map<java.lang.String, java.util.List<java.lang.String>> map)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>? get(
    URI? uRI,
    jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>? map,
  ) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$uRI.pointer,
      _$map.pointer,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>?>(
      const jni$_.JMapNullableType<
        jni$_.JString?,
        jni$_.JList<jni$_.JString?>?
      >(
        jni$_.JStringNullableType(),
        jni$_.JListNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
      ),
    );
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/net/URI;Ljava/util/Map;)V',
  );

  static final _put =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void put(java.net.URI uRI, java.util.Map<java.lang.String, java.util.List<java.lang.String>> map)`
  void put(
    URI? uRI,
    jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>? map,
  ) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    _put(
      reference.pointer,
      _id_put as jni$_.JMethodIDPtr,
      _$uRI.pointer,
      _$map.pointer,
    ).check();
  }
}

final class $CookieHandler$NullableType extends jni$_.JObjType<CookieHandler?> {
  @jni$_.internal
  const $CookieHandler$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/CookieHandler;';

  @jni$_.internal
  @core$_.override
  CookieHandler? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CookieHandler.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CookieHandler?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CookieHandler$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CookieHandler$NullableType) &&
      other is $CookieHandler$NullableType;
}

final class $CookieHandler$Type extends jni$_.JObjType<CookieHandler> {
  @jni$_.internal
  const $CookieHandler$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/CookieHandler;';

  @jni$_.internal
  @core$_.override
  CookieHandler fromReference(jni$_.JReference reference) =>
      CookieHandler.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CookieHandler?> get nullableType =>
      const $CookieHandler$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CookieHandler$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CookieHandler$Type) &&
      other is $CookieHandler$Type;
}

/// from: `java.net.MalformedURLException`
class MalformedURLException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MalformedURLException> $type;

  @jni$_.internal
  MalformedURLException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/MalformedURLException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MalformedURLException$NullableType();
  static const type = $MalformedURLException$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MalformedURLException() => MalformedURLException.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MalformedURLException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return MalformedURLException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $MalformedURLException$NullableType
    extends jni$_.JObjType<MalformedURLException?> {
  @jni$_.internal
  const $MalformedURLException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/MalformedURLException;';

  @jni$_.internal
  @core$_.override
  MalformedURLException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : MalformedURLException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MalformedURLException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($MalformedURLException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($MalformedURLException$NullableType) &&
      other is $MalformedURLException$NullableType;
}

final class $MalformedURLException$Type
    extends jni$_.JObjType<MalformedURLException> {
  @jni$_.internal
  const $MalformedURLException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/MalformedURLException;';

  @jni$_.internal
  @core$_.override
  MalformedURLException fromReference(jni$_.JReference reference) =>
      MalformedURLException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MalformedURLException?> get nullableType =>
      const $MalformedURLException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($MalformedURLException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($MalformedURLException$Type) &&
      other is $MalformedURLException$Type;
}

/// from: `java.net.URLPermission`
class URLPermission extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<URLPermission> $type;

  @jni$_.internal
  URLPermission.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/URLPermission');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $URLPermission$NullableType();
  static const type = $URLPermission$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URLPermission(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return URLPermission.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URLPermission.new$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return URLPermission.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_getActions = _class.instanceMethodId(
    r'getActions',
    r'()Ljava/lang/String;',
  );

  static final _getActions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getActions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getActions() => _getActions(
    reference.pointer,
    _id_getActions as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_implies = _class.instanceMethodId(
    r'implies',
    r'(Ljava/security/Permission;)Z',
  );

  static final _implies =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean implies(java.security.Permission permission)`
  bool implies(jni$_.JObject? permission) {
    final _$permission = permission?.reference ?? jni$_.jNullReference;
    return _implies(
      reference.pointer,
      _id_implies as jni$_.JMethodIDPtr,
      _$permission.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;
}

final class $URLPermission$NullableType extends jni$_.JObjType<URLPermission?> {
  @jni$_.internal
  const $URLPermission$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLPermission;';

  @jni$_.internal
  @core$_.override
  URLPermission? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : URLPermission.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URLPermission?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLPermission$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URLPermission$NullableType) &&
      other is $URLPermission$NullableType;
}

final class $URLPermission$Type extends jni$_.JObjType<URLPermission> {
  @jni$_.internal
  const $URLPermission$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLPermission;';

  @jni$_.internal
  @core$_.override
  URLPermission fromReference(jni$_.JReference reference) =>
      URLPermission.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URLPermission?> get nullableType =>
      const $URLPermission$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLPermission$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URLPermission$Type) &&
      other is $URLPermission$Type;
}

/// from: `java.net.ContentHandler`
class ContentHandler extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ContentHandler> $type;

  @jni$_.internal
  ContentHandler.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/ContentHandler');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ContentHandler$NullableType();
  static const type = $ContentHandler$Type();
  static final _id_getContent = _class.instanceMethodId(
    r'getContent',
    r'(Ljava/net/URLConnection;)Ljava/lang/Object;',
  );

  static final _getContent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object getContent(java.net.URLConnection uRLConnection)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContent(URLConnection? uRLConnection) {
    final _$uRLConnection = uRLConnection?.reference ?? jni$_.jNullReference;
    return _getContent(
      reference.pointer,
      _id_getContent as jni$_.JMethodIDPtr,
      _$uRLConnection.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getContent$1 = _class.instanceMethodId(
    r'getContent',
    r'(Ljava/net/URLConnection;[Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _getContent$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object getContent(java.net.URLConnection uRLConnection, java.lang.Class[] classs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContent$1(
    URLConnection? uRLConnection,
    jni$_.JArray<jni$_.JObject?>? classs,
  ) {
    final _$uRLConnection = uRLConnection?.reference ?? jni$_.jNullReference;
    final _$classs = classs?.reference ?? jni$_.jNullReference;
    return _getContent$1(
      reference.pointer,
      _id_getContent$1 as jni$_.JMethodIDPtr,
      _$uRLConnection.pointer,
      _$classs.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $ContentHandler$NullableType
    extends jni$_.JObjType<ContentHandler?> {
  @jni$_.internal
  const $ContentHandler$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ContentHandler;';

  @jni$_.internal
  @core$_.override
  ContentHandler? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ContentHandler.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ContentHandler?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ContentHandler$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ContentHandler$NullableType) &&
      other is $ContentHandler$NullableType;
}

final class $ContentHandler$Type extends jni$_.JObjType<ContentHandler> {
  @jni$_.internal
  const $ContentHandler$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/ContentHandler;';

  @jni$_.internal
  @core$_.override
  ContentHandler fromReference(jni$_.JReference reference) =>
      ContentHandler.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ContentHandler?> get nullableType =>
      const $ContentHandler$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ContentHandler$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ContentHandler$Type) &&
      other is $ContentHandler$Type;
}

/// from: `java.net.Inet6Address`
class Inet6Address extends InetAddress {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Inet6Address> $type;

  @jni$_.internal
  Inet6Address.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/Inet6Address');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Inet6Address$NullableType();
  static const type = $Inet6Address$Type();
  static final _id_getByAddress$2 = _class.staticMethodId(
    r'getByAddress',
    r'(Ljava/lang/String;[BLjava/net/NetworkInterface;)Ljava/net/Inet6Address;',
  );

  static final _getByAddress$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.net.Inet6Address getByAddress(java.lang.String string, byte[] bs, java.net.NetworkInterface networkInterface)`
  /// The returned object must be released after use, by calling the [release] method.
  static Inet6Address? getByAddress$2(
    jni$_.JString? string,
    jni$_.JByteArray? bs,
    NetworkInterface? networkInterface,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$networkInterface =
        networkInterface?.reference ?? jni$_.jNullReference;
    return _getByAddress$2(
      _class.reference.pointer,
      _id_getByAddress$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bs.pointer,
      _$networkInterface.pointer,
    ).object<Inet6Address?>(const $Inet6Address$NullableType());
  }

  static final _id_getByAddress$3 = _class.staticMethodId(
    r'getByAddress',
    r'(Ljava/lang/String;[BI)Ljava/net/Inet6Address;',
  );

  static final _getByAddress$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public java.net.Inet6Address getByAddress(java.lang.String string, byte[] bs, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static Inet6Address? getByAddress$3(
    jni$_.JString? string,
    jni$_.JByteArray? bs,
    int i,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _getByAddress$3(
      _class.reference.pointer,
      _id_getByAddress$3 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$bs.pointer,
      i,
    ).object<Inet6Address?>(const $Inet6Address$NullableType());
  }

  static final _id_isMulticastAddress = _class.instanceMethodId(
    r'isMulticastAddress',
    r'()Z',
  );

  static final _isMulticastAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMulticastAddress()`
  bool isMulticastAddress() =>
      _isMulticastAddress(
        reference.pointer,
        _id_isMulticastAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isAnyLocalAddress = _class.instanceMethodId(
    r'isAnyLocalAddress',
    r'()Z',
  );

  static final _isAnyLocalAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isAnyLocalAddress()`
  bool isAnyLocalAddress() =>
      _isAnyLocalAddress(
        reference.pointer,
        _id_isAnyLocalAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isLoopbackAddress = _class.instanceMethodId(
    r'isLoopbackAddress',
    r'()Z',
  );

  static final _isLoopbackAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLoopbackAddress()`
  bool isLoopbackAddress() =>
      _isLoopbackAddress(
        reference.pointer,
        _id_isLoopbackAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isLinkLocalAddress = _class.instanceMethodId(
    r'isLinkLocalAddress',
    r'()Z',
  );

  static final _isLinkLocalAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLinkLocalAddress()`
  bool isLinkLocalAddress() =>
      _isLinkLocalAddress(
        reference.pointer,
        _id_isLinkLocalAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isSiteLocalAddress = _class.instanceMethodId(
    r'isSiteLocalAddress',
    r'()Z',
  );

  static final _isSiteLocalAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isSiteLocalAddress()`
  bool isSiteLocalAddress() =>
      _isSiteLocalAddress(
        reference.pointer,
        _id_isSiteLocalAddress as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCGlobal = _class.instanceMethodId(r'isMCGlobal', r'()Z');

  static final _isMCGlobal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCGlobal()`
  bool isMCGlobal() =>
      _isMCGlobal(
        reference.pointer,
        _id_isMCGlobal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCNodeLocal = _class.instanceMethodId(
    r'isMCNodeLocal',
    r'()Z',
  );

  static final _isMCNodeLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCNodeLocal()`
  bool isMCNodeLocal() =>
      _isMCNodeLocal(
        reference.pointer,
        _id_isMCNodeLocal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCLinkLocal = _class.instanceMethodId(
    r'isMCLinkLocal',
    r'()Z',
  );

  static final _isMCLinkLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCLinkLocal()`
  bool isMCLinkLocal() =>
      _isMCLinkLocal(
        reference.pointer,
        _id_isMCLinkLocal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCSiteLocal = _class.instanceMethodId(
    r'isMCSiteLocal',
    r'()Z',
  );

  static final _isMCSiteLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCSiteLocal()`
  bool isMCSiteLocal() =>
      _isMCSiteLocal(
        reference.pointer,
        _id_isMCSiteLocal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isMCOrgLocal = _class.instanceMethodId(
    r'isMCOrgLocal',
    r'()Z',
  );

  static final _isMCOrgLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMCOrgLocal()`
  bool isMCOrgLocal() =>
      _isMCOrgLocal(
        reference.pointer,
        _id_isMCOrgLocal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_getAddress = _class.instanceMethodId(r'getAddress', r'()[B');

  static final _getAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] getAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getAddress() => _getAddress(
    reference.pointer,
    _id_getAddress as jni$_.JMethodIDPtr,
  ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());

  static final _id_getScopeId = _class.instanceMethodId(r'getScopeId', r'()I');

  static final _getScopeId =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getScopeId()`
  int getScopeId() =>
      _getScopeId(
        reference.pointer,
        _id_getScopeId as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getScopedInterface = _class.instanceMethodId(
    r'getScopedInterface',
    r'()Ljava/net/NetworkInterface;',
  );

  static final _getScopedInterface =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.NetworkInterface getScopedInterface()`
  /// The returned object must be released after use, by calling the [release] method.
  NetworkInterface? getScopedInterface() => _getScopedInterface(
    reference.pointer,
    _id_getScopedInterface as jni$_.JMethodIDPtr,
  ).object<NetworkInterface?>(const $NetworkInterface$NullableType());

  static final _id_getHostAddress = _class.instanceMethodId(
    r'getHostAddress',
    r'()Ljava/lang/String;',
  );

  static final _getHostAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getHostAddress()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHostAddress() => _getHostAddress(
    reference.pointer,
    _id_getHostAddress as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_hashCode1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode1() =>
      _hashCode1(
        reference.pointer,
        _id_hashCode1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_isIPv4CompatibleAddress = _class.instanceMethodId(
    r'isIPv4CompatibleAddress',
    r'()Z',
  );

  static final _isIPv4CompatibleAddress =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isIPv4CompatibleAddress()`
  bool isIPv4CompatibleAddress() =>
      _isIPv4CompatibleAddress(
        reference.pointer,
        _id_isIPv4CompatibleAddress as jni$_.JMethodIDPtr,
      ).boolean;
}

final class $Inet6Address$NullableType extends jni$_.JObjType<Inet6Address?> {
  @jni$_.internal
  const $Inet6Address$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Inet6Address;';

  @jni$_.internal
  @core$_.override
  Inet6Address? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Inet6Address.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InetAddress$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Inet6Address?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($Inet6Address$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Inet6Address$NullableType) &&
      other is $Inet6Address$NullableType;
}

final class $Inet6Address$Type extends jni$_.JObjType<Inet6Address> {
  @jni$_.internal
  const $Inet6Address$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/Inet6Address;';

  @jni$_.internal
  @core$_.override
  Inet6Address fromReference(jni$_.JReference reference) =>
      Inet6Address.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InetAddress$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Inet6Address?> get nullableType =>
      const $Inet6Address$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($Inet6Address$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Inet6Address$Type) && other is $Inet6Address$Type;
}

/// from: `java.net.URLEncoder`
class URLEncoder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<URLEncoder> $type;

  @jni$_.internal
  URLEncoder.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/URLEncoder');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $URLEncoder$NullableType();
  static const type = $URLEncoder$Type();
  static final _id_encode = _class.staticMethodId(
    r'encode',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _encode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String encode(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? encode(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _encode(
      _class.reference.pointer,
      _id_encode as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_encode$1 = _class.staticMethodId(
    r'encode',
    r'(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _encode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String encode(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? encode$1(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _encode$1(
      _class.reference.pointer,
      _id_encode$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_encode$2 = _class.staticMethodId(
    r'encode',
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;)Ljava/lang/String;',
  );

  static final _encode$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String encode(java.lang.String string, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? encode$2(
    jni$_.JString? string,
    jni$_.JObject? charset,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return _encode$2(
      _class.reference.pointer,
      _id_encode$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$charset.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $URLEncoder$NullableType extends jni$_.JObjType<URLEncoder?> {
  @jni$_.internal
  const $URLEncoder$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLEncoder;';

  @jni$_.internal
  @core$_.override
  URLEncoder? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : URLEncoder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URLEncoder?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLEncoder$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URLEncoder$NullableType) &&
      other is $URLEncoder$NullableType;
}

final class $URLEncoder$Type extends jni$_.JObjType<URLEncoder> {
  @jni$_.internal
  const $URLEncoder$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URLEncoder;';

  @jni$_.internal
  @core$_.override
  URLEncoder fromReference(jni$_.JReference reference) =>
      URLEncoder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<URLEncoder?> get nullableType =>
      const $URLEncoder$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URLEncoder$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($URLEncoder$Type) && other is $URLEncoder$Type;
}

/// from: `java.net.MulticastSocket`
class MulticastSocket extends DatagramSocket {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MulticastSocket> $type;

  @jni$_.internal
  MulticastSocket.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/MulticastSocket');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MulticastSocket$NullableType();
  static const type = $MulticastSocket$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory MulticastSocket() => MulticastSocket.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new2 = _class.constructorId(r'(I)V');

  static final _new2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MulticastSocket.new2(int i) => MulticastSocket.fromReference(
    _new2(
      _class.reference.pointer,
      _id_new2 as jni$_.JMethodIDPtr,
      i,
    ).reference,
  );

  static final _id_new1 = _class.constructorId(r'(Ljava/net/SocketAddress;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.SocketAddress socketAddress)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MulticastSocket.new1(SocketAddress? socketAddress) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    return MulticastSocket.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$socketAddress.pointer,
      ).reference,
    );
  }

  static final _id_setTTL = _class.instanceMethodId(r'setTTL', r'(B)V');

  static final _setTTL =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setTTL(byte b)`
  void setTTL(int b) {
    _setTTL(reference.pointer, _id_setTTL as jni$_.JMethodIDPtr, b).check();
  }

  static final _id_setTimeToLive = _class.instanceMethodId(
    r'setTimeToLive',
    r'(I)V',
  );

  static final _setTimeToLive =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setTimeToLive(int i)`
  void setTimeToLive(int i) {
    _setTimeToLive(
      reference.pointer,
      _id_setTimeToLive as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getTTL = _class.instanceMethodId(r'getTTL', r'()B');

  static final _getTTL =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte getTTL()`
  int getTTL() =>
      _getTTL(reference.pointer, _id_getTTL as jni$_.JMethodIDPtr).byte;

  static final _id_getTimeToLive = _class.instanceMethodId(
    r'getTimeToLive',
    r'()I',
  );

  static final _getTimeToLive =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getTimeToLive()`
  int getTimeToLive() =>
      _getTimeToLive(
        reference.pointer,
        _id_getTimeToLive as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_joinGroup$1 = _class.instanceMethodId(
    r'joinGroup',
    r'(Ljava/net/InetAddress;)V',
  );

  static final _joinGroup$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void joinGroup(java.net.InetAddress inetAddress)`
  void joinGroup$1(InetAddress? inetAddress) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    _joinGroup$1(
      reference.pointer,
      _id_joinGroup$1 as jni$_.JMethodIDPtr,
      _$inetAddress.pointer,
    ).check();
  }

  static final _id_leaveGroup$1 = _class.instanceMethodId(
    r'leaveGroup',
    r'(Ljava/net/InetAddress;)V',
  );

  static final _leaveGroup$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void leaveGroup(java.net.InetAddress inetAddress)`
  void leaveGroup$1(InetAddress? inetAddress) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    _leaveGroup$1(
      reference.pointer,
      _id_leaveGroup$1 as jni$_.JMethodIDPtr,
      _$inetAddress.pointer,
    ).check();
  }

  static final _id_joinGroup = _class.instanceMethodId(
    r'joinGroup',
    r'(Ljava/net/SocketAddress;Ljava/net/NetworkInterface;)V',
  );

  static final _joinGroup =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void joinGroup(java.net.SocketAddress socketAddress, java.net.NetworkInterface networkInterface)`
  void joinGroup(
    SocketAddress? socketAddress,
    NetworkInterface? networkInterface,
  ) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    final _$networkInterface =
        networkInterface?.reference ?? jni$_.jNullReference;
    _joinGroup(
      reference.pointer,
      _id_joinGroup as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
      _$networkInterface.pointer,
    ).check();
  }

  static final _id_leaveGroup = _class.instanceMethodId(
    r'leaveGroup',
    r'(Ljava/net/SocketAddress;Ljava/net/NetworkInterface;)V',
  );

  static final _leaveGroup =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void leaveGroup(java.net.SocketAddress socketAddress, java.net.NetworkInterface networkInterface)`
  void leaveGroup(
    SocketAddress? socketAddress,
    NetworkInterface? networkInterface,
  ) {
    final _$socketAddress = socketAddress?.reference ?? jni$_.jNullReference;
    final _$networkInterface =
        networkInterface?.reference ?? jni$_.jNullReference;
    _leaveGroup(
      reference.pointer,
      _id_leaveGroup as jni$_.JMethodIDPtr,
      _$socketAddress.pointer,
      _$networkInterface.pointer,
    ).check();
  }

  static final _id_setInterface = _class.instanceMethodId(
    r'setInterface',
    r'(Ljava/net/InetAddress;)V',
  );

  static final _setInterface =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setInterface(java.net.InetAddress inetAddress)`
  void setInterface(InetAddress? inetAddress) {
    final _$inetAddress = inetAddress?.reference ?? jni$_.jNullReference;
    _setInterface(
      reference.pointer,
      _id_setInterface as jni$_.JMethodIDPtr,
      _$inetAddress.pointer,
    ).check();
  }

  static final _id_getInterface = _class.instanceMethodId(
    r'getInterface',
    r'()Ljava/net/InetAddress;',
  );

  static final _getInterface =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.InetAddress getInterface()`
  /// The returned object must be released after use, by calling the [release] method.
  InetAddress? getInterface() => _getInterface(
    reference.pointer,
    _id_getInterface as jni$_.JMethodIDPtr,
  ).object<InetAddress?>(const $InetAddress$NullableType());

  static final _id_setNetworkInterface = _class.instanceMethodId(
    r'setNetworkInterface',
    r'(Ljava/net/NetworkInterface;)V',
  );

  static final _setNetworkInterface =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setNetworkInterface(java.net.NetworkInterface networkInterface)`
  void setNetworkInterface(NetworkInterface? networkInterface) {
    final _$networkInterface =
        networkInterface?.reference ?? jni$_.jNullReference;
    _setNetworkInterface(
      reference.pointer,
      _id_setNetworkInterface as jni$_.JMethodIDPtr,
      _$networkInterface.pointer,
    ).check();
  }

  static final _id_getNetworkInterface = _class.instanceMethodId(
    r'getNetworkInterface',
    r'()Ljava/net/NetworkInterface;',
  );

  static final _getNetworkInterface =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.NetworkInterface getNetworkInterface()`
  /// The returned object must be released after use, by calling the [release] method.
  NetworkInterface? getNetworkInterface() => _getNetworkInterface(
    reference.pointer,
    _id_getNetworkInterface as jni$_.JMethodIDPtr,
  ).object<NetworkInterface?>(const $NetworkInterface$NullableType());

  static final _id_setLoopbackMode = _class.instanceMethodId(
    r'setLoopbackMode',
    r'(Z)V',
  );

  static final _setLoopbackMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setLoopbackMode(boolean z)`
  void setLoopbackMode(bool z) {
    _setLoopbackMode(
      reference.pointer,
      _id_setLoopbackMode as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getLoopbackMode = _class.instanceMethodId(
    r'getLoopbackMode',
    r'()Z',
  );

  static final _getLoopbackMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean getLoopbackMode()`
  bool getLoopbackMode() =>
      _getLoopbackMode(
        reference.pointer,
        _id_getLoopbackMode as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_send$1 = _class.instanceMethodId(
    r'send',
    r'(Ljava/net/DatagramPacket;B)V',
  );

  static final _send$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void send(java.net.DatagramPacket datagramPacket, byte b)`
  void send$1(DatagramPacket? datagramPacket, int b) {
    final _$datagramPacket = datagramPacket?.reference ?? jni$_.jNullReference;
    _send$1(
      reference.pointer,
      _id_send$1 as jni$_.JMethodIDPtr,
      _$datagramPacket.pointer,
      b,
    ).check();
  }
}

final class $MulticastSocket$NullableType
    extends jni$_.JObjType<MulticastSocket?> {
  @jni$_.internal
  const $MulticastSocket$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/MulticastSocket;';

  @jni$_.internal
  @core$_.override
  MulticastSocket? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : MulticastSocket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $DatagramSocket$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MulticastSocket?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($MulticastSocket$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($MulticastSocket$NullableType) &&
      other is $MulticastSocket$NullableType;
}

final class $MulticastSocket$Type extends jni$_.JObjType<MulticastSocket> {
  @jni$_.internal
  const $MulticastSocket$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/MulticastSocket;';

  @jni$_.internal
  @core$_.override
  MulticastSocket fromReference(jni$_.JReference reference) =>
      MulticastSocket.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $DatagramSocket$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MulticastSocket?> get nullableType =>
      const $MulticastSocket$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($MulticastSocket$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($MulticastSocket$Type) &&
      other is $MulticastSocket$Type;
}

/// from: `java.text.Format`
class Format extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Format> $type;

  @jni$_.internal
  Format.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/Format');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Format$NullableType();
  static const type = $Format$Type();
  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/lang/Object;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final java.lang.String format(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_format$1 = _class.instanceMethodId(
    r'format',
    r'(Ljava/lang/Object;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.StringBuffer format(java.lang.Object object, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format$1(
    jni$_.JObject? object,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format$1(
      reference.pointer,
      _id_format$1 as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_formatToCharacterIterator = _class.instanceMethodId(
    r'formatToCharacterIterator',
    r'(Ljava/lang/Object;)Ljava/text/AttributedCharacterIterator;',
  );

  static final _formatToCharacterIterator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  AttributedCharacterIterator? formatToCharacterIterator(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _formatToCharacterIterator(
      reference.pointer,
      _id_formatToCharacterIterator as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<AttributedCharacterIterator?>(
      const $AttributedCharacterIterator$NullableType(),
    );
  }

  static final _id_parseObject = _class.instanceMethodId(
    r'parseObject',
    r'(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/lang/Object;',
  );

  static final _parseObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object parseObject(java.lang.String string, java.text.ParsePosition parsePosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? parseObject(
    jni$_.JString? string,
    ParsePosition? parsePosition,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$parsePosition = parsePosition?.reference ?? jni$_.jNullReference;
    return _parseObject(
      reference.pointer,
      _id_parseObject as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$parsePosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_parseObject$1 = _class.instanceMethodId(
    r'parseObject',
    r'(Ljava/lang/String;)Ljava/lang/Object;',
  );

  static final _parseObject$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object parseObject(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? parseObject$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _parseObject$1(
      reference.pointer,
      _id_parseObject$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
}

final class $Format$NullableType extends jni$_.JObjType<Format?> {
  @jni$_.internal
  const $Format$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/Format;';

  @jni$_.internal
  @core$_.override
  Format? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Format.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Format?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Format$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Format$NullableType) &&
      other is $Format$NullableType;
}

final class $Format$Type extends jni$_.JObjType<Format> {
  @jni$_.internal
  const $Format$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/Format;';

  @jni$_.internal
  @core$_.override
  Format fromReference(jni$_.JReference reference) =>
      Format.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Format?> get nullableType => const $Format$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Format$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Format$Type) && other is $Format$Type;
}

/// from: `java.text.DecimalFormatSymbols`
class DecimalFormatSymbols extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DecimalFormatSymbols> $type;

  @jni$_.internal
  DecimalFormatSymbols.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/DecimalFormatSymbols');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DecimalFormatSymbols$NullableType();
  static const type = $DecimalFormatSymbols$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DecimalFormatSymbols() => DecimalFormatSymbols.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$1 = _class.constructorId(r'(Ljava/util/Locale;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DecimalFormatSymbols.new$1(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return DecimalFormatSymbols.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$locale.pointer,
      ).reference,
    );
  }

  static final _id_getAvailableLocales = _class.staticMethodId(
    r'getAvailableLocales',
    r'()[Ljava/util/Locale;',
  );

  static final _getAvailableLocales =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Locale[] getAvailableLocales()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JObject?>? getAvailableLocales() =>
      _getAvailableLocales(
        _class.reference.pointer,
        _id_getAvailableLocales as jni$_.JMethodIDPtr,
      ).object<jni$_.JArray<jni$_.JObject?>?>(
        const jni$_.JArrayNullableType<jni$_.JObject?>(
          jni$_.JObjectNullableType(),
        ),
      );

  static final _id_getInstance = _class.staticMethodId(
    r'getInstance',
    r'()Ljava/text/DecimalFormatSymbols;',
  );

  static final _getInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public final java.text.DecimalFormatSymbols getInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static DecimalFormatSymbols? getInstance() => _getInstance(
    _class.reference.pointer,
    _id_getInstance as jni$_.JMethodIDPtr,
  ).object<DecimalFormatSymbols?>(const $DecimalFormatSymbols$NullableType());

  static final _id_getInstance$1 = _class.staticMethodId(
    r'getInstance',
    r'(Ljava/util/Locale;)Ljava/text/DecimalFormatSymbols;',
  );

  static final _getInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public final java.text.DecimalFormatSymbols getInstance(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static DecimalFormatSymbols? getInstance$1(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getInstance$1(
      _class.reference.pointer,
      _id_getInstance$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<DecimalFormatSymbols?>(const $DecimalFormatSymbols$NullableType());
  }

  static final _id_getZeroDigit = _class.instanceMethodId(
    r'getZeroDigit',
    r'()C',
  );

  static final _getZeroDigit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char getZeroDigit()`
  int getZeroDigit() =>
      _getZeroDigit(
        reference.pointer,
        _id_getZeroDigit as jni$_.JMethodIDPtr,
      ).char;

  static final _id_setZeroDigit = _class.instanceMethodId(
    r'setZeroDigit',
    r'(C)V',
  );

  static final _setZeroDigit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setZeroDigit(char c)`
  void setZeroDigit(int c) {
    _setZeroDigit(
      reference.pointer,
      _id_setZeroDigit as jni$_.JMethodIDPtr,
      c,
    ).check();
  }

  static final _id_getGroupingSeparator = _class.instanceMethodId(
    r'getGroupingSeparator',
    r'()C',
  );

  static final _getGroupingSeparator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char getGroupingSeparator()`
  int getGroupingSeparator() =>
      _getGroupingSeparator(
        reference.pointer,
        _id_getGroupingSeparator as jni$_.JMethodIDPtr,
      ).char;

  static final _id_setGroupingSeparator = _class.instanceMethodId(
    r'setGroupingSeparator',
    r'(C)V',
  );

  static final _setGroupingSeparator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setGroupingSeparator(char c)`
  void setGroupingSeparator(int c) {
    _setGroupingSeparator(
      reference.pointer,
      _id_setGroupingSeparator as jni$_.JMethodIDPtr,
      c,
    ).check();
  }

  static final _id_getDecimalSeparator = _class.instanceMethodId(
    r'getDecimalSeparator',
    r'()C',
  );

  static final _getDecimalSeparator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char getDecimalSeparator()`
  int getDecimalSeparator() =>
      _getDecimalSeparator(
        reference.pointer,
        _id_getDecimalSeparator as jni$_.JMethodIDPtr,
      ).char;

  static final _id_setDecimalSeparator = _class.instanceMethodId(
    r'setDecimalSeparator',
    r'(C)V',
  );

  static final _setDecimalSeparator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setDecimalSeparator(char c)`
  void setDecimalSeparator(int c) {
    _setDecimalSeparator(
      reference.pointer,
      _id_setDecimalSeparator as jni$_.JMethodIDPtr,
      c,
    ).check();
  }

  static final _id_getPerMill = _class.instanceMethodId(r'getPerMill', r'()C');

  static final _getPerMill =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char getPerMill()`
  int getPerMill() =>
      _getPerMill(reference.pointer, _id_getPerMill as jni$_.JMethodIDPtr).char;

  static final _id_setPerMill = _class.instanceMethodId(r'setPerMill', r'(C)V');

  static final _setPerMill =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setPerMill(char c)`
  void setPerMill(int c) {
    _setPerMill(
      reference.pointer,
      _id_setPerMill as jni$_.JMethodIDPtr,
      c,
    ).check();
  }

  static final _id_getPercent = _class.instanceMethodId(r'getPercent', r'()C');

  static final _getPercent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char getPercent()`
  int getPercent() =>
      _getPercent(reference.pointer, _id_getPercent as jni$_.JMethodIDPtr).char;

  static final _id_setPercent = _class.instanceMethodId(r'setPercent', r'(C)V');

  static final _setPercent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setPercent(char c)`
  void setPercent(int c) {
    _setPercent(
      reference.pointer,
      _id_setPercent as jni$_.JMethodIDPtr,
      c,
    ).check();
  }

  static final _id_getDigit = _class.instanceMethodId(r'getDigit', r'()C');

  static final _getDigit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char getDigit()`
  int getDigit() =>
      _getDigit(reference.pointer, _id_getDigit as jni$_.JMethodIDPtr).char;

  static final _id_setDigit = _class.instanceMethodId(r'setDigit', r'(C)V');

  static final _setDigit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setDigit(char c)`
  void setDigit(int c) {
    _setDigit(reference.pointer, _id_setDigit as jni$_.JMethodIDPtr, c).check();
  }

  static final _id_getPatternSeparator = _class.instanceMethodId(
    r'getPatternSeparator',
    r'()C',
  );

  static final _getPatternSeparator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char getPatternSeparator()`
  int getPatternSeparator() =>
      _getPatternSeparator(
        reference.pointer,
        _id_getPatternSeparator as jni$_.JMethodIDPtr,
      ).char;

  static final _id_setPatternSeparator = _class.instanceMethodId(
    r'setPatternSeparator',
    r'(C)V',
  );

  static final _setPatternSeparator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setPatternSeparator(char c)`
  void setPatternSeparator(int c) {
    _setPatternSeparator(
      reference.pointer,
      _id_setPatternSeparator as jni$_.JMethodIDPtr,
      c,
    ).check();
  }

  static final _id_getInfinity = _class.instanceMethodId(
    r'getInfinity',
    r'()Ljava/lang/String;',
  );

  static final _getInfinity =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getInfinity()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getInfinity() => _getInfinity(
    reference.pointer,
    _id_getInfinity as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setInfinity = _class.instanceMethodId(
    r'setInfinity',
    r'(Ljava/lang/String;)V',
  );

  static final _setInfinity =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setInfinity(java.lang.String string)`
  void setInfinity(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setInfinity(
      reference.pointer,
      _id_setInfinity as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getNaN = _class.instanceMethodId(
    r'getNaN',
    r'()Ljava/lang/String;',
  );

  static final _getNaN =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getNaN()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getNaN() => _getNaN(
    reference.pointer,
    _id_getNaN as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setNaN = _class.instanceMethodId(
    r'setNaN',
    r'(Ljava/lang/String;)V',
  );

  static final _setNaN =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setNaN(java.lang.String string)`
  void setNaN(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setNaN(
      reference.pointer,
      _id_setNaN as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getMinusSign = _class.instanceMethodId(
    r'getMinusSign',
    r'()C',
  );

  static final _getMinusSign =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char getMinusSign()`
  int getMinusSign() =>
      _getMinusSign(
        reference.pointer,
        _id_getMinusSign as jni$_.JMethodIDPtr,
      ).char;

  static final _id_setMinusSign = _class.instanceMethodId(
    r'setMinusSign',
    r'(C)V',
  );

  static final _setMinusSign =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMinusSign(char c)`
  void setMinusSign(int c) {
    _setMinusSign(
      reference.pointer,
      _id_setMinusSign as jni$_.JMethodIDPtr,
      c,
    ).check();
  }

  static final _id_getCurrencySymbol = _class.instanceMethodId(
    r'getCurrencySymbol',
    r'()Ljava/lang/String;',
  );

  static final _getCurrencySymbol =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getCurrencySymbol()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCurrencySymbol() => _getCurrencySymbol(
    reference.pointer,
    _id_getCurrencySymbol as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setCurrencySymbol = _class.instanceMethodId(
    r'setCurrencySymbol',
    r'(Ljava/lang/String;)V',
  );

  static final _setCurrencySymbol =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setCurrencySymbol(java.lang.String string)`
  void setCurrencySymbol(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setCurrencySymbol(
      reference.pointer,
      _id_setCurrencySymbol as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getInternationalCurrencySymbol = _class.instanceMethodId(
    r'getInternationalCurrencySymbol',
    r'()Ljava/lang/String;',
  );

  static final _getInternationalCurrencySymbol =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getInternationalCurrencySymbol()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getInternationalCurrencySymbol() =>
      _getInternationalCurrencySymbol(
        reference.pointer,
        _id_getInternationalCurrencySymbol as jni$_.JMethodIDPtr,
      ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setInternationalCurrencySymbol = _class.instanceMethodId(
    r'setInternationalCurrencySymbol',
    r'(Ljava/lang/String;)V',
  );

  static final _setInternationalCurrencySymbol =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setInternationalCurrencySymbol(java.lang.String string)`
  void setInternationalCurrencySymbol(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setInternationalCurrencySymbol(
      reference.pointer,
      _id_setInternationalCurrencySymbol as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getCurrency = _class.instanceMethodId(
    r'getCurrency',
    r'()Ljava/util/Currency;',
  );

  static final _getCurrency =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Currency getCurrency()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getCurrency() => _getCurrency(
    reference.pointer,
    _id_getCurrency as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_setCurrency = _class.instanceMethodId(
    r'setCurrency',
    r'(Ljava/util/Currency;)V',
  );

  static final _setCurrency =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setCurrency(java.util.Currency currency)`
  void setCurrency(jni$_.JObject? currency) {
    final _$currency = currency?.reference ?? jni$_.jNullReference;
    _setCurrency(
      reference.pointer,
      _id_setCurrency as jni$_.JMethodIDPtr,
      _$currency.pointer,
    ).check();
  }

  static final _id_getMonetaryDecimalSeparator = _class.instanceMethodId(
    r'getMonetaryDecimalSeparator',
    r'()C',
  );

  static final _getMonetaryDecimalSeparator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char getMonetaryDecimalSeparator()`
  int getMonetaryDecimalSeparator() =>
      _getMonetaryDecimalSeparator(
        reference.pointer,
        _id_getMonetaryDecimalSeparator as jni$_.JMethodIDPtr,
      ).char;

  static final _id_setMonetaryDecimalSeparator = _class.instanceMethodId(
    r'setMonetaryDecimalSeparator',
    r'(C)V',
  );

  static final _setMonetaryDecimalSeparator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMonetaryDecimalSeparator(char c)`
  void setMonetaryDecimalSeparator(int c) {
    _setMonetaryDecimalSeparator(
      reference.pointer,
      _id_setMonetaryDecimalSeparator as jni$_.JMethodIDPtr,
      c,
    ).check();
  }

  static final _id_getExponentSeparator = _class.instanceMethodId(
    r'getExponentSeparator',
    r'()Ljava/lang/String;',
  );

  static final _getExponentSeparator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getExponentSeparator()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getExponentSeparator() => _getExponentSeparator(
    reference.pointer,
    _id_getExponentSeparator as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setExponentSeparator = _class.instanceMethodId(
    r'setExponentSeparator',
    r'(Ljava/lang/String;)V',
  );

  static final _setExponentSeparator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setExponentSeparator(java.lang.String string)`
  void setExponentSeparator(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setExponentSeparator(
      reference.pointer,
      _id_setExponentSeparator as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getMonetaryGroupingSeparator = _class.instanceMethodId(
    r'getMonetaryGroupingSeparator',
    r'()C',
  );

  static final _getMonetaryGroupingSeparator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char getMonetaryGroupingSeparator()`
  int getMonetaryGroupingSeparator() =>
      _getMonetaryGroupingSeparator(
        reference.pointer,
        _id_getMonetaryGroupingSeparator as jni$_.JMethodIDPtr,
      ).char;

  static final _id_setMonetaryGroupingSeparator = _class.instanceMethodId(
    r'setMonetaryGroupingSeparator',
    r'(C)V',
  );

  static final _setMonetaryGroupingSeparator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMonetaryGroupingSeparator(char c)`
  void setMonetaryGroupingSeparator(int c) {
    _setMonetaryGroupingSeparator(
      reference.pointer,
      _id_setMonetaryGroupingSeparator as jni$_.JMethodIDPtr,
      c,
    ).check();
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;
}

final class $DecimalFormatSymbols$NullableType
    extends jni$_.JObjType<DecimalFormatSymbols?> {
  @jni$_.internal
  const $DecimalFormatSymbols$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/DecimalFormatSymbols;';

  @jni$_.internal
  @core$_.override
  DecimalFormatSymbols? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DecimalFormatSymbols.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DecimalFormatSymbols?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DecimalFormatSymbols$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DecimalFormatSymbols$NullableType) &&
      other is $DecimalFormatSymbols$NullableType;
}

final class $DecimalFormatSymbols$Type
    extends jni$_.JObjType<DecimalFormatSymbols> {
  @jni$_.internal
  const $DecimalFormatSymbols$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/DecimalFormatSymbols;';

  @jni$_.internal
  @core$_.override
  DecimalFormatSymbols fromReference(jni$_.JReference reference) =>
      DecimalFormatSymbols.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DecimalFormatSymbols?> get nullableType =>
      const $DecimalFormatSymbols$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DecimalFormatSymbols$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DecimalFormatSymbols$Type) &&
      other is $DecimalFormatSymbols$Type;
}

/// from: `java.text.MessageFormat$Field`
class MessageFormat$Field extends Format$Field {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MessageFormat$Field> $type;

  @jni$_.internal
  MessageFormat$Field.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/MessageFormat$Field');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MessageFormat$Field$NullableType();
  static const type = $MessageFormat$Field$Type();
  static final _id_ARGUMENT = _class.staticFieldId(
    r'ARGUMENT',
    r'Ljava/text/MessageFormat$Field;',
  );

  /// from: `static public final java.text.MessageFormat$Field ARGUMENT`
  /// The returned object must be released after use, by calling the [release] method.
  static MessageFormat$Field? get ARGUMENT =>
      _id_ARGUMENT.get(_class, const $MessageFormat$Field$NullableType());
}

final class $MessageFormat$Field$NullableType
    extends jni$_.JObjType<MessageFormat$Field?> {
  @jni$_.internal
  const $MessageFormat$Field$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/MessageFormat$Field;';

  @jni$_.internal
  @core$_.override
  MessageFormat$Field? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : MessageFormat$Field.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Format$Field$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MessageFormat$Field?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($MessageFormat$Field$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($MessageFormat$Field$NullableType) &&
      other is $MessageFormat$Field$NullableType;
}

final class $MessageFormat$Field$Type
    extends jni$_.JObjType<MessageFormat$Field> {
  @jni$_.internal
  const $MessageFormat$Field$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/MessageFormat$Field;';

  @jni$_.internal
  @core$_.override
  MessageFormat$Field fromReference(jni$_.JReference reference) =>
      MessageFormat$Field.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Format$Field$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MessageFormat$Field?> get nullableType =>
      const $MessageFormat$Field$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($MessageFormat$Field$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($MessageFormat$Field$Type) &&
      other is $MessageFormat$Field$Type;
}

/// from: `java.text.Bidi`
class Bidi extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Bidi> $type;

  @jni$_.internal
  Bidi.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/Bidi');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Bidi$NullableType();
  static const type = $Bidi$Type();

  /// from: `static public final int DIRECTION_LEFT_TO_RIGHT`
  static const DIRECTION_LEFT_TO_RIGHT = 0;

  /// from: `static public final int DIRECTION_RIGHT_TO_LEFT`
  static const DIRECTION_RIGHT_TO_LEFT = 1;

  /// from: `static public final int DIRECTION_DEFAULT_LEFT_TO_RIGHT`
  static const DIRECTION_DEFAULT_LEFT_TO_RIGHT = -2;

  /// from: `static public final int DIRECTION_DEFAULT_RIGHT_TO_LEFT`
  static const DIRECTION_DEFAULT_RIGHT_TO_LEFT = -1;
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;I)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Bidi(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return Bidi.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/text/AttributedCharacterIterator;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.text.AttributedCharacterIterator attributedCharacterIterator)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Bidi.new$1(AttributedCharacterIterator? attributedCharacterIterator) {
    final _$attributedCharacterIterator =
        attributedCharacterIterator?.reference ?? jni$_.jNullReference;
    return Bidi.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$attributedCharacterIterator.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'([CI[BIII)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
            )
          >();

  /// from: `public void <init>(char[] cs, int i, byte[] bs, int i1, int i2, int i3)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Bidi.new$2(
    jni$_.JCharArray? cs,
    int i,
    jni$_.JByteArray? bs,
    int i1,
    int i2,
    int i3,
  ) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return Bidi.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$cs.pointer,
        i,
        _$bs.pointer,
        i1,
        i2,
        i3,
      ).reference,
    );
  }

  static final _id_createLineBidi = _class.instanceMethodId(
    r'createLineBidi',
    r'(II)Ljava/text/Bidi;',
  );

  static final _createLineBidi =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public java.text.Bidi createLineBidi(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  Bidi? createLineBidi(int i, int i1) => _createLineBidi(
    reference.pointer,
    _id_createLineBidi as jni$_.JMethodIDPtr,
    i,
    i1,
  ).object<Bidi?>(const $Bidi$NullableType());

  static final _id_isMixed = _class.instanceMethodId(r'isMixed', r'()Z');

  static final _isMixed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMixed()`
  bool isMixed() =>
      _isMixed(reference.pointer, _id_isMixed as jni$_.JMethodIDPtr).boolean;

  static final _id_isLeftToRight = _class.instanceMethodId(
    r'isLeftToRight',
    r'()Z',
  );

  static final _isLeftToRight =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLeftToRight()`
  bool isLeftToRight() =>
      _isLeftToRight(
        reference.pointer,
        _id_isLeftToRight as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_isRightToLeft = _class.instanceMethodId(
    r'isRightToLeft',
    r'()Z',
  );

  static final _isRightToLeft =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isRightToLeft()`
  bool isRightToLeft() =>
      _isRightToLeft(
        reference.pointer,
        _id_isRightToLeft as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_getLength = _class.instanceMethodId(r'getLength', r'()I');

  static final _getLength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLength()`
  int getLength() =>
      _getLength(
        reference.pointer,
        _id_getLength as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_baseIsLeftToRight = _class.instanceMethodId(
    r'baseIsLeftToRight',
    r'()Z',
  );

  static final _baseIsLeftToRight =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean baseIsLeftToRight()`
  bool baseIsLeftToRight() =>
      _baseIsLeftToRight(
        reference.pointer,
        _id_baseIsLeftToRight as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_getBaseLevel = _class.instanceMethodId(
    r'getBaseLevel',
    r'()I',
  );

  static final _getBaseLevel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getBaseLevel()`
  int getBaseLevel() =>
      _getBaseLevel(
        reference.pointer,
        _id_getBaseLevel as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getLevelAt = _class.instanceMethodId(r'getLevelAt', r'(I)I');

  static final _getLevelAt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int getLevelAt(int i)`
  int getLevelAt(int i) =>
      _getLevelAt(
        reference.pointer,
        _id_getLevelAt as jni$_.JMethodIDPtr,
        i,
      ).integer;

  static final _id_getRunCount = _class.instanceMethodId(
    r'getRunCount',
    r'()I',
  );

  static final _getRunCount =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getRunCount()`
  int getRunCount() =>
      _getRunCount(
        reference.pointer,
        _id_getRunCount as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getRunLevel = _class.instanceMethodId(
    r'getRunLevel',
    r'(I)I',
  );

  static final _getRunLevel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int getRunLevel(int i)`
  int getRunLevel(int i) =>
      _getRunLevel(
        reference.pointer,
        _id_getRunLevel as jni$_.JMethodIDPtr,
        i,
      ).integer;

  static final _id_getRunStart = _class.instanceMethodId(
    r'getRunStart',
    r'(I)I',
  );

  static final _getRunStart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int getRunStart(int i)`
  int getRunStart(int i) =>
      _getRunStart(
        reference.pointer,
        _id_getRunStart as jni$_.JMethodIDPtr,
        i,
      ).integer;

  static final _id_getRunLimit = _class.instanceMethodId(
    r'getRunLimit',
    r'(I)I',
  );

  static final _getRunLimit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int getRunLimit(int i)`
  int getRunLimit(int i) =>
      _getRunLimit(
        reference.pointer,
        _id_getRunLimit as jni$_.JMethodIDPtr,
        i,
      ).integer;

  static final _id_requiresBidi = _class.staticMethodId(
    r'requiresBidi',
    r'([CII)Z',
  );

  static final _requiresBidi =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `static public boolean requiresBidi(char[] cs, int i, int i1)`
  static bool requiresBidi(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _requiresBidi(
      _class.reference.pointer,
      _id_requiresBidi as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).boolean;
  }

  static final _id_reorderVisually = _class.staticMethodId(
    r'reorderVisually',
    r'([BI[Ljava/lang/Object;II)V',
  );

  static final _reorderVisually =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `static public void reorderVisually(byte[] bs, int i, java.lang.Object[] objects, int i1, int i2)`
  static void reorderVisually(
    jni$_.JByteArray? bs,
    int i,
    jni$_.JArray<jni$_.JObject?>? objects,
    int i1,
    int i2,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    _reorderVisually(
      _class.reference.pointer,
      _id_reorderVisually as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      _$objects.pointer,
      i1,
      i2,
    ).check();
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $Bidi$NullableType extends jni$_.JObjType<Bidi?> {
  @jni$_.internal
  const $Bidi$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/Bidi;';

  @jni$_.internal
  @core$_.override
  Bidi? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Bidi.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bidi?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bidi$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Bidi$NullableType) && other is $Bidi$NullableType;
}

final class $Bidi$Type extends jni$_.JObjType<Bidi> {
  @jni$_.internal
  const $Bidi$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/Bidi;';

  @jni$_.internal
  @core$_.override
  Bidi fromReference(jni$_.JReference reference) =>
      Bidi.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Bidi?> get nullableType => const $Bidi$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Bidi$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Bidi$Type) && other is $Bidi$Type;
}

/// from: `java.text.FieldPosition`
class FieldPosition extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FieldPosition> $type;

  @jni$_.internal
  FieldPosition.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/FieldPosition');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FieldPosition$NullableType();
  static const type = $FieldPosition$Type();
  static final _id_new$ = _class.constructorId(r'(I)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FieldPosition(int i) => FieldPosition.fromReference(
    _new$(
      _class.reference.pointer,
      _id_new$ as jni$_.JMethodIDPtr,
      i,
    ).reference,
  );

  static final _id_new$1 = _class.constructorId(r'(Ljava/text/Format$Field;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.text.Format$Field field)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FieldPosition.new$1(Format$Field? field) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return FieldPosition.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$field.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/text/Format$Field;I)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.text.Format$Field field, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FieldPosition.new$2(Format$Field? field, int i) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return FieldPosition.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$field.pointer,
        i,
      ).reference,
    );
  }

  static final _id_getFieldAttribute = _class.instanceMethodId(
    r'getFieldAttribute',
    r'()Ljava/text/Format$Field;',
  );

  static final _getFieldAttribute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.text.Format$Field getFieldAttribute()`
  /// The returned object must be released after use, by calling the [release] method.
  Format$Field? getFieldAttribute() => _getFieldAttribute(
    reference.pointer,
    _id_getFieldAttribute as jni$_.JMethodIDPtr,
  ).object<Format$Field?>(const $Format$Field$NullableType());

  static final _id_getField = _class.instanceMethodId(r'getField', r'()I');

  static final _getField =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getField()`
  int getField() =>
      _getField(reference.pointer, _id_getField as jni$_.JMethodIDPtr).integer;

  static final _id_getBeginIndex = _class.instanceMethodId(
    r'getBeginIndex',
    r'()I',
  );

  static final _getBeginIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getBeginIndex()`
  int getBeginIndex() =>
      _getBeginIndex(
        reference.pointer,
        _id_getBeginIndex as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getEndIndex = _class.instanceMethodId(
    r'getEndIndex',
    r'()I',
  );

  static final _getEndIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getEndIndex()`
  int getEndIndex() =>
      _getEndIndex(
        reference.pointer,
        _id_getEndIndex as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setBeginIndex = _class.instanceMethodId(
    r'setBeginIndex',
    r'(I)V',
  );

  static final _setBeginIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setBeginIndex(int i)`
  void setBeginIndex(int i) {
    _setBeginIndex(
      reference.pointer,
      _id_setBeginIndex as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setEndIndex = _class.instanceMethodId(
    r'setEndIndex',
    r'(I)V',
  );

  static final _setEndIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setEndIndex(int i)`
  void setEndIndex(int i) {
    _setEndIndex(
      reference.pointer,
      _id_setEndIndex as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $FieldPosition$NullableType extends jni$_.JObjType<FieldPosition?> {
  @jni$_.internal
  const $FieldPosition$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/FieldPosition;';

  @jni$_.internal
  @core$_.override
  FieldPosition? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FieldPosition.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FieldPosition?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FieldPosition$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FieldPosition$NullableType) &&
      other is $FieldPosition$NullableType;
}

final class $FieldPosition$Type extends jni$_.JObjType<FieldPosition> {
  @jni$_.internal
  const $FieldPosition$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/FieldPosition;';

  @jni$_.internal
  @core$_.override
  FieldPosition fromReference(jni$_.JReference reference) =>
      FieldPosition.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FieldPosition?> get nullableType =>
      const $FieldPosition$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FieldPosition$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($FieldPosition$Type) &&
      other is $FieldPosition$Type;
}

/// from: `java.text.Annotation`
class Annotation extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Annotation> $type;

  @jni$_.internal
  Annotation.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/Annotation');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Annotation$NullableType();
  static const type = $Annotation$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/Object;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Annotation(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return Annotation.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$object.pointer,
      ).reference,
    );
  }

  static final _id_getValue = _class.instanceMethodId(
    r'getValue',
    r'()Ljava/lang/Object;',
  );

  static final _getValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object getValue()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getValue() => _getValue(
    reference.pointer,
    _id_getValue as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $Annotation$NullableType extends jni$_.JObjType<Annotation?> {
  @jni$_.internal
  const $Annotation$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/Annotation;';

  @jni$_.internal
  @core$_.override
  Annotation? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Annotation.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Annotation?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Annotation$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Annotation$NullableType) &&
      other is $Annotation$NullableType;
}

final class $Annotation$Type extends jni$_.JObjType<Annotation> {
  @jni$_.internal
  const $Annotation$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/Annotation;';

  @jni$_.internal
  @core$_.override
  Annotation fromReference(jni$_.JReference reference) =>
      Annotation.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Annotation?> get nullableType =>
      const $Annotation$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Annotation$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Annotation$Type) && other is $Annotation$Type;
}

/// from: `java.text.ParseException`
class ParseException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ParseException> $type;

  @jni$_.internal
  ParseException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/ParseException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ParseException$NullableType();
  static const type = $ParseException$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;I)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ParseException(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return ParseException.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
      ).reference,
    );
  }

  static final _id_getErrorOffset = _class.instanceMethodId(
    r'getErrorOffset',
    r'()I',
  );

  static final _getErrorOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getErrorOffset()`
  int getErrorOffset() =>
      _getErrorOffset(
        reference.pointer,
        _id_getErrorOffset as jni$_.JMethodIDPtr,
      ).integer;
}

final class $ParseException$NullableType
    extends jni$_.JObjType<ParseException?> {
  @jni$_.internal
  const $ParseException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/ParseException;';

  @jni$_.internal
  @core$_.override
  ParseException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ParseException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ParseException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ParseException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ParseException$NullableType) &&
      other is $ParseException$NullableType;
}

final class $ParseException$Type extends jni$_.JObjType<ParseException> {
  @jni$_.internal
  const $ParseException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/ParseException;';

  @jni$_.internal
  @core$_.override
  ParseException fromReference(jni$_.JReference reference) =>
      ParseException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ParseException?> get nullableType =>
      const $ParseException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ParseException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ParseException$Type) &&
      other is $ParseException$Type;
}

/// from: `java.text.DateFormat`
class DateFormat extends Format {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DateFormat> $type;

  @jni$_.internal
  DateFormat.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/DateFormat');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DateFormat$NullableType();
  static const type = $DateFormat$Type();

  /// from: `static public final int ERA_FIELD`
  static const ERA_FIELD = 0;

  /// from: `static public final int YEAR_FIELD`
  static const YEAR_FIELD = 1;

  /// from: `static public final int MONTH_FIELD`
  static const MONTH_FIELD = 2;

  /// from: `static public final int DATE_FIELD`
  static const DATE_FIELD = 3;

  /// from: `static public final int HOUR_OF_DAY1_FIELD`
  static const HOUR_OF_DAY1_FIELD = 4;

  /// from: `static public final int HOUR_OF_DAY0_FIELD`
  static const HOUR_OF_DAY0_FIELD = 5;

  /// from: `static public final int MINUTE_FIELD`
  static const MINUTE_FIELD = 6;

  /// from: `static public final int SECOND_FIELD`
  static const SECOND_FIELD = 7;

  /// from: `static public final int MILLISECOND_FIELD`
  static const MILLISECOND_FIELD = 8;

  /// from: `static public final int DAY_OF_WEEK_FIELD`
  static const DAY_OF_WEEK_FIELD = 9;

  /// from: `static public final int DAY_OF_YEAR_FIELD`
  static const DAY_OF_YEAR_FIELD = 10;

  /// from: `static public final int DAY_OF_WEEK_IN_MONTH_FIELD`
  static const DAY_OF_WEEK_IN_MONTH_FIELD = 11;

  /// from: `static public final int WEEK_OF_YEAR_FIELD`
  static const WEEK_OF_YEAR_FIELD = 12;

  /// from: `static public final int WEEK_OF_MONTH_FIELD`
  static const WEEK_OF_MONTH_FIELD = 13;

  /// from: `static public final int AM_PM_FIELD`
  static const AM_PM_FIELD = 14;

  /// from: `static public final int HOUR1_FIELD`
  static const HOUR1_FIELD = 15;

  /// from: `static public final int HOUR0_FIELD`
  static const HOUR0_FIELD = 16;

  /// from: `static public final int TIMEZONE_FIELD`
  static const TIMEZONE_FIELD = 17;

  /// from: `static public final int FULL`
  static const FULL = 0;

  /// from: `static public final int LONG`
  static const LONG = 1;

  /// from: `static public final int MEDIUM`
  static const MEDIUM = 2;

  /// from: `static public final int SHORT`
  static const SHORT = 3;

  /// from: `static public final int DEFAULT`
  static const DEFAULT = 2;
  static final _id_format1 = _class.instanceMethodId(
    r'format',
    r'(Ljava/lang/Object;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final java.lang.StringBuffer format(java.lang.Object object, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format1(
    jni$_.JObject? object,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format1(
      reference.pointer,
      _id_format1 as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_format$2 = _class.instanceMethodId(
    r'format',
    r'(Ljava/util/Date;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.StringBuffer format(java.util.Date date, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format$2(
    jni$_.JObject? date,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$date = date?.reference ?? jni$_.jNullReference;
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format$2(
      reference.pointer,
      _id_format$2 as jni$_.JMethodIDPtr,
      _$date.pointer,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_format$3 = _class.instanceMethodId(
    r'format',
    r'(Ljava/util/Date;)Ljava/lang/String;',
  );

  static final _format$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final java.lang.String format(java.util.Date date)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format$3(jni$_.JObject? date) {
    final _$date = date?.reference ?? jni$_.jNullReference;
    return _format$3(
      reference.pointer,
      _id_format$3 as jni$_.JMethodIDPtr,
      _$date.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_parse = _class.instanceMethodId(
    r'parse',
    r'(Ljava/lang/String;)Ljava/util/Date;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.Date parse(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? parse(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _parse(
      reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_parse$1 = _class.instanceMethodId(
    r'parse',
    r'(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/util/Date;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.util.Date parse(java.lang.String string, java.text.ParsePosition parsePosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? parse$1(jni$_.JString? string, ParsePosition? parsePosition) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$parsePosition = parsePosition?.reference ?? jni$_.jNullReference;
    return _parse$1(
      reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$parsePosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_parseObject = _class.instanceMethodId(
    r'parseObject',
    r'(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/lang/Object;',
  );

  static final _parseObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object parseObject(java.lang.String string, java.text.ParsePosition parsePosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? parseObject(
    jni$_.JString? string,
    ParsePosition? parsePosition,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$parsePosition = parsePosition?.reference ?? jni$_.jNullReference;
    return _parseObject(
      reference.pointer,
      _id_parseObject as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$parsePosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getTimeInstance = _class.staticMethodId(
    r'getTimeInstance',
    r'()Ljava/text/DateFormat;',
  );

  static final _getTimeInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public final java.text.DateFormat getTimeInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat? getTimeInstance() => _getTimeInstance(
    _class.reference.pointer,
    _id_getTimeInstance as jni$_.JMethodIDPtr,
  ).object<DateFormat?>(const $DateFormat$NullableType());

  static final _id_getTimeInstance$1 = _class.staticMethodId(
    r'getTimeInstance',
    r'(I)Ljava/text/DateFormat;',
  );

  static final _getTimeInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final java.text.DateFormat getTimeInstance(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat? getTimeInstance$1(int i) => _getTimeInstance$1(
    _class.reference.pointer,
    _id_getTimeInstance$1 as jni$_.JMethodIDPtr,
    i,
  ).object<DateFormat?>(const $DateFormat$NullableType());

  static final _id_getTimeInstance$2 = _class.staticMethodId(
    r'getTimeInstance',
    r'(ILjava/util/Locale;)Ljava/text/DateFormat;',
  );

  static final _getTimeInstance$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public final java.text.DateFormat getTimeInstance(int i, java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat? getTimeInstance$2(int i, jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getTimeInstance$2(
      _class.reference.pointer,
      _id_getTimeInstance$2 as jni$_.JMethodIDPtr,
      i,
      _$locale.pointer,
    ).object<DateFormat?>(const $DateFormat$NullableType());
  }

  static final _id_getDateInstance = _class.staticMethodId(
    r'getDateInstance',
    r'()Ljava/text/DateFormat;',
  );

  static final _getDateInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public final java.text.DateFormat getDateInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat? getDateInstance() => _getDateInstance(
    _class.reference.pointer,
    _id_getDateInstance as jni$_.JMethodIDPtr,
  ).object<DateFormat?>(const $DateFormat$NullableType());

  static final _id_getDateInstance$1 = _class.staticMethodId(
    r'getDateInstance',
    r'(I)Ljava/text/DateFormat;',
  );

  static final _getDateInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final java.text.DateFormat getDateInstance(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat? getDateInstance$1(int i) => _getDateInstance$1(
    _class.reference.pointer,
    _id_getDateInstance$1 as jni$_.JMethodIDPtr,
    i,
  ).object<DateFormat?>(const $DateFormat$NullableType());

  static final _id_getDateInstance$2 = _class.staticMethodId(
    r'getDateInstance',
    r'(ILjava/util/Locale;)Ljava/text/DateFormat;',
  );

  static final _getDateInstance$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public final java.text.DateFormat getDateInstance(int i, java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat? getDateInstance$2(int i, jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDateInstance$2(
      _class.reference.pointer,
      _id_getDateInstance$2 as jni$_.JMethodIDPtr,
      i,
      _$locale.pointer,
    ).object<DateFormat?>(const $DateFormat$NullableType());
  }

  static final _id_getDateTimeInstance = _class.staticMethodId(
    r'getDateTimeInstance',
    r'()Ljava/text/DateFormat;',
  );

  static final _getDateTimeInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public final java.text.DateFormat getDateTimeInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat? getDateTimeInstance() => _getDateTimeInstance(
    _class.reference.pointer,
    _id_getDateTimeInstance as jni$_.JMethodIDPtr,
  ).object<DateFormat?>(const $DateFormat$NullableType());

  static final _id_getDateTimeInstance$1 = _class.staticMethodId(
    r'getDateTimeInstance',
    r'(II)Ljava/text/DateFormat;',
  );

  static final _getDateTimeInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `static public final java.text.DateFormat getDateTimeInstance(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat? getDateTimeInstance$1(int i, int i1) =>
      _getDateTimeInstance$1(
        _class.reference.pointer,
        _id_getDateTimeInstance$1 as jni$_.JMethodIDPtr,
        i,
        i1,
      ).object<DateFormat?>(const $DateFormat$NullableType());

  static final _id_getDateTimeInstance$2 = _class.staticMethodId(
    r'getDateTimeInstance',
    r'(IILjava/util/Locale;)Ljava/text/DateFormat;',
  );

  static final _getDateTimeInstance$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public final java.text.DateFormat getDateTimeInstance(int i, int i1, java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat? getDateTimeInstance$2(
    int i,
    int i1,
    jni$_.JObject? locale,
  ) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDateTimeInstance$2(
      _class.reference.pointer,
      _id_getDateTimeInstance$2 as jni$_.JMethodIDPtr,
      i,
      i1,
      _$locale.pointer,
    ).object<DateFormat?>(const $DateFormat$NullableType());
  }

  static final _id_getInstance = _class.staticMethodId(
    r'getInstance',
    r'()Ljava/text/DateFormat;',
  );

  static final _getInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public final java.text.DateFormat getInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat? getInstance() => _getInstance(
    _class.reference.pointer,
    _id_getInstance as jni$_.JMethodIDPtr,
  ).object<DateFormat?>(const $DateFormat$NullableType());

  static final _id_getAvailableLocales = _class.staticMethodId(
    r'getAvailableLocales',
    r'()[Ljava/util/Locale;',
  );

  static final _getAvailableLocales =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Locale[] getAvailableLocales()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JObject?>? getAvailableLocales() =>
      _getAvailableLocales(
        _class.reference.pointer,
        _id_getAvailableLocales as jni$_.JMethodIDPtr,
      ).object<jni$_.JArray<jni$_.JObject?>?>(
        const jni$_.JArrayNullableType<jni$_.JObject?>(
          jni$_.JObjectNullableType(),
        ),
      );

  static final _id_setCalendar = _class.instanceMethodId(
    r'setCalendar',
    r'(Ljava/util/Calendar;)V',
  );

  static final _setCalendar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setCalendar(java.util.Calendar calendar)`
  void setCalendar(jni$_.JObject? calendar) {
    final _$calendar = calendar?.reference ?? jni$_.jNullReference;
    _setCalendar(
      reference.pointer,
      _id_setCalendar as jni$_.JMethodIDPtr,
      _$calendar.pointer,
    ).check();
  }

  static final _id_getCalendar = _class.instanceMethodId(
    r'getCalendar',
    r'()Ljava/util/Calendar;',
  );

  static final _getCalendar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Calendar getCalendar()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getCalendar() => _getCalendar(
    reference.pointer,
    _id_getCalendar as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_setNumberFormat = _class.instanceMethodId(
    r'setNumberFormat',
    r'(Ljava/text/NumberFormat;)V',
  );

  static final _setNumberFormat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setNumberFormat(java.text.NumberFormat numberFormat)`
  void setNumberFormat(NumberFormat? numberFormat) {
    final _$numberFormat = numberFormat?.reference ?? jni$_.jNullReference;
    _setNumberFormat(
      reference.pointer,
      _id_setNumberFormat as jni$_.JMethodIDPtr,
      _$numberFormat.pointer,
    ).check();
  }

  static final _id_getNumberFormat = _class.instanceMethodId(
    r'getNumberFormat',
    r'()Ljava/text/NumberFormat;',
  );

  static final _getNumberFormat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.text.NumberFormat getNumberFormat()`
  /// The returned object must be released after use, by calling the [release] method.
  NumberFormat? getNumberFormat() => _getNumberFormat(
    reference.pointer,
    _id_getNumberFormat as jni$_.JMethodIDPtr,
  ).object<NumberFormat?>(const $NumberFormat$NullableType());

  static final _id_setTimeZone = _class.instanceMethodId(
    r'setTimeZone',
    r'(Ljava/util/TimeZone;)V',
  );

  static final _setTimeZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setTimeZone(java.util.TimeZone timeZone)`
  void setTimeZone(jni$_.JObject? timeZone) {
    final _$timeZone = timeZone?.reference ?? jni$_.jNullReference;
    _setTimeZone(
      reference.pointer,
      _id_setTimeZone as jni$_.JMethodIDPtr,
      _$timeZone.pointer,
    ).check();
  }

  static final _id_getTimeZone = _class.instanceMethodId(
    r'getTimeZone',
    r'()Ljava/util/TimeZone;',
  );

  static final _getTimeZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.TimeZone getTimeZone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTimeZone() => _getTimeZone(
    reference.pointer,
    _id_getTimeZone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_setLenient = _class.instanceMethodId(r'setLenient', r'(Z)V');

  static final _setLenient =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setLenient(boolean z)`
  void setLenient(bool z) {
    _setLenient(
      reference.pointer,
      _id_setLenient as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_isLenient = _class.instanceMethodId(r'isLenient', r'()Z');

  static final _isLenient =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isLenient()`
  bool isLenient() =>
      _isLenient(
        reference.pointer,
        _id_isLenient as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
}

final class $DateFormat$NullableType extends jni$_.JObjType<DateFormat?> {
  @jni$_.internal
  const $DateFormat$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/DateFormat;';

  @jni$_.internal
  @core$_.override
  DateFormat? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DateFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Format$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DateFormat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($DateFormat$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DateFormat$NullableType) &&
      other is $DateFormat$NullableType;
}

final class $DateFormat$Type extends jni$_.JObjType<DateFormat> {
  @jni$_.internal
  const $DateFormat$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/DateFormat;';

  @jni$_.internal
  @core$_.override
  DateFormat fromReference(jni$_.JReference reference) =>
      DateFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Format$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DateFormat?> get nullableType =>
      const $DateFormat$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($DateFormat$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DateFormat$Type) && other is $DateFormat$Type;
}

/// from: `java.text.NumberFormat$Style`
class NumberFormat$Style extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NumberFormat$Style> $type;

  @jni$_.internal
  NumberFormat$Style.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/NumberFormat$Style');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NumberFormat$Style$NullableType();
  static const type = $NumberFormat$Style$Type();
  static final _id_SHORT = _class.staticFieldId(
    r'SHORT',
    r'Ljava/text/NumberFormat$Style;',
  );

  /// from: `static public final java.text.NumberFormat$Style SHORT`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Style get SHORT =>
      _id_SHORT.get(_class, const $NumberFormat$Style$Type());

  static final _id_LONG = _class.staticFieldId(
    r'LONG',
    r'Ljava/text/NumberFormat$Style;',
  );

  /// from: `static public final java.text.NumberFormat$Style LONG`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Style get LONG =>
      _id_LONG.get(_class, const $NumberFormat$Style$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/text/NumberFormat$Style;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.text.NumberFormat$Style[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<NumberFormat$Style?>? values() => _values(
    _class.reference.pointer,
    _id_values as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<NumberFormat$Style?>?>(
    const jni$_.JArrayNullableType<NumberFormat$Style?>(
      $NumberFormat$Style$NullableType(),
    ),
  );

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/text/NumberFormat$Style;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.text.NumberFormat$Style valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Style? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<NumberFormat$Style?>(const $NumberFormat$Style$NullableType());
  }
}

final class $NumberFormat$Style$NullableType
    extends jni$_.JObjType<NumberFormat$Style?> {
  @jni$_.internal
  const $NumberFormat$Style$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/NumberFormat$Style;';

  @jni$_.internal
  @core$_.override
  NumberFormat$Style? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NumberFormat$Style.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NumberFormat$Style?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NumberFormat$Style$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NumberFormat$Style$NullableType) &&
      other is $NumberFormat$Style$NullableType;
}

final class $NumberFormat$Style$Type
    extends jni$_.JObjType<NumberFormat$Style> {
  @jni$_.internal
  const $NumberFormat$Style$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/NumberFormat$Style;';

  @jni$_.internal
  @core$_.override
  NumberFormat$Style fromReference(jni$_.JReference reference) =>
      NumberFormat$Style.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NumberFormat$Style?> get nullableType =>
      const $NumberFormat$Style$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($NumberFormat$Style$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NumberFormat$Style$Type) &&
      other is $NumberFormat$Style$Type;
}

/// from: `java.text.CharacterIterator`
class CharacterIterator extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CharacterIterator> $type;

  @jni$_.internal
  CharacterIterator.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/CharacterIterator');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CharacterIterator$NullableType();
  static const type = $CharacterIterator$Type();

  /// from: `static public final char DONE`
  static const DONE = 65535;
  static final _id_first = _class.instanceMethodId(r'first', r'()C');

  static final _first =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract char first()`
  int first() =>
      _first(reference.pointer, _id_first as jni$_.JMethodIDPtr).char;

  static final _id_last = _class.instanceMethodId(r'last', r'()C');

  static final _last =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract char last()`
  int last() => _last(reference.pointer, _id_last as jni$_.JMethodIDPtr).char;

  static final _id_current = _class.instanceMethodId(r'current', r'()C');

  static final _current =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract char current()`
  int current() =>
      _current(reference.pointer, _id_current as jni$_.JMethodIDPtr).char;

  static final _id_next = _class.instanceMethodId(r'next', r'()C');

  static final _next =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract char next()`
  int next() => _next(reference.pointer, _id_next as jni$_.JMethodIDPtr).char;

  static final _id_previous = _class.instanceMethodId(r'previous', r'()C');

  static final _previous =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract char previous()`
  int previous() =>
      _previous(reference.pointer, _id_previous as jni$_.JMethodIDPtr).char;

  static final _id_setIndex = _class.instanceMethodId(r'setIndex', r'(I)C');

  static final _setIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract char setIndex(int i)`
  int setIndex(int i) =>
      _setIndex(reference.pointer, _id_setIndex as jni$_.JMethodIDPtr, i).char;

  static final _id_getBeginIndex = _class.instanceMethodId(
    r'getBeginIndex',
    r'()I',
  );

  static final _getBeginIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int getBeginIndex()`
  int getBeginIndex() =>
      _getBeginIndex(
        reference.pointer,
        _id_getBeginIndex as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getEndIndex = _class.instanceMethodId(
    r'getEndIndex',
    r'()I',
  );

  static final _getEndIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int getEndIndex()`
  int getEndIndex() =>
      _getEndIndex(
        reference.pointer,
        _id_getEndIndex as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getIndex = _class.instanceMethodId(r'getIndex', r'()I');

  static final _getIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int getIndex()`
  int getIndex() =>
      _getIndex(reference.pointer, _id_getIndex as jni$_.JMethodIDPtr).integer;

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $CharacterIterator> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'first()C') {
        final $r = _$impls[$p]!.first();
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'last()C') {
        final $r = _$impls[$p]!.last();
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'current()C') {
        final $r = _$impls[$p]!.current();
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'next()C') {
        final $r = _$impls[$p]!.next();
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'previous()C') {
        final $r = _$impls[$p]!.previous();
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'setIndex(I)C') {
        final $r = _$impls[$p]!.setIndex(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'getBeginIndex()I') {
        final $r = _$impls[$p]!.getBeginIndex();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'getEndIndex()I') {
        final $r = _$impls[$p]!.getEndIndex();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'getIndex()I') {
        final $r = _$impls[$p]!.getIndex();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'clone()Ljava/lang/Object;') {
        final $r = _$impls[$p]!.clone();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $CharacterIterator $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.text.CharacterIterator', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory CharacterIterator.implement($CharacterIterator $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return CharacterIterator.fromReference($i.implementReference());
  }
}

abstract base mixin class $CharacterIterator {
  factory $CharacterIterator({
    required int Function() first,
    required int Function() last,
    required int Function() current,
    required int Function() next,
    required int Function() previous,
    required int Function(int i) setIndex,
    required int Function() getBeginIndex,
    required int Function() getEndIndex,
    required int Function() getIndex,
    required jni$_.JObject? Function() clone,
  }) = _$CharacterIterator;

  int first();
  int last();
  int current();
  int next();
  int previous();
  int setIndex(int i);
  int getBeginIndex();
  int getEndIndex();
  int getIndex();
  jni$_.JObject? clone();
}

final class _$CharacterIterator with $CharacterIterator {
  _$CharacterIterator({
    required int Function() first,
    required int Function() last,
    required int Function() current,
    required int Function() next,
    required int Function() previous,
    required int Function(int i) setIndex,
    required int Function() getBeginIndex,
    required int Function() getEndIndex,
    required int Function() getIndex,
    required jni$_.JObject? Function() clone,
  }) : _first = first,
       _last = last,
       _current = current,
       _next = next,
       _previous = previous,
       _setIndex = setIndex,
       _getBeginIndex = getBeginIndex,
       _getEndIndex = getEndIndex,
       _getIndex = getIndex,
       _clone = clone;

  final int Function() _first;
  final int Function() _last;
  final int Function() _current;
  final int Function() _next;
  final int Function() _previous;
  final int Function(int i) _setIndex;
  final int Function() _getBeginIndex;
  final int Function() _getEndIndex;
  final int Function() _getIndex;
  final jni$_.JObject? Function() _clone;

  int first() => _first();

  int last() => _last();

  int current() => _current();

  int next() => _next();

  int previous() => _previous();

  int setIndex(int i) => _setIndex(i);

  int getBeginIndex() => _getBeginIndex();

  int getEndIndex() => _getEndIndex();

  int getIndex() => _getIndex();

  jni$_.JObject? clone() => _clone();
}

final class $CharacterIterator$NullableType
    extends jni$_.JObjType<CharacterIterator?> {
  @jni$_.internal
  const $CharacterIterator$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/CharacterIterator;';

  @jni$_.internal
  @core$_.override
  CharacterIterator? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CharacterIterator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CharacterIterator?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CharacterIterator$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CharacterIterator$NullableType) &&
      other is $CharacterIterator$NullableType;
}

final class $CharacterIterator$Type extends jni$_.JObjType<CharacterIterator> {
  @jni$_.internal
  const $CharacterIterator$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/CharacterIterator;';

  @jni$_.internal
  @core$_.override
  CharacterIterator fromReference(jni$_.JReference reference) =>
      CharacterIterator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CharacterIterator?> get nullableType =>
      const $CharacterIterator$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CharacterIterator$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CharacterIterator$Type) &&
      other is $CharacterIterator$Type;
}

/// from: `java.text.NumberFormat$Field`
class NumberFormat$Field extends Format$Field {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NumberFormat$Field> $type;

  @jni$_.internal
  NumberFormat$Field.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/NumberFormat$Field');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NumberFormat$Field$NullableType();
  static const type = $NumberFormat$Field$Type();
  static final _id_INTEGER = _class.staticFieldId(
    r'INTEGER',
    r'Ljava/text/NumberFormat$Field;',
  );

  /// from: `static public final java.text.NumberFormat$Field INTEGER`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Field? get INTEGER =>
      _id_INTEGER.get(_class, const $NumberFormat$Field$NullableType());

  static final _id_FRACTION = _class.staticFieldId(
    r'FRACTION',
    r'Ljava/text/NumberFormat$Field;',
  );

  /// from: `static public final java.text.NumberFormat$Field FRACTION`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Field? get FRACTION =>
      _id_FRACTION.get(_class, const $NumberFormat$Field$NullableType());

  static final _id_EXPONENT = _class.staticFieldId(
    r'EXPONENT',
    r'Ljava/text/NumberFormat$Field;',
  );

  /// from: `static public final java.text.NumberFormat$Field EXPONENT`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Field? get EXPONENT =>
      _id_EXPONENT.get(_class, const $NumberFormat$Field$NullableType());

  static final _id_DECIMAL_SEPARATOR = _class.staticFieldId(
    r'DECIMAL_SEPARATOR',
    r'Ljava/text/NumberFormat$Field;',
  );

  /// from: `static public final java.text.NumberFormat$Field DECIMAL_SEPARATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Field? get DECIMAL_SEPARATOR => _id_DECIMAL_SEPARATOR.get(
    _class,
    const $NumberFormat$Field$NullableType(),
  );

  static final _id_SIGN = _class.staticFieldId(
    r'SIGN',
    r'Ljava/text/NumberFormat$Field;',
  );

  /// from: `static public final java.text.NumberFormat$Field SIGN`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Field? get SIGN =>
      _id_SIGN.get(_class, const $NumberFormat$Field$NullableType());

  static final _id_GROUPING_SEPARATOR = _class.staticFieldId(
    r'GROUPING_SEPARATOR',
    r'Ljava/text/NumberFormat$Field;',
  );

  /// from: `static public final java.text.NumberFormat$Field GROUPING_SEPARATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Field? get GROUPING_SEPARATOR => _id_GROUPING_SEPARATOR
      .get(_class, const $NumberFormat$Field$NullableType());

  static final _id_EXPONENT_SYMBOL = _class.staticFieldId(
    r'EXPONENT_SYMBOL',
    r'Ljava/text/NumberFormat$Field;',
  );

  /// from: `static public final java.text.NumberFormat$Field EXPONENT_SYMBOL`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Field? get EXPONENT_SYMBOL =>
      _id_EXPONENT_SYMBOL.get(_class, const $NumberFormat$Field$NullableType());

  static final _id_PERCENT = _class.staticFieldId(
    r'PERCENT',
    r'Ljava/text/NumberFormat$Field;',
  );

  /// from: `static public final java.text.NumberFormat$Field PERCENT`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Field? get PERCENT =>
      _id_PERCENT.get(_class, const $NumberFormat$Field$NullableType());

  static final _id_PERMILLE = _class.staticFieldId(
    r'PERMILLE',
    r'Ljava/text/NumberFormat$Field;',
  );

  /// from: `static public final java.text.NumberFormat$Field PERMILLE`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Field? get PERMILLE =>
      _id_PERMILLE.get(_class, const $NumberFormat$Field$NullableType());

  static final _id_CURRENCY = _class.staticFieldId(
    r'CURRENCY',
    r'Ljava/text/NumberFormat$Field;',
  );

  /// from: `static public final java.text.NumberFormat$Field CURRENCY`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Field? get CURRENCY =>
      _id_CURRENCY.get(_class, const $NumberFormat$Field$NullableType());

  static final _id_EXPONENT_SIGN = _class.staticFieldId(
    r'EXPONENT_SIGN',
    r'Ljava/text/NumberFormat$Field;',
  );

  /// from: `static public final java.text.NumberFormat$Field EXPONENT_SIGN`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Field? get EXPONENT_SIGN =>
      _id_EXPONENT_SIGN.get(_class, const $NumberFormat$Field$NullableType());

  static final _id_PREFIX = _class.staticFieldId(
    r'PREFIX',
    r'Ljava/text/NumberFormat$Field;',
  );

  /// from: `static public final java.text.NumberFormat$Field PREFIX`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Field? get PREFIX =>
      _id_PREFIX.get(_class, const $NumberFormat$Field$NullableType());

  static final _id_SUFFIX = _class.staticFieldId(
    r'SUFFIX',
    r'Ljava/text/NumberFormat$Field;',
  );

  /// from: `static public final java.text.NumberFormat$Field SUFFIX`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat$Field? get SUFFIX =>
      _id_SUFFIX.get(_class, const $NumberFormat$Field$NullableType());
}

final class $NumberFormat$Field$NullableType
    extends jni$_.JObjType<NumberFormat$Field?> {
  @jni$_.internal
  const $NumberFormat$Field$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/NumberFormat$Field;';

  @jni$_.internal
  @core$_.override
  NumberFormat$Field? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NumberFormat$Field.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Format$Field$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NumberFormat$Field?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($NumberFormat$Field$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NumberFormat$Field$NullableType) &&
      other is $NumberFormat$Field$NullableType;
}

final class $NumberFormat$Field$Type
    extends jni$_.JObjType<NumberFormat$Field> {
  @jni$_.internal
  const $NumberFormat$Field$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/NumberFormat$Field;';

  @jni$_.internal
  @core$_.override
  NumberFormat$Field fromReference(jni$_.JReference reference) =>
      NumberFormat$Field.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Format$Field$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NumberFormat$Field?> get nullableType =>
      const $NumberFormat$Field$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($NumberFormat$Field$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NumberFormat$Field$Type) &&
      other is $NumberFormat$Field$Type;
}

/// from: `java.text.AttributedString`
class AttributedString extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AttributedString> $type;

  @jni$_.internal
  AttributedString.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/AttributedString');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AttributedString$NullableType();
  static const type = $AttributedString$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AttributedString(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return AttributedString.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/util/Map;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.util.Map<? extends java.text.AttributedCharacterIterator$Attribute, ?> map)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AttributedString.new$1(
    jni$_.JString? string,
    jni$_.JMap<AttributedCharacterIterator$Attribute?, jni$_.JObject?>? map,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$map = map?.reference ?? jni$_.jNullReference;
    return AttributedString.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$map.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/text/AttributedCharacterIterator;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.text.AttributedCharacterIterator attributedCharacterIterator)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AttributedString.new$2(
    AttributedCharacterIterator? attributedCharacterIterator,
  ) {
    final _$attributedCharacterIterator =
        attributedCharacterIterator?.reference ?? jni$_.jNullReference;
    return AttributedString.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$attributedCharacterIterator.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/text/AttributedCharacterIterator;II)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void <init>(java.text.AttributedCharacterIterator attributedCharacterIterator, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AttributedString.new$3(
    AttributedCharacterIterator? attributedCharacterIterator,
    int i,
    int i1,
  ) {
    final _$attributedCharacterIterator =
        attributedCharacterIterator?.reference ?? jni$_.jNullReference;
    return AttributedString.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$attributedCharacterIterator.pointer,
        i,
        i1,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(
    r'(Ljava/text/AttributedCharacterIterator;II[Ljava/text/AttributedCharacterIterator$Attribute;)V',
  );

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.text.AttributedCharacterIterator attributedCharacterIterator, int i, int i1, java.text.AttributedCharacterIterator$Attribute[] attributes)`
  /// The returned object must be released after use, by calling the [release] method.
  factory AttributedString.new$4(
    AttributedCharacterIterator? attributedCharacterIterator,
    int i,
    int i1,
    jni$_.JArray<AttributedCharacterIterator$Attribute?>? attributes,
  ) {
    final _$attributedCharacterIterator =
        attributedCharacterIterator?.reference ?? jni$_.jNullReference;
    final _$attributes = attributes?.reference ?? jni$_.jNullReference;
    return AttributedString.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$attributedCharacterIterator.pointer,
        i,
        i1,
        _$attributes.pointer,
      ).reference,
    );
  }

  static final _id_addAttribute = _class.instanceMethodId(
    r'addAttribute',
    r'(Ljava/text/AttributedCharacterIterator$Attribute;Ljava/lang/Object;)V',
  );

  static final _addAttribute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void addAttribute(java.text.AttributedCharacterIterator$Attribute attribute, java.lang.Object object)`
  void addAttribute(
    AttributedCharacterIterator$Attribute? attribute,
    jni$_.JObject? object,
  ) {
    final _$attribute = attribute?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _addAttribute(
      reference.pointer,
      _id_addAttribute as jni$_.JMethodIDPtr,
      _$attribute.pointer,
      _$object.pointer,
    ).check();
  }

  static final _id_addAttribute$1 = _class.instanceMethodId(
    r'addAttribute',
    r'(Ljava/text/AttributedCharacterIterator$Attribute;Ljava/lang/Object;II)V',
  );

  static final _addAttribute$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void addAttribute(java.text.AttributedCharacterIterator$Attribute attribute, java.lang.Object object, int i, int i1)`
  void addAttribute$1(
    AttributedCharacterIterator$Attribute? attribute,
    jni$_.JObject? object,
    int i,
    int i1,
  ) {
    final _$attribute = attribute?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _addAttribute$1(
      reference.pointer,
      _id_addAttribute$1 as jni$_.JMethodIDPtr,
      _$attribute.pointer,
      _$object.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_addAttributes = _class.instanceMethodId(
    r'addAttributes',
    r'(Ljava/util/Map;II)V',
  );

  static final _addAttributes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void addAttributes(java.util.Map<? extends java.text.AttributedCharacterIterator$Attribute, ?> map, int i, int i1)`
  void addAttributes(
    jni$_.JMap<AttributedCharacterIterator$Attribute?, jni$_.JObject?>? map,
    int i,
    int i1,
  ) {
    final _$map = map?.reference ?? jni$_.jNullReference;
    _addAttributes(
      reference.pointer,
      _id_addAttributes as jni$_.JMethodIDPtr,
      _$map.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_getIterator = _class.instanceMethodId(
    r'getIterator',
    r'()Ljava/text/AttributedCharacterIterator;',
  );

  static final _getIterator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.text.AttributedCharacterIterator getIterator()`
  /// The returned object must be released after use, by calling the [release] method.
  AttributedCharacterIterator? getIterator() => _getIterator(
    reference.pointer,
    _id_getIterator as jni$_.JMethodIDPtr,
  ).object<AttributedCharacterIterator?>(
    const $AttributedCharacterIterator$NullableType(),
  );

  static final _id_getIterator$1 = _class.instanceMethodId(
    r'getIterator',
    r'([Ljava/text/AttributedCharacterIterator$Attribute;)Ljava/text/AttributedCharacterIterator;',
  );

  static final _getIterator$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.text.AttributedCharacterIterator getIterator(java.text.AttributedCharacterIterator$Attribute[] attributes)`
  /// The returned object must be released after use, by calling the [release] method.
  AttributedCharacterIterator? getIterator$1(
    jni$_.JArray<AttributedCharacterIterator$Attribute?>? attributes,
  ) {
    final _$attributes = attributes?.reference ?? jni$_.jNullReference;
    return _getIterator$1(
      reference.pointer,
      _id_getIterator$1 as jni$_.JMethodIDPtr,
      _$attributes.pointer,
    ).object<AttributedCharacterIterator?>(
      const $AttributedCharacterIterator$NullableType(),
    );
  }

  static final _id_getIterator$2 = _class.instanceMethodId(
    r'getIterator',
    r'([Ljava/text/AttributedCharacterIterator$Attribute;II)Ljava/text/AttributedCharacterIterator;',
  );

  static final _getIterator$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public java.text.AttributedCharacterIterator getIterator(java.text.AttributedCharacterIterator$Attribute[] attributes, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  AttributedCharacterIterator? getIterator$2(
    jni$_.JArray<AttributedCharacterIterator$Attribute?>? attributes,
    int i,
    int i1,
  ) {
    final _$attributes = attributes?.reference ?? jni$_.jNullReference;
    return _getIterator$2(
      reference.pointer,
      _id_getIterator$2 as jni$_.JMethodIDPtr,
      _$attributes.pointer,
      i,
      i1,
    ).object<AttributedCharacterIterator?>(
      const $AttributedCharacterIterator$NullableType(),
    );
  }
}

final class $AttributedString$NullableType
    extends jni$_.JObjType<AttributedString?> {
  @jni$_.internal
  const $AttributedString$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/AttributedString;';

  @jni$_.internal
  @core$_.override
  AttributedString? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : AttributedString.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AttributedString?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AttributedString$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($AttributedString$NullableType) &&
      other is $AttributedString$NullableType;
}

final class $AttributedString$Type extends jni$_.JObjType<AttributedString> {
  @jni$_.internal
  const $AttributedString$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/AttributedString;';

  @jni$_.internal
  @core$_.override
  AttributedString fromReference(jni$_.JReference reference) =>
      AttributedString.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AttributedString?> get nullableType =>
      const $AttributedString$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AttributedString$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($AttributedString$Type) &&
      other is $AttributedString$Type;
}

/// from: `java.text.Format$Field`
class Format$Field extends AttributedCharacterIterator$Attribute {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Format$Field> $type;

  @jni$_.internal
  Format$Field.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/Format$Field');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Format$Field$NullableType();
  static const type = $Format$Field$Type();
}

final class $Format$Field$NullableType extends jni$_.JObjType<Format$Field?> {
  @jni$_.internal
  const $Format$Field$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/Format$Field;';

  @jni$_.internal
  @core$_.override
  Format$Field? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Format$Field.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $AttributedCharacterIterator$Attribute$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Format$Field?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($Format$Field$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Format$Field$NullableType) &&
      other is $Format$Field$NullableType;
}

final class $Format$Field$Type extends jni$_.JObjType<Format$Field> {
  @jni$_.internal
  const $Format$Field$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/Format$Field;';

  @jni$_.internal
  @core$_.override
  Format$Field fromReference(jni$_.JReference reference) =>
      Format$Field.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType =>
      const $AttributedCharacterIterator$Attribute$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Format$Field?> get nullableType =>
      const $Format$Field$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($Format$Field$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Format$Field$Type) && other is $Format$Field$Type;
}

/// from: `java.text.AttributedCharacterIterator`
class AttributedCharacterIterator extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AttributedCharacterIterator> $type;

  @jni$_.internal
  AttributedCharacterIterator.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/text/AttributedCharacterIterator',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $AttributedCharacterIterator$NullableType();
  static const type = $AttributedCharacterIterator$Type();
  static final _id_getRunStart = _class.instanceMethodId(
    r'getRunStart',
    r'()I',
  );

  static final _getRunStart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int getRunStart()`
  int getRunStart() =>
      _getRunStart(
        reference.pointer,
        _id_getRunStart as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getRunStart$1 = _class.instanceMethodId(
    r'getRunStart',
    r'(Ljava/text/AttributedCharacterIterator$Attribute;)I',
  );

  static final _getRunStart$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract int getRunStart(java.text.AttributedCharacterIterator$Attribute attribute)`
  int getRunStart$1(AttributedCharacterIterator$Attribute? attribute) {
    final _$attribute = attribute?.reference ?? jni$_.jNullReference;
    return _getRunStart$1(
      reference.pointer,
      _id_getRunStart$1 as jni$_.JMethodIDPtr,
      _$attribute.pointer,
    ).integer;
  }

  static final _id_getRunStart$2 = _class.instanceMethodId(
    r'getRunStart',
    r'(Ljava/util/Set;)I',
  );

  static final _getRunStart$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract int getRunStart(java.util.Set<? extends java.text.AttributedCharacterIterator$Attribute> set)`
  int getRunStart$2(jni$_.JSet<AttributedCharacterIterator$Attribute?>? set) {
    final _$set = set?.reference ?? jni$_.jNullReference;
    return _getRunStart$2(
      reference.pointer,
      _id_getRunStart$2 as jni$_.JMethodIDPtr,
      _$set.pointer,
    ).integer;
  }

  static final _id_getRunLimit = _class.instanceMethodId(
    r'getRunLimit',
    r'()I',
  );

  static final _getRunLimit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int getRunLimit()`
  int getRunLimit() =>
      _getRunLimit(
        reference.pointer,
        _id_getRunLimit as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getRunLimit$1 = _class.instanceMethodId(
    r'getRunLimit',
    r'(Ljava/text/AttributedCharacterIterator$Attribute;)I',
  );

  static final _getRunLimit$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract int getRunLimit(java.text.AttributedCharacterIterator$Attribute attribute)`
  int getRunLimit$1(AttributedCharacterIterator$Attribute? attribute) {
    final _$attribute = attribute?.reference ?? jni$_.jNullReference;
    return _getRunLimit$1(
      reference.pointer,
      _id_getRunLimit$1 as jni$_.JMethodIDPtr,
      _$attribute.pointer,
    ).integer;
  }

  static final _id_getRunLimit$2 = _class.instanceMethodId(
    r'getRunLimit',
    r'(Ljava/util/Set;)I',
  );

  static final _getRunLimit$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract int getRunLimit(java.util.Set<? extends java.text.AttributedCharacterIterator$Attribute> set)`
  int getRunLimit$2(jni$_.JSet<AttributedCharacterIterator$Attribute?>? set) {
    final _$set = set?.reference ?? jni$_.jNullReference;
    return _getRunLimit$2(
      reference.pointer,
      _id_getRunLimit$2 as jni$_.JMethodIDPtr,
      _$set.pointer,
    ).integer;
  }

  static final _id_getAttributes = _class.instanceMethodId(
    r'getAttributes',
    r'()Ljava/util/Map;',
  );

  static final _getAttributes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.util.Map<java.text.AttributedCharacterIterator$Attribute, java.lang.Object> getAttributes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<AttributedCharacterIterator$Attribute?, jni$_.JObject?>?
  getAttributes() => _getAttributes(
    reference.pointer,
    _id_getAttributes as jni$_.JMethodIDPtr,
  ).object<jni$_.JMap<AttributedCharacterIterator$Attribute?, jni$_.JObject?>?>(
    const jni$_.JMapNullableType<
      AttributedCharacterIterator$Attribute?,
      jni$_.JObject?
    >(
      $AttributedCharacterIterator$Attribute$NullableType(),
      jni$_.JObjectNullableType(),
    ),
  );

  static final _id_getAttribute = _class.instanceMethodId(
    r'getAttribute',
    r'(Ljava/text/AttributedCharacterIterator$Attribute;)Ljava/lang/Object;',
  );

  static final _getAttribute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object getAttribute(java.text.AttributedCharacterIterator$Attribute attribute)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getAttribute(
    AttributedCharacterIterator$Attribute? attribute,
  ) {
    final _$attribute = attribute?.reference ?? jni$_.jNullReference;
    return _getAttribute(
      reference.pointer,
      _id_getAttribute as jni$_.JMethodIDPtr,
      _$attribute.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getAllAttributeKeys = _class.instanceMethodId(
    r'getAllAttributeKeys',
    r'()Ljava/util/Set;',
  );

  static final _getAllAttributeKeys =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.util.Set<java.text.AttributedCharacterIterator$Attribute> getAllAttributeKeys()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<AttributedCharacterIterator$Attribute?>? getAllAttributeKeys() =>
      _getAllAttributeKeys(
        reference.pointer,
        _id_getAllAttributeKeys as jni$_.JMethodIDPtr,
      ).object<jni$_.JSet<AttributedCharacterIterator$Attribute?>?>(
        const jni$_.JSetNullableType<AttributedCharacterIterator$Attribute?>(
          $AttributedCharacterIterator$Attribute$NullableType(),
        ),
      );

  static final _id_first = _class.instanceMethodId(r'first', r'()C');

  static final _first =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract char first()`
  int first() =>
      _first(reference.pointer, _id_first as jni$_.JMethodIDPtr).char;

  static final _id_last = _class.instanceMethodId(r'last', r'()C');

  static final _last =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract char last()`
  int last() => _last(reference.pointer, _id_last as jni$_.JMethodIDPtr).char;

  static final _id_current = _class.instanceMethodId(r'current', r'()C');

  static final _current =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract char current()`
  int current() =>
      _current(reference.pointer, _id_current as jni$_.JMethodIDPtr).char;

  static final _id_next = _class.instanceMethodId(r'next', r'()C');

  static final _next =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract char next()`
  int next() => _next(reference.pointer, _id_next as jni$_.JMethodIDPtr).char;

  static final _id_previous = _class.instanceMethodId(r'previous', r'()C');

  static final _previous =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract char previous()`
  int previous() =>
      _previous(reference.pointer, _id_previous as jni$_.JMethodIDPtr).char;

  static final _id_setIndex = _class.instanceMethodId(r'setIndex', r'(I)C');

  static final _setIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract char setIndex(int i)`
  int setIndex(int i) =>
      _setIndex(reference.pointer, _id_setIndex as jni$_.JMethodIDPtr, i).char;

  static final _id_getBeginIndex = _class.instanceMethodId(
    r'getBeginIndex',
    r'()I',
  );

  static final _getBeginIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int getBeginIndex()`
  int getBeginIndex() =>
      _getBeginIndex(
        reference.pointer,
        _id_getBeginIndex as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getEndIndex = _class.instanceMethodId(
    r'getEndIndex',
    r'()I',
  );

  static final _getEndIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int getEndIndex()`
  int getEndIndex() =>
      _getEndIndex(
        reference.pointer,
        _id_getEndIndex as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getIndex = _class.instanceMethodId(r'getIndex', r'()I');

  static final _getIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int getIndex()`
  int getIndex() =>
      _getIndex(reference.pointer, _id_getIndex as jni$_.JMethodIDPtr).integer;

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $AttributedCharacterIterator> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'getRunStart()I') {
        final $r = _$impls[$p]!.getRunStart();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d ==
          r'getRunStart(Ljava/text/AttributedCharacterIterator$Attribute;)I') {
        final $r = _$impls[$p]!.getRunStart$1(
          $a![0]?.as(
            const $AttributedCharacterIterator$Attribute$Type(),
            releaseOriginal: true,
          ),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'getRunStart(Ljava/util/Set;)I') {
        final $r = _$impls[$p]!.getRunStart$2(
          $a![0]?.as(
            const jni$_.JSetType<AttributedCharacterIterator$Attribute?>(
              $AttributedCharacterIterator$Attribute$NullableType(),
            ),
            releaseOriginal: true,
          ),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'getRunLimit()I') {
        final $r = _$impls[$p]!.getRunLimit();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d ==
          r'getRunLimit(Ljava/text/AttributedCharacterIterator$Attribute;)I') {
        final $r = _$impls[$p]!.getRunLimit$1(
          $a![0]?.as(
            const $AttributedCharacterIterator$Attribute$Type(),
            releaseOriginal: true,
          ),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'getRunLimit(Ljava/util/Set;)I') {
        final $r = _$impls[$p]!.getRunLimit$2(
          $a![0]?.as(
            const jni$_.JSetType<AttributedCharacterIterator$Attribute?>(
              $AttributedCharacterIterator$Attribute$NullableType(),
            ),
            releaseOriginal: true,
          ),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'getAttributes()Ljava/util/Map;') {
        final $r = _$impls[$p]!.getAttributes();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'getAttribute(Ljava/text/AttributedCharacterIterator$Attribute;)Ljava/lang/Object;') {
        final $r = _$impls[$p]!.getAttribute(
          $a![0]?.as(
            const $AttributedCharacterIterator$Attribute$Type(),
            releaseOriginal: true,
          ),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'getAllAttributeKeys()Ljava/util/Set;') {
        final $r = _$impls[$p]!.getAllAttributeKeys();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'first()C') {
        final $r = _$impls[$p]!.first();
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'last()C') {
        final $r = _$impls[$p]!.last();
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'current()C') {
        final $r = _$impls[$p]!.current();
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'next()C') {
        final $r = _$impls[$p]!.next();
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'previous()C') {
        final $r = _$impls[$p]!.previous();
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'setIndex(I)C') {
        final $r = _$impls[$p]!.setIndex(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'getBeginIndex()I') {
        final $r = _$impls[$p]!.getBeginIndex();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'getEndIndex()I') {
        final $r = _$impls[$p]!.getEndIndex();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'getIndex()I') {
        final $r = _$impls[$p]!.getIndex();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'clone()Ljava/lang/Object;') {
        final $r = _$impls[$p]!.clone();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $AttributedCharacterIterator $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'java.text.AttributedCharacterIterator',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory AttributedCharacterIterator.implement(
    $AttributedCharacterIterator $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return AttributedCharacterIterator.fromReference($i.implementReference());
  }
}

abstract base mixin class $AttributedCharacterIterator {
  factory $AttributedCharacterIterator({
    required int Function() getRunStart,
    required int Function(AttributedCharacterIterator$Attribute? attribute)
    getRunStart$1,
    required int Function(
      jni$_.JSet<AttributedCharacterIterator$Attribute?>? set,
    )
    getRunStart$2,
    required int Function() getRunLimit,
    required int Function(AttributedCharacterIterator$Attribute? attribute)
    getRunLimit$1,
    required int Function(
      jni$_.JSet<AttributedCharacterIterator$Attribute?>? set,
    )
    getRunLimit$2,
    required jni$_.JMap<AttributedCharacterIterator$Attribute?, jni$_.JObject?>?
    Function()
    getAttributes,
    required jni$_.JObject? Function(
      AttributedCharacterIterator$Attribute? attribute,
    )
    getAttribute,
    required jni$_.JSet<AttributedCharacterIterator$Attribute?>? Function()
    getAllAttributeKeys,
    required int Function() first,
    required int Function() last,
    required int Function() current,
    required int Function() next,
    required int Function() previous,
    required int Function(int i) setIndex,
    required int Function() getBeginIndex,
    required int Function() getEndIndex,
    required int Function() getIndex,
    required jni$_.JObject? Function() clone,
  }) = _$AttributedCharacterIterator;

  int getRunStart();
  int getRunStart$1(AttributedCharacterIterator$Attribute? attribute);
  int getRunStart$2(jni$_.JSet<AttributedCharacterIterator$Attribute?>? set);
  int getRunLimit();
  int getRunLimit$1(AttributedCharacterIterator$Attribute? attribute);
  int getRunLimit$2(jni$_.JSet<AttributedCharacterIterator$Attribute?>? set);
  jni$_.JMap<AttributedCharacterIterator$Attribute?, jni$_.JObject?>?
  getAttributes();
  jni$_.JObject? getAttribute(AttributedCharacterIterator$Attribute? attribute);
  jni$_.JSet<AttributedCharacterIterator$Attribute?>? getAllAttributeKeys();
  int first();
  int last();
  int current();
  int next();
  int previous();
  int setIndex(int i);
  int getBeginIndex();
  int getEndIndex();
  int getIndex();
  jni$_.JObject? clone();
}

final class _$AttributedCharacterIterator with $AttributedCharacterIterator {
  _$AttributedCharacterIterator({
    required int Function() getRunStart,
    required int Function(AttributedCharacterIterator$Attribute? attribute)
    getRunStart$1,
    required int Function(
      jni$_.JSet<AttributedCharacterIterator$Attribute?>? set,
    )
    getRunStart$2,
    required int Function() getRunLimit,
    required int Function(AttributedCharacterIterator$Attribute? attribute)
    getRunLimit$1,
    required int Function(
      jni$_.JSet<AttributedCharacterIterator$Attribute?>? set,
    )
    getRunLimit$2,
    required jni$_.JMap<AttributedCharacterIterator$Attribute?, jni$_.JObject?>?
    Function()
    getAttributes,
    required jni$_.JObject? Function(
      AttributedCharacterIterator$Attribute? attribute,
    )
    getAttribute,
    required jni$_.JSet<AttributedCharacterIterator$Attribute?>? Function()
    getAllAttributeKeys,
    required int Function() first,
    required int Function() last,
    required int Function() current,
    required int Function() next,
    required int Function() previous,
    required int Function(int i) setIndex,
    required int Function() getBeginIndex,
    required int Function() getEndIndex,
    required int Function() getIndex,
    required jni$_.JObject? Function() clone,
  }) : _getRunStart = getRunStart,
       _getRunStart$1 = getRunStart$1,
       _getRunStart$2 = getRunStart$2,
       _getRunLimit = getRunLimit,
       _getRunLimit$1 = getRunLimit$1,
       _getRunLimit$2 = getRunLimit$2,
       _getAttributes = getAttributes,
       _getAttribute = getAttribute,
       _getAllAttributeKeys = getAllAttributeKeys,
       _first = first,
       _last = last,
       _current = current,
       _next = next,
       _previous = previous,
       _setIndex = setIndex,
       _getBeginIndex = getBeginIndex,
       _getEndIndex = getEndIndex,
       _getIndex = getIndex,
       _clone = clone;

  final int Function() _getRunStart;
  final int Function(AttributedCharacterIterator$Attribute? attribute)
  _getRunStart$1;
  final int Function(jni$_.JSet<AttributedCharacterIterator$Attribute?>? set)
  _getRunStart$2;
  final int Function() _getRunLimit;
  final int Function(AttributedCharacterIterator$Attribute? attribute)
  _getRunLimit$1;
  final int Function(jni$_.JSet<AttributedCharacterIterator$Attribute?>? set)
  _getRunLimit$2;
  final jni$_.JMap<AttributedCharacterIterator$Attribute?, jni$_.JObject?>?
  Function()
  _getAttributes;
  final jni$_.JObject? Function(
    AttributedCharacterIterator$Attribute? attribute,
  )
  _getAttribute;
  final jni$_.JSet<AttributedCharacterIterator$Attribute?>? Function()
  _getAllAttributeKeys;
  final int Function() _first;
  final int Function() _last;
  final int Function() _current;
  final int Function() _next;
  final int Function() _previous;
  final int Function(int i) _setIndex;
  final int Function() _getBeginIndex;
  final int Function() _getEndIndex;
  final int Function() _getIndex;
  final jni$_.JObject? Function() _clone;

  int getRunStart() => _getRunStart();

  int getRunStart$1(AttributedCharacterIterator$Attribute? attribute) =>
      _getRunStart$1(attribute);

  int getRunStart$2(jni$_.JSet<AttributedCharacterIterator$Attribute?>? set) =>
      _getRunStart$2(set);

  int getRunLimit() => _getRunLimit();

  int getRunLimit$1(AttributedCharacterIterator$Attribute? attribute) =>
      _getRunLimit$1(attribute);

  int getRunLimit$2(jni$_.JSet<AttributedCharacterIterator$Attribute?>? set) =>
      _getRunLimit$2(set);

  jni$_.JMap<AttributedCharacterIterator$Attribute?, jni$_.JObject?>?
  getAttributes() => _getAttributes();

  jni$_.JObject? getAttribute(
    AttributedCharacterIterator$Attribute? attribute,
  ) => _getAttribute(attribute);

  jni$_.JSet<AttributedCharacterIterator$Attribute?>? getAllAttributeKeys() =>
      _getAllAttributeKeys();

  int first() => _first();

  int last() => _last();

  int current() => _current();

  int next() => _next();

  int previous() => _previous();

  int setIndex(int i) => _setIndex(i);

  int getBeginIndex() => _getBeginIndex();

  int getEndIndex() => _getEndIndex();

  int getIndex() => _getIndex();

  jni$_.JObject? clone() => _clone();
}

final class $AttributedCharacterIterator$NullableType
    extends jni$_.JObjType<AttributedCharacterIterator?> {
  @jni$_.internal
  const $AttributedCharacterIterator$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/AttributedCharacterIterator;';

  @jni$_.internal
  @core$_.override
  AttributedCharacterIterator? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : AttributedCharacterIterator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AttributedCharacterIterator?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AttributedCharacterIterator$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($AttributedCharacterIterator$NullableType) &&
      other is $AttributedCharacterIterator$NullableType;
}

final class $AttributedCharacterIterator$Type
    extends jni$_.JObjType<AttributedCharacterIterator> {
  @jni$_.internal
  const $AttributedCharacterIterator$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/AttributedCharacterIterator;';

  @jni$_.internal
  @core$_.override
  AttributedCharacterIterator fromReference(jni$_.JReference reference) =>
      AttributedCharacterIterator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AttributedCharacterIterator?> get nullableType =>
      const $AttributedCharacterIterator$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AttributedCharacterIterator$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($AttributedCharacterIterator$Type) &&
      other is $AttributedCharacterIterator$Type;
}

/// from: `java.text.CollationKey`
class CollationKey extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CollationKey> $type;

  @jni$_.internal
  CollationKey.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/CollationKey');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CollationKey$NullableType();
  static const type = $CollationKey$Type();
  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/text/CollationKey;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract int compareTo(java.text.CollationKey collationKey)`
  int compareTo(CollationKey? collationKey) {
    final _$collationKey = collationKey?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$collationKey.pointer,
    ).integer;
  }

  static final _id_getSourceString = _class.instanceMethodId(
    r'getSourceString',
    r'()Ljava/lang/String;',
  );

  static final _getSourceString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getSourceString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getSourceString() => _getSourceString(
    reference.pointer,
    _id_getSourceString as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_toByteArray = _class.instanceMethodId(
    r'toByteArray',
    r'()[B',
  );

  static final _toByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract byte[] toByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? toByteArray() => _toByteArray(
    reference.pointer,
    _id_toByteArray as jni$_.JMethodIDPtr,
  ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());

  bool operator <(CollationKey? collationKey) => compareTo(collationKey) < 0;

  bool operator <=(CollationKey? collationKey) => compareTo(collationKey) <= 0;

  bool operator >(CollationKey? collationKey) => compareTo(collationKey) > 0;

  bool operator >=(CollationKey? collationKey) => compareTo(collationKey) >= 0;
}

final class $CollationKey$NullableType extends jni$_.JObjType<CollationKey?> {
  @jni$_.internal
  const $CollationKey$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/CollationKey;';

  @jni$_.internal
  @core$_.override
  CollationKey? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CollationKey.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CollationKey?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CollationKey$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CollationKey$NullableType) &&
      other is $CollationKey$NullableType;
}

final class $CollationKey$Type extends jni$_.JObjType<CollationKey> {
  @jni$_.internal
  const $CollationKey$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/CollationKey;';

  @jni$_.internal
  @core$_.override
  CollationKey fromReference(jni$_.JReference reference) =>
      CollationKey.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CollationKey?> get nullableType =>
      const $CollationKey$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CollationKey$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CollationKey$Type) && other is $CollationKey$Type;
}

/// from: `java.text.Normalizer$Form`
class Normalizer$Form extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Normalizer$Form> $type;

  @jni$_.internal
  Normalizer$Form.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/Normalizer$Form');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Normalizer$Form$NullableType();
  static const type = $Normalizer$Form$Type();
  static final _id_NFD = _class.staticFieldId(
    r'NFD',
    r'Ljava/text/Normalizer$Form;',
  );

  /// from: `static public final java.text.Normalizer$Form NFD`
  /// The returned object must be released after use, by calling the [release] method.
  static Normalizer$Form get NFD =>
      _id_NFD.get(_class, const $Normalizer$Form$Type());

  static final _id_NFC = _class.staticFieldId(
    r'NFC',
    r'Ljava/text/Normalizer$Form;',
  );

  /// from: `static public final java.text.Normalizer$Form NFC`
  /// The returned object must be released after use, by calling the [release] method.
  static Normalizer$Form get NFC =>
      _id_NFC.get(_class, const $Normalizer$Form$Type());

  static final _id_NFKD = _class.staticFieldId(
    r'NFKD',
    r'Ljava/text/Normalizer$Form;',
  );

  /// from: `static public final java.text.Normalizer$Form NFKD`
  /// The returned object must be released after use, by calling the [release] method.
  static Normalizer$Form get NFKD =>
      _id_NFKD.get(_class, const $Normalizer$Form$Type());

  static final _id_NFKC = _class.staticFieldId(
    r'NFKC',
    r'Ljava/text/Normalizer$Form;',
  );

  /// from: `static public final java.text.Normalizer$Form NFKC`
  /// The returned object must be released after use, by calling the [release] method.
  static Normalizer$Form get NFKC =>
      _id_NFKC.get(_class, const $Normalizer$Form$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/text/Normalizer$Form;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.text.Normalizer$Form[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Normalizer$Form?>? values() => _values(
    _class.reference.pointer,
    _id_values as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<Normalizer$Form?>?>(
    const jni$_.JArrayNullableType<Normalizer$Form?>(
      $Normalizer$Form$NullableType(),
    ),
  );

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/text/Normalizer$Form;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.text.Normalizer$Form valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static Normalizer$Form? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<Normalizer$Form?>(const $Normalizer$Form$NullableType());
  }
}

final class $Normalizer$Form$NullableType
    extends jni$_.JObjType<Normalizer$Form?> {
  @jni$_.internal
  const $Normalizer$Form$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/Normalizer$Form;';

  @jni$_.internal
  @core$_.override
  Normalizer$Form? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Normalizer$Form.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Normalizer$Form?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Normalizer$Form$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Normalizer$Form$NullableType) &&
      other is $Normalizer$Form$NullableType;
}

final class $Normalizer$Form$Type extends jni$_.JObjType<Normalizer$Form> {
  @jni$_.internal
  const $Normalizer$Form$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/Normalizer$Form;';

  @jni$_.internal
  @core$_.override
  Normalizer$Form fromReference(jni$_.JReference reference) =>
      Normalizer$Form.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Normalizer$Form?> get nullableType =>
      const $Normalizer$Form$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Normalizer$Form$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Normalizer$Form$Type) &&
      other is $Normalizer$Form$Type;
}

/// from: `java.text.CompactNumberFormat`
class CompactNumberFormat extends NumberFormat {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CompactNumberFormat> $type;

  @jni$_.internal
  CompactNumberFormat.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/CompactNumberFormat');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CompactNumberFormat$NullableType();
  static const type = $CompactNumberFormat$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/text/DecimalFormatSymbols;[Ljava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.text.DecimalFormatSymbols decimalFormatSymbols, java.lang.String[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CompactNumberFormat(
    jni$_.JString? string,
    DecimalFormatSymbols? decimalFormatSymbols,
    jni$_.JArray<jni$_.JString?>? strings,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$decimalFormatSymbols =
        decimalFormatSymbols?.reference ?? jni$_.jNullReference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    return CompactNumberFormat.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$decimalFormatSymbols.pointer,
        _$strings.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/text/DecimalFormatSymbols;[Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.text.DecimalFormatSymbols decimalFormatSymbols, java.lang.String[] strings, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CompactNumberFormat.new$1(
    jni$_.JString? string,
    DecimalFormatSymbols? decimalFormatSymbols,
    jni$_.JArray<jni$_.JString?>? strings,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$decimalFormatSymbols =
        decimalFormatSymbols?.reference ?? jni$_.jNullReference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return CompactNumberFormat.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$decimalFormatSymbols.pointer,
        _$strings.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_format1 = _class.instanceMethodId(
    r'format',
    r'(Ljava/lang/Object;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final java.lang.StringBuffer format(java.lang.Object object, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format1(
    jni$_.JObject? object,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format1(
      reference.pointer,
      _id_format1 as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_format4 = _class.instanceMethodId(
    r'format',
    r'(DLjava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Double,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.StringBuffer format(double d, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format4(
    double d,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format4(
      reference.pointer,
      _id_format4 as jni$_.JMethodIDPtr,
      d,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_format5 = _class.instanceMethodId(
    r'format',
    r'(JLjava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int64,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.StringBuffer format(long j, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format5(
    int j,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format5(
      reference.pointer,
      _id_format5 as jni$_.JMethodIDPtr,
      j,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_formatToCharacterIterator$1 = _class.instanceMethodId(
    r'formatToCharacterIterator',
    r'(Ljava/lang/Object;)Ljava/text/AttributedCharacterIterator;',
  );

  static final _formatToCharacterIterator$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  AttributedCharacterIterator? formatToCharacterIterator$1(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _formatToCharacterIterator$1(
      reference.pointer,
      _id_formatToCharacterIterator$1 as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<AttributedCharacterIterator?>(
      const $AttributedCharacterIterator$NullableType(),
    );
  }

  static final _id_parse = _class.instanceMethodId(
    r'parse',
    r'(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/lang/Number;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Number parse(java.lang.String string, java.text.ParsePosition parsePosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JNumber? parse(jni$_.JString? string, ParsePosition? parsePosition) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$parsePosition = parsePosition?.reference ?? jni$_.jNullReference;
    return _parse(
      reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$parsePosition.pointer,
    ).object<jni$_.JNumber?>(const jni$_.JNumberNullableType());
  }

  static final _id_setMaximumIntegerDigits = _class.instanceMethodId(
    r'setMaximumIntegerDigits',
    r'(I)V',
  );

  static final _setMaximumIntegerDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMaximumIntegerDigits(int i)`
  void setMaximumIntegerDigits(int i) {
    _setMaximumIntegerDigits(
      reference.pointer,
      _id_setMaximumIntegerDigits as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setMinimumIntegerDigits = _class.instanceMethodId(
    r'setMinimumIntegerDigits',
    r'(I)V',
  );

  static final _setMinimumIntegerDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMinimumIntegerDigits(int i)`
  void setMinimumIntegerDigits(int i) {
    _setMinimumIntegerDigits(
      reference.pointer,
      _id_setMinimumIntegerDigits as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setMinimumFractionDigits = _class.instanceMethodId(
    r'setMinimumFractionDigits',
    r'(I)V',
  );

  static final _setMinimumFractionDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMinimumFractionDigits(int i)`
  void setMinimumFractionDigits(int i) {
    _setMinimumFractionDigits(
      reference.pointer,
      _id_setMinimumFractionDigits as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setMaximumFractionDigits = _class.instanceMethodId(
    r'setMaximumFractionDigits',
    r'(I)V',
  );

  static final _setMaximumFractionDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMaximumFractionDigits(int i)`
  void setMaximumFractionDigits(int i) {
    _setMaximumFractionDigits(
      reference.pointer,
      _id_setMaximumFractionDigits as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getRoundingMode = _class.instanceMethodId(
    r'getRoundingMode',
    r'()Ljava/math/RoundingMode;',
  );

  static final _getRoundingMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.math.RoundingMode getRoundingMode()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRoundingMode() => _getRoundingMode(
    reference.pointer,
    _id_getRoundingMode as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_setRoundingMode = _class.instanceMethodId(
    r'setRoundingMode',
    r'(Ljava/math/RoundingMode;)V',
  );

  static final _setRoundingMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setRoundingMode(java.math.RoundingMode roundingMode)`
  void setRoundingMode(jni$_.JObject? roundingMode) {
    final _$roundingMode = roundingMode?.reference ?? jni$_.jNullReference;
    _setRoundingMode(
      reference.pointer,
      _id_setRoundingMode as jni$_.JMethodIDPtr,
      _$roundingMode.pointer,
    ).check();
  }

  static final _id_getGroupingSize = _class.instanceMethodId(
    r'getGroupingSize',
    r'()I',
  );

  static final _getGroupingSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getGroupingSize()`
  int getGroupingSize() =>
      _getGroupingSize(
        reference.pointer,
        _id_getGroupingSize as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setGroupingSize = _class.instanceMethodId(
    r'setGroupingSize',
    r'(I)V',
  );

  static final _setGroupingSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setGroupingSize(int i)`
  void setGroupingSize(int i) {
    _setGroupingSize(
      reference.pointer,
      _id_setGroupingSize as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_isGroupingUsed = _class.instanceMethodId(
    r'isGroupingUsed',
    r'()Z',
  );

  static final _isGroupingUsed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isGroupingUsed()`
  bool isGroupingUsed() =>
      _isGroupingUsed(
        reference.pointer,
        _id_isGroupingUsed as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setGroupingUsed = _class.instanceMethodId(
    r'setGroupingUsed',
    r'(Z)V',
  );

  static final _setGroupingUsed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setGroupingUsed(boolean z)`
  void setGroupingUsed(bool z) {
    _setGroupingUsed(
      reference.pointer,
      _id_setGroupingUsed as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_isParseIntegerOnly = _class.instanceMethodId(
    r'isParseIntegerOnly',
    r'()Z',
  );

  static final _isParseIntegerOnly =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isParseIntegerOnly()`
  bool isParseIntegerOnly() =>
      _isParseIntegerOnly(
        reference.pointer,
        _id_isParseIntegerOnly as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setParseIntegerOnly = _class.instanceMethodId(
    r'setParseIntegerOnly',
    r'(Z)V',
  );

  static final _setParseIntegerOnly =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setParseIntegerOnly(boolean z)`
  void setParseIntegerOnly(bool z) {
    _setParseIntegerOnly(
      reference.pointer,
      _id_setParseIntegerOnly as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_isParseBigDecimal = _class.instanceMethodId(
    r'isParseBigDecimal',
    r'()Z',
  );

  static final _isParseBigDecimal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isParseBigDecimal()`
  bool isParseBigDecimal() =>
      _isParseBigDecimal(
        reference.pointer,
        _id_isParseBigDecimal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setParseBigDecimal = _class.instanceMethodId(
    r'setParseBigDecimal',
    r'(Z)V',
  );

  static final _setParseBigDecimal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setParseBigDecimal(boolean z)`
  void setParseBigDecimal(bool z) {
    _setParseBigDecimal(
      reference.pointer,
      _id_setParseBigDecimal as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode1() =>
      _hashCode1(
        reference.pointer,
        _id_hashCode1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_clone$1 = _class.instanceMethodId(
    r'clone',
    r'()Ljava/text/CompactNumberFormat;',
  );

  static final _clone$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.text.CompactNumberFormat clone()`
  /// The returned object must be released after use, by calling the [release] method.
  CompactNumberFormat? clone$1() => _clone$1(
    reference.pointer,
    _id_clone$1 as jni$_.JMethodIDPtr,
  ).object<CompactNumberFormat?>(const $CompactNumberFormat$NullableType());
}

final class $CompactNumberFormat$NullableType
    extends jni$_.JObjType<CompactNumberFormat?> {
  @jni$_.internal
  const $CompactNumberFormat$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/CompactNumberFormat;';

  @jni$_.internal
  @core$_.override
  CompactNumberFormat? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CompactNumberFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $NumberFormat$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CompactNumberFormat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($CompactNumberFormat$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CompactNumberFormat$NullableType) &&
      other is $CompactNumberFormat$NullableType;
}

final class $CompactNumberFormat$Type
    extends jni$_.JObjType<CompactNumberFormat> {
  @jni$_.internal
  const $CompactNumberFormat$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/CompactNumberFormat;';

  @jni$_.internal
  @core$_.override
  CompactNumberFormat fromReference(jni$_.JReference reference) =>
      CompactNumberFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $NumberFormat$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CompactNumberFormat?> get nullableType =>
      const $CompactNumberFormat$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($CompactNumberFormat$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CompactNumberFormat$Type) &&
      other is $CompactNumberFormat$Type;
}

/// from: `java.text.ParsePosition`
class ParsePosition extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ParsePosition> $type;

  @jni$_.internal
  ParsePosition.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/ParsePosition');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ParsePosition$NullableType();
  static const type = $ParsePosition$Type();
  static final _id_getIndex = _class.instanceMethodId(r'getIndex', r'()I');

  static final _getIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getIndex()`
  int getIndex() =>
      _getIndex(reference.pointer, _id_getIndex as jni$_.JMethodIDPtr).integer;

  static final _id_setIndex = _class.instanceMethodId(r'setIndex', r'(I)V');

  static final _setIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setIndex(int i)`
  void setIndex(int i) {
    _setIndex(reference.pointer, _id_setIndex as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_new$ = _class.constructorId(r'(I)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ParsePosition(int i) => ParsePosition.fromReference(
    _new$(
      _class.reference.pointer,
      _id_new$ as jni$_.JMethodIDPtr,
      i,
    ).reference,
  );

  static final _id_setErrorIndex = _class.instanceMethodId(
    r'setErrorIndex',
    r'(I)V',
  );

  static final _setErrorIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setErrorIndex(int i)`
  void setErrorIndex(int i) {
    _setErrorIndex(
      reference.pointer,
      _id_setErrorIndex as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getErrorIndex = _class.instanceMethodId(
    r'getErrorIndex',
    r'()I',
  );

  static final _getErrorIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getErrorIndex()`
  int getErrorIndex() =>
      _getErrorIndex(
        reference.pointer,
        _id_getErrorIndex as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $ParsePosition$NullableType extends jni$_.JObjType<ParsePosition?> {
  @jni$_.internal
  const $ParsePosition$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/ParsePosition;';

  @jni$_.internal
  @core$_.override
  ParsePosition? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ParsePosition.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ParsePosition?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ParsePosition$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ParsePosition$NullableType) &&
      other is $ParsePosition$NullableType;
}

final class $ParsePosition$Type extends jni$_.JObjType<ParsePosition> {
  @jni$_.internal
  const $ParsePosition$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/ParsePosition;';

  @jni$_.internal
  @core$_.override
  ParsePosition fromReference(jni$_.JReference reference) =>
      ParsePosition.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ParsePosition?> get nullableType =>
      const $ParsePosition$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ParsePosition$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ParsePosition$Type) &&
      other is $ParsePosition$Type;
}

/// from: `java.text.SimpleDateFormat`
class SimpleDateFormat extends DateFormat {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SimpleDateFormat> $type;

  @jni$_.internal
  SimpleDateFormat.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/SimpleDateFormat');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SimpleDateFormat$NullableType();
  static const type = $SimpleDateFormat$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory SimpleDateFormat() => SimpleDateFormat.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SimpleDateFormat.new$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return SimpleDateFormat.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/util/Locale;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SimpleDateFormat.new$2(jni$_.JString? string, jni$_.JObject? locale) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return SimpleDateFormat.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$locale.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/text/DateFormatSymbols;)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.text.DateFormatSymbols dateFormatSymbols)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SimpleDateFormat.new$3(
    jni$_.JString? string,
    DateFormatSymbols? dateFormatSymbols,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$dateFormatSymbols =
        dateFormatSymbols?.reference ?? jni$_.jNullReference;
    return SimpleDateFormat.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$dateFormatSymbols.pointer,
      ).reference,
    );
  }

  static final _id_set2DigitYearStart = _class.instanceMethodId(
    r'set2DigitYearStart',
    r'(Ljava/util/Date;)V',
  );

  static final _set2DigitYearStart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void set2DigitYearStart(java.util.Date date)`
  void set2DigitYearStart(jni$_.JObject? date) {
    final _$date = date?.reference ?? jni$_.jNullReference;
    _set2DigitYearStart(
      reference.pointer,
      _id_set2DigitYearStart as jni$_.JMethodIDPtr,
      _$date.pointer,
    ).check();
  }

  static final _id_get2DigitYearStart = _class.instanceMethodId(
    r'get2DigitYearStart',
    r'()Ljava/util/Date;',
  );

  static final _get2DigitYearStart =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Date get2DigitYearStart()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get2DigitYearStart() => _get2DigitYearStart(
    reference.pointer,
    _id_get2DigitYearStart as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_format2 = _class.instanceMethodId(
    r'format',
    r'(Ljava/util/Date;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.StringBuffer format(java.util.Date date, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format2(
    jni$_.JObject? date,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$date = date?.reference ?? jni$_.jNullReference;
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format2(
      reference.pointer,
      _id_format2 as jni$_.JMethodIDPtr,
      _$date.pointer,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_formatToCharacterIterator$1 = _class.instanceMethodId(
    r'formatToCharacterIterator',
    r'(Ljava/lang/Object;)Ljava/text/AttributedCharacterIterator;',
  );

  static final _formatToCharacterIterator$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  AttributedCharacterIterator? formatToCharacterIterator$1(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _formatToCharacterIterator$1(
      reference.pointer,
      _id_formatToCharacterIterator$1 as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<AttributedCharacterIterator?>(
      const $AttributedCharacterIterator$NullableType(),
    );
  }

  static final _id_parse1 = _class.instanceMethodId(
    r'parse',
    r'(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/util/Date;',
  );

  static final _parse1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.Date parse(java.lang.String string, java.text.ParsePosition parsePosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? parse1(jni$_.JString? string, ParsePosition? parsePosition) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$parsePosition = parsePosition?.reference ?? jni$_.jNullReference;
    return _parse1(
      reference.pointer,
      _id_parse1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$parsePosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toPattern = _class.instanceMethodId(
    r'toPattern',
    r'()Ljava/lang/String;',
  );

  static final _toPattern =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toPattern()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toPattern() => _toPattern(
    reference.pointer,
    _id_toPattern as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_toLocalizedPattern = _class.instanceMethodId(
    r'toLocalizedPattern',
    r'()Ljava/lang/String;',
  );

  static final _toLocalizedPattern =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toLocalizedPattern()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toLocalizedPattern() => _toLocalizedPattern(
    reference.pointer,
    _id_toLocalizedPattern as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_applyPattern = _class.instanceMethodId(
    r'applyPattern',
    r'(Ljava/lang/String;)V',
  );

  static final _applyPattern =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void applyPattern(java.lang.String string)`
  void applyPattern(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _applyPattern(
      reference.pointer,
      _id_applyPattern as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_applyLocalizedPattern = _class.instanceMethodId(
    r'applyLocalizedPattern',
    r'(Ljava/lang/String;)V',
  );

  static final _applyLocalizedPattern =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void applyLocalizedPattern(java.lang.String string)`
  void applyLocalizedPattern(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _applyLocalizedPattern(
      reference.pointer,
      _id_applyLocalizedPattern as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getDateFormatSymbols = _class.instanceMethodId(
    r'getDateFormatSymbols',
    r'()Ljava/text/DateFormatSymbols;',
  );

  static final _getDateFormatSymbols =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.text.DateFormatSymbols getDateFormatSymbols()`
  /// The returned object must be released after use, by calling the [release] method.
  DateFormatSymbols? getDateFormatSymbols() => _getDateFormatSymbols(
    reference.pointer,
    _id_getDateFormatSymbols as jni$_.JMethodIDPtr,
  ).object<DateFormatSymbols?>(const $DateFormatSymbols$NullableType());

  static final _id_setDateFormatSymbols = _class.instanceMethodId(
    r'setDateFormatSymbols',
    r'(Ljava/text/DateFormatSymbols;)V',
  );

  static final _setDateFormatSymbols =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setDateFormatSymbols(java.text.DateFormatSymbols dateFormatSymbols)`
  void setDateFormatSymbols(DateFormatSymbols? dateFormatSymbols) {
    final _$dateFormatSymbols =
        dateFormatSymbols?.reference ?? jni$_.jNullReference;
    _setDateFormatSymbols(
      reference.pointer,
      _id_setDateFormatSymbols as jni$_.JMethodIDPtr,
      _$dateFormatSymbols.pointer,
    ).check();
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_hashCode1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode1() =>
      _hashCode1(
        reference.pointer,
        _id_hashCode1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }
}

final class $SimpleDateFormat$NullableType
    extends jni$_.JObjType<SimpleDateFormat?> {
  @jni$_.internal
  const $SimpleDateFormat$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/SimpleDateFormat;';

  @jni$_.internal
  @core$_.override
  SimpleDateFormat? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SimpleDateFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $DateFormat$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SimpleDateFormat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($SimpleDateFormat$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SimpleDateFormat$NullableType) &&
      other is $SimpleDateFormat$NullableType;
}

final class $SimpleDateFormat$Type extends jni$_.JObjType<SimpleDateFormat> {
  @jni$_.internal
  const $SimpleDateFormat$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/SimpleDateFormat;';

  @jni$_.internal
  @core$_.override
  SimpleDateFormat fromReference(jni$_.JReference reference) =>
      SimpleDateFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $DateFormat$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SimpleDateFormat?> get nullableType =>
      const $SimpleDateFormat$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($SimpleDateFormat$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($SimpleDateFormat$Type) &&
      other is $SimpleDateFormat$Type;
}

/// from: `java.text.NumberFormat`
class NumberFormat extends Format {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NumberFormat> $type;

  @jni$_.internal
  NumberFormat.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/NumberFormat');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NumberFormat$NullableType();
  static const type = $NumberFormat$Type();

  /// from: `static public final int INTEGER_FIELD`
  static const INTEGER_FIELD = 0;

  /// from: `static public final int FRACTION_FIELD`
  static const FRACTION_FIELD = 1;
  static final _id_format1 = _class.instanceMethodId(
    r'format',
    r'(Ljava/lang/Object;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.StringBuffer format(java.lang.Object object, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format1(
    jni$_.JObject? object,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format1(
      reference.pointer,
      _id_format1 as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_parseObject = _class.instanceMethodId(
    r'parseObject',
    r'(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/lang/Object;',
  );

  static final _parseObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final java.lang.Object parseObject(java.lang.String string, java.text.ParsePosition parsePosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? parseObject(
    jni$_.JString? string,
    ParsePosition? parsePosition,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$parsePosition = parsePosition?.reference ?? jni$_.jNullReference;
    return _parseObject(
      reference.pointer,
      _id_parseObject as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$parsePosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_format$2 = _class.instanceMethodId(
    r'format',
    r'(D)Ljava/lang/String;',
  );

  static final _format$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public final java.lang.String format(double d)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format$2(double d) => _format$2(
    reference.pointer,
    _id_format$2 as jni$_.JMethodIDPtr,
    d,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_format$3 = _class.instanceMethodId(
    r'format',
    r'(J)Ljava/lang/String;',
  );

  static final _format$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final java.lang.String format(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format$3(int j) => _format$3(
    reference.pointer,
    _id_format$3 as jni$_.JMethodIDPtr,
    j,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_format$4 = _class.instanceMethodId(
    r'format',
    r'(DLjava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Double,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.StringBuffer format(double d, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format$4(
    double d,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format$4(
      reference.pointer,
      _id_format$4 as jni$_.JMethodIDPtr,
      d,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_format$5 = _class.instanceMethodId(
    r'format',
    r'(JLjava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int64,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.StringBuffer format(long j, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format$5(
    int j,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format$5(
      reference.pointer,
      _id_format$5 as jni$_.JMethodIDPtr,
      j,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_parse = _class.instanceMethodId(
    r'parse',
    r'(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/lang/Number;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Number parse(java.lang.String string, java.text.ParsePosition parsePosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JNumber? parse(jni$_.JString? string, ParsePosition? parsePosition) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$parsePosition = parsePosition?.reference ?? jni$_.jNullReference;
    return _parse(
      reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$parsePosition.pointer,
    ).object<jni$_.JNumber?>(const jni$_.JNumberNullableType());
  }

  static final _id_parse$1 = _class.instanceMethodId(
    r'parse',
    r'(Ljava/lang/String;)Ljava/lang/Number;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Number parse(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JNumber? parse$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _parse$1(
      reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JNumber?>(const jni$_.JNumberNullableType());
  }

  static final _id_isParseIntegerOnly = _class.instanceMethodId(
    r'isParseIntegerOnly',
    r'()Z',
  );

  static final _isParseIntegerOnly =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isParseIntegerOnly()`
  bool isParseIntegerOnly() =>
      _isParseIntegerOnly(
        reference.pointer,
        _id_isParseIntegerOnly as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setParseIntegerOnly = _class.instanceMethodId(
    r'setParseIntegerOnly',
    r'(Z)V',
  );

  static final _setParseIntegerOnly =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setParseIntegerOnly(boolean z)`
  void setParseIntegerOnly(bool z) {
    _setParseIntegerOnly(
      reference.pointer,
      _id_setParseIntegerOnly as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getInstance = _class.staticMethodId(
    r'getInstance',
    r'()Ljava/text/NumberFormat;',
  );

  static final _getInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public final java.text.NumberFormat getInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat? getInstance() => _getInstance(
    _class.reference.pointer,
    _id_getInstance as jni$_.JMethodIDPtr,
  ).object<NumberFormat?>(const $NumberFormat$NullableType());

  static final _id_getInstance$1 = _class.staticMethodId(
    r'getInstance',
    r'(Ljava/util/Locale;)Ljava/text/NumberFormat;',
  );

  static final _getInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.text.NumberFormat getInstance(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat? getInstance$1(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getInstance$1(
      _class.reference.pointer,
      _id_getInstance$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<NumberFormat?>(const $NumberFormat$NullableType());
  }

  static final _id_getNumberInstance = _class.staticMethodId(
    r'getNumberInstance',
    r'()Ljava/text/NumberFormat;',
  );

  static final _getNumberInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public final java.text.NumberFormat getNumberInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat? getNumberInstance() => _getNumberInstance(
    _class.reference.pointer,
    _id_getNumberInstance as jni$_.JMethodIDPtr,
  ).object<NumberFormat?>(const $NumberFormat$NullableType());

  static final _id_getNumberInstance$1 = _class.staticMethodId(
    r'getNumberInstance',
    r'(Ljava/util/Locale;)Ljava/text/NumberFormat;',
  );

  static final _getNumberInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.text.NumberFormat getNumberInstance(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat? getNumberInstance$1(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getNumberInstance$1(
      _class.reference.pointer,
      _id_getNumberInstance$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<NumberFormat?>(const $NumberFormat$NullableType());
  }

  static final _id_getIntegerInstance = _class.staticMethodId(
    r'getIntegerInstance',
    r'()Ljava/text/NumberFormat;',
  );

  static final _getIntegerInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public final java.text.NumberFormat getIntegerInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat? getIntegerInstance() => _getIntegerInstance(
    _class.reference.pointer,
    _id_getIntegerInstance as jni$_.JMethodIDPtr,
  ).object<NumberFormat?>(const $NumberFormat$NullableType());

  static final _id_getIntegerInstance$1 = _class.staticMethodId(
    r'getIntegerInstance',
    r'(Ljava/util/Locale;)Ljava/text/NumberFormat;',
  );

  static final _getIntegerInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.text.NumberFormat getIntegerInstance(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat? getIntegerInstance$1(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getIntegerInstance$1(
      _class.reference.pointer,
      _id_getIntegerInstance$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<NumberFormat?>(const $NumberFormat$NullableType());
  }

  static final _id_getCurrencyInstance = _class.staticMethodId(
    r'getCurrencyInstance',
    r'()Ljava/text/NumberFormat;',
  );

  static final _getCurrencyInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public final java.text.NumberFormat getCurrencyInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat? getCurrencyInstance() => _getCurrencyInstance(
    _class.reference.pointer,
    _id_getCurrencyInstance as jni$_.JMethodIDPtr,
  ).object<NumberFormat?>(const $NumberFormat$NullableType());

  static final _id_getCurrencyInstance$1 = _class.staticMethodId(
    r'getCurrencyInstance',
    r'(Ljava/util/Locale;)Ljava/text/NumberFormat;',
  );

  static final _getCurrencyInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.text.NumberFormat getCurrencyInstance(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat? getCurrencyInstance$1(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getCurrencyInstance$1(
      _class.reference.pointer,
      _id_getCurrencyInstance$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<NumberFormat?>(const $NumberFormat$NullableType());
  }

  static final _id_getPercentInstance = _class.staticMethodId(
    r'getPercentInstance',
    r'()Ljava/text/NumberFormat;',
  );

  static final _getPercentInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public final java.text.NumberFormat getPercentInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat? getPercentInstance() => _getPercentInstance(
    _class.reference.pointer,
    _id_getPercentInstance as jni$_.JMethodIDPtr,
  ).object<NumberFormat?>(const $NumberFormat$NullableType());

  static final _id_getPercentInstance$1 = _class.staticMethodId(
    r'getPercentInstance',
    r'(Ljava/util/Locale;)Ljava/text/NumberFormat;',
  );

  static final _getPercentInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.text.NumberFormat getPercentInstance(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat? getPercentInstance$1(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getPercentInstance$1(
      _class.reference.pointer,
      _id_getPercentInstance$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<NumberFormat?>(const $NumberFormat$NullableType());
  }

  static final _id_getCompactNumberInstance = _class.staticMethodId(
    r'getCompactNumberInstance',
    r'()Ljava/text/NumberFormat;',
  );

  static final _getCompactNumberInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.text.NumberFormat getCompactNumberInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat? getCompactNumberInstance() => _getCompactNumberInstance(
    _class.reference.pointer,
    _id_getCompactNumberInstance as jni$_.JMethodIDPtr,
  ).object<NumberFormat?>(const $NumberFormat$NullableType());

  static final _id_getCompactNumberInstance$1 = _class.staticMethodId(
    r'getCompactNumberInstance',
    r'(Ljava/util/Locale;Ljava/text/NumberFormat$Style;)Ljava/text/NumberFormat;',
  );

  static final _getCompactNumberInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.text.NumberFormat getCompactNumberInstance(java.util.Locale locale, java.text.NumberFormat$Style style)`
  /// The returned object must be released after use, by calling the [release] method.
  static NumberFormat? getCompactNumberInstance$1(
    jni$_.JObject? locale,
    NumberFormat$Style? style,
  ) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    final _$style = style?.reference ?? jni$_.jNullReference;
    return _getCompactNumberInstance$1(
      _class.reference.pointer,
      _id_getCompactNumberInstance$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
      _$style.pointer,
    ).object<NumberFormat?>(const $NumberFormat$NullableType());
  }

  static final _id_getAvailableLocales = _class.staticMethodId(
    r'getAvailableLocales',
    r'()[Ljava/util/Locale;',
  );

  static final _getAvailableLocales =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Locale[] getAvailableLocales()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JObject?>? getAvailableLocales() =>
      _getAvailableLocales(
        _class.reference.pointer,
        _id_getAvailableLocales as jni$_.JMethodIDPtr,
      ).object<jni$_.JArray<jni$_.JObject?>?>(
        const jni$_.JArrayNullableType<jni$_.JObject?>(
          jni$_.JObjectNullableType(),
        ),
      );

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_isGroupingUsed = _class.instanceMethodId(
    r'isGroupingUsed',
    r'()Z',
  );

  static final _isGroupingUsed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isGroupingUsed()`
  bool isGroupingUsed() =>
      _isGroupingUsed(
        reference.pointer,
        _id_isGroupingUsed as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setGroupingUsed = _class.instanceMethodId(
    r'setGroupingUsed',
    r'(Z)V',
  );

  static final _setGroupingUsed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setGroupingUsed(boolean z)`
  void setGroupingUsed(bool z) {
    _setGroupingUsed(
      reference.pointer,
      _id_setGroupingUsed as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getMaximumIntegerDigits = _class.instanceMethodId(
    r'getMaximumIntegerDigits',
    r'()I',
  );

  static final _getMaximumIntegerDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMaximumIntegerDigits()`
  int getMaximumIntegerDigits() =>
      _getMaximumIntegerDigits(
        reference.pointer,
        _id_getMaximumIntegerDigits as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setMaximumIntegerDigits = _class.instanceMethodId(
    r'setMaximumIntegerDigits',
    r'(I)V',
  );

  static final _setMaximumIntegerDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMaximumIntegerDigits(int i)`
  void setMaximumIntegerDigits(int i) {
    _setMaximumIntegerDigits(
      reference.pointer,
      _id_setMaximumIntegerDigits as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getMinimumIntegerDigits = _class.instanceMethodId(
    r'getMinimumIntegerDigits',
    r'()I',
  );

  static final _getMinimumIntegerDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMinimumIntegerDigits()`
  int getMinimumIntegerDigits() =>
      _getMinimumIntegerDigits(
        reference.pointer,
        _id_getMinimumIntegerDigits as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setMinimumIntegerDigits = _class.instanceMethodId(
    r'setMinimumIntegerDigits',
    r'(I)V',
  );

  static final _setMinimumIntegerDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMinimumIntegerDigits(int i)`
  void setMinimumIntegerDigits(int i) {
    _setMinimumIntegerDigits(
      reference.pointer,
      _id_setMinimumIntegerDigits as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getMaximumFractionDigits = _class.instanceMethodId(
    r'getMaximumFractionDigits',
    r'()I',
  );

  static final _getMaximumFractionDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMaximumFractionDigits()`
  int getMaximumFractionDigits() =>
      _getMaximumFractionDigits(
        reference.pointer,
        _id_getMaximumFractionDigits as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setMaximumFractionDigits = _class.instanceMethodId(
    r'setMaximumFractionDigits',
    r'(I)V',
  );

  static final _setMaximumFractionDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMaximumFractionDigits(int i)`
  void setMaximumFractionDigits(int i) {
    _setMaximumFractionDigits(
      reference.pointer,
      _id_setMaximumFractionDigits as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getMinimumFractionDigits = _class.instanceMethodId(
    r'getMinimumFractionDigits',
    r'()I',
  );

  static final _getMinimumFractionDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMinimumFractionDigits()`
  int getMinimumFractionDigits() =>
      _getMinimumFractionDigits(
        reference.pointer,
        _id_getMinimumFractionDigits as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setMinimumFractionDigits = _class.instanceMethodId(
    r'setMinimumFractionDigits',
    r'(I)V',
  );

  static final _setMinimumFractionDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMinimumFractionDigits(int i)`
  void setMinimumFractionDigits(int i) {
    _setMinimumFractionDigits(
      reference.pointer,
      _id_setMinimumFractionDigits as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getCurrency = _class.instanceMethodId(
    r'getCurrency',
    r'()Ljava/util/Currency;',
  );

  static final _getCurrency =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Currency getCurrency()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getCurrency() => _getCurrency(
    reference.pointer,
    _id_getCurrency as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_setCurrency = _class.instanceMethodId(
    r'setCurrency',
    r'(Ljava/util/Currency;)V',
  );

  static final _setCurrency =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setCurrency(java.util.Currency currency)`
  void setCurrency(jni$_.JObject? currency) {
    final _$currency = currency?.reference ?? jni$_.jNullReference;
    _setCurrency(
      reference.pointer,
      _id_setCurrency as jni$_.JMethodIDPtr,
      _$currency.pointer,
    ).check();
  }

  static final _id_getRoundingMode = _class.instanceMethodId(
    r'getRoundingMode',
    r'()Ljava/math/RoundingMode;',
  );

  static final _getRoundingMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.math.RoundingMode getRoundingMode()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRoundingMode() => _getRoundingMode(
    reference.pointer,
    _id_getRoundingMode as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_setRoundingMode = _class.instanceMethodId(
    r'setRoundingMode',
    r'(Ljava/math/RoundingMode;)V',
  );

  static final _setRoundingMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setRoundingMode(java.math.RoundingMode roundingMode)`
  void setRoundingMode(jni$_.JObject? roundingMode) {
    final _$roundingMode = roundingMode?.reference ?? jni$_.jNullReference;
    _setRoundingMode(
      reference.pointer,
      _id_setRoundingMode as jni$_.JMethodIDPtr,
      _$roundingMode.pointer,
    ).check();
  }
}

final class $NumberFormat$NullableType extends jni$_.JObjType<NumberFormat?> {
  @jni$_.internal
  const $NumberFormat$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/NumberFormat;';

  @jni$_.internal
  @core$_.override
  NumberFormat? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NumberFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Format$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NumberFormat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($NumberFormat$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NumberFormat$NullableType) &&
      other is $NumberFormat$NullableType;
}

final class $NumberFormat$Type extends jni$_.JObjType<NumberFormat> {
  @jni$_.internal
  const $NumberFormat$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/NumberFormat;';

  @jni$_.internal
  @core$_.override
  NumberFormat fromReference(jni$_.JReference reference) =>
      NumberFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Format$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NumberFormat?> get nullableType =>
      const $NumberFormat$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($NumberFormat$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($NumberFormat$Type) && other is $NumberFormat$Type;
}

/// from: `java.text.MessageFormat`
class MessageFormat extends Format {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<MessageFormat> $type;

  @jni$_.internal
  MessageFormat.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/MessageFormat');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $MessageFormat$NullableType();
  static const type = $MessageFormat$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MessageFormat(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return MessageFormat.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/util/Locale;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  factory MessageFormat.new$1(jni$_.JString? string, jni$_.JObject? locale) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return MessageFormat.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$locale.pointer,
      ).reference,
    );
  }

  static final _id_setLocale = _class.instanceMethodId(
    r'setLocale',
    r'(Ljava/util/Locale;)V',
  );

  static final _setLocale =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setLocale(java.util.Locale locale)`
  void setLocale(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    _setLocale(
      reference.pointer,
      _id_setLocale as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).check();
  }

  static final _id_getLocale = _class.instanceMethodId(
    r'getLocale',
    r'()Ljava/util/Locale;',
  );

  static final _getLocale =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Locale getLocale()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getLocale() => _getLocale(
    reference.pointer,
    _id_getLocale as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_applyPattern = _class.instanceMethodId(
    r'applyPattern',
    r'(Ljava/lang/String;)V',
  );

  static final _applyPattern =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void applyPattern(java.lang.String string)`
  void applyPattern(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _applyPattern(
      reference.pointer,
      _id_applyPattern as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_toPattern = _class.instanceMethodId(
    r'toPattern',
    r'()Ljava/lang/String;',
  );

  static final _toPattern =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toPattern()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toPattern() => _toPattern(
    reference.pointer,
    _id_toPattern as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setFormatsByArgumentIndex = _class.instanceMethodId(
    r'setFormatsByArgumentIndex',
    r'([Ljava/text/Format;)V',
  );

  static final _setFormatsByArgumentIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setFormatsByArgumentIndex(java.text.Format[] formats)`
  void setFormatsByArgumentIndex(jni$_.JArray<Format?>? formats) {
    final _$formats = formats?.reference ?? jni$_.jNullReference;
    _setFormatsByArgumentIndex(
      reference.pointer,
      _id_setFormatsByArgumentIndex as jni$_.JMethodIDPtr,
      _$formats.pointer,
    ).check();
  }

  static final _id_setFormats = _class.instanceMethodId(
    r'setFormats',
    r'([Ljava/text/Format;)V',
  );

  static final _setFormats =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setFormats(java.text.Format[] formats)`
  void setFormats(jni$_.JArray<Format?>? formats) {
    final _$formats = formats?.reference ?? jni$_.jNullReference;
    _setFormats(
      reference.pointer,
      _id_setFormats as jni$_.JMethodIDPtr,
      _$formats.pointer,
    ).check();
  }

  static final _id_setFormatByArgumentIndex = _class.instanceMethodId(
    r'setFormatByArgumentIndex',
    r'(ILjava/text/Format;)V',
  );

  static final _setFormatByArgumentIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setFormatByArgumentIndex(int i, java.text.Format format)`
  void setFormatByArgumentIndex(int i, Format? format) {
    final _$format = format?.reference ?? jni$_.jNullReference;
    _setFormatByArgumentIndex(
      reference.pointer,
      _id_setFormatByArgumentIndex as jni$_.JMethodIDPtr,
      i,
      _$format.pointer,
    ).check();
  }

  static final _id_setFormat = _class.instanceMethodId(
    r'setFormat',
    r'(ILjava/text/Format;)V',
  );

  static final _setFormat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setFormat(int i, java.text.Format format)`
  void setFormat(int i, Format? format) {
    final _$format = format?.reference ?? jni$_.jNullReference;
    _setFormat(
      reference.pointer,
      _id_setFormat as jni$_.JMethodIDPtr,
      i,
      _$format.pointer,
    ).check();
  }

  static final _id_getFormatsByArgumentIndex = _class.instanceMethodId(
    r'getFormatsByArgumentIndex',
    r'()[Ljava/text/Format;',
  );

  static final _getFormatsByArgumentIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.text.Format[] getFormatsByArgumentIndex()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<Format?>? getFormatsByArgumentIndex() =>
      _getFormatsByArgumentIndex(
        reference.pointer,
        _id_getFormatsByArgumentIndex as jni$_.JMethodIDPtr,
      ).object<jni$_.JArray<Format?>?>(
        const jni$_.JArrayNullableType<Format?>($Format$NullableType()),
      );

  static final _id_getFormats = _class.instanceMethodId(
    r'getFormats',
    r'()[Ljava/text/Format;',
  );

  static final _getFormats =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.text.Format[] getFormats()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<Format?>? getFormats() => _getFormats(
    reference.pointer,
    _id_getFormats as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<Format?>?>(
    const jni$_.JArrayNullableType<Format?>($Format$NullableType()),
  );

  static final _id_format$2 = _class.instanceMethodId(
    r'format',
    r'([Ljava/lang/Object;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final java.lang.StringBuffer format(java.lang.Object[] objects, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format$2(
    jni$_.JArray<jni$_.JObject?>? objects,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format$2(
      reference.pointer,
      _id_format$2 as jni$_.JMethodIDPtr,
      _$objects.pointer,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_format$3 = _class.staticMethodId(
    r'format',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;',
  );

  static final _format$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String format(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? format$3(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _format$3(
      _class.reference.pointer,
      _id_format$3 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_format1 = _class.instanceMethodId(
    r'format',
    r'(Ljava/lang/Object;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final java.lang.StringBuffer format(java.lang.Object object, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format1(
    jni$_.JObject? object,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format1(
      reference.pointer,
      _id_format1 as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_formatToCharacterIterator = _class.instanceMethodId(
    r'formatToCharacterIterator',
    r'(Ljava/lang/Object;)Ljava/text/AttributedCharacterIterator;',
  );

  static final _formatToCharacterIterator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  AttributedCharacterIterator? formatToCharacterIterator(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _formatToCharacterIterator(
      reference.pointer,
      _id_formatToCharacterIterator as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<AttributedCharacterIterator?>(
      const $AttributedCharacterIterator$NullableType(),
    );
  }

  static final _id_parse = _class.instanceMethodId(
    r'parse',
    r'(Ljava/lang/String;Ljava/text/ParsePosition;)[Ljava/lang/Object;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object[] parse(java.lang.String string, java.text.ParsePosition parsePosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? parse(
    jni$_.JString? string,
    ParsePosition? parsePosition,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$parsePosition = parsePosition?.reference ?? jni$_.jNullReference;
    return _parse(
      reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$parsePosition.pointer,
    ).object<jni$_.JArray<jni$_.JObject?>?>(
      const jni$_.JArrayNullableType<jni$_.JObject?>(
        jni$_.JObjectNullableType(),
      ),
    );
  }

  static final _id_parse$1 = _class.instanceMethodId(
    r'parse',
    r'(Ljava/lang/String;)[Ljava/lang/Object;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object[] parse(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? parse$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _parse$1(
      reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JArray<jni$_.JObject?>?>(
      const jni$_.JArrayNullableType<jni$_.JObject?>(
        jni$_.JObjectNullableType(),
      ),
    );
  }

  static final _id_parseObject = _class.instanceMethodId(
    r'parseObject',
    r'(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/lang/Object;',
  );

  static final _parseObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Object parseObject(java.lang.String string, java.text.ParsePosition parsePosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? parseObject(
    jni$_.JString? string,
    ParsePosition? parsePosition,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$parsePosition = parsePosition?.reference ?? jni$_.jNullReference;
    return _parseObject(
      reference.pointer,
      _id_parseObject as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$parsePosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;
}

final class $MessageFormat$NullableType extends jni$_.JObjType<MessageFormat?> {
  @jni$_.internal
  const $MessageFormat$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/MessageFormat;';

  @jni$_.internal
  @core$_.override
  MessageFormat? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : MessageFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Format$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MessageFormat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($MessageFormat$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($MessageFormat$NullableType) &&
      other is $MessageFormat$NullableType;
}

final class $MessageFormat$Type extends jni$_.JObjType<MessageFormat> {
  @jni$_.internal
  const $MessageFormat$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/MessageFormat;';

  @jni$_.internal
  @core$_.override
  MessageFormat fromReference(jni$_.JReference reference) =>
      MessageFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Format$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<MessageFormat?> get nullableType =>
      const $MessageFormat$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($MessageFormat$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($MessageFormat$Type) &&
      other is $MessageFormat$Type;
}

/// from: `java.text.AttributedCharacterIterator$Attribute`
class AttributedCharacterIterator$Attribute extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<AttributedCharacterIterator$Attribute> $type;

  @jni$_.internal
  AttributedCharacterIterator$Attribute.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/text/AttributedCharacterIterator$Attribute',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $AttributedCharacterIterator$Attribute$NullableType();
  static const type = $AttributedCharacterIterator$Attribute$Type();
  static final _id_LANGUAGE = _class.staticFieldId(
    r'LANGUAGE',
    r'Ljava/text/AttributedCharacterIterator$Attribute;',
  );

  /// from: `static public final java.text.AttributedCharacterIterator$Attribute LANGUAGE`
  /// The returned object must be released after use, by calling the [release] method.
  static AttributedCharacterIterator$Attribute? get LANGUAGE => _id_LANGUAGE
      .get(_class, const $AttributedCharacterIterator$Attribute$NullableType());

  static final _id_READING = _class.staticFieldId(
    r'READING',
    r'Ljava/text/AttributedCharacterIterator$Attribute;',
  );

  /// from: `static public final java.text.AttributedCharacterIterator$Attribute READING`
  /// The returned object must be released after use, by calling the [release] method.
  static AttributedCharacterIterator$Attribute? get READING => _id_READING.get(
    _class,
    const $AttributedCharacterIterator$Attribute$NullableType(),
  );

  static final _id_INPUT_METHOD_SEGMENT = _class.staticFieldId(
    r'INPUT_METHOD_SEGMENT',
    r'Ljava/text/AttributedCharacterIterator$Attribute;',
  );

  /// from: `static public final java.text.AttributedCharacterIterator$Attribute INPUT_METHOD_SEGMENT`
  /// The returned object must be released after use, by calling the [release] method.
  static AttributedCharacterIterator$Attribute? get INPUT_METHOD_SEGMENT =>
      _id_INPUT_METHOD_SEGMENT.get(
        _class,
        const $AttributedCharacterIterator$Attribute$NullableType(),
      );

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() => _toString$1(
    reference.pointer,
    _id_toString$1 as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());
}

final class $AttributedCharacterIterator$Attribute$NullableType
    extends jni$_.JObjType<AttributedCharacterIterator$Attribute?> {
  @jni$_.internal
  const $AttributedCharacterIterator$Attribute$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/AttributedCharacterIterator$Attribute;';

  @jni$_.internal
  @core$_.override
  AttributedCharacterIterator$Attribute? fromReference(
    jni$_.JReference reference,
  ) =>
      reference.isNull
          ? null
          : AttributedCharacterIterator$Attribute.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AttributedCharacterIterator$Attribute?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($AttributedCharacterIterator$Attribute$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType ==
          ($AttributedCharacterIterator$Attribute$NullableType) &&
      other is $AttributedCharacterIterator$Attribute$NullableType;
}

final class $AttributedCharacterIterator$Attribute$Type
    extends jni$_.JObjType<AttributedCharacterIterator$Attribute> {
  @jni$_.internal
  const $AttributedCharacterIterator$Attribute$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/AttributedCharacterIterator$Attribute;';

  @jni$_.internal
  @core$_.override
  AttributedCharacterIterator$Attribute fromReference(
    jni$_.JReference reference,
  ) => AttributedCharacterIterator$Attribute.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<AttributedCharacterIterator$Attribute?> get nullableType =>
      const $AttributedCharacterIterator$Attribute$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($AttributedCharacterIterator$Attribute$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($AttributedCharacterIterator$Attribute$Type) &&
      other is $AttributedCharacterIterator$Attribute$Type;
}

/// from: `java.text.CollationElementIterator`
class CollationElementIterator extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CollationElementIterator> $type;

  @jni$_.internal
  CollationElementIterator.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/text/CollationElementIterator',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CollationElementIterator$NullableType();
  static const type = $CollationElementIterator$Type();

  /// from: `static public final int NULLORDER`
  static const NULLORDER = -1;
  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_next = _class.instanceMethodId(r'next', r'()I');

  static final _next =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int next()`
  int next() =>
      _next(reference.pointer, _id_next as jni$_.JMethodIDPtr).integer;

  static final _id_previous = _class.instanceMethodId(r'previous', r'()I');

  static final _previous =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int previous()`
  int previous() =>
      _previous(reference.pointer, _id_previous as jni$_.JMethodIDPtr).integer;

  static final _id_primaryOrder = _class.staticMethodId(
    r'primaryOrder',
    r'(I)I',
  );

  static final _primaryOrder =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final int primaryOrder(int i)`
  static int primaryOrder(int i) =>
      _primaryOrder(
        _class.reference.pointer,
        _id_primaryOrder as jni$_.JMethodIDPtr,
        i,
      ).integer;

  static final _id_secondaryOrder = _class.staticMethodId(
    r'secondaryOrder',
    r'(I)S',
  );

  static final _secondaryOrder =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final short secondaryOrder(int i)`
  static int secondaryOrder(int i) =>
      _secondaryOrder(
        _class.reference.pointer,
        _id_secondaryOrder as jni$_.JMethodIDPtr,
        i,
      ).short;

  static final _id_tertiaryOrder = _class.staticMethodId(
    r'tertiaryOrder',
    r'(I)S',
  );

  static final _tertiaryOrder =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public final short tertiaryOrder(int i)`
  static int tertiaryOrder(int i) =>
      _tertiaryOrder(
        _class.reference.pointer,
        _id_tertiaryOrder as jni$_.JMethodIDPtr,
        i,
      ).short;

  static final _id_setOffset = _class.instanceMethodId(r'setOffset', r'(I)V');

  static final _setOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setOffset(int i)`
  void setOffset(int i) {
    _setOffset(
      reference.pointer,
      _id_setOffset as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getOffset = _class.instanceMethodId(r'getOffset', r'()I');

  static final _getOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getOffset()`
  int getOffset() =>
      _getOffset(
        reference.pointer,
        _id_getOffset as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getMaxExpansion = _class.instanceMethodId(
    r'getMaxExpansion',
    r'(I)I',
  );

  static final _getMaxExpansion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int getMaxExpansion(int i)`
  int getMaxExpansion(int i) =>
      _getMaxExpansion(
        reference.pointer,
        _id_getMaxExpansion as jni$_.JMethodIDPtr,
        i,
      ).integer;

  static final _id_setText = _class.instanceMethodId(
    r'setText',
    r'(Ljava/lang/String;)V',
  );

  static final _setText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setText(java.lang.String string)`
  void setText(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setText(
      reference.pointer,
      _id_setText as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_setText$1 = _class.instanceMethodId(
    r'setText',
    r'(Ljava/text/CharacterIterator;)V',
  );

  static final _setText$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setText(java.text.CharacterIterator characterIterator)`
  void setText$1(CharacterIterator? characterIterator) {
    final _$characterIterator =
        characterIterator?.reference ?? jni$_.jNullReference;
    _setText$1(
      reference.pointer,
      _id_setText$1 as jni$_.JMethodIDPtr,
      _$characterIterator.pointer,
    ).check();
  }
}

final class $CollationElementIterator$NullableType
    extends jni$_.JObjType<CollationElementIterator?> {
  @jni$_.internal
  const $CollationElementIterator$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/CollationElementIterator;';

  @jni$_.internal
  @core$_.override
  CollationElementIterator? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : CollationElementIterator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CollationElementIterator?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CollationElementIterator$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CollationElementIterator$NullableType) &&
      other is $CollationElementIterator$NullableType;
}

final class $CollationElementIterator$Type
    extends jni$_.JObjType<CollationElementIterator> {
  @jni$_.internal
  const $CollationElementIterator$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/CollationElementIterator;';

  @jni$_.internal
  @core$_.override
  CollationElementIterator fromReference(jni$_.JReference reference) =>
      CollationElementIterator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CollationElementIterator?> get nullableType =>
      const $CollationElementIterator$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CollationElementIterator$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($CollationElementIterator$Type) &&
      other is $CollationElementIterator$Type;
}

/// from: `java.text.Collator`
class Collator extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Collator> $type;

  @jni$_.internal
  Collator.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/Collator');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Collator$NullableType();
  static const type = $Collator$Type();

  /// from: `static public final int PRIMARY`
  static const PRIMARY = 0;

  /// from: `static public final int SECONDARY`
  static const SECONDARY = 1;

  /// from: `static public final int TERTIARY`
  static const TERTIARY = 2;

  /// from: `static public final int IDENTICAL`
  static const IDENTICAL = 3;

  /// from: `static public final int NO_DECOMPOSITION`
  static const NO_DECOMPOSITION = 0;

  /// from: `static public final int CANONICAL_DECOMPOSITION`
  static const CANONICAL_DECOMPOSITION = 1;

  /// from: `static public final int FULL_DECOMPOSITION`
  static const FULL_DECOMPOSITION = 2;
  static final _id_getInstance = _class.staticMethodId(
    r'getInstance',
    r'()Ljava/text/Collator;',
  );

  static final _getInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.text.Collator getInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static Collator? getInstance() => _getInstance(
    _class.reference.pointer,
    _id_getInstance as jni$_.JMethodIDPtr,
  ).object<Collator?>(const $Collator$NullableType());

  static final _id_getInstance$1 = _class.staticMethodId(
    r'getInstance',
    r'(Ljava/util/Locale;)Ljava/text/Collator;',
  );

  static final _getInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.text.Collator getInstance(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static Collator? getInstance$1(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getInstance$1(
      _class.reference.pointer,
      _id_getInstance$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<Collator?>(const $Collator$NullableType());
  }

  static final _id_compare = _class.instanceMethodId(
    r'compare',
    r'(Ljava/lang/String;Ljava/lang/String;)I',
  );

  static final _compare =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract int compare(java.lang.String string, java.lang.String string1)`
  int compare(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _compare(
      reference.pointer,
      _id_compare as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).integer;
  }

  static final _id_compare$1 = _class.instanceMethodId(
    r'compare',
    r'(Ljava/lang/Object;Ljava/lang/Object;)I',
  );

  static final _compare$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compare(java.lang.Object object, java.lang.Object object1)`
  int compare$1(jni$_.JObject? object, jni$_.JObject? object1) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$object1 = object1?.reference ?? jni$_.jNullReference;
    return _compare$1(
      reference.pointer,
      _id_compare$1 as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$object1.pointer,
    ).integer;
  }

  static final _id_getCollationKey = _class.instanceMethodId(
    r'getCollationKey',
    r'(Ljava/lang/String;)Ljava/text/CollationKey;',
  );

  static final _getCollationKey =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.text.CollationKey getCollationKey(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  CollationKey? getCollationKey(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getCollationKey(
      reference.pointer,
      _id_getCollationKey as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<CollationKey?>(const $CollationKey$NullableType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/String;Ljava/lang/String;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.String string, java.lang.String string1)`
  bool equals(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).boolean;
  }

  static final _id_getStrength = _class.instanceMethodId(
    r'getStrength',
    r'()I',
  );

  static final _getStrength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getStrength()`
  int getStrength() =>
      _getStrength(
        reference.pointer,
        _id_getStrength as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setStrength = _class.instanceMethodId(
    r'setStrength',
    r'(I)V',
  );

  static final _setStrength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setStrength(int i)`
  void setStrength(int i) {
    _setStrength(
      reference.pointer,
      _id_setStrength as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getDecomposition = _class.instanceMethodId(
    r'getDecomposition',
    r'()I',
  );

  static final _getDecomposition =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getDecomposition()`
  int getDecomposition() =>
      _getDecomposition(
        reference.pointer,
        _id_getDecomposition as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setDecomposition = _class.instanceMethodId(
    r'setDecomposition',
    r'(I)V',
  );

  static final _setDecomposition =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setDecomposition(int i)`
  void setDecomposition(int i) {
    _setDecomposition(
      reference.pointer,
      _id_setDecomposition as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getAvailableLocales = _class.staticMethodId(
    r'getAvailableLocales',
    r'()[Ljava/util/Locale;',
  );

  static final _getAvailableLocales =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Locale[] getAvailableLocales()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JObject?>? getAvailableLocales() =>
      _getAvailableLocales(
        _class.reference.pointer,
        _id_getAvailableLocales as jni$_.JMethodIDPtr,
      ).object<jni$_.JArray<jni$_.JObject?>?>(
        const jni$_.JArrayNullableType<jni$_.JObject?>(
          jni$_.JObjectNullableType(),
        ),
      );

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_equals$1 = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals$1(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals$1(
      reference.pointer,
      _id_equals$1 as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;
}

final class $Collator$NullableType extends jni$_.JObjType<Collator?> {
  @jni$_.internal
  const $Collator$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/Collator;';

  @jni$_.internal
  @core$_.override
  Collator? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Collator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Collator?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Collator$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Collator$NullableType) &&
      other is $Collator$NullableType;
}

final class $Collator$Type extends jni$_.JObjType<Collator> {
  @jni$_.internal
  const $Collator$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/Collator;';

  @jni$_.internal
  @core$_.override
  Collator fromReference(jni$_.JReference reference) =>
      Collator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Collator?> get nullableType => const $Collator$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Collator$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Collator$Type) && other is $Collator$Type;
}

/// from: `java.text.RuleBasedCollator`
class RuleBasedCollator extends Collator {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<RuleBasedCollator> $type;

  @jni$_.internal
  RuleBasedCollator.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/RuleBasedCollator');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $RuleBasedCollator$NullableType();
  static const type = $RuleBasedCollator$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory RuleBasedCollator(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return RuleBasedCollator.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_getRules = _class.instanceMethodId(
    r'getRules',
    r'()Ljava/lang/String;',
  );

  static final _getRules =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getRules()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRules() => _getRules(
    reference.pointer,
    _id_getRules as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_getCollationElementIterator = _class.instanceMethodId(
    r'getCollationElementIterator',
    r'(Ljava/lang/String;)Ljava/text/CollationElementIterator;',
  );

  static final _getCollationElementIterator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.text.CollationElementIterator getCollationElementIterator(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  CollationElementIterator? getCollationElementIterator(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getCollationElementIterator(
      reference.pointer,
      _id_getCollationElementIterator as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<CollationElementIterator?>(
      const $CollationElementIterator$NullableType(),
    );
  }

  static final _id_getCollationElementIterator$1 = _class.instanceMethodId(
    r'getCollationElementIterator',
    r'(Ljava/text/CharacterIterator;)Ljava/text/CollationElementIterator;',
  );

  static final _getCollationElementIterator$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.text.CollationElementIterator getCollationElementIterator(java.text.CharacterIterator characterIterator)`
  /// The returned object must be released after use, by calling the [release] method.
  CollationElementIterator? getCollationElementIterator$1(
    CharacterIterator? characterIterator,
  ) {
    final _$characterIterator =
        characterIterator?.reference ?? jni$_.jNullReference;
    return _getCollationElementIterator$1(
      reference.pointer,
      _id_getCollationElementIterator$1 as jni$_.JMethodIDPtr,
      _$characterIterator.pointer,
    ).object<CollationElementIterator?>(
      const $CollationElementIterator$NullableType(),
    );
  }

  static final _id_compare = _class.instanceMethodId(
    r'compare',
    r'(Ljava/lang/String;Ljava/lang/String;)I',
  );

  static final _compare =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compare(java.lang.String string, java.lang.String string1)`
  int compare(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _compare(
      reference.pointer,
      _id_compare as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).integer;
  }

  static final _id_getCollationKey = _class.instanceMethodId(
    r'getCollationKey',
    r'(Ljava/lang/String;)Ljava/text/CollationKey;',
  );

  static final _getCollationKey =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.text.CollationKey getCollationKey(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  CollationKey? getCollationKey(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getCollationKey(
      reference.pointer,
      _id_getCollationKey as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<CollationKey?>(const $CollationKey$NullableType());
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_equals1 = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals1(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals1(
      reference.pointer,
      _id_equals1 as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode1() =>
      _hashCode1(
        reference.pointer,
        _id_hashCode1 as jni$_.JMethodIDPtr,
      ).integer;
}

final class $RuleBasedCollator$NullableType
    extends jni$_.JObjType<RuleBasedCollator?> {
  @jni$_.internal
  const $RuleBasedCollator$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/RuleBasedCollator;';

  @jni$_.internal
  @core$_.override
  RuleBasedCollator? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : RuleBasedCollator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Collator$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RuleBasedCollator?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($RuleBasedCollator$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($RuleBasedCollator$NullableType) &&
      other is $RuleBasedCollator$NullableType;
}

final class $RuleBasedCollator$Type extends jni$_.JObjType<RuleBasedCollator> {
  @jni$_.internal
  const $RuleBasedCollator$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/RuleBasedCollator;';

  @jni$_.internal
  @core$_.override
  RuleBasedCollator fromReference(jni$_.JReference reference) =>
      RuleBasedCollator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Collator$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RuleBasedCollator?> get nullableType =>
      const $RuleBasedCollator$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($RuleBasedCollator$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($RuleBasedCollator$Type) &&
      other is $RuleBasedCollator$Type;
}

/// from: `java.text.DecimalFormat`
class DecimalFormat extends NumberFormat {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DecimalFormat> $type;

  @jni$_.internal
  DecimalFormat.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/DecimalFormat');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DecimalFormat$NullableType();
  static const type = $DecimalFormat$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DecimalFormat() => DecimalFormat.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DecimalFormat.new$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return DecimalFormat.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/text/DecimalFormatSymbols;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.text.DecimalFormatSymbols decimalFormatSymbols)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DecimalFormat.new$2(
    jni$_.JString? string,
    DecimalFormatSymbols? decimalFormatSymbols,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$decimalFormatSymbols =
        decimalFormatSymbols?.reference ?? jni$_.jNullReference;
    return DecimalFormat.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$decimalFormatSymbols.pointer,
      ).reference,
    );
  }

  static final _id_format1 = _class.instanceMethodId(
    r'format',
    r'(Ljava/lang/Object;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final java.lang.StringBuffer format(java.lang.Object object, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format1(
    jni$_.JObject? object,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format1(
      reference.pointer,
      _id_format1 as jni$_.JMethodIDPtr,
      _$object.pointer,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_format4 = _class.instanceMethodId(
    r'format',
    r'(DLjava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Double,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.StringBuffer format(double d, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format4(
    double d,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format4(
      reference.pointer,
      _id_format4 as jni$_.JMethodIDPtr,
      d,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_format5 = _class.instanceMethodId(
    r'format',
    r'(JLjava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int64,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.StringBuffer format(long j, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format5(
    int j,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format5(
      reference.pointer,
      _id_format5 as jni$_.JMethodIDPtr,
      j,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_formatToCharacterIterator$1 = _class.instanceMethodId(
    r'formatToCharacterIterator',
    r'(Ljava/lang/Object;)Ljava/text/AttributedCharacterIterator;',
  );

  static final _formatToCharacterIterator$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  AttributedCharacterIterator? formatToCharacterIterator$1(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _formatToCharacterIterator$1(
      reference.pointer,
      _id_formatToCharacterIterator$1 as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).object<AttributedCharacterIterator?>(
      const $AttributedCharacterIterator$NullableType(),
    );
  }

  static final _id_parse = _class.instanceMethodId(
    r'parse',
    r'(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/lang/Number;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Number parse(java.lang.String string, java.text.ParsePosition parsePosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JNumber? parse(jni$_.JString? string, ParsePosition? parsePosition) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$parsePosition = parsePosition?.reference ?? jni$_.jNullReference;
    return _parse(
      reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$parsePosition.pointer,
    ).object<jni$_.JNumber?>(const jni$_.JNumberNullableType());
  }

  static final _id_getDecimalFormatSymbols = _class.instanceMethodId(
    r'getDecimalFormatSymbols',
    r'()Ljava/text/DecimalFormatSymbols;',
  );

  static final _getDecimalFormatSymbols =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.text.DecimalFormatSymbols getDecimalFormatSymbols()`
  /// The returned object must be released after use, by calling the [release] method.
  DecimalFormatSymbols? getDecimalFormatSymbols() => _getDecimalFormatSymbols(
    reference.pointer,
    _id_getDecimalFormatSymbols as jni$_.JMethodIDPtr,
  ).object<DecimalFormatSymbols?>(const $DecimalFormatSymbols$NullableType());

  static final _id_setDecimalFormatSymbols = _class.instanceMethodId(
    r'setDecimalFormatSymbols',
    r'(Ljava/text/DecimalFormatSymbols;)V',
  );

  static final _setDecimalFormatSymbols =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setDecimalFormatSymbols(java.text.DecimalFormatSymbols decimalFormatSymbols)`
  void setDecimalFormatSymbols(DecimalFormatSymbols? decimalFormatSymbols) {
    final _$decimalFormatSymbols =
        decimalFormatSymbols?.reference ?? jni$_.jNullReference;
    _setDecimalFormatSymbols(
      reference.pointer,
      _id_setDecimalFormatSymbols as jni$_.JMethodIDPtr,
      _$decimalFormatSymbols.pointer,
    ).check();
  }

  static final _id_getPositivePrefix = _class.instanceMethodId(
    r'getPositivePrefix',
    r'()Ljava/lang/String;',
  );

  static final _getPositivePrefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getPositivePrefix()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPositivePrefix() => _getPositivePrefix(
    reference.pointer,
    _id_getPositivePrefix as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setPositivePrefix = _class.instanceMethodId(
    r'setPositivePrefix',
    r'(Ljava/lang/String;)V',
  );

  static final _setPositivePrefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setPositivePrefix(java.lang.String string)`
  void setPositivePrefix(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setPositivePrefix(
      reference.pointer,
      _id_setPositivePrefix as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getNegativePrefix = _class.instanceMethodId(
    r'getNegativePrefix',
    r'()Ljava/lang/String;',
  );

  static final _getNegativePrefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getNegativePrefix()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getNegativePrefix() => _getNegativePrefix(
    reference.pointer,
    _id_getNegativePrefix as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setNegativePrefix = _class.instanceMethodId(
    r'setNegativePrefix',
    r'(Ljava/lang/String;)V',
  );

  static final _setNegativePrefix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setNegativePrefix(java.lang.String string)`
  void setNegativePrefix(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setNegativePrefix(
      reference.pointer,
      _id_setNegativePrefix as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getPositiveSuffix = _class.instanceMethodId(
    r'getPositiveSuffix',
    r'()Ljava/lang/String;',
  );

  static final _getPositiveSuffix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getPositiveSuffix()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPositiveSuffix() => _getPositiveSuffix(
    reference.pointer,
    _id_getPositiveSuffix as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setPositiveSuffix = _class.instanceMethodId(
    r'setPositiveSuffix',
    r'(Ljava/lang/String;)V',
  );

  static final _setPositiveSuffix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setPositiveSuffix(java.lang.String string)`
  void setPositiveSuffix(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setPositiveSuffix(
      reference.pointer,
      _id_setPositiveSuffix as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getNegativeSuffix = _class.instanceMethodId(
    r'getNegativeSuffix',
    r'()Ljava/lang/String;',
  );

  static final _getNegativeSuffix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getNegativeSuffix()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getNegativeSuffix() => _getNegativeSuffix(
    reference.pointer,
    _id_getNegativeSuffix as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setNegativeSuffix = _class.instanceMethodId(
    r'setNegativeSuffix',
    r'(Ljava/lang/String;)V',
  );

  static final _setNegativeSuffix =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setNegativeSuffix(java.lang.String string)`
  void setNegativeSuffix(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setNegativeSuffix(
      reference.pointer,
      _id_setNegativeSuffix as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_getMultiplier = _class.instanceMethodId(
    r'getMultiplier',
    r'()I',
  );

  static final _getMultiplier =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMultiplier()`
  int getMultiplier() =>
      _getMultiplier(
        reference.pointer,
        _id_getMultiplier as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setMultiplier = _class.instanceMethodId(
    r'setMultiplier',
    r'(I)V',
  );

  static final _setMultiplier =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMultiplier(int i)`
  void setMultiplier(int i) {
    _setMultiplier(
      reference.pointer,
      _id_setMultiplier as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setGroupingUsed = _class.instanceMethodId(
    r'setGroupingUsed',
    r'(Z)V',
  );

  static final _setGroupingUsed =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setGroupingUsed(boolean z)`
  void setGroupingUsed(bool z) {
    _setGroupingUsed(
      reference.pointer,
      _id_setGroupingUsed as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getGroupingSize = _class.instanceMethodId(
    r'getGroupingSize',
    r'()I',
  );

  static final _getGroupingSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getGroupingSize()`
  int getGroupingSize() =>
      _getGroupingSize(
        reference.pointer,
        _id_getGroupingSize as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_setGroupingSize = _class.instanceMethodId(
    r'setGroupingSize',
    r'(I)V',
  );

  static final _setGroupingSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setGroupingSize(int i)`
  void setGroupingSize(int i) {
    _setGroupingSize(
      reference.pointer,
      _id_setGroupingSize as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_isDecimalSeparatorAlwaysShown = _class.instanceMethodId(
    r'isDecimalSeparatorAlwaysShown',
    r'()Z',
  );

  static final _isDecimalSeparatorAlwaysShown =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isDecimalSeparatorAlwaysShown()`
  bool isDecimalSeparatorAlwaysShown() =>
      _isDecimalSeparatorAlwaysShown(
        reference.pointer,
        _id_isDecimalSeparatorAlwaysShown as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setDecimalSeparatorAlwaysShown = _class.instanceMethodId(
    r'setDecimalSeparatorAlwaysShown',
    r'(Z)V',
  );

  static final _setDecimalSeparatorAlwaysShown =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setDecimalSeparatorAlwaysShown(boolean z)`
  void setDecimalSeparatorAlwaysShown(bool z) {
    _setDecimalSeparatorAlwaysShown(
      reference.pointer,
      _id_setDecimalSeparatorAlwaysShown as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_isParseBigDecimal = _class.instanceMethodId(
    r'isParseBigDecimal',
    r'()Z',
  );

  static final _isParseBigDecimal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isParseBigDecimal()`
  bool isParseBigDecimal() =>
      _isParseBigDecimal(
        reference.pointer,
        _id_isParseBigDecimal as jni$_.JMethodIDPtr,
      ).boolean;

  static final _id_setParseBigDecimal = _class.instanceMethodId(
    r'setParseBigDecimal',
    r'(Z)V',
  );

  static final _setParseBigDecimal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setParseBigDecimal(boolean z)`
  void setParseBigDecimal(bool z) {
    _setParseBigDecimal(
      reference.pointer,
      _id_setParseBigDecimal as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode1() =>
      _hashCode1(
        reference.pointer,
        _id_hashCode1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_toPattern = _class.instanceMethodId(
    r'toPattern',
    r'()Ljava/lang/String;',
  );

  static final _toPattern =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toPattern()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toPattern() => _toPattern(
    reference.pointer,
    _id_toPattern as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_toLocalizedPattern = _class.instanceMethodId(
    r'toLocalizedPattern',
    r'()Ljava/lang/String;',
  );

  static final _toLocalizedPattern =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toLocalizedPattern()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toLocalizedPattern() => _toLocalizedPattern(
    reference.pointer,
    _id_toLocalizedPattern as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_applyPattern = _class.instanceMethodId(
    r'applyPattern',
    r'(Ljava/lang/String;)V',
  );

  static final _applyPattern =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void applyPattern(java.lang.String string)`
  void applyPattern(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _applyPattern(
      reference.pointer,
      _id_applyPattern as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_applyLocalizedPattern = _class.instanceMethodId(
    r'applyLocalizedPattern',
    r'(Ljava/lang/String;)V',
  );

  static final _applyLocalizedPattern =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void applyLocalizedPattern(java.lang.String string)`
  void applyLocalizedPattern(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _applyLocalizedPattern(
      reference.pointer,
      _id_applyLocalizedPattern as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_setMaximumIntegerDigits = _class.instanceMethodId(
    r'setMaximumIntegerDigits',
    r'(I)V',
  );

  static final _setMaximumIntegerDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMaximumIntegerDigits(int i)`
  void setMaximumIntegerDigits(int i) {
    _setMaximumIntegerDigits(
      reference.pointer,
      _id_setMaximumIntegerDigits as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setMinimumIntegerDigits = _class.instanceMethodId(
    r'setMinimumIntegerDigits',
    r'(I)V',
  );

  static final _setMinimumIntegerDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMinimumIntegerDigits(int i)`
  void setMinimumIntegerDigits(int i) {
    _setMinimumIntegerDigits(
      reference.pointer,
      _id_setMinimumIntegerDigits as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setMaximumFractionDigits = _class.instanceMethodId(
    r'setMaximumFractionDigits',
    r'(I)V',
  );

  static final _setMaximumFractionDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMaximumFractionDigits(int i)`
  void setMaximumFractionDigits(int i) {
    _setMaximumFractionDigits(
      reference.pointer,
      _id_setMaximumFractionDigits as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setMinimumFractionDigits = _class.instanceMethodId(
    r'setMinimumFractionDigits',
    r'(I)V',
  );

  static final _setMinimumFractionDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setMinimumFractionDigits(int i)`
  void setMinimumFractionDigits(int i) {
    _setMinimumFractionDigits(
      reference.pointer,
      _id_setMinimumFractionDigits as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getMaximumIntegerDigits = _class.instanceMethodId(
    r'getMaximumIntegerDigits',
    r'()I',
  );

  static final _getMaximumIntegerDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMaximumIntegerDigits()`
  int getMaximumIntegerDigits() =>
      _getMaximumIntegerDigits(
        reference.pointer,
        _id_getMaximumIntegerDigits as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getMinimumIntegerDigits = _class.instanceMethodId(
    r'getMinimumIntegerDigits',
    r'()I',
  );

  static final _getMinimumIntegerDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMinimumIntegerDigits()`
  int getMinimumIntegerDigits() =>
      _getMinimumIntegerDigits(
        reference.pointer,
        _id_getMinimumIntegerDigits as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getMaximumFractionDigits = _class.instanceMethodId(
    r'getMaximumFractionDigits',
    r'()I',
  );

  static final _getMaximumFractionDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMaximumFractionDigits()`
  int getMaximumFractionDigits() =>
      _getMaximumFractionDigits(
        reference.pointer,
        _id_getMaximumFractionDigits as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getMinimumFractionDigits = _class.instanceMethodId(
    r'getMinimumFractionDigits',
    r'()I',
  );

  static final _getMinimumFractionDigits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getMinimumFractionDigits()`
  int getMinimumFractionDigits() =>
      _getMinimumFractionDigits(
        reference.pointer,
        _id_getMinimumFractionDigits as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getCurrency = _class.instanceMethodId(
    r'getCurrency',
    r'()Ljava/util/Currency;',
  );

  static final _getCurrency =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Currency getCurrency()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getCurrency() => _getCurrency(
    reference.pointer,
    _id_getCurrency as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_setCurrency = _class.instanceMethodId(
    r'setCurrency',
    r'(Ljava/util/Currency;)V',
  );

  static final _setCurrency =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setCurrency(java.util.Currency currency)`
  void setCurrency(jni$_.JObject? currency) {
    final _$currency = currency?.reference ?? jni$_.jNullReference;
    _setCurrency(
      reference.pointer,
      _id_setCurrency as jni$_.JMethodIDPtr,
      _$currency.pointer,
    ).check();
  }

  static final _id_getRoundingMode = _class.instanceMethodId(
    r'getRoundingMode',
    r'()Ljava/math/RoundingMode;',
  );

  static final _getRoundingMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.math.RoundingMode getRoundingMode()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRoundingMode() => _getRoundingMode(
    reference.pointer,
    _id_getRoundingMode as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_setRoundingMode = _class.instanceMethodId(
    r'setRoundingMode',
    r'(Ljava/math/RoundingMode;)V',
  );

  static final _setRoundingMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setRoundingMode(java.math.RoundingMode roundingMode)`
  void setRoundingMode(jni$_.JObject? roundingMode) {
    final _$roundingMode = roundingMode?.reference ?? jni$_.jNullReference;
    _setRoundingMode(
      reference.pointer,
      _id_setRoundingMode as jni$_.JMethodIDPtr,
      _$roundingMode.pointer,
    ).check();
  }
}

final class $DecimalFormat$NullableType extends jni$_.JObjType<DecimalFormat?> {
  @jni$_.internal
  const $DecimalFormat$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/DecimalFormat;';

  @jni$_.internal
  @core$_.override
  DecimalFormat? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DecimalFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $NumberFormat$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DecimalFormat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($DecimalFormat$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DecimalFormat$NullableType) &&
      other is $DecimalFormat$NullableType;
}

final class $DecimalFormat$Type extends jni$_.JObjType<DecimalFormat> {
  @jni$_.internal
  const $DecimalFormat$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/DecimalFormat;';

  @jni$_.internal
  @core$_.override
  DecimalFormat fromReference(jni$_.JReference reference) =>
      DecimalFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $NumberFormat$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DecimalFormat?> get nullableType =>
      const $DecimalFormat$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($DecimalFormat$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DecimalFormat$Type) &&
      other is $DecimalFormat$Type;
}

/// from: `java.text.Normalizer`
class Normalizer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Normalizer> $type;

  @jni$_.internal
  Normalizer.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/Normalizer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Normalizer$NullableType();
  static const type = $Normalizer$Type();
  static final _id_normalize = _class.staticMethodId(
    r'normalize',
    r'(Ljava/lang/CharSequence;Ljava/text/Normalizer$Form;)Ljava/lang/String;',
  );

  static final _normalize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String normalize(java.lang.CharSequence charSequence, java.text.Normalizer$Form form)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? normalize(
    jni$_.JObject? charSequence,
    Normalizer$Form? form,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$form = form?.reference ?? jni$_.jNullReference;
    return _normalize(
      _class.reference.pointer,
      _id_normalize as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$form.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isNormalized = _class.staticMethodId(
    r'isNormalized',
    r'(Ljava/lang/CharSequence;Ljava/text/Normalizer$Form;)Z',
  );

  static final _isNormalized =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public boolean isNormalized(java.lang.CharSequence charSequence, java.text.Normalizer$Form form)`
  static bool isNormalized(jni$_.JObject? charSequence, Normalizer$Form? form) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$form = form?.reference ?? jni$_.jNullReference;
    return _isNormalized(
      _class.reference.pointer,
      _id_isNormalized as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      _$form.pointer,
    ).boolean;
  }
}

final class $Normalizer$NullableType extends jni$_.JObjType<Normalizer?> {
  @jni$_.internal
  const $Normalizer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/Normalizer;';

  @jni$_.internal
  @core$_.override
  Normalizer? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Normalizer.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Normalizer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Normalizer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Normalizer$NullableType) &&
      other is $Normalizer$NullableType;
}

final class $Normalizer$Type extends jni$_.JObjType<Normalizer> {
  @jni$_.internal
  const $Normalizer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/Normalizer;';

  @jni$_.internal
  @core$_.override
  Normalizer fromReference(jni$_.JReference reference) =>
      Normalizer.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Normalizer?> get nullableType =>
      const $Normalizer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Normalizer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Normalizer$Type) && other is $Normalizer$Type;
}

/// from: `java.text.StringCharacterIterator`
class StringCharacterIterator extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StringCharacterIterator> $type;

  @jni$_.internal
  StringCharacterIterator.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/text/StringCharacterIterator',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StringCharacterIterator$NullableType();
  static const type = $StringCharacterIterator$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringCharacterIterator(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return StringCharacterIterator.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/lang/String;I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringCharacterIterator.new$1(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return StringCharacterIterator.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Ljava/lang/String;III)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringCharacterIterator.new$2(
    jni$_.JString? string,
    int i,
    int i1,
    int i2,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return StringCharacterIterator.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$string.pointer,
        i,
        i1,
        i2,
      ).reference,
    );
  }

  static final _id_setText = _class.instanceMethodId(
    r'setText',
    r'(Ljava/lang/String;)V',
  );

  static final _setText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setText(java.lang.String string)`
  void setText(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setText(
      reference.pointer,
      _id_setText as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_first = _class.instanceMethodId(r'first', r'()C');

  static final _first =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char first()`
  int first() =>
      _first(reference.pointer, _id_first as jni$_.JMethodIDPtr).char;

  static final _id_last = _class.instanceMethodId(r'last', r'()C');

  static final _last =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char last()`
  int last() => _last(reference.pointer, _id_last as jni$_.JMethodIDPtr).char;

  static final _id_setIndex = _class.instanceMethodId(r'setIndex', r'(I)C');

  static final _setIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public char setIndex(int i)`
  int setIndex(int i) =>
      _setIndex(reference.pointer, _id_setIndex as jni$_.JMethodIDPtr, i).char;

  static final _id_current = _class.instanceMethodId(r'current', r'()C');

  static final _current =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char current()`
  int current() =>
      _current(reference.pointer, _id_current as jni$_.JMethodIDPtr).char;

  static final _id_next = _class.instanceMethodId(r'next', r'()C');

  static final _next =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char next()`
  int next() => _next(reference.pointer, _id_next as jni$_.JMethodIDPtr).char;

  static final _id_previous = _class.instanceMethodId(r'previous', r'()C');

  static final _previous =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char previous()`
  int previous() =>
      _previous(reference.pointer, _id_previous as jni$_.JMethodIDPtr).char;

  static final _id_getBeginIndex = _class.instanceMethodId(
    r'getBeginIndex',
    r'()I',
  );

  static final _getBeginIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getBeginIndex()`
  int getBeginIndex() =>
      _getBeginIndex(
        reference.pointer,
        _id_getBeginIndex as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getEndIndex = _class.instanceMethodId(
    r'getEndIndex',
    r'()I',
  );

  static final _getEndIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getEndIndex()`
  int getEndIndex() =>
      _getEndIndex(
        reference.pointer,
        _id_getEndIndex as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_getIndex = _class.instanceMethodId(r'getIndex', r'()I');

  static final _getIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getIndex()`
  int getIndex() =>
      _getIndex(reference.pointer, _id_getIndex as jni$_.JMethodIDPtr).integer;

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
}

final class $StringCharacterIterator$NullableType
    extends jni$_.JObjType<StringCharacterIterator?> {
  @jni$_.internal
  const $StringCharacterIterator$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/StringCharacterIterator;';

  @jni$_.internal
  @core$_.override
  StringCharacterIterator? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : StringCharacterIterator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringCharacterIterator?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StringCharacterIterator$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StringCharacterIterator$NullableType) &&
      other is $StringCharacterIterator$NullableType;
}

final class $StringCharacterIterator$Type
    extends jni$_.JObjType<StringCharacterIterator> {
  @jni$_.internal
  const $StringCharacterIterator$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/StringCharacterIterator;';

  @jni$_.internal
  @core$_.override
  StringCharacterIterator fromReference(jni$_.JReference reference) =>
      StringCharacterIterator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringCharacterIterator?> get nullableType =>
      const $StringCharacterIterator$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StringCharacterIterator$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($StringCharacterIterator$Type) &&
      other is $StringCharacterIterator$Type;
}

/// from: `java.text.DateFormat$Field`
class DateFormat$Field extends Format$Field {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DateFormat$Field> $type;

  @jni$_.internal
  DateFormat$Field.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/DateFormat$Field');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DateFormat$Field$NullableType();
  static const type = $DateFormat$Field$Type();
  static final _id_ERA = _class.staticFieldId(
    r'ERA',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field ERA`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get ERA =>
      _id_ERA.get(_class, const $DateFormat$Field$NullableType());

  static final _id_YEAR = _class.staticFieldId(
    r'YEAR',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field YEAR`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get YEAR =>
      _id_YEAR.get(_class, const $DateFormat$Field$NullableType());

  static final _id_MONTH = _class.staticFieldId(
    r'MONTH',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field MONTH`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get MONTH =>
      _id_MONTH.get(_class, const $DateFormat$Field$NullableType());

  static final _id_DAY_OF_MONTH = _class.staticFieldId(
    r'DAY_OF_MONTH',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field DAY_OF_MONTH`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get DAY_OF_MONTH =>
      _id_DAY_OF_MONTH.get(_class, const $DateFormat$Field$NullableType());

  static final _id_HOUR_OF_DAY1 = _class.staticFieldId(
    r'HOUR_OF_DAY1',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field HOUR_OF_DAY1`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get HOUR_OF_DAY1 =>
      _id_HOUR_OF_DAY1.get(_class, const $DateFormat$Field$NullableType());

  static final _id_HOUR_OF_DAY0 = _class.staticFieldId(
    r'HOUR_OF_DAY0',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field HOUR_OF_DAY0`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get HOUR_OF_DAY0 =>
      _id_HOUR_OF_DAY0.get(_class, const $DateFormat$Field$NullableType());

  static final _id_MINUTE = _class.staticFieldId(
    r'MINUTE',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field MINUTE`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get MINUTE =>
      _id_MINUTE.get(_class, const $DateFormat$Field$NullableType());

  static final _id_SECOND = _class.staticFieldId(
    r'SECOND',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field SECOND`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get SECOND =>
      _id_SECOND.get(_class, const $DateFormat$Field$NullableType());

  static final _id_MILLISECOND = _class.staticFieldId(
    r'MILLISECOND',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field MILLISECOND`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get MILLISECOND =>
      _id_MILLISECOND.get(_class, const $DateFormat$Field$NullableType());

  static final _id_DAY_OF_WEEK = _class.staticFieldId(
    r'DAY_OF_WEEK',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field DAY_OF_WEEK`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get DAY_OF_WEEK =>
      _id_DAY_OF_WEEK.get(_class, const $DateFormat$Field$NullableType());

  static final _id_DAY_OF_YEAR = _class.staticFieldId(
    r'DAY_OF_YEAR',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field DAY_OF_YEAR`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get DAY_OF_YEAR =>
      _id_DAY_OF_YEAR.get(_class, const $DateFormat$Field$NullableType());

  static final _id_DAY_OF_WEEK_IN_MONTH = _class.staticFieldId(
    r'DAY_OF_WEEK_IN_MONTH',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field DAY_OF_WEEK_IN_MONTH`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get DAY_OF_WEEK_IN_MONTH => _id_DAY_OF_WEEK_IN_MONTH
      .get(_class, const $DateFormat$Field$NullableType());

  static final _id_WEEK_OF_YEAR = _class.staticFieldId(
    r'WEEK_OF_YEAR',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field WEEK_OF_YEAR`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get WEEK_OF_YEAR =>
      _id_WEEK_OF_YEAR.get(_class, const $DateFormat$Field$NullableType());

  static final _id_WEEK_OF_MONTH = _class.staticFieldId(
    r'WEEK_OF_MONTH',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field WEEK_OF_MONTH`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get WEEK_OF_MONTH =>
      _id_WEEK_OF_MONTH.get(_class, const $DateFormat$Field$NullableType());

  static final _id_AM_PM = _class.staticFieldId(
    r'AM_PM',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field AM_PM`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get AM_PM =>
      _id_AM_PM.get(_class, const $DateFormat$Field$NullableType());

  static final _id_HOUR1 = _class.staticFieldId(
    r'HOUR1',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field HOUR1`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get HOUR1 =>
      _id_HOUR1.get(_class, const $DateFormat$Field$NullableType());

  static final _id_HOUR0 = _class.staticFieldId(
    r'HOUR0',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field HOUR0`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get HOUR0 =>
      _id_HOUR0.get(_class, const $DateFormat$Field$NullableType());

  static final _id_TIME_ZONE = _class.staticFieldId(
    r'TIME_ZONE',
    r'Ljava/text/DateFormat$Field;',
  );

  /// from: `static public final java.text.DateFormat$Field TIME_ZONE`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? get TIME_ZONE =>
      _id_TIME_ZONE.get(_class, const $DateFormat$Field$NullableType());

  static final _id_ofCalendarField = _class.staticMethodId(
    r'ofCalendarField',
    r'(I)Ljava/text/DateFormat$Field;',
  );

  static final _ofCalendarField =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `static public java.text.DateFormat$Field ofCalendarField(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormat$Field? ofCalendarField(int i) => _ofCalendarField(
    _class.reference.pointer,
    _id_ofCalendarField as jni$_.JMethodIDPtr,
    i,
  ).object<DateFormat$Field?>(const $DateFormat$Field$NullableType());

  static final _id_getCalendarField = _class.instanceMethodId(
    r'getCalendarField',
    r'()I',
  );

  static final _getCalendarField =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getCalendarField()`
  int getCalendarField() =>
      _getCalendarField(
        reference.pointer,
        _id_getCalendarField as jni$_.JMethodIDPtr,
      ).integer;
}

final class $DateFormat$Field$NullableType
    extends jni$_.JObjType<DateFormat$Field?> {
  @jni$_.internal
  const $DateFormat$Field$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/DateFormat$Field;';

  @jni$_.internal
  @core$_.override
  DateFormat$Field? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DateFormat$Field.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Format$Field$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DateFormat$Field?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($DateFormat$Field$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DateFormat$Field$NullableType) &&
      other is $DateFormat$Field$NullableType;
}

final class $DateFormat$Field$Type extends jni$_.JObjType<DateFormat$Field> {
  @jni$_.internal
  const $DateFormat$Field$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/DateFormat$Field;';

  @jni$_.internal
  @core$_.override
  DateFormat$Field fromReference(jni$_.JReference reference) =>
      DateFormat$Field.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Format$Field$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DateFormat$Field?> get nullableType =>
      const $DateFormat$Field$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($DateFormat$Field$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DateFormat$Field$Type) &&
      other is $DateFormat$Field$Type;
}

/// from: `java.text.DateFormatSymbols`
class DateFormatSymbols extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DateFormatSymbols> $type;

  @jni$_.internal
  DateFormatSymbols.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/DateFormatSymbols');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DateFormatSymbols$NullableType();
  static const type = $DateFormatSymbols$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory DateFormatSymbols() => DateFormatSymbols.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$1 = _class.constructorId(r'(Ljava/util/Locale;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DateFormatSymbols.new$1(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return DateFormatSymbols.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$locale.pointer,
      ).reference,
    );
  }

  static final _id_getAvailableLocales = _class.staticMethodId(
    r'getAvailableLocales',
    r'()[Ljava/util/Locale;',
  );

  static final _getAvailableLocales =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Locale[] getAvailableLocales()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JObject?>? getAvailableLocales() =>
      _getAvailableLocales(
        _class.reference.pointer,
        _id_getAvailableLocales as jni$_.JMethodIDPtr,
      ).object<jni$_.JArray<jni$_.JObject?>?>(
        const jni$_.JArrayNullableType<jni$_.JObject?>(
          jni$_.JObjectNullableType(),
        ),
      );

  static final _id_getInstance = _class.staticMethodId(
    r'getInstance',
    r'()Ljava/text/DateFormatSymbols;',
  );

  static final _getInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public final java.text.DateFormatSymbols getInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormatSymbols? getInstance() => _getInstance(
    _class.reference.pointer,
    _id_getInstance as jni$_.JMethodIDPtr,
  ).object<DateFormatSymbols?>(const $DateFormatSymbols$NullableType());

  static final _id_getInstance$1 = _class.staticMethodId(
    r'getInstance',
    r'(Ljava/util/Locale;)Ljava/text/DateFormatSymbols;',
  );

  static final _getInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public final java.text.DateFormatSymbols getInstance(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static DateFormatSymbols? getInstance$1(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getInstance$1(
      _class.reference.pointer,
      _id_getInstance$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<DateFormatSymbols?>(const $DateFormatSymbols$NullableType());
  }

  static final _id_getEras = _class.instanceMethodId(
    r'getEras',
    r'()[Ljava/lang/String;',
  );

  static final _getEras =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String[] getEras()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? getEras() => _getEras(
    reference.pointer,
    _id_getEras as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<jni$_.JString?>?>(
    const jni$_.JArrayNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
  );

  static final _id_setEras = _class.instanceMethodId(
    r'setEras',
    r'([Ljava/lang/String;)V',
  );

  static final _setEras =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setEras(java.lang.String[] strings)`
  void setEras(jni$_.JArray<jni$_.JString?>? strings) {
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    _setEras(
      reference.pointer,
      _id_setEras as jni$_.JMethodIDPtr,
      _$strings.pointer,
    ).check();
  }

  static final _id_getMonths = _class.instanceMethodId(
    r'getMonths',
    r'()[Ljava/lang/String;',
  );

  static final _getMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String[] getMonths()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? getMonths() => _getMonths(
    reference.pointer,
    _id_getMonths as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<jni$_.JString?>?>(
    const jni$_.JArrayNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
  );

  static final _id_setMonths = _class.instanceMethodId(
    r'setMonths',
    r'([Ljava/lang/String;)V',
  );

  static final _setMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setMonths(java.lang.String[] strings)`
  void setMonths(jni$_.JArray<jni$_.JString?>? strings) {
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    _setMonths(
      reference.pointer,
      _id_setMonths as jni$_.JMethodIDPtr,
      _$strings.pointer,
    ).check();
  }

  static final _id_getShortMonths = _class.instanceMethodId(
    r'getShortMonths',
    r'()[Ljava/lang/String;',
  );

  static final _getShortMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String[] getShortMonths()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? getShortMonths() => _getShortMonths(
    reference.pointer,
    _id_getShortMonths as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<jni$_.JString?>?>(
    const jni$_.JArrayNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
  );

  static final _id_setShortMonths = _class.instanceMethodId(
    r'setShortMonths',
    r'([Ljava/lang/String;)V',
  );

  static final _setShortMonths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setShortMonths(java.lang.String[] strings)`
  void setShortMonths(jni$_.JArray<jni$_.JString?>? strings) {
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    _setShortMonths(
      reference.pointer,
      _id_setShortMonths as jni$_.JMethodIDPtr,
      _$strings.pointer,
    ).check();
  }

  static final _id_getWeekdays = _class.instanceMethodId(
    r'getWeekdays',
    r'()[Ljava/lang/String;',
  );

  static final _getWeekdays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String[] getWeekdays()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? getWeekdays() => _getWeekdays(
    reference.pointer,
    _id_getWeekdays as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<jni$_.JString?>?>(
    const jni$_.JArrayNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
  );

  static final _id_setWeekdays = _class.instanceMethodId(
    r'setWeekdays',
    r'([Ljava/lang/String;)V',
  );

  static final _setWeekdays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setWeekdays(java.lang.String[] strings)`
  void setWeekdays(jni$_.JArray<jni$_.JString?>? strings) {
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    _setWeekdays(
      reference.pointer,
      _id_setWeekdays as jni$_.JMethodIDPtr,
      _$strings.pointer,
    ).check();
  }

  static final _id_getShortWeekdays = _class.instanceMethodId(
    r'getShortWeekdays',
    r'()[Ljava/lang/String;',
  );

  static final _getShortWeekdays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String[] getShortWeekdays()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? getShortWeekdays() => _getShortWeekdays(
    reference.pointer,
    _id_getShortWeekdays as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<jni$_.JString?>?>(
    const jni$_.JArrayNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
  );

  static final _id_setShortWeekdays = _class.instanceMethodId(
    r'setShortWeekdays',
    r'([Ljava/lang/String;)V',
  );

  static final _setShortWeekdays =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setShortWeekdays(java.lang.String[] strings)`
  void setShortWeekdays(jni$_.JArray<jni$_.JString?>? strings) {
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    _setShortWeekdays(
      reference.pointer,
      _id_setShortWeekdays as jni$_.JMethodIDPtr,
      _$strings.pointer,
    ).check();
  }

  static final _id_getAmPmStrings = _class.instanceMethodId(
    r'getAmPmStrings',
    r'()[Ljava/lang/String;',
  );

  static final _getAmPmStrings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String[] getAmPmStrings()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? getAmPmStrings() => _getAmPmStrings(
    reference.pointer,
    _id_getAmPmStrings as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<jni$_.JString?>?>(
    const jni$_.JArrayNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
  );

  static final _id_setAmPmStrings = _class.instanceMethodId(
    r'setAmPmStrings',
    r'([Ljava/lang/String;)V',
  );

  static final _setAmPmStrings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setAmPmStrings(java.lang.String[] strings)`
  void setAmPmStrings(jni$_.JArray<jni$_.JString?>? strings) {
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    _setAmPmStrings(
      reference.pointer,
      _id_setAmPmStrings as jni$_.JMethodIDPtr,
      _$strings.pointer,
    ).check();
  }

  static final _id_getZoneStrings = _class.instanceMethodId(
    r'getZoneStrings',
    r'()[Ljava/lang/String;',
  );

  static final _getZoneStrings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String[] getZoneStrings()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? getZoneStrings() => _getZoneStrings(
    reference.pointer,
    _id_getZoneStrings as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<jni$_.JString?>?>(
    const jni$_.JArrayNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
  );

  static final _id_setZoneStrings = _class.instanceMethodId(
    r'setZoneStrings',
    r'([Ljava/lang/String;)V',
  );

  static final _setZoneStrings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setZoneStrings(java.lang.String[] strings)`
  void setZoneStrings(jni$_.JArray<jni$_.JString?>? strings) {
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    _setZoneStrings(
      reference.pointer,
      _id_setZoneStrings as jni$_.JMethodIDPtr,
      _$strings.pointer,
    ).check();
  }

  static final _id_getLocalPatternChars = _class.instanceMethodId(
    r'getLocalPatternChars',
    r'()Ljava/lang/String;',
  );

  static final _getLocalPatternChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getLocalPatternChars()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getLocalPatternChars() => _getLocalPatternChars(
    reference.pointer,
    _id_getLocalPatternChars as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_setLocalPatternChars = _class.instanceMethodId(
    r'setLocalPatternChars',
    r'(Ljava/lang/String;)V',
  );

  static final _setLocalPatternChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setLocalPatternChars(java.lang.String string)`
  void setLocalPatternChars(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setLocalPatternChars(
      reference.pointer,
      _id_setLocalPatternChars as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() =>
      _hashCode$1(
        reference.pointer,
        _id_hashCode$1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }
}

final class $DateFormatSymbols$NullableType
    extends jni$_.JObjType<DateFormatSymbols?> {
  @jni$_.internal
  const $DateFormatSymbols$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/DateFormatSymbols;';

  @jni$_.internal
  @core$_.override
  DateFormatSymbols? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DateFormatSymbols.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DateFormatSymbols?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DateFormatSymbols$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DateFormatSymbols$NullableType) &&
      other is $DateFormatSymbols$NullableType;
}

final class $DateFormatSymbols$Type extends jni$_.JObjType<DateFormatSymbols> {
  @jni$_.internal
  const $DateFormatSymbols$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/DateFormatSymbols;';

  @jni$_.internal
  @core$_.override
  DateFormatSymbols fromReference(jni$_.JReference reference) =>
      DateFormatSymbols.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DateFormatSymbols?> get nullableType =>
      const $DateFormatSymbols$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DateFormatSymbols$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($DateFormatSymbols$Type) &&
      other is $DateFormatSymbols$Type;
}

/// from: `java.text.BreakIterator`
class BreakIterator extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<BreakIterator> $type;

  @jni$_.internal
  BreakIterator.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/BreakIterator');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $BreakIterator$NullableType();
  static const type = $BreakIterator$Type();

  /// from: `static public final int DONE`
  static const DONE = -1;
  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_first = _class.instanceMethodId(r'first', r'()I');

  static final _first =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int first()`
  int first() =>
      _first(reference.pointer, _id_first as jni$_.JMethodIDPtr).integer;

  static final _id_last = _class.instanceMethodId(r'last', r'()I');

  static final _last =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int last()`
  int last() =>
      _last(reference.pointer, _id_last as jni$_.JMethodIDPtr).integer;

  static final _id_next = _class.instanceMethodId(r'next', r'(I)I');

  static final _next =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract int next(int i)`
  int next(int i) =>
      _next(reference.pointer, _id_next as jni$_.JMethodIDPtr, i).integer;

  static final _id_next$1 = _class.instanceMethodId(r'next', r'()I');

  static final _next$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int next()`
  int next$1() =>
      _next$1(reference.pointer, _id_next$1 as jni$_.JMethodIDPtr).integer;

  static final _id_previous = _class.instanceMethodId(r'previous', r'()I');

  static final _previous =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int previous()`
  int previous() =>
      _previous(reference.pointer, _id_previous as jni$_.JMethodIDPtr).integer;

  static final _id_following = _class.instanceMethodId(r'following', r'(I)I');

  static final _following =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract int following(int i)`
  int following(int i) =>
      _following(
        reference.pointer,
        _id_following as jni$_.JMethodIDPtr,
        i,
      ).integer;

  static final _id_preceding = _class.instanceMethodId(r'preceding', r'(I)I');

  static final _preceding =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int preceding(int i)`
  int preceding(int i) =>
      _preceding(
        reference.pointer,
        _id_preceding as jni$_.JMethodIDPtr,
        i,
      ).integer;

  static final _id_isBoundary = _class.instanceMethodId(r'isBoundary', r'(I)Z');

  static final _isBoundary =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean isBoundary(int i)`
  bool isBoundary(int i) =>
      _isBoundary(
        reference.pointer,
        _id_isBoundary as jni$_.JMethodIDPtr,
        i,
      ).boolean;

  static final _id_current = _class.instanceMethodId(r'current', r'()I');

  static final _current =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int current()`
  int current() =>
      _current(reference.pointer, _id_current as jni$_.JMethodIDPtr).integer;

  static final _id_getText = _class.instanceMethodId(
    r'getText',
    r'()Ljava/text/CharacterIterator;',
  );

  static final _getText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.text.CharacterIterator getText()`
  /// The returned object must be released after use, by calling the [release] method.
  CharacterIterator? getText() => _getText(
    reference.pointer,
    _id_getText as jni$_.JMethodIDPtr,
  ).object<CharacterIterator?>(const $CharacterIterator$NullableType());

  static final _id_setText = _class.instanceMethodId(
    r'setText',
    r'(Ljava/lang/String;)V',
  );

  static final _setText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setText(java.lang.String string)`
  void setText(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setText(
      reference.pointer,
      _id_setText as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_setText$1 = _class.instanceMethodId(
    r'setText',
    r'(Ljava/text/CharacterIterator;)V',
  );

  static final _setText$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void setText(java.text.CharacterIterator characterIterator)`
  void setText$1(CharacterIterator? characterIterator) {
    final _$characterIterator =
        characterIterator?.reference ?? jni$_.jNullReference;
    _setText$1(
      reference.pointer,
      _id_setText$1 as jni$_.JMethodIDPtr,
      _$characterIterator.pointer,
    ).check();
  }

  static final _id_getWordInstance = _class.staticMethodId(
    r'getWordInstance',
    r'()Ljava/text/BreakIterator;',
  );

  static final _getWordInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.text.BreakIterator getWordInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static BreakIterator? getWordInstance() => _getWordInstance(
    _class.reference.pointer,
    _id_getWordInstance as jni$_.JMethodIDPtr,
  ).object<BreakIterator?>(const $BreakIterator$NullableType());

  static final _id_getWordInstance$1 = _class.staticMethodId(
    r'getWordInstance',
    r'(Ljava/util/Locale;)Ljava/text/BreakIterator;',
  );

  static final _getWordInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.text.BreakIterator getWordInstance(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static BreakIterator? getWordInstance$1(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getWordInstance$1(
      _class.reference.pointer,
      _id_getWordInstance$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<BreakIterator?>(const $BreakIterator$NullableType());
  }

  static final _id_getLineInstance = _class.staticMethodId(
    r'getLineInstance',
    r'()Ljava/text/BreakIterator;',
  );

  static final _getLineInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.text.BreakIterator getLineInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static BreakIterator? getLineInstance() => _getLineInstance(
    _class.reference.pointer,
    _id_getLineInstance as jni$_.JMethodIDPtr,
  ).object<BreakIterator?>(const $BreakIterator$NullableType());

  static final _id_getLineInstance$1 = _class.staticMethodId(
    r'getLineInstance',
    r'(Ljava/util/Locale;)Ljava/text/BreakIterator;',
  );

  static final _getLineInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.text.BreakIterator getLineInstance(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static BreakIterator? getLineInstance$1(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getLineInstance$1(
      _class.reference.pointer,
      _id_getLineInstance$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<BreakIterator?>(const $BreakIterator$NullableType());
  }

  static final _id_getCharacterInstance = _class.staticMethodId(
    r'getCharacterInstance',
    r'()Ljava/text/BreakIterator;',
  );

  static final _getCharacterInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.text.BreakIterator getCharacterInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static BreakIterator? getCharacterInstance() => _getCharacterInstance(
    _class.reference.pointer,
    _id_getCharacterInstance as jni$_.JMethodIDPtr,
  ).object<BreakIterator?>(const $BreakIterator$NullableType());

  static final _id_getCharacterInstance$1 = _class.staticMethodId(
    r'getCharacterInstance',
    r'(Ljava/util/Locale;)Ljava/text/BreakIterator;',
  );

  static final _getCharacterInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.text.BreakIterator getCharacterInstance(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static BreakIterator? getCharacterInstance$1(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getCharacterInstance$1(
      _class.reference.pointer,
      _id_getCharacterInstance$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<BreakIterator?>(const $BreakIterator$NullableType());
  }

  static final _id_getSentenceInstance = _class.staticMethodId(
    r'getSentenceInstance',
    r'()Ljava/text/BreakIterator;',
  );

  static final _getSentenceInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.text.BreakIterator getSentenceInstance()`
  /// The returned object must be released after use, by calling the [release] method.
  static BreakIterator? getSentenceInstance() => _getSentenceInstance(
    _class.reference.pointer,
    _id_getSentenceInstance as jni$_.JMethodIDPtr,
  ).object<BreakIterator?>(const $BreakIterator$NullableType());

  static final _id_getSentenceInstance$1 = _class.staticMethodId(
    r'getSentenceInstance',
    r'(Ljava/util/Locale;)Ljava/text/BreakIterator;',
  );

  static final _getSentenceInstance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.text.BreakIterator getSentenceInstance(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  static BreakIterator? getSentenceInstance$1(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getSentenceInstance$1(
      _class.reference.pointer,
      _id_getSentenceInstance$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<BreakIterator?>(const $BreakIterator$NullableType());
  }

  static final _id_getAvailableLocales = _class.staticMethodId(
    r'getAvailableLocales',
    r'()[Ljava/util/Locale;',
  );

  static final _getAvailableLocales =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.Locale[] getAvailableLocales()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<jni$_.JObject?>? getAvailableLocales() =>
      _getAvailableLocales(
        _class.reference.pointer,
        _id_getAvailableLocales as jni$_.JMethodIDPtr,
      ).object<jni$_.JArray<jni$_.JObject?>?>(
        const jni$_.JArrayNullableType<jni$_.JObject?>(
          jni$_.JObjectNullableType(),
        ),
      );
}

final class $BreakIterator$NullableType extends jni$_.JObjType<BreakIterator?> {
  @jni$_.internal
  const $BreakIterator$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/BreakIterator;';

  @jni$_.internal
  @core$_.override
  BreakIterator? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : BreakIterator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BreakIterator?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($BreakIterator$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($BreakIterator$NullableType) &&
      other is $BreakIterator$NullableType;
}

final class $BreakIterator$Type extends jni$_.JObjType<BreakIterator> {
  @jni$_.internal
  const $BreakIterator$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/BreakIterator;';

  @jni$_.internal
  @core$_.override
  BreakIterator fromReference(jni$_.JReference reference) =>
      BreakIterator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BreakIterator?> get nullableType =>
      const $BreakIterator$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($BreakIterator$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($BreakIterator$Type) &&
      other is $BreakIterator$Type;
}

/// from: `java.text.ChoiceFormat`
class ChoiceFormat extends NumberFormat {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ChoiceFormat> $type;

  @jni$_.internal
  ChoiceFormat.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/text/ChoiceFormat');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ChoiceFormat$NullableType();
  static const type = $ChoiceFormat$Type();
  static final _id_applyPattern = _class.instanceMethodId(
    r'applyPattern',
    r'(Ljava/lang/String;)V',
  );

  static final _applyPattern =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void applyPattern(java.lang.String string)`
  void applyPattern(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _applyPattern(
      reference.pointer,
      _id_applyPattern as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_toPattern = _class.instanceMethodId(
    r'toPattern',
    r'()Ljava/lang/String;',
  );

  static final _toPattern =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toPattern()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toPattern() => _toPattern(
    reference.pointer,
    _id_toPattern as jni$_.JMethodIDPtr,
  ).object<jni$_.JString?>(const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ChoiceFormat(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return ChoiceFormat.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'([D[Ljava/lang/String;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(double[] ds, java.lang.String[] strings)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ChoiceFormat.new$1(
    jni$_.JDoubleArray? ds,
    jni$_.JArray<jni$_.JString?>? strings,
  ) {
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    return ChoiceFormat.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$ds.pointer,
        _$strings.pointer,
      ).reference,
    );
  }

  static final _id_setChoices = _class.instanceMethodId(
    r'setChoices',
    r'([D[Ljava/lang/String;)V',
  );

  static final _setChoices =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setChoices(double[] ds, java.lang.String[] strings)`
  void setChoices(
    jni$_.JDoubleArray? ds,
    jni$_.JArray<jni$_.JString?>? strings,
  ) {
    final _$ds = ds?.reference ?? jni$_.jNullReference;
    final _$strings = strings?.reference ?? jni$_.jNullReference;
    _setChoices(
      reference.pointer,
      _id_setChoices as jni$_.JMethodIDPtr,
      _$ds.pointer,
      _$strings.pointer,
    ).check();
  }

  static final _id_getLimits = _class.instanceMethodId(r'getLimits', r'()[D');

  static final _getLimits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double[] getLimits()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JDoubleArray? getLimits() => _getLimits(
    reference.pointer,
    _id_getLimits as jni$_.JMethodIDPtr,
  ).object<jni$_.JDoubleArray?>(const jni$_.JDoubleArrayNullableType());

  static final _id_getFormats = _class.instanceMethodId(
    r'getFormats',
    r'()[Ljava/lang/Object;',
  );

  static final _getFormats =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object[] getFormats()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JObject?>? getFormats() => _getFormats(
    reference.pointer,
    _id_getFormats as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<jni$_.JObject?>?>(
    const jni$_.JArrayNullableType<jni$_.JObject?>(jni$_.JObjectNullableType()),
  );

  static final _id_format5 = _class.instanceMethodId(
    r'format',
    r'(JLjava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int64,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.StringBuffer format(long j, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format5(
    int j,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format5(
      reference.pointer,
      _id_format5 as jni$_.JMethodIDPtr,
      j,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_format4 = _class.instanceMethodId(
    r'format',
    r'(DLjava/lang/StringBuffer;Ljava/text/FieldPosition;)Ljava/lang/StringBuffer;',
  );

  static final _format4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Double,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.StringBuffer format(double d, java.lang.StringBuffer stringBuffer, java.text.FieldPosition fieldPosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? format4(
    double d,
    jni$_.JObject? stringBuffer,
    FieldPosition? fieldPosition,
  ) {
    final _$stringBuffer = stringBuffer?.reference ?? jni$_.jNullReference;
    final _$fieldPosition = fieldPosition?.reference ?? jni$_.jNullReference;
    return _format4(
      reference.pointer,
      _id_format4 as jni$_.JMethodIDPtr,
      d,
      _$stringBuffer.pointer,
      _$fieldPosition.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_parse = _class.instanceMethodId(
    r'parse',
    r'(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/lang/Number;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.Number parse(java.lang.String string, java.text.ParsePosition parsePosition)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JNumber? parse(jni$_.JString? string, ParsePosition? parsePosition) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$parsePosition = parsePosition?.reference ?? jni$_.jNullReference;
    return _parse(
      reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$parsePosition.pointer,
    ).object<jni$_.JNumber?>(const jni$_.JNumberNullableType());
  }

  static final _id_nextDouble = _class.staticMethodId(r'nextDouble', r'(D)D');

  static final _nextDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallStaticDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `static public final double nextDouble(double d)`
  static double nextDouble(double d) =>
      _nextDouble(
        _class.reference.pointer,
        _id_nextDouble as jni$_.JMethodIDPtr,
        d,
      ).doubleFloat;

  static final _id_previousDouble = _class.staticMethodId(
    r'previousDouble',
    r'(D)D',
  );

  static final _previousDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallStaticDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `static public final double previousDouble(double d)`
  static double previousDouble(double d) =>
      _previousDouble(
        _class.reference.pointer,
        _id_previousDouble as jni$_.JMethodIDPtr,
        d,
      ).doubleFloat;

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object clone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? clone() => _clone(
    reference.pointer,
    _id_clone as jni$_.JMethodIDPtr,
  ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());

  static final _id_hashCode1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode1() =>
      _hashCode1(
        reference.pointer,
        _id_hashCode1 as jni$_.JMethodIDPtr,
      ).integer;

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_nextDouble$1 = _class.staticMethodId(
    r'nextDouble',
    r'(DZ)D',
  );

  static final _nextDouble$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              int,
            )
          >();

  /// from: `static public double nextDouble(double d, boolean z)`
  static double nextDouble$1(double d, bool z) =>
      _nextDouble$1(
        _class.reference.pointer,
        _id_nextDouble$1 as jni$_.JMethodIDPtr,
        d,
        z ? 1 : 0,
      ).doubleFloat;
}

final class $ChoiceFormat$NullableType extends jni$_.JObjType<ChoiceFormat?> {
  @jni$_.internal
  const $ChoiceFormat$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/ChoiceFormat;';

  @jni$_.internal
  @core$_.override
  ChoiceFormat? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ChoiceFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $NumberFormat$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ChoiceFormat?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($ChoiceFormat$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ChoiceFormat$NullableType) &&
      other is $ChoiceFormat$NullableType;
}

final class $ChoiceFormat$Type extends jni$_.JObjType<ChoiceFormat> {
  @jni$_.internal
  const $ChoiceFormat$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/text/ChoiceFormat;';

  @jni$_.internal
  @core$_.override
  ChoiceFormat fromReference(jni$_.JReference reference) =>
      ChoiceFormat.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $NumberFormat$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ChoiceFormat?> get nullableType =>
      const $ChoiceFormat$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($ChoiceFormat$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($ChoiceFormat$Type) && other is $ChoiceFormat$Type;
}

/// from: `com.Accumulator`
class Accumulator extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Accumulator> $type;

  @jni$_.internal
  Accumulator.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/Accumulator');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Accumulator$NullableType();
  static const type = $Accumulator$Type();
  static final _id_accumulator = _class.instanceFieldId(r'accumulator', r'I');

  /// from: `public int accumulator`
  int get accumulator => _id_accumulator.get(this, const jni$_.jintType());

  /// from: `public int accumulator`
  set accumulator(int value) =>
      _id_accumulator.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Accumulator() => Accumulator.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_new$1 = _class.constructorId(r'(I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int initialValue)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Accumulator.new$1(int initialValue) => Accumulator.fromReference(
    _new$1(
      _class.reference.pointer,
      _id_new$1 as jni$_.JMethodIDPtr,
      initialValue,
    ).reference,
  );

  static final _id_new$2 = _class.constructorId(r'(Lcom/Accumulator;)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(com.Accumulator other)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Accumulator.new$2(Accumulator? other) {
    final _$other = other?.reference ?? jni$_.jNullReference;
    return Accumulator.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$other.pointer,
      ).reference,
    );
  }

  static final _id_add = _class.instanceMethodId(r'add', r'(I)V');

  static final _add =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void add(int value)`
  void add(int value) {
    _add(reference.pointer, _id_add as jni$_.JMethodIDPtr, value).check();
  }

  static final _id_add$1 = _class.instanceMethodId(r'add', r'(II)V');

  static final _add$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void add(int value1, int value2)`
  void add$1(int value1, int value2) {
    _add$1(
      reference.pointer,
      _id_add$1 as jni$_.JMethodIDPtr,
      value1,
      value2,
    ).check();
  }

  static final _id_add$2 = _class.instanceMethodId(r'add', r'(III)V');

  static final _add$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public void add(int value1, int value2, int value3)`
  void add$2(int value1, int value2, int value3) {
    _add$2(
      reference.pointer,
      _id_add$2 as jni$_.JMethodIDPtr,
      value1,
      value2,
      value3,
    ).check();
  }

  static final _id_add$3 = _class.instanceMethodId(
    r'add',
    r'(Lcom/Accumulator;)V',
  );

  static final _add$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void add(com.Accumulator other)`
  void add$3(Accumulator? other) {
    final _$other = other?.reference ?? jni$_.jNullReference;
    _add$3(
      reference.pointer,
      _id_add$3 as jni$_.JMethodIDPtr,
      _$other.pointer,
    ).check();
  }
}

final class $Accumulator$NullableType extends jni$_.JObjType<Accumulator?> {
  @jni$_.internal
  const $Accumulator$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Accumulator;';

  @jni$_.internal
  @core$_.override
  Accumulator? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Accumulator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Accumulator?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Accumulator$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Accumulator$NullableType) &&
      other is $Accumulator$NullableType;
}

final class $Accumulator$Type extends jni$_.JObjType<Accumulator> {
  @jni$_.internal
  const $Accumulator$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Accumulator;';

  @jni$_.internal
  @core$_.override
  Accumulator fromReference(jni$_.JReference reference) =>
      Accumulator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Accumulator?> get nullableType =>
      const $Accumulator$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Accumulator$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Accumulator$Type) && other is $Accumulator$Type;
}

/// from: `com.Example`
class Example extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Example> $type;

  @jni$_.internal
  Example.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/Example');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Example$NullableType();
  static const type = $Example$Type();
  static final _id_has$$dollar$$sign = _class.staticFieldId(
    r'has$dollar$sign',
    r'I',
  );

  /// from: `static public int has$dollar$sign`
  static int get has$$dollar$$sign =>
      _id_has$$dollar$$sign.get(_class, const jni$_.jintType());

  /// from: `static public int has$dollar$sign`
  static set has$$dollar$$sign(int value) =>
      _id_has$$dollar$$sign.set(_class, const jni$_.jintType(), value);

  static final _id_$_startsWithUnderscore = _class.staticFieldId(
    r'_startsWithUnderscore',
    r'I',
  );

  /// from: `static public int _startsWithUnderscore`
  static int get $_startsWithUnderscore =>
      _id_$_startsWithUnderscore.get(_class, const jni$_.jintType());

  /// from: `static public int _startsWithUnderscore`
  static set $_startsWithUnderscore(int value) =>
      _id_$_startsWithUnderscore.set(_class, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example() => Example.fromReference(
    _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
  );

  static final _id_greet = _class.instanceMethodId(
    r'greet',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _greet =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String greet(java.lang.String name)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? greet(jni$_.JString? name) {
    final _$name = name?.reference ?? jni$_.jNullReference;
    return _greet(
      reference.pointer,
      _id_greet as jni$_.JMethodIDPtr,
      _$name.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_enumValueToString = _class.instanceMethodId(
    r'enumValueToString',
    r'(Lcom/Example$Operation;)Ljava/lang/String;',
  );

  static final _enumValueToString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String enumValueToString(com.Example$Operation operation)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? enumValueToString(Example$Operation? operation) {
    final _$operation = operation?.reference ?? jni$_.jNullReference;
    return _enumValueToString(
      reference.pointer,
      _id_enumValueToString as jni$_.JMethodIDPtr,
      _$operation.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $Example$NullableType extends jni$_.JObjType<Example?> {
  @jni$_.internal
  const $Example$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Example;';

  @jni$_.internal
  @core$_.override
  Example? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Example.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Example$NullableType) &&
      other is $Example$NullableType;
}

final class $Example$Type extends jni$_.JObjType<Example> {
  @jni$_.internal
  const $Example$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Example;';

  @jni$_.internal
  @core$_.override
  Example fromReference(jni$_.JReference reference) =>
      Example.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example?> get nullableType => const $Example$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Example$Type) && other is $Example$Type;
}

/// from: `com.Example$Operation`
class Example$Operation extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Example$Operation> $type;

  @jni$_.internal
  Example$Operation.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/Example$Operation');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Example$Operation$NullableType();
  static const type = $Example$Operation$Type();
  static final _id_ADD = _class.staticFieldId(
    r'ADD',
    r'Lcom/Example$Operation;',
  );

  /// from: `static public final com.Example$Operation ADD`
  /// The returned object must be released after use, by calling the [release] method.
  static Example$Operation get ADD =>
      _id_ADD.get(_class, const $Example$Operation$Type());

  static final _id_SUBTRACT = _class.staticFieldId(
    r'SUBTRACT',
    r'Lcom/Example$Operation;',
  );

  /// from: `static public final com.Example$Operation SUBTRACT`
  /// The returned object must be released after use, by calling the [release] method.
  static Example$Operation get SUBTRACT =>
      _id_SUBTRACT.get(_class, const $Example$Operation$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lcom/Example$Operation;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public com.Example$Operation[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Example$Operation?>? values() => _values(
    _class.reference.pointer,
    _id_values as jni$_.JMethodIDPtr,
  ).object<jni$_.JArray<Example$Operation?>?>(
    const jni$_.JArrayNullableType<Example$Operation?>(
      $Example$Operation$NullableType(),
    ),
  );

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lcom/Example$Operation;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public com.Example$Operation valueOf(java.lang.String name)`
  /// The returned object must be released after use, by calling the [release] method.
  static Example$Operation? valueOf(jni$_.JString? name) {
    final _$name = name?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$name.pointer,
    ).object<Example$Operation?>(const $Example$Operation$NullableType());
  }
}

final class $Example$Operation$NullableType
    extends jni$_.JObjType<Example$Operation?> {
  @jni$_.internal
  const $Example$Operation$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Example$Operation;';

  @jni$_.internal
  @core$_.override
  Example$Operation? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Example$Operation.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$Operation?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Operation$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Example$Operation$NullableType) &&
      other is $Example$Operation$NullableType;
}

final class $Example$Operation$Type extends jni$_.JObjType<Example$Operation> {
  @jni$_.internal
  const $Example$Operation$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Example$Operation;';

  @jni$_.internal
  @core$_.override
  Example$Operation fromReference(jni$_.JReference reference) =>
      Example$Operation.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$Operation?> get nullableType =>
      const $Example$Operation$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Operation$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Example$Operation$Type) &&
      other is $Example$Operation$Type;
}

/// from: `com.Runnable`
class Runnable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Runnable> $type;

  @jni$_.internal
  Runnable.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/Runnable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Runnable$NullableType();
  static const type = $Runnable$Type();
  static final _id_run = _class.instanceMethodId(r'run', r'()I');

  static final _run =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int run()`
  int run() => _run(reference.pointer, _id_run as jni$_.JMethodIDPtr).integer;

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Runnable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) => _$invokeMethod(
    port,
    jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
  );

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'run()I') {
        final $r = _$impls[$p]!.run();
        return jni$_.JInteger($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $Runnable $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'com.Runnable', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Runnable.implement($Runnable $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Runnable.fromReference($i.implementReference());
  }
}

abstract base mixin class $Runnable {
  factory $Runnable({required int Function() run}) = _$Runnable;

  int run();
}

final class _$Runnable with $Runnable {
  _$Runnable({required int Function() run}) : _run = run;

  final int Function() _run;

  int run() => _run();
}

final class $Runnable$NullableType extends jni$_.JObjType<Runnable?> {
  @jni$_.internal
  const $Runnable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Runnable;';

  @jni$_.internal
  @core$_.override
  Runnable? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Runnable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Runnable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Runnable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Runnable$NullableType) &&
      other is $Runnable$NullableType;
}

final class $Runnable$Type extends jni$_.JObjType<Runnable> {
  @jni$_.internal
  const $Runnable$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Runnable;';

  @jni$_.internal
  @core$_.override
  Runnable fromReference(jni$_.JReference reference) =>
      Runnable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Runnable?> get nullableType => const $Runnable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Runnable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) =>
      other.runtimeType == ($Runnable$Type) && other is $Runnable$Type;
}
