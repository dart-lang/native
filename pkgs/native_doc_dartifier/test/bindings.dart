// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `java.io.RandomAccessFile`
class RandomAccessFile extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<RandomAccessFile> $type;

  @jni$_.internal
  RandomAccessFile.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/RandomAccessFile');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $RandomAccessFile$NullableType();
  static const type = $RandomAccessFile$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory RandomAccessFile(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return RandomAccessFile.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/io/File;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory RandomAccessFile.new$1(File? file, jni$_.JString? string) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return RandomAccessFile.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_getFD = _class.instanceMethodId(
    r'getFD',
    r'()Ljava/io/FileDescriptor;',
  );

  static final _getFD =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.io.FileDescriptor getFD()`
  /// The returned object must be released after use, by calling the [release] method.
  FileDescriptor? getFD() {
    return _getFD(
      reference.pointer,
      _id_getFD as jni$_.JMethodIDPtr,
    ).object<FileDescriptor?>(const $FileDescriptor$NullableType());
  }

  static final _id_getChannel = _class.instanceMethodId(
    r'getChannel',
    r'()Ljava/nio/channels/FileChannel;',
  );

  static final _getChannel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.nio.channels.FileChannel getChannel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChannel() {
    return _getChannel(
      reference.pointer,
      _id_getChannel as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() {
    return _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read$1 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read$1(
      reference.pointer,
      _id_read$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_read$2 = _class.instanceMethodId(r'read', r'([B)I');

  static final _read$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(byte[] bs)`
  int read$2(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read$2(
      reference.pointer,
      _id_read$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).integer;
  }

  static final _id_readFully = _class.instanceMethodId(r'readFully', r'([B)V');

  static final _readFully =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void readFully(byte[] bs)`
  void readFully(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully(
      reference.pointer,
      _id_readFully as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_readFully$1 = _class.instanceMethodId(
    r'readFully',
    r'([BII)V',
  );

  static final _readFully$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public final void readFully(byte[] bs, int i, int i1)`
  void readFully$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully$1(
      reference.pointer,
      _id_readFully$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_skipBytes = _class.instanceMethodId(r'skipBytes', r'(I)I');

  static final _skipBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int skipBytes(int i)`
  int skipBytes(int i) {
    return _skipBytes(
      reference.pointer,
      _id_skipBytes as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write$1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(byte[] bs)`
  void write$1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$1(
      reference.pointer,
      _id_write$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_write$2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write$2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$2(
      reference.pointer,
      _id_write$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_getFilePointer = _class.instanceMethodId(
    r'getFilePointer',
    r'()J',
  );

  static final _getFilePointer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public native long getFilePointer()`
  int getFilePointer() {
    return _getFilePointer(
      reference.pointer,
      _id_getFilePointer as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_seek = _class.instanceMethodId(r'seek', r'(J)V');

  static final _seek =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void seek(long j)`
  void seek(int j) {
    _seek(reference.pointer, _id_seek as jni$_.JMethodIDPtr, j).check();
  }

  static final _id_length = _class.instanceMethodId(r'length', r'()J');

  static final _length =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public native long length()`
  int length() {
    return _length(reference.pointer, _id_length as jni$_.JMethodIDPtr).long;
  }

  static final _id_setLength = _class.instanceMethodId(r'setLength', r'(J)V');

  static final _setLength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public native void setLength(long j)`
  void setLength(int j) {
    _setLength(
      reference.pointer,
      _id_setLength as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_readBoolean = _class.instanceMethodId(
    r'readBoolean',
    r'()Z',
  );

  static final _readBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean readBoolean()`
  bool readBoolean() {
    return _readBoolean(
      reference.pointer,
      _id_readBoolean as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_readByte = _class.instanceMethodId(r'readByte', r'()B');

  static final _readByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final byte readByte()`
  int readByte() {
    return _readByte(
      reference.pointer,
      _id_readByte as jni$_.JMethodIDPtr,
    ).byte;
  }

  static final _id_readUnsignedByte = _class.instanceMethodId(
    r'readUnsignedByte',
    r'()I',
  );

  static final _readUnsignedByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int readUnsignedByte()`
  int readUnsignedByte() {
    return _readUnsignedByte(
      reference.pointer,
      _id_readUnsignedByte as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readShort = _class.instanceMethodId(r'readShort', r'()S');

  static final _readShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final short readShort()`
  int readShort() {
    return _readShort(
      reference.pointer,
      _id_readShort as jni$_.JMethodIDPtr,
    ).short;
  }

  static final _id_readUnsignedShort = _class.instanceMethodId(
    r'readUnsignedShort',
    r'()I',
  );

  static final _readUnsignedShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int readUnsignedShort()`
  int readUnsignedShort() {
    return _readUnsignedShort(
      reference.pointer,
      _id_readUnsignedShort as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readChar = _class.instanceMethodId(r'readChar', r'()C');

  static final _readChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final char readChar()`
  int readChar() {
    return _readChar(
      reference.pointer,
      _id_readChar as jni$_.JMethodIDPtr,
    ).char;
  }

  static final _id_readInt = _class.instanceMethodId(r'readInt', r'()I');

  static final _readInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int readInt()`
  int readInt() {
    return _readInt(
      reference.pointer,
      _id_readInt as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readLong = _class.instanceMethodId(r'readLong', r'()J');

  static final _readLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long readLong()`
  int readLong() {
    return _readLong(
      reference.pointer,
      _id_readLong as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_readFloat = _class.instanceMethodId(r'readFloat', r'()F');

  static final _readFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final float readFloat()`
  double readFloat() {
    return _readFloat(
      reference.pointer,
      _id_readFloat as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_readDouble = _class.instanceMethodId(r'readDouble', r'()D');

  static final _readDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final double readDouble()`
  double readDouble() {
    return _readDouble(
      reference.pointer,
      _id_readDouble as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine() {
    return _readLine(
      reference.pointer,
      _id_readLine as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_readUTF = _class.instanceMethodId(
    r'readUTF',
    r'()Ljava/lang/String;',
  );

  static final _readUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String readUTF()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readUTF() {
    return _readUTF(
      reference.pointer,
      _id_readUTF as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_writeBoolean = _class.instanceMethodId(
    r'writeBoolean',
    r'(Z)V',
  );

  static final _writeBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeBoolean(boolean z)`
  void writeBoolean(bool z) {
    _writeBoolean(
      reference.pointer,
      _id_writeBoolean as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_writeByte = _class.instanceMethodId(r'writeByte', r'(I)V');

  static final _writeByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeByte(int i)`
  void writeByte(int i) {
    _writeByte(
      reference.pointer,
      _id_writeByte as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeShort = _class.instanceMethodId(r'writeShort', r'(I)V');

  static final _writeShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeShort(int i)`
  void writeShort(int i) {
    _writeShort(
      reference.pointer,
      _id_writeShort as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeChar = _class.instanceMethodId(r'writeChar', r'(I)V');

  static final _writeChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeChar(int i)`
  void writeChar(int i) {
    _writeChar(
      reference.pointer,
      _id_writeChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeInt = _class.instanceMethodId(r'writeInt', r'(I)V');

  static final _writeInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeInt(int i)`
  void writeInt(int i) {
    _writeInt(reference.pointer, _id_writeInt as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_writeLong = _class.instanceMethodId(r'writeLong', r'(J)V');

  static final _writeLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeLong(long j)`
  void writeLong(int j) {
    _writeLong(
      reference.pointer,
      _id_writeLong as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_writeFloat = _class.instanceMethodId(r'writeFloat', r'(F)V');

  static final _writeFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public final void writeFloat(float f)`
  void writeFloat(double f) {
    _writeFloat(
      reference.pointer,
      _id_writeFloat as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_writeDouble = _class.instanceMethodId(
    r'writeDouble',
    r'(D)V',
  );

  static final _writeDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public final void writeDouble(double d)`
  void writeDouble(double d) {
    _writeDouble(
      reference.pointer,
      _id_writeDouble as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'(Ljava/lang/String;)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void writeBytes(java.lang.String string)`
  void writeBytes(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeChars = _class.instanceMethodId(
    r'writeChars',
    r'(Ljava/lang/String;)V',
  );

  static final _writeChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void writeChars(java.lang.String string)`
  void writeChars(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeChars(
      reference.pointer,
      _id_writeChars as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeUTF = _class.instanceMethodId(
    r'writeUTF',
    r'(Ljava/lang/String;)V',
  );

  static final _writeUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void writeUTF(java.lang.String string)`
  void writeUTF(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeUTF(
      reference.pointer,
      _id_writeUTF as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }
}

final class $RandomAccessFile$NullableType
    extends jni$_.JObjType<RandomAccessFile?> {
  @jni$_.internal
  const $RandomAccessFile$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/RandomAccessFile;';

  @jni$_.internal
  @core$_.override
  RandomAccessFile? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : RandomAccessFile.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RandomAccessFile?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RandomAccessFile$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RandomAccessFile$NullableType) &&
        other is $RandomAccessFile$NullableType;
  }
}

final class $RandomAccessFile$Type extends jni$_.JObjType<RandomAccessFile> {
  @jni$_.internal
  const $RandomAccessFile$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/RandomAccessFile;';

  @jni$_.internal
  @core$_.override
  RandomAccessFile fromReference(jni$_.JReference reference) =>
      RandomAccessFile.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<RandomAccessFile?> get nullableType =>
      const $RandomAccessFile$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($RandomAccessFile$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($RandomAccessFile$Type) &&
        other is $RandomAccessFile$Type;
  }
}

/// from: `java.io.BufferedInputStream`
class BufferedInputStream extends FilterInputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<BufferedInputStream> $type;

  @jni$_.internal
  BufferedInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/BufferedInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $BufferedInputStream$NullableType();
  static const type = $BufferedInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/InputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedInputStream(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return BufferedInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/InputStream;I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedInputStream.new$1(InputStream? inputStream, int i) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return BufferedInputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
        i,
      ).reference,
    );
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() {
    return _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() {
    return _available(
      reference.pointer,
      _id_available as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() {
    return _markSupported(
      reference.pointer,
      _id_markSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $BufferedInputStream$NullableType
    extends jni$_.JObjType<BufferedInputStream?> {
  @jni$_.internal
  const $BufferedInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedInputStream;';

  @jni$_.internal
  @core$_.override
  BufferedInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : BufferedInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($BufferedInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BufferedInputStream$NullableType) &&
        other is $BufferedInputStream$NullableType;
  }
}

final class $BufferedInputStream$Type
    extends jni$_.JObjType<BufferedInputStream> {
  @jni$_.internal
  const $BufferedInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedInputStream;';

  @jni$_.internal
  @core$_.override
  BufferedInputStream fromReference(jni$_.JReference reference) =>
      BufferedInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedInputStream?> get nullableType =>
      const $BufferedInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($BufferedInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BufferedInputStream$Type) &&
        other is $BufferedInputStream$Type;
  }
}

/// from: `java.io.CharArrayReader`
class CharArrayReader extends Reader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CharArrayReader> $type;

  @jni$_.internal
  CharArrayReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/CharArrayReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CharArrayReader$NullableType();
  static const type = $CharArrayReader$Type();
  static final _id_new$ = _class.constructorId(r'([C)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(char[] cs)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CharArrayReader(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return CharArrayReader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$cs.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'([CII)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void <init>(char[] cs, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CharArrayReader.new$1(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return CharArrayReader.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$cs.pointer,
        i,
        i1,
      ).reference,
    );
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() {
    return _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_read = _class.instanceMethodId(
    r'read',
    r'(Ljava/nio/CharBuffer;)I',
  );

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(java.nio.CharBuffer charBuffer)`
  int read(jni$_.JObject? charBuffer) {
    final _$charBuffer = charBuffer?.reference ?? jni$_.jNullReference;
    return _read(
      reference.pointer,
      _id_read as jni$_.JMethodIDPtr,
      _$charBuffer.pointer,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() {
    return _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() {
    return _markSupported(
      reference.pointer,
      _id_markSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $CharArrayReader$NullableType
    extends jni$_.JObjType<CharArrayReader?> {
  @jni$_.internal
  const $CharArrayReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/CharArrayReader;';

  @jni$_.internal
  @core$_.override
  CharArrayReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CharArrayReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CharArrayReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($CharArrayReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CharArrayReader$NullableType) &&
        other is $CharArrayReader$NullableType;
  }
}

final class $CharArrayReader$Type extends jni$_.JObjType<CharArrayReader> {
  @jni$_.internal
  const $CharArrayReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/CharArrayReader;';

  @jni$_.internal
  @core$_.override
  CharArrayReader fromReference(jni$_.JReference reference) =>
      CharArrayReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CharArrayReader?> get nullableType =>
      const $CharArrayReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($CharArrayReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CharArrayReader$Type) &&
        other is $CharArrayReader$Type;
  }
}

/// from: `java.io.ObjectOutputStream$PutField`
class ObjectOutputStream$PutField extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectOutputStream$PutField> $type;

  @jni$_.internal
  ObjectOutputStream$PutField.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/ObjectOutputStream$PutField',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectOutputStream$PutField$NullableType();
  static const type = $ObjectOutputStream$PutField$Type();
  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;Z)V',
  );

  static final _put =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, boolean z)`
  void put(jni$_.JString? string, bool z) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put(
      reference.pointer,
      _id_put as jni$_.JMethodIDPtr,
      _$string.pointer,
      z ? 1 : 0,
    ).check();
  }

  static final _id_put$1 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;B)V',
  );

  static final _put$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, byte b)`
  void put$1(jni$_.JString? string, int b) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put$1(
      reference.pointer,
      _id_put$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      b,
    ).check();
  }

  static final _id_put$2 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;C)V',
  );

  static final _put$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, char c)`
  void put$2(jni$_.JString? string, int c) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put$2(
      reference.pointer,
      _id_put$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      c,
    ).check();
  }

  static final _id_put$3 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;S)V',
  );

  static final _put$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, short s)`
  void put$3(jni$_.JString? string, int s) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put$3(
      reference.pointer,
      _id_put$3 as jni$_.JMethodIDPtr,
      _$string.pointer,
      s,
    ).check();
  }

  static final _id_put$4 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;I)V',
  );

  static final _put$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, int i)`
  void put$4(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put$4(
      reference.pointer,
      _id_put$4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
    ).check();
  }

  static final _id_put$5 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;J)V',
  );

  static final _put$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, long j)`
  void put$5(jni$_.JString? string, int j) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put$5(
      reference.pointer,
      _id_put$5 as jni$_.JMethodIDPtr,
      _$string.pointer,
      j,
    ).check();
  }

  static final _id_put$6 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;F)V',
  );

  static final _put$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Double)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              double,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, float f)`
  void put$6(jni$_.JString? string, double f) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put$6(
      reference.pointer,
      _id_put$6 as jni$_.JMethodIDPtr,
      _$string.pointer,
      f,
    ).check();
  }

  static final _id_put$7 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;D)V',
  );

  static final _put$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Double)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              double,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, double d)`
  void put$7(jni$_.JString? string, double d) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _put$7(
      reference.pointer,
      _id_put$7 as jni$_.JMethodIDPtr,
      _$string.pointer,
      d,
    ).check();
  }

  static final _id_put$8 = _class.instanceMethodId(
    r'put',
    r'(Ljava/lang/String;Ljava/lang/Object;)V',
  );

  static final _put$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void put(java.lang.String string, java.lang.Object object)`
  void put$8(jni$_.JString? string, jni$_.JObject? object) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    _put$8(
      reference.pointer,
      _id_put$8 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$object.pointer,
    ).check();
  }

  static final _id_write = _class.instanceMethodId(
    r'write',
    r'(Ljava/io/ObjectOutput;)V',
  );

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void write(java.io.ObjectOutput objectOutput)`
  void write(ObjectOutput? objectOutput) {
    final _$objectOutput = objectOutput?.reference ?? jni$_.jNullReference;
    _write(
      reference.pointer,
      _id_write as jni$_.JMethodIDPtr,
      _$objectOutput.pointer,
    ).check();
  }
}

final class $ObjectOutputStream$PutField$NullableType
    extends jni$_.JObjType<ObjectOutputStream$PutField?> {
  @jni$_.internal
  const $ObjectOutputStream$PutField$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectOutputStream$PutField;';

  @jni$_.internal
  @core$_.override
  ObjectOutputStream$PutField? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ObjectOutputStream$PutField.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectOutputStream$PutField?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectOutputStream$PutField$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectOutputStream$PutField$NullableType) &&
        other is $ObjectOutputStream$PutField$NullableType;
  }
}

final class $ObjectOutputStream$PutField$Type
    extends jni$_.JObjType<ObjectOutputStream$PutField> {
  @jni$_.internal
  const $ObjectOutputStream$PutField$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectOutputStream$PutField;';

  @jni$_.internal
  @core$_.override
  ObjectOutputStream$PutField fromReference(jni$_.JReference reference) =>
      ObjectOutputStream$PutField.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectOutputStream$PutField?> get nullableType =>
      const $ObjectOutputStream$PutField$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectOutputStream$PutField$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectOutputStream$PutField$Type) &&
        other is $ObjectOutputStream$PutField$Type;
  }
}

/// from: `java.io.PushbackInputStream`
class PushbackInputStream extends FilterInputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PushbackInputStream> $type;

  @jni$_.internal
  PushbackInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PushbackInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PushbackInputStream$NullableType();
  static const type = $PushbackInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/InputStream;I)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PushbackInputStream(InputStream? inputStream, int i) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return PushbackInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/InputStream;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PushbackInputStream.new$1(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return PushbackInputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
      ).reference,
    );
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() {
    return _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_unread = _class.instanceMethodId(r'unread', r'(I)V');

  static final _unread =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void unread(int i)`
  void unread(int i) {
    _unread(reference.pointer, _id_unread as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_unread$1 = _class.instanceMethodId(r'unread', r'([BII)V');

  static final _unread$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void unread(byte[] bs, int i, int i1)`
  void unread$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _unread$1(
      reference.pointer,
      _id_unread$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_unread$2 = _class.instanceMethodId(r'unread', r'([B)V');

  static final _unread$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void unread(byte[] bs)`
  void unread$2(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _unread$2(
      reference.pointer,
      _id_unread$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() {
    return _available(
      reference.pointer,
      _id_available as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() {
    return _markSupported(
      reference.pointer,
      _id_markSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $PushbackInputStream$NullableType
    extends jni$_.JObjType<PushbackInputStream?> {
  @jni$_.internal
  const $PushbackInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PushbackInputStream;';

  @jni$_.internal
  @core$_.override
  PushbackInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PushbackInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PushbackInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($PushbackInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PushbackInputStream$NullableType) &&
        other is $PushbackInputStream$NullableType;
  }
}

final class $PushbackInputStream$Type
    extends jni$_.JObjType<PushbackInputStream> {
  @jni$_.internal
  const $PushbackInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PushbackInputStream;';

  @jni$_.internal
  @core$_.override
  PushbackInputStream fromReference(jni$_.JReference reference) =>
      PushbackInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PushbackInputStream?> get nullableType =>
      const $PushbackInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($PushbackInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PushbackInputStream$Type) &&
        other is $PushbackInputStream$Type;
  }
}

/// from: `java.io.FilterReader`
class FilterReader extends Reader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FilterReader> $type;

  @jni$_.internal
  FilterReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FilterReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FilterReader$NullableType();
  static const type = $FilterReader$Type();
  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() {
    return _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() {
    return _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() {
    return _markSupported(
      reference.pointer,
      _id_markSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $FilterReader$NullableType extends jni$_.JObjType<FilterReader?> {
  @jni$_.internal
  const $FilterReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterReader;';

  @jni$_.internal
  @core$_.override
  FilterReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FilterReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FilterReader$NullableType) &&
        other is $FilterReader$NullableType;
  }
}

final class $FilterReader$Type extends jni$_.JObjType<FilterReader> {
  @jni$_.internal
  const $FilterReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterReader;';

  @jni$_.internal
  @core$_.override
  FilterReader fromReference(jni$_.JReference reference) =>
      FilterReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterReader?> get nullableType =>
      const $FilterReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FilterReader$Type) &&
        other is $FilterReader$Type;
  }
}

/// from: `java.io.DataOutputStream`
class DataOutputStream extends FilterOutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DataOutputStream> $type;

  @jni$_.internal
  DataOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/DataOutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DataOutputStream$NullableType();
  static const type = $DataOutputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DataOutputStream(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return DataOutputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_writeBoolean = _class.instanceMethodId(
    r'writeBoolean',
    r'(Z)V',
  );

  static final _writeBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeBoolean(boolean z)`
  void writeBoolean(bool z) {
    _writeBoolean(
      reference.pointer,
      _id_writeBoolean as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_writeByte = _class.instanceMethodId(r'writeByte', r'(I)V');

  static final _writeByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeByte(int i)`
  void writeByte(int i) {
    _writeByte(
      reference.pointer,
      _id_writeByte as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeShort = _class.instanceMethodId(r'writeShort', r'(I)V');

  static final _writeShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeShort(int i)`
  void writeShort(int i) {
    _writeShort(
      reference.pointer,
      _id_writeShort as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeChar = _class.instanceMethodId(r'writeChar', r'(I)V');

  static final _writeChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeChar(int i)`
  void writeChar(int i) {
    _writeChar(
      reference.pointer,
      _id_writeChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeInt = _class.instanceMethodId(r'writeInt', r'(I)V');

  static final _writeInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeInt(int i)`
  void writeInt(int i) {
    _writeInt(reference.pointer, _id_writeInt as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_writeLong = _class.instanceMethodId(r'writeLong', r'(J)V');

  static final _writeLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final void writeLong(long j)`
  void writeLong(int j) {
    _writeLong(
      reference.pointer,
      _id_writeLong as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_writeFloat = _class.instanceMethodId(r'writeFloat', r'(F)V');

  static final _writeFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public final void writeFloat(float f)`
  void writeFloat(double f) {
    _writeFloat(
      reference.pointer,
      _id_writeFloat as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_writeDouble = _class.instanceMethodId(
    r'writeDouble',
    r'(D)V',
  );

  static final _writeDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public final void writeDouble(double d)`
  void writeDouble(double d) {
    _writeDouble(
      reference.pointer,
      _id_writeDouble as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'(Ljava/lang/String;)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void writeBytes(java.lang.String string)`
  void writeBytes(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeChars = _class.instanceMethodId(
    r'writeChars',
    r'(Ljava/lang/String;)V',
  );

  static final _writeChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void writeChars(java.lang.String string)`
  void writeChars(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeChars(
      reference.pointer,
      _id_writeChars as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeUTF = _class.instanceMethodId(
    r'writeUTF',
    r'(Ljava/lang/String;)V',
  );

  static final _writeUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void writeUTF(java.lang.String string)`
  void writeUTF(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeUTF(
      reference.pointer,
      _id_writeUTF as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_size = _class.instanceMethodId(r'size', r'()I');

  static final _size =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int size()`
  int size() {
    return _size(reference.pointer, _id_size as jni$_.JMethodIDPtr).integer;
  }

  static final _id_write1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void write(byte[] bs)`
  void write1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write1(
      reference.pointer,
      _id_write1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }
}

final class $DataOutputStream$NullableType
    extends jni$_.JObjType<DataOutputStream?> {
  @jni$_.internal
  const $DataOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataOutputStream;';

  @jni$_.internal
  @core$_.override
  DataOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DataOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($DataOutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DataOutputStream$NullableType) &&
        other is $DataOutputStream$NullableType;
  }
}

final class $DataOutputStream$Type extends jni$_.JObjType<DataOutputStream> {
  @jni$_.internal
  const $DataOutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataOutputStream;';

  @jni$_.internal
  @core$_.override
  DataOutputStream fromReference(jni$_.JReference reference) =>
      DataOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataOutputStream?> get nullableType =>
      const $DataOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($DataOutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DataOutputStream$Type) &&
        other is $DataOutputStream$Type;
  }
}

/// from: `java.io.PipedInputStream`
class PipedInputStream extends InputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PipedInputStream> $type;

  @jni$_.internal
  PipedInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PipedInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PipedInputStream$NullableType();
  static const type = $PipedInputStream$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/io/PipedOutputStream;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.PipedOutputStream pipedOutputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedInputStream(PipedOutputStream? pipedOutputStream) {
    final _$pipedOutputStream =
        pipedOutputStream?.reference ?? jni$_.jNullReference;
    return PipedInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$pipedOutputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/io/PipedOutputStream;I)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.PipedOutputStream pipedOutputStream, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedInputStream.new$1(PipedOutputStream? pipedOutputStream, int i) {
    final _$pipedOutputStream =
        pipedOutputStream?.reference ?? jni$_.jNullReference;
    return PipedInputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$pipedOutputStream.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'()V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedInputStream.new$2() {
    return PipedInputStream.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(I)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedInputStream.new$3(int i) {
    return PipedInputStream.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        i,
      ).reference,
    );
  }

  static final _id_connect = _class.instanceMethodId(
    r'connect',
    r'(Ljava/io/PipedOutputStream;)V',
  );

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void connect(java.io.PipedOutputStream pipedOutputStream)`
  void connect(PipedOutputStream? pipedOutputStream) {
    final _$pipedOutputStream =
        pipedOutputStream?.reference ?? jni$_.jNullReference;
    _connect(
      reference.pointer,
      _id_connect as jni$_.JMethodIDPtr,
      _$pipedOutputStream.pointer,
    ).check();
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() {
    return _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() {
    return _available(
      reference.pointer,
      _id_available as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $PipedInputStream$NullableType
    extends jni$_.JObjType<PipedInputStream?> {
  @jni$_.internal
  const $PipedInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedInputStream;';

  @jni$_.internal
  @core$_.override
  PipedInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PipedInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PipedInputStream$NullableType) &&
        other is $PipedInputStream$NullableType;
  }
}

final class $PipedInputStream$Type extends jni$_.JObjType<PipedInputStream> {
  @jni$_.internal
  const $PipedInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedInputStream;';

  @jni$_.internal
  @core$_.override
  PipedInputStream fromReference(jni$_.JReference reference) =>
      PipedInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedInputStream?> get nullableType =>
      const $PipedInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PipedInputStream$Type) &&
        other is $PipedInputStream$Type;
  }
}

/// from: `java.io.FilePermission`
class FilePermission extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FilePermission> $type;

  @jni$_.internal
  FilePermission.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FilePermission');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FilePermission$NullableType();
  static const type = $FilePermission$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FilePermission(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return FilePermission.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_implies = _class.instanceMethodId(
    r'implies',
    r'(Ljava/security/Permission;)Z',
  );

  static final _implies =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean implies(java.security.Permission permission)`
  bool implies(jni$_.JObject? permission) {
    final _$permission = permission?.reference ?? jni$_.jNullReference;
    return _implies(
      reference.pointer,
      _id_implies as jni$_.JMethodIDPtr,
      _$permission.pointer,
    ).boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getActions = _class.instanceMethodId(
    r'getActions',
    r'()Ljava/lang/String;',
  );

  static final _getActions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getActions()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getActions() {
    return _getActions(
      reference.pointer,
      _id_getActions as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_newPermissionCollection = _class.instanceMethodId(
    r'newPermissionCollection',
    r'()Ljava/security/PermissionCollection;',
  );

  static final _newPermissionCollection =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.security.PermissionCollection newPermissionCollection()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? newPermissionCollection() {
    return _newPermissionCollection(
      reference.pointer,
      _id_newPermissionCollection as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $FilePermission$NullableType
    extends jni$_.JObjType<FilePermission?> {
  @jni$_.internal
  const $FilePermission$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilePermission;';

  @jni$_.internal
  @core$_.override
  FilePermission? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FilePermission.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilePermission?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FilePermission$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FilePermission$NullableType) &&
        other is $FilePermission$NullableType;
  }
}

final class $FilePermission$Type extends jni$_.JObjType<FilePermission> {
  @jni$_.internal
  const $FilePermission$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilePermission;';

  @jni$_.internal
  @core$_.override
  FilePermission fromReference(jni$_.JReference reference) =>
      FilePermission.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilePermission?> get nullableType =>
      const $FilePermission$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FilePermission$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FilePermission$Type) &&
        other is $FilePermission$Type;
  }
}

/// from: `java.io.InvalidObjectException`
class InvalidObjectException extends ObjectStreamException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InvalidObjectException> $type;

  @jni$_.internal
  InvalidObjectException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/InvalidObjectException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InvalidObjectException$NullableType();
  static const type = $InvalidObjectException$Type();
  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InvalidObjectException.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return InvalidObjectException.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $InvalidObjectException$NullableType
    extends jni$_.JObjType<InvalidObjectException?> {
  @jni$_.internal
  const $InvalidObjectException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InvalidObjectException;';

  @jni$_.internal
  @core$_.override
  InvalidObjectException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InvalidObjectException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InvalidObjectException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($InvalidObjectException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InvalidObjectException$NullableType) &&
        other is $InvalidObjectException$NullableType;
  }
}

final class $InvalidObjectException$Type
    extends jni$_.JObjType<InvalidObjectException> {
  @jni$_.internal
  const $InvalidObjectException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InvalidObjectException;';

  @jni$_.internal
  @core$_.override
  InvalidObjectException fromReference(jni$_.JReference reference) =>
      InvalidObjectException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InvalidObjectException?> get nullableType =>
      const $InvalidObjectException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($InvalidObjectException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InvalidObjectException$Type) &&
        other is $InvalidObjectException$Type;
  }
}

/// from: `java.io.ObjectStreamField`
class ObjectStreamField extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectStreamField> $type;

  @jni$_.internal
  ObjectStreamField.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectStreamField');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectStreamField$NullableType();
  static const type = $ObjectStreamField$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/Class;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.Class<?> class)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ObjectStreamField(jni$_.JString? string, jni$_.JObject? class$) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    return ObjectStreamField.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$class$.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/Class;Z)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.Class<?> class, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ObjectStreamField.new$1(
    jni$_.JString? string,
    jni$_.JObject? class$,
    bool z,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    return ObjectStreamField.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$class$.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() {
    return _getName(
      reference.pointer,
      _id_getName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getType = _class.instanceMethodId(
    r'getType',
    r'()Ljava/lang/Class;',
  );

  static final _getType =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Class<?> getType()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getType() {
    return _getType(
      reference.pointer,
      _id_getType as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getTypeCode = _class.instanceMethodId(
    r'getTypeCode',
    r'()C',
  );

  static final _getTypeCode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char getTypeCode()`
  int getTypeCode() {
    return _getTypeCode(
      reference.pointer,
      _id_getTypeCode as jni$_.JMethodIDPtr,
    ).char;
  }

  static final _id_getTypeString = _class.instanceMethodId(
    r'getTypeString',
    r'()Ljava/lang/String;',
  );

  static final _getTypeString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getTypeString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getTypeString() {
    return _getTypeString(
      reference.pointer,
      _id_getTypeString as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getOffset = _class.instanceMethodId(r'getOffset', r'()I');

  static final _getOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getOffset()`
  int getOffset() {
    return _getOffset(
      reference.pointer,
      _id_getOffset as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_isPrimitive = _class.instanceMethodId(
    r'isPrimitive',
    r'()Z',
  );

  static final _isPrimitive =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isPrimitive()`
  bool isPrimitive() {
    return _isPrimitive(
      reference.pointer,
      _id_isPrimitive as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isUnshared = _class.instanceMethodId(r'isUnshared', r'()Z');

  static final _isUnshared =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isUnshared()`
  bool isUnshared() {
    return _isUnshared(
      reference.pointer,
      _id_isUnshared as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/lang/Object;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.lang.Object object)`
  int compareTo(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $ObjectStreamField$NullableType
    extends jni$_.JObjType<ObjectStreamField?> {
  @jni$_.internal
  const $ObjectStreamField$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamField;';

  @jni$_.internal
  @core$_.override
  ObjectStreamField? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectStreamField.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamField?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectStreamField$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectStreamField$NullableType) &&
        other is $ObjectStreamField$NullableType;
  }
}

final class $ObjectStreamField$Type extends jni$_.JObjType<ObjectStreamField> {
  @jni$_.internal
  const $ObjectStreamField$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamField;';

  @jni$_.internal
  @core$_.override
  ObjectStreamField fromReference(jni$_.JReference reference) =>
      ObjectStreamField.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamField?> get nullableType =>
      const $ObjectStreamField$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectStreamField$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectStreamField$Type) &&
        other is $ObjectStreamField$Type;
  }
}

/// from: `java.io.PrintWriter`
class PrintWriter extends Writer {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PrintWriter> $type;

  @jni$_.internal
  PrintWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PrintWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PrintWriter$NullableType();
  static const type = $PrintWriter$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/Writer;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.Writer writer)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter(Writer? writer) {
    final _$writer = writer?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$writer.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/Writer;Z)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.Writer writer, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$1(Writer? writer, bool z) {
    final _$writer = writer?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$writer.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$2(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(Ljava/io/OutputStream;Z)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$3(OutputStream? outputStream, bool z) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(
    r'(Ljava/io/OutputStream;ZLjava/nio/charset/Charset;)V',
  );

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, boolean z, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$4(
    OutputStream? outputStream,
    bool z,
    jni$_.JObject? charset,
  ) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        z ? 1 : 0,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$5(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$6 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$6(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$6(
        _class.reference.pointer,
        _id_new$6 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_new$7 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;)V',
  );

  static final _new$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$7(jni$_.JString? string, jni$_.JObject? charset) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$7(
        _class.reference.pointer,
        _id_new$7 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$8 = _class.constructorId(r'(Ljava/io/File;)V');

  static final _new$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$8(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$8(
        _class.reference.pointer,
        _id_new$8 as jni$_.JMethodIDPtr,
        _$file.pointer,
      ).reference,
    );
  }

  static final _id_new$9 = _class.constructorId(
    r'(Ljava/io/File;Ljava/lang/String;)V',
  );

  static final _new$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$9(File? file, jni$_.JString? string) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$9(
        _class.reference.pointer,
        _id_new$9 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$10 = _class.constructorId(
    r'(Ljava/io/File;Ljava/nio/charset/Charset;)V',
  );

  static final _new$10 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintWriter.new$10(File? file, jni$_.JObject? charset) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return PrintWriter.fromReference(
      _new$10(
        _class.reference.pointer,
        _id_new$10 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_checkError = _class.instanceMethodId(r'checkError', r'()Z');

  static final _checkError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean checkError()`
  bool checkError() {
    return _checkError(
      reference.pointer,
      _id_checkError as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(char[] cs, int i, int i1)`
  void write2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write1 = _class.instanceMethodId(r'write', r'([C)V');

  static final _write1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(char[] cs)`
  void write1(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write1(
      reference.pointer,
      _id_write1 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).check();
  }

  static final _id_write4 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;II)V',
  );

  static final _write4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(java.lang.String string, int i, int i1)`
  void write4(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write4(
      reference.pointer,
      _id_write4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write3 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;)V',
  );

  static final _write3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(java.lang.String string)`
  void write3(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write3(
      reference.pointer,
      _id_write3 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_print = _class.instanceMethodId(r'print', r'(Z)V');

  static final _print =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(boolean z)`
  void print(bool z) {
    _print(
      reference.pointer,
      _id_print as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_print$1 = _class.instanceMethodId(r'print', r'(C)V');

  static final _print$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(char c)`
  void print$1(int c) {
    _print$1(reference.pointer, _id_print$1 as jni$_.JMethodIDPtr, c).check();
  }

  static final _id_print$2 = _class.instanceMethodId(r'print', r'(I)V');

  static final _print$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(int i)`
  void print$2(int i) {
    _print$2(reference.pointer, _id_print$2 as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_print$3 = _class.instanceMethodId(r'print', r'(J)V');

  static final _print$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(long j)`
  void print$3(int j) {
    _print$3(reference.pointer, _id_print$3 as jni$_.JMethodIDPtr, j).check();
  }

  static final _id_print$4 = _class.instanceMethodId(r'print', r'(F)V');

  static final _print$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void print(float f)`
  void print$4(double f) {
    _print$4(reference.pointer, _id_print$4 as jni$_.JMethodIDPtr, f).check();
  }

  static final _id_print$5 = _class.instanceMethodId(r'print', r'(D)V');

  static final _print$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void print(double d)`
  void print$5(double d) {
    _print$5(reference.pointer, _id_print$5 as jni$_.JMethodIDPtr, d).check();
  }

  static final _id_print$6 = _class.instanceMethodId(r'print', r'([C)V');

  static final _print$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void print(char[] cs)`
  void print$6(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _print$6(
      reference.pointer,
      _id_print$6 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).check();
  }

  static final _id_print$7 = _class.instanceMethodId(
    r'print',
    r'(Ljava/lang/String;)V',
  );

  static final _print$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void print(java.lang.String string)`
  void print$7(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _print$7(
      reference.pointer,
      _id_print$7 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_print$8 = _class.instanceMethodId(
    r'print',
    r'(Ljava/lang/Object;)V',
  );

  static final _print$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void print(java.lang.Object object)`
  void print$8(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _print$8(
      reference.pointer,
      _id_print$8 as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_println = _class.instanceMethodId(r'println', r'()V');

  static final _println =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void println()`
  void println() {
    _println(reference.pointer, _id_println as jni$_.JMethodIDPtr).check();
  }

  static final _id_println$1 = _class.instanceMethodId(r'println', r'(Z)V');

  static final _println$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(boolean z)`
  void println$1(bool z) {
    _println$1(
      reference.pointer,
      _id_println$1 as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_println$2 = _class.instanceMethodId(r'println', r'(C)V');

  static final _println$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(char c)`
  void println$2(int c) {
    _println$2(
      reference.pointer,
      _id_println$2 as jni$_.JMethodIDPtr,
      c,
    ).check();
  }

  static final _id_println$3 = _class.instanceMethodId(r'println', r'(I)V');

  static final _println$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(int i)`
  void println$3(int i) {
    _println$3(
      reference.pointer,
      _id_println$3 as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_println$4 = _class.instanceMethodId(r'println', r'(J)V');

  static final _println$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(long j)`
  void println$4(int j) {
    _println$4(
      reference.pointer,
      _id_println$4 as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_println$5 = _class.instanceMethodId(r'println', r'(F)V');

  static final _println$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void println(float f)`
  void println$5(double f) {
    _println$5(
      reference.pointer,
      _id_println$5 as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_println$6 = _class.instanceMethodId(r'println', r'(D)V');

  static final _println$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void println(double d)`
  void println$6(double d) {
    _println$6(
      reference.pointer,
      _id_println$6 as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_println$7 = _class.instanceMethodId(r'println', r'([C)V');

  static final _println$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void println(char[] cs)`
  void println$7(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _println$7(
      reference.pointer,
      _id_println$7 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).check();
  }

  static final _id_println$8 = _class.instanceMethodId(
    r'println',
    r'(Ljava/lang/String;)V',
  );

  static final _println$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void println(java.lang.String string)`
  void println$8(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _println$8(
      reference.pointer,
      _id_println$8 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_println$9 = _class.instanceMethodId(
    r'println',
    r'(Ljava/lang/Object;)V',
  );

  static final _println$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void println(java.lang.Object object)`
  void println$9(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _println$9(
      reference.pointer,
      _id_println$9 as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_printf = _class.instanceMethodId(
    r'printf',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintWriter;',
  );

  static final _printf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintWriter printf(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? printf(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _printf(
      reference.pointer,
      _id_printf as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintWriter?>(const $PrintWriter$NullableType());
  }

  static final _id_printf$1 = _class.instanceMethodId(
    r'printf',
    r'(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintWriter;',
  );

  static final _printf$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintWriter printf(java.util.Locale locale, java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? printf$1(
    jni$_.JObject? locale,
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _printf$1(
      reference.pointer,
      _id_printf$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintWriter?>(const $PrintWriter$NullableType());
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintWriter;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintWriter format(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? format(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintWriter?>(const $PrintWriter$NullableType());
  }

  static final _id_format$1 = _class.instanceMethodId(
    r'format',
    r'(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintWriter;',
  );

  static final _format$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintWriter format(java.util.Locale locale, java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? format$1(
    jni$_.JObject? locale,
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _format$1(
      reference.pointer,
      _id_format$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintWriter?>(const $PrintWriter$NullableType());
  }

  static final _id_append$3 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;)Ljava/io/PrintWriter;',
  );

  static final _append$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintWriter append(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? append$3(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$3(
      reference.pointer,
      _id_append$3 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<PrintWriter?>(const $PrintWriter$NullableType());
  }

  static final _id_append$4 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;II)Ljava/io/PrintWriter;',
  );

  static final _append$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public java.io.PrintWriter append(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? append$4(jni$_.JObject? charSequence, int i, int i1) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$4(
      reference.pointer,
      _id_append$4 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
    ).object<PrintWriter?>(const $PrintWriter$NullableType());
  }

  static final _id_append$5 = _class.instanceMethodId(
    r'append',
    r'(C)Ljava/io/PrintWriter;',
  );

  static final _append$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.io.PrintWriter append(char c)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? append$5(int c) {
    return _append$5(
      reference.pointer,
      _id_append$5 as jni$_.JMethodIDPtr,
      c,
    ).object<PrintWriter?>(const $PrintWriter$NullableType());
  }
}

final class $PrintWriter$NullableType extends jni$_.JObjType<PrintWriter?> {
  @jni$_.internal
  const $PrintWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PrintWriter;';

  @jni$_.internal
  @core$_.override
  PrintWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PrintWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PrintWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PrintWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PrintWriter$NullableType) &&
        other is $PrintWriter$NullableType;
  }
}

final class $PrintWriter$Type extends jni$_.JObjType<PrintWriter> {
  @jni$_.internal
  const $PrintWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PrintWriter;';

  @jni$_.internal
  @core$_.override
  PrintWriter fromReference(jni$_.JReference reference) =>
      PrintWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PrintWriter?> get nullableType =>
      const $PrintWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PrintWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PrintWriter$Type) &&
        other is $PrintWriter$Type;
  }
}

/// from: `java.io.StreamCorruptedException`
class StreamCorruptedException extends ObjectStreamException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StreamCorruptedException> $type;

  @jni$_.internal
  StreamCorruptedException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/StreamCorruptedException',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StreamCorruptedException$NullableType();
  static const type = $StreamCorruptedException$Type();
  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StreamCorruptedException.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return StreamCorruptedException.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'()V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StreamCorruptedException.new$5() {
    return StreamCorruptedException.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }
}

final class $StreamCorruptedException$NullableType
    extends jni$_.JObjType<StreamCorruptedException?> {
  @jni$_.internal
  const $StreamCorruptedException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StreamCorruptedException;';

  @jni$_.internal
  @core$_.override
  StreamCorruptedException? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : StreamCorruptedException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StreamCorruptedException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($StreamCorruptedException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StreamCorruptedException$NullableType) &&
        other is $StreamCorruptedException$NullableType;
  }
}

final class $StreamCorruptedException$Type
    extends jni$_.JObjType<StreamCorruptedException> {
  @jni$_.internal
  const $StreamCorruptedException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StreamCorruptedException;';

  @jni$_.internal
  @core$_.override
  StreamCorruptedException fromReference(jni$_.JReference reference) =>
      StreamCorruptedException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StreamCorruptedException?> get nullableType =>
      const $StreamCorruptedException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($StreamCorruptedException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StreamCorruptedException$Type) &&
        other is $StreamCorruptedException$Type;
  }
}

/// from: `java.io.Externalizable`
class Externalizable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Externalizable> $type;

  @jni$_.internal
  Externalizable.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Externalizable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Externalizable$NullableType();
  static const type = $Externalizable$Type();
  static final _id_writeExternal = _class.instanceMethodId(
    r'writeExternal',
    r'(Ljava/io/ObjectOutput;)V',
  );

  static final _writeExternal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeExternal(java.io.ObjectOutput objectOutput)`
  void writeExternal(ObjectOutput? objectOutput) {
    final _$objectOutput = objectOutput?.reference ?? jni$_.jNullReference;
    _writeExternal(
      reference.pointer,
      _id_writeExternal as jni$_.JMethodIDPtr,
      _$objectOutput.pointer,
    ).check();
  }

  static final _id_readExternal = _class.instanceMethodId(
    r'readExternal',
    r'(Ljava/io/ObjectInput;)V',
  );

  static final _readExternal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void readExternal(java.io.ObjectInput objectInput)`
  void readExternal(ObjectInput? objectInput) {
    final _$objectInput = objectInput?.reference ?? jni$_.jNullReference;
    _readExternal(
      reference.pointer,
      _id_readExternal as jni$_.JMethodIDPtr,
      _$objectInput.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Externalizable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'writeExternal(Ljava/io/ObjectOutput;)V') {
        _$impls[$p]!.writeExternal(
          $a![0]?.as(const $ObjectOutput$Type(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'readExternal(Ljava/io/ObjectInput;)V') {
        _$impls[$p]!.readExternal(
          $a![0]?.as(const $ObjectInput$Type(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $Externalizable $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.Externalizable', $p, _$invokePointer, [
      if ($impl.writeExternal$async) r'writeExternal(Ljava/io/ObjectOutput;)V',
      if ($impl.readExternal$async) r'readExternal(Ljava/io/ObjectInput;)V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Externalizable.implement($Externalizable $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Externalizable.fromReference($i.implementReference());
  }
}

abstract base mixin class $Externalizable {
  factory $Externalizable({
    required void Function(ObjectOutput? objectOutput) writeExternal,
    bool writeExternal$async,
    required void Function(ObjectInput? objectInput) readExternal,
    bool readExternal$async,
  }) = _$Externalizable;

  void writeExternal(ObjectOutput? objectOutput);
  bool get writeExternal$async => false;
  void readExternal(ObjectInput? objectInput);
  bool get readExternal$async => false;
}

final class _$Externalizable with $Externalizable {
  _$Externalizable({
    required void Function(ObjectOutput? objectOutput) writeExternal,
    this.writeExternal$async = false,
    required void Function(ObjectInput? objectInput) readExternal,
    this.readExternal$async = false,
  }) : _writeExternal = writeExternal,
       _readExternal = readExternal;

  final void Function(ObjectOutput? objectOutput) _writeExternal;
  final bool writeExternal$async;
  final void Function(ObjectInput? objectInput) _readExternal;
  final bool readExternal$async;

  void writeExternal(ObjectOutput? objectOutput) {
    return _writeExternal(objectOutput);
  }

  void readExternal(ObjectInput? objectInput) {
    return _readExternal(objectInput);
  }
}

final class $Externalizable$NullableType
    extends jni$_.JObjType<Externalizable?> {
  @jni$_.internal
  const $Externalizable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Externalizable;';

  @jni$_.internal
  @core$_.override
  Externalizable? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Externalizable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Externalizable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Externalizable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Externalizable$NullableType) &&
        other is $Externalizable$NullableType;
  }
}

final class $Externalizable$Type extends jni$_.JObjType<Externalizable> {
  @jni$_.internal
  const $Externalizable$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Externalizable;';

  @jni$_.internal
  @core$_.override
  Externalizable fromReference(jni$_.JReference reference) =>
      Externalizable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Externalizable?> get nullableType =>
      const $Externalizable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Externalizable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Externalizable$Type) &&
        other is $Externalizable$Type;
  }
}

/// from: `java.io.ObjectInputValidation`
class ObjectInputValidation extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInputValidation> $type;

  @jni$_.internal
  ObjectInputValidation.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectInputValidation');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInputValidation$NullableType();
  static const type = $ObjectInputValidation$Type();
  static final _id_validateObject = _class.instanceMethodId(
    r'validateObject',
    r'()V',
  );

  static final _validateObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void validateObject()`
  void validateObject() {
    _validateObject(
      reference.pointer,
      _id_validateObject as jni$_.JMethodIDPtr,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ObjectInputValidation> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'validateObject()V') {
        _$impls[$p]!.validateObject();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ObjectInputValidation $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.ObjectInputValidation', $p, _$invokePointer, [
      if ($impl.validateObject$async) r'validateObject()V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ObjectInputValidation.implement($ObjectInputValidation $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ObjectInputValidation.fromReference($i.implementReference());
  }
}

abstract base mixin class $ObjectInputValidation {
  factory $ObjectInputValidation({
    required void Function() validateObject,
    bool validateObject$async,
  }) = _$ObjectInputValidation;

  void validateObject();
  bool get validateObject$async => false;
}

final class _$ObjectInputValidation with $ObjectInputValidation {
  _$ObjectInputValidation({
    required void Function() validateObject,
    this.validateObject$async = false,
  }) : _validateObject = validateObject;

  final void Function() _validateObject;
  final bool validateObject$async;

  void validateObject() {
    return _validateObject();
  }
}

final class $ObjectInputValidation$NullableType
    extends jni$_.JObjType<ObjectInputValidation?> {
  @jni$_.internal
  const $ObjectInputValidation$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputValidation;';

  @jni$_.internal
  @core$_.override
  ObjectInputValidation? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectInputValidation.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputValidation?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputValidation$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInputValidation$NullableType) &&
        other is $ObjectInputValidation$NullableType;
  }
}

final class $ObjectInputValidation$Type
    extends jni$_.JObjType<ObjectInputValidation> {
  @jni$_.internal
  const $ObjectInputValidation$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputValidation;';

  @jni$_.internal
  @core$_.override
  ObjectInputValidation fromReference(jni$_.JReference reference) =>
      ObjectInputValidation.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputValidation?> get nullableType =>
      const $ObjectInputValidation$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputValidation$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInputValidation$Type) &&
        other is $ObjectInputValidation$Type;
  }
}

/// from: `java.io.FilterOutputStream`
class FilterOutputStream extends OutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FilterOutputStream> $type;

  @jni$_.internal
  FilterOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FilterOutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FilterOutputStream$NullableType();
  static const type = $FilterOutputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FilterOutputStream(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return FilterOutputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(byte[] bs)`
  void write1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write1(
      reference.pointer,
      _id_write1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $FilterOutputStream$NullableType
    extends jni$_.JObjType<FilterOutputStream?> {
  @jni$_.internal
  const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterOutputStream;';

  @jni$_.internal
  @core$_.override
  FilterOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FilterOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterOutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FilterOutputStream$NullableType) &&
        other is $FilterOutputStream$NullableType;
  }
}

final class $FilterOutputStream$Type
    extends jni$_.JObjType<FilterOutputStream> {
  @jni$_.internal
  const $FilterOutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterOutputStream;';

  @jni$_.internal
  @core$_.override
  FilterOutputStream fromReference(jni$_.JReference reference) =>
      FilterOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterOutputStream?> get nullableType =>
      const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterOutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FilterOutputStream$Type) &&
        other is $FilterOutputStream$Type;
  }
}

/// from: `java.io.Reader`
class Reader extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Reader> $type;

  @jni$_.internal
  Reader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Reader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Reader$NullableType();
  static const type = $Reader$Type();
  static final _id_nullReader = _class.staticMethodId(
    r'nullReader',
    r'()Ljava/io/Reader;',
  );

  static final _nullReader =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.Reader nullReader()`
  /// The returned object must be released after use, by calling the [release] method.
  static Reader? nullReader() {
    return _nullReader(
      _class.reference.pointer,
      _id_nullReader as jni$_.JMethodIDPtr,
    ).object<Reader?>(const $Reader$NullableType());
  }

  static final _id_read = _class.instanceMethodId(
    r'read',
    r'(Ljava/nio/CharBuffer;)I',
  );

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(java.nio.CharBuffer charBuffer)`
  int read(jni$_.JObject? charBuffer) {
    final _$charBuffer = charBuffer?.reference ?? jni$_.jNullReference;
    return _read(
      reference.pointer,
      _id_read as jni$_.JMethodIDPtr,
      _$charBuffer.pointer,
    ).integer;
  }

  static final _id_read$1 = _class.instanceMethodId(r'read', r'()I');

  static final _read$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read$1() {
    return _read$1(reference.pointer, _id_read$1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read$2 = _class.instanceMethodId(r'read', r'([C)I');

  static final _read$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(char[] cs)`
  int read$2(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read$2(
      reference.pointer,
      _id_read$2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).integer;
  }

  static final _id_read$3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract int read(char[] cs, int i, int i1)`
  int read$3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read$3(
      reference.pointer,
      _id_read$3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() {
    return _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() {
    return _markSupported(
      reference.pointer,
      _id_markSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_transferTo = _class.instanceMethodId(
    r'transferTo',
    r'(Ljava/io/Writer;)J',
  );

  static final _transferTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long transferTo(java.io.Writer writer)`
  int transferTo(Writer? writer) {
    final _$writer = writer?.reference ?? jni$_.jNullReference;
    return _transferTo(
      reference.pointer,
      _id_transferTo as jni$_.JMethodIDPtr,
      _$writer.pointer,
    ).long;
  }
}

final class $Reader$NullableType extends jni$_.JObjType<Reader?> {
  @jni$_.internal
  const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Reader;';

  @jni$_.internal
  @core$_.override
  Reader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Reader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Reader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Reader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Reader$NullableType) &&
        other is $Reader$NullableType;
  }
}

final class $Reader$Type extends jni$_.JObjType<Reader> {
  @jni$_.internal
  const $Reader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Reader;';

  @jni$_.internal
  @core$_.override
  Reader fromReference(jni$_.JReference reference) =>
      Reader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Reader?> get nullableType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Reader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Reader$Type) && other is $Reader$Type;
  }
}

/// from: `java.io.PipedWriter`
class PipedWriter extends Writer {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PipedWriter> $type;

  @jni$_.internal
  PipedWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PipedWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PipedWriter$NullableType();
  static const type = $PipedWriter$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/PipedReader;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.PipedReader pipedReader)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedWriter(PipedReader? pipedReader) {
    final _$pipedReader = pipedReader?.reference ?? jni$_.jNullReference;
    return PipedWriter.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$pipedReader.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'()V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedWriter.new$1() {
    return PipedWriter.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }

  static final _id_connect = _class.instanceMethodId(
    r'connect',
    r'(Ljava/io/PipedReader;)V',
  );

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void connect(java.io.PipedReader pipedReader)`
  void connect(PipedReader? pipedReader) {
    final _$pipedReader = pipedReader?.reference ?? jni$_.jNullReference;
    _connect(
      reference.pointer,
      _id_connect as jni$_.JMethodIDPtr,
      _$pipedReader.pointer,
    ).check();
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(char[] cs, int i, int i1)`
  void write2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $PipedWriter$NullableType extends jni$_.JObjType<PipedWriter?> {
  @jni$_.internal
  const $PipedWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedWriter;';

  @jni$_.internal
  @core$_.override
  PipedWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PipedWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PipedWriter$NullableType) &&
        other is $PipedWriter$NullableType;
  }
}

final class $PipedWriter$Type extends jni$_.JObjType<PipedWriter> {
  @jni$_.internal
  const $PipedWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedWriter;';

  @jni$_.internal
  @core$_.override
  PipedWriter fromReference(jni$_.JReference reference) =>
      PipedWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedWriter?> get nullableType =>
      const $PipedWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PipedWriter$Type) &&
        other is $PipedWriter$Type;
  }
}

/// from: `java.io.Serializable`
class Serializable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Serializable> $type;

  @jni$_.internal
  Serializable.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Serializable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Serializable$NullableType();
  static const type = $Serializable$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Serializable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $Serializable $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.Serializable', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Serializable.implement($Serializable $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Serializable.fromReference($i.implementReference());
  }
}

abstract base mixin class $Serializable {
  factory $Serializable() = _$Serializable;
}

final class _$Serializable with $Serializable {
  _$Serializable();
}

final class $Serializable$NullableType extends jni$_.JObjType<Serializable?> {
  @jni$_.internal
  const $Serializable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Serializable;';

  @jni$_.internal
  @core$_.override
  Serializable? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Serializable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Serializable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Serializable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Serializable$NullableType) &&
        other is $Serializable$NullableType;
  }
}

final class $Serializable$Type extends jni$_.JObjType<Serializable> {
  @jni$_.internal
  const $Serializable$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Serializable;';

  @jni$_.internal
  @core$_.override
  Serializable fromReference(jni$_.JReference reference) =>
      Serializable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Serializable?> get nullableType =>
      const $Serializable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Serializable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Serializable$Type) &&
        other is $Serializable$Type;
  }
}

/// from: `java.io.UncheckedIOException`
class UncheckedIOException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<UncheckedIOException> $type;

  @jni$_.internal
  UncheckedIOException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/UncheckedIOException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $UncheckedIOException$NullableType();
  static const type = $UncheckedIOException$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/io/IOException;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.io.IOException iOException)`
  /// The returned object must be released after use, by calling the [release] method.
  factory UncheckedIOException(
    jni$_.JString? string,
    IOException? iOException,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$iOException = iOException?.reference ?? jni$_.jNullReference;
    return UncheckedIOException.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$iOException.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/IOException;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.IOException iOException)`
  /// The returned object must be released after use, by calling the [release] method.
  factory UncheckedIOException.new$1(IOException? iOException) {
    final _$iOException = iOException?.reference ?? jni$_.jNullReference;
    return UncheckedIOException.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$iOException.pointer,
      ).reference,
    );
  }

  static final _id_getCause = _class.instanceMethodId(
    r'getCause',
    r'()Ljava/io/IOException;',
  );

  static final _getCause =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.IOException getCause()`
  /// The returned object must be released after use, by calling the [release] method.
  IOException? getCause() {
    return _getCause(
      reference.pointer,
      _id_getCause as jni$_.JMethodIDPtr,
    ).object<IOException?>(const $IOException$NullableType());
  }
}

final class $UncheckedIOException$NullableType
    extends jni$_.JObjType<UncheckedIOException?> {
  @jni$_.internal
  const $UncheckedIOException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/UncheckedIOException;';

  @jni$_.internal
  @core$_.override
  UncheckedIOException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : UncheckedIOException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UncheckedIOException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UncheckedIOException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UncheckedIOException$NullableType) &&
        other is $UncheckedIOException$NullableType;
  }
}

final class $UncheckedIOException$Type
    extends jni$_.JObjType<UncheckedIOException> {
  @jni$_.internal
  const $UncheckedIOException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/UncheckedIOException;';

  @jni$_.internal
  @core$_.override
  UncheckedIOException fromReference(jni$_.JReference reference) =>
      UncheckedIOException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UncheckedIOException?> get nullableType =>
      const $UncheckedIOException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UncheckedIOException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UncheckedIOException$Type) &&
        other is $UncheckedIOException$Type;
  }
}

/// from: `java.io.SyncFailedException`
class SyncFailedException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SyncFailedException> $type;

  @jni$_.internal
  SyncFailedException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/SyncFailedException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SyncFailedException$NullableType();
  static const type = $SyncFailedException$Type();
  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SyncFailedException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return SyncFailedException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $SyncFailedException$NullableType
    extends jni$_.JObjType<SyncFailedException?> {
  @jni$_.internal
  const $SyncFailedException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/SyncFailedException;';

  @jni$_.internal
  @core$_.override
  SyncFailedException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SyncFailedException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SyncFailedException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SyncFailedException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SyncFailedException$NullableType) &&
        other is $SyncFailedException$NullableType;
  }
}

final class $SyncFailedException$Type
    extends jni$_.JObjType<SyncFailedException> {
  @jni$_.internal
  const $SyncFailedException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/SyncFailedException;';

  @jni$_.internal
  @core$_.override
  SyncFailedException fromReference(jni$_.JReference reference) =>
      SyncFailedException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SyncFailedException?> get nullableType =>
      const $SyncFailedException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SyncFailedException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SyncFailedException$Type) &&
        other is $SyncFailedException$Type;
  }
}

/// from: `java.io.ObjectInputStream$GetField`
class ObjectInputStream$GetField extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInputStream$GetField> $type;

  @jni$_.internal
  ObjectInputStream$GetField.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/ObjectInputStream$GetField',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInputStream$GetField$NullableType();
  static const type = $ObjectInputStream$GetField$Type();
  static final _id_getObjectStreamClass = _class.instanceMethodId(
    r'getObjectStreamClass',
    r'()Ljava/io/ObjectStreamClass;',
  );

  static final _getObjectStreamClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.io.ObjectStreamClass getObjectStreamClass()`
  /// The returned object must be released after use, by calling the [release] method.
  ObjectStreamClass? getObjectStreamClass() {
    return _getObjectStreamClass(
      reference.pointer,
      _id_getObjectStreamClass as jni$_.JMethodIDPtr,
    ).object<ObjectStreamClass?>(const $ObjectStreamClass$NullableType());
  }

  static final _id_defaulted = _class.instanceMethodId(
    r'defaulted',
    r'(Ljava/lang/String;)Z',
  );

  static final _defaulted =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean defaulted(java.lang.String string)`
  bool defaulted(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _defaulted(
      reference.pointer,
      _id_defaulted as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).boolean;
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;Z)Z',
  );

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract boolean get(java.lang.String string, boolean z)`
  bool get(jni$_.JString? string, bool z) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get(
      reference.pointer,
      _id_get as jni$_.JMethodIDPtr,
      _$string.pointer,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_get$1 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;B)B',
  );

  static final _get$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract byte get(java.lang.String string, byte b)`
  int get$1(jni$_.JString? string, int b) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get$1(
      reference.pointer,
      _id_get$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      b,
    ).byte;
  }

  static final _id_get$2 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;C)C',
  );

  static final _get$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract char get(java.lang.String string, char c)`
  int get$2(jni$_.JString? string, int c) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get$2(
      reference.pointer,
      _id_get$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      c,
    ).char;
  }

  static final _id_get$3 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;S)S',
  );

  static final _get$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract short get(java.lang.String string, short s)`
  int get$3(jni$_.JString? string, int s) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get$3(
      reference.pointer,
      _id_get$3 as jni$_.JMethodIDPtr,
      _$string.pointer,
      s,
    ).short;
  }

  static final _id_get$4 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;I)I',
  );

  static final _get$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract int get(java.lang.String string, int i)`
  int get$4(jni$_.JString? string, int i) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get$4(
      reference.pointer,
      _id_get$4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
    ).integer;
  }

  static final _id_get$5 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;J)J',
  );

  static final _get$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public abstract long get(java.lang.String string, long j)`
  int get$5(jni$_.JString? string, int j) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get$5(
      reference.pointer,
      _id_get$5 as jni$_.JMethodIDPtr,
      _$string.pointer,
      j,
    ).long;
  }

  static final _id_get$6 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;F)F',
  );

  static final _get$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Double)>,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              double,
            )
          >();

  /// from: `public abstract float get(java.lang.String string, float f)`
  double get$6(jni$_.JString? string, double f) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get$6(
      reference.pointer,
      _id_get$6 as jni$_.JMethodIDPtr,
      _$string.pointer,
      f,
    ).float;
  }

  static final _id_get$7 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;D)D',
  );

  static final _get$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Double)>,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              double,
            )
          >();

  /// from: `public abstract double get(java.lang.String string, double d)`
  double get$7(jni$_.JString? string, double d) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _get$7(
      reference.pointer,
      _id_get$7 as jni$_.JMethodIDPtr,
      _$string.pointer,
      d,
    ).doubleFloat;
  }

  static final _id_get$8 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;',
  );

  static final _get$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.lang.Object get(java.lang.String string, java.lang.Object object)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get$8(jni$_.JString? string, jni$_.JObject? object) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _get$8(
      reference.pointer,
      _id_get$8 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$object.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $ObjectInputStream$GetField$NullableType
    extends jni$_.JObjType<ObjectInputStream$GetField?> {
  @jni$_.internal
  const $ObjectInputStream$GetField$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputStream$GetField;';

  @jni$_.internal
  @core$_.override
  ObjectInputStream$GetField? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ObjectInputStream$GetField.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputStream$GetField?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputStream$GetField$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInputStream$GetField$NullableType) &&
        other is $ObjectInputStream$GetField$NullableType;
  }
}

final class $ObjectInputStream$GetField$Type
    extends jni$_.JObjType<ObjectInputStream$GetField> {
  @jni$_.internal
  const $ObjectInputStream$GetField$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputStream$GetField;';

  @jni$_.internal
  @core$_.override
  ObjectInputStream$GetField fromReference(jni$_.JReference reference) =>
      ObjectInputStream$GetField.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputStream$GetField?> get nullableType =>
      const $ObjectInputStream$GetField$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputStream$GetField$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInputStream$GetField$Type) &&
        other is $ObjectInputStream$GetField$Type;
  }
}

/// from: `java.io.WriteAbortedException`
class WriteAbortedException extends ObjectStreamException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<WriteAbortedException> $type;

  @jni$_.internal
  WriteAbortedException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/WriteAbortedException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $WriteAbortedException$NullableType();
  static const type = $WriteAbortedException$Type();
  static final _id_detail = _class.instanceFieldId(
    r'detail',
    r'Ljava/lang/Exception;',
  );

  /// from: `public java.lang.Exception detail`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? get detail =>
      _id_detail.get(this, const jni$_.JObjectNullableType());

  /// from: `public java.lang.Exception detail`
  /// The returned object must be released after use, by calling the [release] method.
  set detail(jni$_.JObject? value) =>
      _id_detail.set(this, const jni$_.JObjectNullableType(), value);

  static final _id_new$4 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/Exception;)V',
  );

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.Exception exception)`
  /// The returned object must be released after use, by calling the [release] method.
  factory WriteAbortedException.new$4(
    jni$_.JString? string,
    jni$_.JObject? exception,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$exception = exception?.reference ?? jni$_.jNullReference;
    return WriteAbortedException.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$exception.pointer,
      ).reference,
    );
  }

  static final _id_getMessage = _class.instanceMethodId(
    r'getMessage',
    r'()Ljava/lang/String;',
  );

  static final _getMessage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getMessage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getMessage() {
    return _getMessage(
      reference.pointer,
      _id_getMessage as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getCause = _class.instanceMethodId(
    r'getCause',
    r'()Ljava/lang/Throwable;',
  );

  static final _getCause =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Throwable getCause()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getCause() {
    return _getCause(
      reference.pointer,
      _id_getCause as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $WriteAbortedException$NullableType
    extends jni$_.JObjType<WriteAbortedException?> {
  @jni$_.internal
  const $WriteAbortedException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/WriteAbortedException;';

  @jni$_.internal
  @core$_.override
  WriteAbortedException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : WriteAbortedException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<WriteAbortedException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($WriteAbortedException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WriteAbortedException$NullableType) &&
        other is $WriteAbortedException$NullableType;
  }
}

final class $WriteAbortedException$Type
    extends jni$_.JObjType<WriteAbortedException> {
  @jni$_.internal
  const $WriteAbortedException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/WriteAbortedException;';

  @jni$_.internal
  @core$_.override
  WriteAbortedException fromReference(jni$_.JReference reference) =>
      WriteAbortedException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<WriteAbortedException?> get nullableType =>
      const $WriteAbortedException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($WriteAbortedException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($WriteAbortedException$Type) &&
        other is $WriteAbortedException$Type;
  }
}

/// from: `java.io.FilenameFilter`
class FilenameFilter extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FilenameFilter> $type;

  @jni$_.internal
  FilenameFilter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FilenameFilter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FilenameFilter$NullableType();
  static const type = $FilenameFilter$Type();
  static final _id_accept = _class.instanceMethodId(
    r'accept',
    r'(Ljava/io/File;Ljava/lang/String;)Z',
  );

  static final _accept =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean accept(java.io.File file, java.lang.String string)`
  bool accept(File? file, jni$_.JString? string) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _accept(
      reference.pointer,
      _id_accept as jni$_.JMethodIDPtr,
      _$file.pointer,
      _$string.pointer,
    ).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $FilenameFilter> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'accept(Ljava/io/File;Ljava/lang/String;)Z') {
        final $r = _$impls[$p]!.accept(
          $a![0]?.as(const $File$Type(), releaseOriginal: true),
          $a![1]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $FilenameFilter $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.FilenameFilter', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory FilenameFilter.implement($FilenameFilter $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return FilenameFilter.fromReference($i.implementReference());
  }
}

abstract base mixin class $FilenameFilter {
  factory $FilenameFilter({
    required bool Function(File? file, jni$_.JString? string) accept,
  }) = _$FilenameFilter;

  bool accept(File? file, jni$_.JString? string);
}

final class _$FilenameFilter with $FilenameFilter {
  _$FilenameFilter({
    required bool Function(File? file, jni$_.JString? string) accept,
  }) : _accept = accept;

  final bool Function(File? file, jni$_.JString? string) _accept;

  bool accept(File? file, jni$_.JString? string) {
    return _accept(file, string);
  }
}

final class $FilenameFilter$NullableType
    extends jni$_.JObjType<FilenameFilter?> {
  @jni$_.internal
  const $FilenameFilter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilenameFilter;';

  @jni$_.internal
  @core$_.override
  FilenameFilter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FilenameFilter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilenameFilter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FilenameFilter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FilenameFilter$NullableType) &&
        other is $FilenameFilter$NullableType;
  }
}

final class $FilenameFilter$Type extends jni$_.JObjType<FilenameFilter> {
  @jni$_.internal
  const $FilenameFilter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilenameFilter;';

  @jni$_.internal
  @core$_.override
  FilenameFilter fromReference(jni$_.JReference reference) =>
      FilenameFilter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilenameFilter?> get nullableType =>
      const $FilenameFilter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FilenameFilter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FilenameFilter$Type) &&
        other is $FilenameFilter$Type;
  }
}

/// from: `java.io.ObjectInputFilter$FilterInfo`
class ObjectInputFilter$FilterInfo extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInputFilter$FilterInfo> $type;

  @jni$_.internal
  ObjectInputFilter$FilterInfo.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/ObjectInputFilter$FilterInfo',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInputFilter$FilterInfo$NullableType();
  static const type = $ObjectInputFilter$FilterInfo$Type();
  static final _id_serialClass = _class.instanceMethodId(
    r'serialClass',
    r'()Ljava/lang/Class;',
  );

  static final _serialClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.Class<?> serialClass()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? serialClass() {
    return _serialClass(
      reference.pointer,
      _id_serialClass as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_arrayLength = _class.instanceMethodId(
    r'arrayLength',
    r'()J',
  );

  static final _arrayLength =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract long arrayLength()`
  int arrayLength() {
    return _arrayLength(
      reference.pointer,
      _id_arrayLength as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_depth = _class.instanceMethodId(r'depth', r'()J');

  static final _depth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract long depth()`
  int depth() {
    return _depth(reference.pointer, _id_depth as jni$_.JMethodIDPtr).long;
  }

  static final _id_references = _class.instanceMethodId(r'references', r'()J');

  static final _references =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract long references()`
  int references() {
    return _references(
      reference.pointer,
      _id_references as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_streamBytes = _class.instanceMethodId(
    r'streamBytes',
    r'()J',
  );

  static final _streamBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract long streamBytes()`
  int streamBytes() {
    return _streamBytes(
      reference.pointer,
      _id_streamBytes as jni$_.JMethodIDPtr,
    ).long;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ObjectInputFilter$FilterInfo> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'serialClass()Ljava/lang/Class;') {
        final $r = _$impls[$p]!.serialClass();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'arrayLength()J') {
        final $r = _$impls[$p]!.arrayLength();
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'depth()J') {
        final $r = _$impls[$p]!.depth();
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'references()J') {
        final $r = _$impls[$p]!.references();
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'streamBytes()J') {
        final $r = _$impls[$p]!.streamBytes();
        return jni$_.JLong($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ObjectInputFilter$FilterInfo $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'java.io.ObjectInputFilter$FilterInfo',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ObjectInputFilter$FilterInfo.implement(
    $ObjectInputFilter$FilterInfo $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ObjectInputFilter$FilterInfo.fromReference($i.implementReference());
  }
}

abstract base mixin class $ObjectInputFilter$FilterInfo {
  factory $ObjectInputFilter$FilterInfo({
    required jni$_.JObject? Function() serialClass,
    required int Function() arrayLength,
    required int Function() depth,
    required int Function() references,
    required int Function() streamBytes,
  }) = _$ObjectInputFilter$FilterInfo;

  jni$_.JObject? serialClass();
  int arrayLength();
  int depth();
  int references();
  int streamBytes();
}

final class _$ObjectInputFilter$FilterInfo with $ObjectInputFilter$FilterInfo {
  _$ObjectInputFilter$FilterInfo({
    required jni$_.JObject? Function() serialClass,
    required int Function() arrayLength,
    required int Function() depth,
    required int Function() references,
    required int Function() streamBytes,
  }) : _serialClass = serialClass,
       _arrayLength = arrayLength,
       _depth = depth,
       _references = references,
       _streamBytes = streamBytes;

  final jni$_.JObject? Function() _serialClass;
  final int Function() _arrayLength;
  final int Function() _depth;
  final int Function() _references;
  final int Function() _streamBytes;

  jni$_.JObject? serialClass() {
    return _serialClass();
  }

  int arrayLength() {
    return _arrayLength();
  }

  int depth() {
    return _depth();
  }

  int references() {
    return _references();
  }

  int streamBytes() {
    return _streamBytes();
  }
}

final class $ObjectInputFilter$FilterInfo$NullableType
    extends jni$_.JObjType<ObjectInputFilter$FilterInfo?> {
  @jni$_.internal
  const $ObjectInputFilter$FilterInfo$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter$FilterInfo;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter$FilterInfo? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ObjectInputFilter$FilterInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter$FilterInfo?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$FilterInfo$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInputFilter$FilterInfo$NullableType) &&
        other is $ObjectInputFilter$FilterInfo$NullableType;
  }
}

final class $ObjectInputFilter$FilterInfo$Type
    extends jni$_.JObjType<ObjectInputFilter$FilterInfo> {
  @jni$_.internal
  const $ObjectInputFilter$FilterInfo$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter$FilterInfo;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter$FilterInfo fromReference(jni$_.JReference reference) =>
      ObjectInputFilter$FilterInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter$FilterInfo?> get nullableType =>
      const $ObjectInputFilter$FilterInfo$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$FilterInfo$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInputFilter$FilterInfo$Type) &&
        other is $ObjectInputFilter$FilterInfo$Type;
  }
}

/// from: `java.io.PipedReader`
class PipedReader extends Reader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PipedReader> $type;

  @jni$_.internal
  PipedReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PipedReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PipedReader$NullableType();
  static const type = $PipedReader$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/PipedWriter;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.PipedWriter pipedWriter)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedReader(PipedWriter? pipedWriter) {
    final _$pipedWriter = pipedWriter?.reference ?? jni$_.jNullReference;
    return PipedReader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$pipedWriter.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/PipedWriter;I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.PipedWriter pipedWriter, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedReader.new$1(PipedWriter? pipedWriter, int i) {
    final _$pipedWriter = pipedWriter?.reference ?? jni$_.jNullReference;
    return PipedReader.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$pipedWriter.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'()V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedReader.new$2() {
    return PipedReader.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(I)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedReader.new$3(int i) {
    return PipedReader.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        i,
      ).reference,
    );
  }

  static final _id_connect = _class.instanceMethodId(
    r'connect',
    r'(Ljava/io/PipedWriter;)V',
  );

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void connect(java.io.PipedWriter pipedWriter)`
  void connect(PipedWriter? pipedWriter) {
    final _$pipedWriter = pipedWriter?.reference ?? jni$_.jNullReference;
    _connect(
      reference.pointer,
      _id_connect as jni$_.JMethodIDPtr,
      _$pipedWriter.pointer,
    ).check();
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() {
    return _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() {
    return _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $PipedReader$NullableType extends jni$_.JObjType<PipedReader?> {
  @jni$_.internal
  const $PipedReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedReader;';

  @jni$_.internal
  @core$_.override
  PipedReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PipedReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PipedReader$NullableType) &&
        other is $PipedReader$NullableType;
  }
}

final class $PipedReader$Type extends jni$_.JObjType<PipedReader> {
  @jni$_.internal
  const $PipedReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedReader;';

  @jni$_.internal
  @core$_.override
  PipedReader fromReference(jni$_.JReference reference) =>
      PipedReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedReader?> get nullableType =>
      const $PipedReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PipedReader$Type) &&
        other is $PipedReader$Type;
  }
}

/// from: `java.io.ByteArrayOutputStream`
class ByteArrayOutputStream extends OutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ByteArrayOutputStream> $type;

  @jni$_.internal
  ByteArrayOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ByteArrayOutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ByteArrayOutputStream$NullableType();
  static const type = $ByteArrayOutputStream$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ByteArrayOutputStream() {
    return ByteArrayOutputStream.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ByteArrayOutputStream.new$1(int i) {
    return ByteArrayOutputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        i,
      ).reference,
    );
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'([B)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeBytes(byte[] bs)`
  void writeBytes(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_writeTo = _class.instanceMethodId(
    r'writeTo',
    r'(Ljava/io/OutputStream;)V',
  );

  static final _writeTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeTo(java.io.OutputStream outputStream)`
  void writeTo(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    _writeTo(
      reference.pointer,
      _id_writeTo as jni$_.JMethodIDPtr,
      _$outputStream.pointer,
    ).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_toByteArray = _class.instanceMethodId(
    r'toByteArray',
    r'()[B',
  );

  static final _toByteArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] toByteArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? toByteArray() {
    return _toByteArray(
      reference.pointer,
      _id_toByteArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_size = _class.instanceMethodId(r'size', r'()I');

  static final _size =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int size()`
  int size() {
    return _size(reference.pointer, _id_size as jni$_.JMethodIDPtr).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toString$2 = _class.instanceMethodId(
    r'toString',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _toString$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String toString(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$2(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _toString$2(
      reference.pointer,
      _id_toString$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toString$3 = _class.instanceMethodId(
    r'toString',
    r'(Ljava/nio/charset/Charset;)Ljava/lang/String;',
  );

  static final _toString$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String toString(java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$3(jni$_.JObject? charset) {
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return _toString$3(
      reference.pointer,
      _id_toString$3 as jni$_.JMethodIDPtr,
      _$charset.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toString$4 = _class.instanceMethodId(
    r'toString',
    r'(I)Ljava/lang/String;',
  );

  static final _toString$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.lang.String toString(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$4(int i) {
    return _toString$4(
      reference.pointer,
      _id_toString$4 as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $ByteArrayOutputStream$NullableType
    extends jni$_.JObjType<ByteArrayOutputStream?> {
  @jni$_.internal
  const $ByteArrayOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ByteArrayOutputStream;';

  @jni$_.internal
  @core$_.override
  ByteArrayOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ByteArrayOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ByteArrayOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ByteArrayOutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ByteArrayOutputStream$NullableType) &&
        other is $ByteArrayOutputStream$NullableType;
  }
}

final class $ByteArrayOutputStream$Type
    extends jni$_.JObjType<ByteArrayOutputStream> {
  @jni$_.internal
  const $ByteArrayOutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ByteArrayOutputStream;';

  @jni$_.internal
  @core$_.override
  ByteArrayOutputStream fromReference(jni$_.JReference reference) =>
      ByteArrayOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ByteArrayOutputStream?> get nullableType =>
      const $ByteArrayOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ByteArrayOutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ByteArrayOutputStream$Type) &&
        other is $ByteArrayOutputStream$Type;
  }
}

/// from: `java.io.InterruptedIOException`
class InterruptedIOException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InterruptedIOException> $type;

  @jni$_.internal
  InterruptedIOException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/InterruptedIOException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InterruptedIOException$NullableType();
  static const type = $InterruptedIOException$Type();
  static final _id_bytesTransferred = _class.instanceFieldId(
    r'bytesTransferred',
    r'I',
  );

  /// from: `public int bytesTransferred`
  int get bytesTransferred =>
      _id_bytesTransferred.get(this, const jni$_.jintType());

  /// from: `public int bytesTransferred`
  set bytesTransferred(int value) =>
      _id_bytesTransferred.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory InterruptedIOException() {
    return InterruptedIOException.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InterruptedIOException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return InterruptedIOException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $InterruptedIOException$NullableType
    extends jni$_.JObjType<InterruptedIOException?> {
  @jni$_.internal
  const $InterruptedIOException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InterruptedIOException;';

  @jni$_.internal
  @core$_.override
  InterruptedIOException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InterruptedIOException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InterruptedIOException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($InterruptedIOException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InterruptedIOException$NullableType) &&
        other is $InterruptedIOException$NullableType;
  }
}

final class $InterruptedIOException$Type
    extends jni$_.JObjType<InterruptedIOException> {
  @jni$_.internal
  const $InterruptedIOException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InterruptedIOException;';

  @jni$_.internal
  @core$_.override
  InterruptedIOException fromReference(jni$_.JReference reference) =>
      InterruptedIOException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InterruptedIOException?> get nullableType =>
      const $InterruptedIOException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($InterruptedIOException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InterruptedIOException$Type) &&
        other is $InterruptedIOException$Type;
  }
}

/// from: `java.io.BufferedOutputStream`
class BufferedOutputStream extends FilterOutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<BufferedOutputStream> $type;

  @jni$_.internal
  BufferedOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/BufferedOutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $BufferedOutputStream$NullableType();
  static const type = $BufferedOutputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedOutputStream(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return BufferedOutputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/OutputStream;I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedOutputStream.new$1(OutputStream? outputStream, int i) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return BufferedOutputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        i,
      ).reference,
    );
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }
}

final class $BufferedOutputStream$NullableType
    extends jni$_.JObjType<BufferedOutputStream?> {
  @jni$_.internal
  const $BufferedOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedOutputStream;';

  @jni$_.internal
  @core$_.override
  BufferedOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : BufferedOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($BufferedOutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BufferedOutputStream$NullableType) &&
        other is $BufferedOutputStream$NullableType;
  }
}

final class $BufferedOutputStream$Type
    extends jni$_.JObjType<BufferedOutputStream> {
  @jni$_.internal
  const $BufferedOutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedOutputStream;';

  @jni$_.internal
  @core$_.override
  BufferedOutputStream fromReference(jni$_.JReference reference) =>
      BufferedOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedOutputStream?> get nullableType =>
      const $BufferedOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($BufferedOutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BufferedOutputStream$Type) &&
        other is $BufferedOutputStream$Type;
  }
}

/// from: `java.io.Console`
class Console extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Console> $type;

  @jni$_.internal
  Console.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Console');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Console$NullableType();
  static const type = $Console$Type();
  static final _id_writer = _class.instanceMethodId(
    r'writer',
    r'()Ljava/io/PrintWriter;',
  );

  static final _writer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.PrintWriter writer()`
  /// The returned object must be released after use, by calling the [release] method.
  PrintWriter? writer() {
    return _writer(
      reference.pointer,
      _id_writer as jni$_.JMethodIDPtr,
    ).object<PrintWriter?>(const $PrintWriter$NullableType());
  }

  static final _id_reader = _class.instanceMethodId(
    r'reader',
    r'()Ljava/io/Reader;',
  );

  static final _reader =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.Reader reader()`
  /// The returned object must be released after use, by calling the [release] method.
  Reader? reader() {
    return _reader(
      reference.pointer,
      _id_reader as jni$_.JMethodIDPtr,
    ).object<Reader?>(const $Reader$NullableType());
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/Console;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.Console format(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  Console? format(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<Console?>(const $Console$NullableType());
  }

  static final _id_printf = _class.instanceMethodId(
    r'printf',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/Console;',
  );

  static final _printf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.Console printf(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  Console? printf(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _printf(
      reference.pointer,
      _id_printf as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<Console?>(const $Console$NullableType());
  }

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String readLine(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _readLine(
      reference.pointer,
      _id_readLine as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_readLine$1 = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine$1() {
    return _readLine$1(
      reference.pointer,
      _id_readLine$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_readPassword = _class.instanceMethodId(
    r'readPassword',
    r'(Ljava/lang/String;[Ljava/lang/Object;)[C',
  );

  static final _readPassword =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public char[] readPassword(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JCharArray? readPassword(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _readPassword(
      reference.pointer,
      _id_readPassword as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<jni$_.JCharArray?>(const jni$_.JCharArrayNullableType());
  }

  static final _id_readPassword$1 = _class.instanceMethodId(
    r'readPassword',
    r'()[C',
  );

  static final _readPassword$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char[] readPassword()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JCharArray? readPassword$1() {
    return _readPassword$1(
      reference.pointer,
      _id_readPassword$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JCharArray?>(const jni$_.JCharArrayNullableType());
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_charset = _class.instanceMethodId(
    r'charset',
    r'()Ljava/nio/charset/Charset;',
  );

  static final _charset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.charset.Charset charset()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? charset() {
    return _charset(
      reference.pointer,
      _id_charset as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $Console$NullableType extends jni$_.JObjType<Console?> {
  @jni$_.internal
  const $Console$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Console;';

  @jni$_.internal
  @core$_.override
  Console? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Console.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Console?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Console$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Console$NullableType) &&
        other is $Console$NullableType;
  }
}

final class $Console$Type extends jni$_.JObjType<Console> {
  @jni$_.internal
  const $Console$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Console;';

  @jni$_.internal
  @core$_.override
  Console fromReference(jni$_.JReference reference) =>
      Console.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Console?> get nullableType => const $Console$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Console$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Console$Type) && other is $Console$Type;
  }
}

/// from: `java.io.ObjectOutputStream`
class ObjectOutputStream extends OutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectOutputStream> $type;

  @jni$_.internal
  ObjectOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectOutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectOutputStream$NullableType();
  static const type = $ObjectOutputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ObjectOutputStream(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return ObjectOutputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_useProtocolVersion = _class.instanceMethodId(
    r'useProtocolVersion',
    r'(I)V',
  );

  static final _useProtocolVersion =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void useProtocolVersion(int i)`
  void useProtocolVersion(int i) {
    _useProtocolVersion(
      reference.pointer,
      _id_useProtocolVersion as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeObject = _class.instanceMethodId(
    r'writeObject',
    r'(Ljava/lang/Object;)V',
  );

  static final _writeObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void writeObject(java.lang.Object object)`
  void writeObject(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _writeObject(
      reference.pointer,
      _id_writeObject as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_writeUnshared = _class.instanceMethodId(
    r'writeUnshared',
    r'(Ljava/lang/Object;)V',
  );

  static final _writeUnshared =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeUnshared(java.lang.Object object)`
  void writeUnshared(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _writeUnshared(
      reference.pointer,
      _id_writeUnshared as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_defaultWriteObject = _class.instanceMethodId(
    r'defaultWriteObject',
    r'()V',
  );

  static final _defaultWriteObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void defaultWriteObject()`
  void defaultWriteObject() {
    _defaultWriteObject(
      reference.pointer,
      _id_defaultWriteObject as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_putFields = _class.instanceMethodId(
    r'putFields',
    r'()Ljava/io/ObjectOutputStream$PutField;',
  );

  static final _putFields =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.ObjectOutputStream$PutField putFields()`
  /// The returned object must be released after use, by calling the [release] method.
  ObjectOutputStream$PutField? putFields() {
    return _putFields(
      reference.pointer,
      _id_putFields as jni$_.JMethodIDPtr,
    ).object<ObjectOutputStream$PutField?>(
      const $ObjectOutputStream$PutField$NullableType(),
    );
  }

  static final _id_writeFields = _class.instanceMethodId(
    r'writeFields',
    r'()V',
  );

  static final _writeFields =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void writeFields()`
  void writeFields() {
    _writeFields(
      reference.pointer,
      _id_writeFields as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(byte[] bs)`
  void write1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write1(
      reference.pointer,
      _id_write1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_writeBoolean = _class.instanceMethodId(
    r'writeBoolean',
    r'(Z)V',
  );

  static final _writeBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void writeBoolean(boolean z)`
  void writeBoolean(bool z) {
    _writeBoolean(
      reference.pointer,
      _id_writeBoolean as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_writeByte = _class.instanceMethodId(r'writeByte', r'(I)V');

  static final _writeByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void writeByte(int i)`
  void writeByte(int i) {
    _writeByte(
      reference.pointer,
      _id_writeByte as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeShort = _class.instanceMethodId(r'writeShort', r'(I)V');

  static final _writeShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void writeShort(int i)`
  void writeShort(int i) {
    _writeShort(
      reference.pointer,
      _id_writeShort as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeChar = _class.instanceMethodId(r'writeChar', r'(I)V');

  static final _writeChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void writeChar(int i)`
  void writeChar(int i) {
    _writeChar(
      reference.pointer,
      _id_writeChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeInt = _class.instanceMethodId(r'writeInt', r'(I)V');

  static final _writeInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void writeInt(int i)`
  void writeInt(int i) {
    _writeInt(reference.pointer, _id_writeInt as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_writeLong = _class.instanceMethodId(r'writeLong', r'(J)V');

  static final _writeLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void writeLong(long j)`
  void writeLong(int j) {
    _writeLong(
      reference.pointer,
      _id_writeLong as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_writeFloat = _class.instanceMethodId(r'writeFloat', r'(F)V');

  static final _writeFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void writeFloat(float f)`
  void writeFloat(double f) {
    _writeFloat(
      reference.pointer,
      _id_writeFloat as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_writeDouble = _class.instanceMethodId(
    r'writeDouble',
    r'(D)V',
  );

  static final _writeDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void writeDouble(double d)`
  void writeDouble(double d) {
    _writeDouble(
      reference.pointer,
      _id_writeDouble as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'(Ljava/lang/String;)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeBytes(java.lang.String string)`
  void writeBytes(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeChars = _class.instanceMethodId(
    r'writeChars',
    r'(Ljava/lang/String;)V',
  );

  static final _writeChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeChars(java.lang.String string)`
  void writeChars(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeChars(
      reference.pointer,
      _id_writeChars as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeUTF = _class.instanceMethodId(
    r'writeUTF',
    r'(Ljava/lang/String;)V',
  );

  static final _writeUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeUTF(java.lang.String string)`
  void writeUTF(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeUTF(
      reference.pointer,
      _id_writeUTF as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }
}

final class $ObjectOutputStream$NullableType
    extends jni$_.JObjType<ObjectOutputStream?> {
  @jni$_.internal
  const $ObjectOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectOutputStream;';

  @jni$_.internal
  @core$_.override
  ObjectOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ObjectOutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectOutputStream$NullableType) &&
        other is $ObjectOutputStream$NullableType;
  }
}

final class $ObjectOutputStream$Type
    extends jni$_.JObjType<ObjectOutputStream> {
  @jni$_.internal
  const $ObjectOutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectOutputStream;';

  @jni$_.internal
  @core$_.override
  ObjectOutputStream fromReference(jni$_.JReference reference) =>
      ObjectOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectOutputStream?> get nullableType =>
      const $ObjectOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ObjectOutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectOutputStream$Type) &&
        other is $ObjectOutputStream$Type;
  }
}

/// from: `java.io.Flushable`
class Flushable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Flushable> $type;

  @jni$_.internal
  Flushable.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Flushable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Flushable$NullableType();
  static const type = $Flushable$Type();
  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Flushable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'flush()V') {
        _$impls[$p]!.flush();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $Flushable $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.Flushable', $p, _$invokePointer, [
      if ($impl.flush$async) r'flush()V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Flushable.implement($Flushable $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Flushable.fromReference($i.implementReference());
  }
}

abstract base mixin class $Flushable {
  factory $Flushable({required void Function() flush, bool flush$async}) =
      _$Flushable;

  void flush();
  bool get flush$async => false;
}

final class _$Flushable with $Flushable {
  _$Flushable({required void Function() flush, this.flush$async = false})
    : _flush = flush;

  final void Function() _flush;
  final bool flush$async;

  void flush() {
    return _flush();
  }
}

final class $Flushable$NullableType extends jni$_.JObjType<Flushable?> {
  @jni$_.internal
  const $Flushable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Flushable;';

  @jni$_.internal
  @core$_.override
  Flushable? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Flushable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Flushable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Flushable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Flushable$NullableType) &&
        other is $Flushable$NullableType;
  }
}

final class $Flushable$Type extends jni$_.JObjType<Flushable> {
  @jni$_.internal
  const $Flushable$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Flushable;';

  @jni$_.internal
  @core$_.override
  Flushable fromReference(jni$_.JReference reference) =>
      Flushable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Flushable?> get nullableType =>
      const $Flushable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Flushable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Flushable$Type) && other is $Flushable$Type;
  }
}

/// from: `java.io.DataOutput`
class DataOutput extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DataOutput> $type;

  @jni$_.internal
  DataOutput.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/DataOutput');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DataOutput$NullableType();
  static const type = $DataOutput$Type();
  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write$1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void write(byte[] bs)`
  void write$1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$1(
      reference.pointer,
      _id_write$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_write$2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract void write(byte[] bs, int i, int i1)`
  void write$2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$2(
      reference.pointer,
      _id_write$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_writeBoolean = _class.instanceMethodId(
    r'writeBoolean',
    r'(Z)V',
  );

  static final _writeBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeBoolean(boolean z)`
  void writeBoolean(bool z) {
    _writeBoolean(
      reference.pointer,
      _id_writeBoolean as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_writeByte = _class.instanceMethodId(r'writeByte', r'(I)V');

  static final _writeByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeByte(int i)`
  void writeByte(int i) {
    _writeByte(
      reference.pointer,
      _id_writeByte as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeShort = _class.instanceMethodId(r'writeShort', r'(I)V');

  static final _writeShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeShort(int i)`
  void writeShort(int i) {
    _writeShort(
      reference.pointer,
      _id_writeShort as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeChar = _class.instanceMethodId(r'writeChar', r'(I)V');

  static final _writeChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeChar(int i)`
  void writeChar(int i) {
    _writeChar(
      reference.pointer,
      _id_writeChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeInt = _class.instanceMethodId(r'writeInt', r'(I)V');

  static final _writeInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeInt(int i)`
  void writeInt(int i) {
    _writeInt(reference.pointer, _id_writeInt as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_writeLong = _class.instanceMethodId(r'writeLong', r'(J)V');

  static final _writeLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeLong(long j)`
  void writeLong(int j) {
    _writeLong(
      reference.pointer,
      _id_writeLong as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_writeFloat = _class.instanceMethodId(r'writeFloat', r'(F)V');

  static final _writeFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public abstract void writeFloat(float f)`
  void writeFloat(double f) {
    _writeFloat(
      reference.pointer,
      _id_writeFloat as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_writeDouble = _class.instanceMethodId(
    r'writeDouble',
    r'(D)V',
  );

  static final _writeDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public abstract void writeDouble(double d)`
  void writeDouble(double d) {
    _writeDouble(
      reference.pointer,
      _id_writeDouble as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'(Ljava/lang/String;)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeBytes(java.lang.String string)`
  void writeBytes(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeChars = _class.instanceMethodId(
    r'writeChars',
    r'(Ljava/lang/String;)V',
  );

  static final _writeChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeChars(java.lang.String string)`
  void writeChars(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeChars(
      reference.pointer,
      _id_writeChars as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeUTF = _class.instanceMethodId(
    r'writeUTF',
    r'(Ljava/lang/String;)V',
  );

  static final _writeUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeUTF(java.lang.String string)`
  void writeUTF(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeUTF(
      reference.pointer,
      _id_writeUTF as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $DataOutput> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'write(I)V') {
        _$impls[$p]!.write(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'write([B)V') {
        _$impls[$p]!.write$1(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'write([BII)V') {
        _$impls[$p]!.write$2(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeBoolean(Z)V') {
        _$impls[$p]!.writeBoolean(
          $a![0]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeByte(I)V') {
        _$impls[$p]!.writeByte(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeShort(I)V') {
        _$impls[$p]!.writeShort(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeChar(I)V') {
        _$impls[$p]!.writeChar(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeInt(I)V') {
        _$impls[$p]!.writeInt(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeLong(J)V') {
        _$impls[$p]!.writeLong(
          $a![0]!
              .as(const jni$_.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeFloat(F)V') {
        _$impls[$p]!.writeFloat(
          $a![0]!
              .as(const jni$_.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeDouble(D)V') {
        _$impls[$p]!.writeDouble(
          $a![0]!
              .as(const jni$_.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeBytes(Ljava/lang/String;)V') {
        _$impls[$p]!.writeBytes(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeChars(Ljava/lang/String;)V') {
        _$impls[$p]!.writeChars(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeUTF(Ljava/lang/String;)V') {
        _$impls[$p]!.writeUTF(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $DataOutput $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.DataOutput', $p, _$invokePointer, [
      if ($impl.write$async) r'write(I)V',
      if ($impl.write$1$async) r'write([B)V',
      if ($impl.write$2$async) r'write([BII)V',
      if ($impl.writeBoolean$async) r'writeBoolean(Z)V',
      if ($impl.writeByte$async) r'writeByte(I)V',
      if ($impl.writeShort$async) r'writeShort(I)V',
      if ($impl.writeChar$async) r'writeChar(I)V',
      if ($impl.writeInt$async) r'writeInt(I)V',
      if ($impl.writeLong$async) r'writeLong(J)V',
      if ($impl.writeFloat$async) r'writeFloat(F)V',
      if ($impl.writeDouble$async) r'writeDouble(D)V',
      if ($impl.writeBytes$async) r'writeBytes(Ljava/lang/String;)V',
      if ($impl.writeChars$async) r'writeChars(Ljava/lang/String;)V',
      if ($impl.writeUTF$async) r'writeUTF(Ljava/lang/String;)V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory DataOutput.implement($DataOutput $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return DataOutput.fromReference($i.implementReference());
  }
}

abstract base mixin class $DataOutput {
  factory $DataOutput({
    required void Function(int i) write,
    bool write$async,
    required void Function(jni$_.JByteArray? bs) write$1,
    bool write$1$async,
    required void Function(jni$_.JByteArray? bs, int i, int i1) write$2,
    bool write$2$async,
    required void Function(bool z) writeBoolean,
    bool writeBoolean$async,
    required void Function(int i) writeByte,
    bool writeByte$async,
    required void Function(int i) writeShort,
    bool writeShort$async,
    required void Function(int i) writeChar,
    bool writeChar$async,
    required void Function(int i) writeInt,
    bool writeInt$async,
    required void Function(int j) writeLong,
    bool writeLong$async,
    required void Function(double f) writeFloat,
    bool writeFloat$async,
    required void Function(double d) writeDouble,
    bool writeDouble$async,
    required void Function(jni$_.JString? string) writeBytes,
    bool writeBytes$async,
    required void Function(jni$_.JString? string) writeChars,
    bool writeChars$async,
    required void Function(jni$_.JString? string) writeUTF,
    bool writeUTF$async,
  }) = _$DataOutput;

  void write(int i);
  bool get write$async => false;
  void write$1(jni$_.JByteArray? bs);
  bool get write$1$async => false;
  void write$2(jni$_.JByteArray? bs, int i, int i1);
  bool get write$2$async => false;
  void writeBoolean(bool z);
  bool get writeBoolean$async => false;
  void writeByte(int i);
  bool get writeByte$async => false;
  void writeShort(int i);
  bool get writeShort$async => false;
  void writeChar(int i);
  bool get writeChar$async => false;
  void writeInt(int i);
  bool get writeInt$async => false;
  void writeLong(int j);
  bool get writeLong$async => false;
  void writeFloat(double f);
  bool get writeFloat$async => false;
  void writeDouble(double d);
  bool get writeDouble$async => false;
  void writeBytes(jni$_.JString? string);
  bool get writeBytes$async => false;
  void writeChars(jni$_.JString? string);
  bool get writeChars$async => false;
  void writeUTF(jni$_.JString? string);
  bool get writeUTF$async => false;
}

final class _$DataOutput with $DataOutput {
  _$DataOutput({
    required void Function(int i) write,
    this.write$async = false,
    required void Function(jni$_.JByteArray? bs) write$1,
    this.write$1$async = false,
    required void Function(jni$_.JByteArray? bs, int i, int i1) write$2,
    this.write$2$async = false,
    required void Function(bool z) writeBoolean,
    this.writeBoolean$async = false,
    required void Function(int i) writeByte,
    this.writeByte$async = false,
    required void Function(int i) writeShort,
    this.writeShort$async = false,
    required void Function(int i) writeChar,
    this.writeChar$async = false,
    required void Function(int i) writeInt,
    this.writeInt$async = false,
    required void Function(int j) writeLong,
    this.writeLong$async = false,
    required void Function(double f) writeFloat,
    this.writeFloat$async = false,
    required void Function(double d) writeDouble,
    this.writeDouble$async = false,
    required void Function(jni$_.JString? string) writeBytes,
    this.writeBytes$async = false,
    required void Function(jni$_.JString? string) writeChars,
    this.writeChars$async = false,
    required void Function(jni$_.JString? string) writeUTF,
    this.writeUTF$async = false,
  }) : _write = write,
       _write$1 = write$1,
       _write$2 = write$2,
       _writeBoolean = writeBoolean,
       _writeByte = writeByte,
       _writeShort = writeShort,
       _writeChar = writeChar,
       _writeInt = writeInt,
       _writeLong = writeLong,
       _writeFloat = writeFloat,
       _writeDouble = writeDouble,
       _writeBytes = writeBytes,
       _writeChars = writeChars,
       _writeUTF = writeUTF;

  final void Function(int i) _write;
  final bool write$async;
  final void Function(jni$_.JByteArray? bs) _write$1;
  final bool write$1$async;
  final void Function(jni$_.JByteArray? bs, int i, int i1) _write$2;
  final bool write$2$async;
  final void Function(bool z) _writeBoolean;
  final bool writeBoolean$async;
  final void Function(int i) _writeByte;
  final bool writeByte$async;
  final void Function(int i) _writeShort;
  final bool writeShort$async;
  final void Function(int i) _writeChar;
  final bool writeChar$async;
  final void Function(int i) _writeInt;
  final bool writeInt$async;
  final void Function(int j) _writeLong;
  final bool writeLong$async;
  final void Function(double f) _writeFloat;
  final bool writeFloat$async;
  final void Function(double d) _writeDouble;
  final bool writeDouble$async;
  final void Function(jni$_.JString? string) _writeBytes;
  final bool writeBytes$async;
  final void Function(jni$_.JString? string) _writeChars;
  final bool writeChars$async;
  final void Function(jni$_.JString? string) _writeUTF;
  final bool writeUTF$async;

  void write(int i) {
    return _write(i);
  }

  void write$1(jni$_.JByteArray? bs) {
    return _write$1(bs);
  }

  void write$2(jni$_.JByteArray? bs, int i, int i1) {
    return _write$2(bs, i, i1);
  }

  void writeBoolean(bool z) {
    return _writeBoolean(z);
  }

  void writeByte(int i) {
    return _writeByte(i);
  }

  void writeShort(int i) {
    return _writeShort(i);
  }

  void writeChar(int i) {
    return _writeChar(i);
  }

  void writeInt(int i) {
    return _writeInt(i);
  }

  void writeLong(int j) {
    return _writeLong(j);
  }

  void writeFloat(double f) {
    return _writeFloat(f);
  }

  void writeDouble(double d) {
    return _writeDouble(d);
  }

  void writeBytes(jni$_.JString? string) {
    return _writeBytes(string);
  }

  void writeChars(jni$_.JString? string) {
    return _writeChars(string);
  }

  void writeUTF(jni$_.JString? string) {
    return _writeUTF(string);
  }
}

final class $DataOutput$NullableType extends jni$_.JObjType<DataOutput?> {
  @jni$_.internal
  const $DataOutput$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataOutput;';

  @jni$_.internal
  @core$_.override
  DataOutput? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DataOutput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataOutput?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DataOutput$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DataOutput$NullableType) &&
        other is $DataOutput$NullableType;
  }
}

final class $DataOutput$Type extends jni$_.JObjType<DataOutput> {
  @jni$_.internal
  const $DataOutput$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataOutput;';

  @jni$_.internal
  @core$_.override
  DataOutput fromReference(jni$_.JReference reference) =>
      DataOutput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataOutput?> get nullableType =>
      const $DataOutput$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DataOutput$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DataOutput$Type) && other is $DataOutput$Type;
  }
}

/// from: `java.io.BufferedWriter`
class BufferedWriter extends Writer {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<BufferedWriter> $type;

  @jni$_.internal
  BufferedWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/BufferedWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $BufferedWriter$NullableType();
  static const type = $BufferedWriter$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/Writer;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.Writer writer)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedWriter(Writer? writer) {
    final _$writer = writer?.reference ?? jni$_.jNullReference;
    return BufferedWriter.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$writer.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/Writer;I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.Writer writer, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedWriter.new$1(Writer? writer, int i) {
    final _$writer = writer?.reference ?? jni$_.jNullReference;
    return BufferedWriter.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$writer.pointer,
        i,
      ).reference,
    );
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(char[] cs, int i, int i1)`
  void write2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write4 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;II)V',
  );

  static final _write4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(java.lang.String string, int i, int i1)`
  void write4(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write4(
      reference.pointer,
      _id_write4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_newLine = _class.instanceMethodId(r'newLine', r'()V');

  static final _newLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void newLine()`
  void newLine() {
    _newLine(reference.pointer, _id_newLine as jni$_.JMethodIDPtr).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $BufferedWriter$NullableType
    extends jni$_.JObjType<BufferedWriter?> {
  @jni$_.internal
  const $BufferedWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedWriter;';

  @jni$_.internal
  @core$_.override
  BufferedWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : BufferedWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($BufferedWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BufferedWriter$NullableType) &&
        other is $BufferedWriter$NullableType;
  }
}

final class $BufferedWriter$Type extends jni$_.JObjType<BufferedWriter> {
  @jni$_.internal
  const $BufferedWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedWriter;';

  @jni$_.internal
  @core$_.override
  BufferedWriter fromReference(jni$_.JReference reference) =>
      BufferedWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedWriter?> get nullableType =>
      const $BufferedWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($BufferedWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BufferedWriter$Type) &&
        other is $BufferedWriter$Type;
  }
}

/// from: `java.io.StringWriter`
class StringWriter extends Writer {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StringWriter> $type;

  @jni$_.internal
  StringWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/StringWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StringWriter$NullableType();
  static const type = $StringWriter$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringWriter() {
    return StringWriter.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringWriter.new$1(int i) {
    return StringWriter.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        i,
      ).reference,
    );
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(char[] cs, int i, int i1)`
  void write2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write3 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;)V',
  );

  static final _write3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(java.lang.String string)`
  void write3(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write3(
      reference.pointer,
      _id_write3 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_write4 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;II)V',
  );

  static final _write4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(java.lang.String string, int i, int i1)`
  void write4(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write4(
      reference.pointer,
      _id_write4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_append$3 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;)Ljava/io/StringWriter;',
  );

  static final _append$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.StringWriter append(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  StringWriter? append$3(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$3(
      reference.pointer,
      _id_append$3 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<StringWriter?>(const $StringWriter$NullableType());
  }

  static final _id_append$4 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;II)Ljava/io/StringWriter;',
  );

  static final _append$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public java.io.StringWriter append(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  StringWriter? append$4(jni$_.JObject? charSequence, int i, int i1) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$4(
      reference.pointer,
      _id_append$4 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
    ).object<StringWriter?>(const $StringWriter$NullableType());
  }

  static final _id_append$5 = _class.instanceMethodId(
    r'append',
    r'(C)Ljava/io/StringWriter;',
  );

  static final _append$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.io.StringWriter append(char c)`
  /// The returned object must be released after use, by calling the [release] method.
  StringWriter? append$5(int c) {
    return _append$5(
      reference.pointer,
      _id_append$5 as jni$_.JMethodIDPtr,
      c,
    ).object<StringWriter?>(const $StringWriter$NullableType());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getBuffer = _class.instanceMethodId(
    r'getBuffer',
    r'()Ljava/lang/StringBuffer;',
  );

  static final _getBuffer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.StringBuffer getBuffer()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getBuffer() {
    return _getBuffer(
      reference.pointer,
      _id_getBuffer as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $StringWriter$NullableType extends jni$_.JObjType<StringWriter?> {
  @jni$_.internal
  const $StringWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StringWriter;';

  @jni$_.internal
  @core$_.override
  StringWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : StringWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($StringWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringWriter$NullableType) &&
        other is $StringWriter$NullableType;
  }
}

final class $StringWriter$Type extends jni$_.JObjType<StringWriter> {
  @jni$_.internal
  const $StringWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StringWriter;';

  @jni$_.internal
  @core$_.override
  StringWriter fromReference(jni$_.JReference reference) =>
      StringWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringWriter?> get nullableType =>
      const $StringWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($StringWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringWriter$Type) &&
        other is $StringWriter$Type;
  }
}

/// from: `java.io.FileOutputStream`
class FileOutputStream extends OutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileOutputStream> $type;

  @jni$_.internal
  FileOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FileOutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileOutputStream$NullableType();
  static const type = $FileOutputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileOutputStream(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return FileOutputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/lang/String;Z)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileOutputStream.new$1(jni$_.JString? string, bool z) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return FileOutputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Ljava/io/File;)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileOutputStream.new$2(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return FileOutputStream.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$file.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(Ljava/io/File;Z)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.File file, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileOutputStream.new$3(File? file, bool z) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return FileOutputStream.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$file.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(r'(Ljava/io/FileDescriptor;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.FileDescriptor fileDescriptor)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileOutputStream.new$4(FileDescriptor? fileDescriptor) {
    final _$fileDescriptor = fileDescriptor?.reference ?? jni$_.jNullReference;
    return FileOutputStream.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$fileDescriptor.pointer,
      ).reference,
    );
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(byte[] bs)`
  void write1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write1(
      reference.pointer,
      _id_write1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_getFD = _class.instanceMethodId(
    r'getFD',
    r'()Ljava/io/FileDescriptor;',
  );

  static final _getFD =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.io.FileDescriptor getFD()`
  /// The returned object must be released after use, by calling the [release] method.
  FileDescriptor? getFD() {
    return _getFD(
      reference.pointer,
      _id_getFD as jni$_.JMethodIDPtr,
    ).object<FileDescriptor?>(const $FileDescriptor$NullableType());
  }

  static final _id_getChannel = _class.instanceMethodId(
    r'getChannel',
    r'()Ljava/nio/channels/FileChannel;',
  );

  static final _getChannel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.channels.FileChannel getChannel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChannel() {
    return _getChannel(
      reference.pointer,
      _id_getChannel as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $FileOutputStream$NullableType
    extends jni$_.JObjType<FileOutputStream?> {
  @jni$_.internal
  const $FileOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileOutputStream;';

  @jni$_.internal
  @core$_.override
  FileOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FileOutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileOutputStream$NullableType) &&
        other is $FileOutputStream$NullableType;
  }
}

final class $FileOutputStream$Type extends jni$_.JObjType<FileOutputStream> {
  @jni$_.internal
  const $FileOutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileOutputStream;';

  @jni$_.internal
  @core$_.override
  FileOutputStream fromReference(jni$_.JReference reference) =>
      FileOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileOutputStream?> get nullableType =>
      const $FileOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FileOutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileOutputStream$Type) &&
        other is $FileOutputStream$Type;
  }
}

/// from: `java.io.IOException`
class IOException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<IOException> $type;

  @jni$_.internal
  IOException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/IOException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $IOException$NullableType();
  static const type = $IOException$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory IOException() {
    return IOException.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory IOException.new$1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return IOException.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/Throwable;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.Throwable throwable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory IOException.new$2(jni$_.JString? string, jni$_.JObject? throwable) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    return IOException.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$throwable.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(Ljava/lang/Throwable;)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.Throwable throwable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory IOException.new$3(jni$_.JObject? throwable) {
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    return IOException.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$throwable.pointer,
      ).reference,
    );
  }
}

final class $IOException$NullableType extends jni$_.JObjType<IOException?> {
  @jni$_.internal
  const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/IOException;';

  @jni$_.internal
  @core$_.override
  IOException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : IOException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IOException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IOException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IOException$NullableType) &&
        other is $IOException$NullableType;
  }
}

final class $IOException$Type extends jni$_.JObjType<IOException> {
  @jni$_.internal
  const $IOException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/IOException;';

  @jni$_.internal
  @core$_.override
  IOException fromReference(jni$_.JReference reference) =>
      IOException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IOException?> get nullableType =>
      const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IOException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IOException$Type) &&
        other is $IOException$Type;
  }
}

/// from: `java.io.PipedOutputStream`
class PipedOutputStream extends OutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PipedOutputStream> $type;

  @jni$_.internal
  PipedOutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PipedOutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PipedOutputStream$NullableType();
  static const type = $PipedOutputStream$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/io/PipedInputStream;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.PipedInputStream pipedInputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedOutputStream(PipedInputStream? pipedInputStream) {
    final _$pipedInputStream =
        pipedInputStream?.reference ?? jni$_.jNullReference;
    return PipedOutputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$pipedInputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'()V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory PipedOutputStream.new$1() {
    return PipedOutputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }

  static final _id_connect = _class.instanceMethodId(
    r'connect',
    r'(Ljava/io/PipedInputStream;)V',
  );

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void connect(java.io.PipedInputStream pipedInputStream)`
  void connect(PipedInputStream? pipedInputStream) {
    final _$pipedInputStream =
        pipedInputStream?.reference ?? jni$_.jNullReference;
    _connect(
      reference.pointer,
      _id_connect as jni$_.JMethodIDPtr,
      _$pipedInputStream.pointer,
    ).check();
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $PipedOutputStream$NullableType
    extends jni$_.JObjType<PipedOutputStream?> {
  @jni$_.internal
  const $PipedOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedOutputStream;';

  @jni$_.internal
  @core$_.override
  PipedOutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PipedOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedOutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedOutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PipedOutputStream$NullableType) &&
        other is $PipedOutputStream$NullableType;
  }
}

final class $PipedOutputStream$Type extends jni$_.JObjType<PipedOutputStream> {
  @jni$_.internal
  const $PipedOutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PipedOutputStream;';

  @jni$_.internal
  @core$_.override
  PipedOutputStream fromReference(jni$_.JReference reference) =>
      PipedOutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PipedOutputStream?> get nullableType =>
      const $PipedOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($PipedOutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PipedOutputStream$Type) &&
        other is $PipedOutputStream$Type;
  }
}

/// from: `java.io.InputStreamReader`
class InputStreamReader extends Reader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InputStreamReader> $type;

  @jni$_.internal
  InputStreamReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/InputStreamReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InputStreamReader$NullableType();
  static const type = $InputStreamReader$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/InputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InputStreamReader(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return InputStreamReader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/io/InputStream;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InputStreamReader.new$1(
    InputStream? inputStream,
    jni$_.JString? string,
  ) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return InputStreamReader.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/io/InputStream;Ljava/nio/charset/Charset;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InputStreamReader.new$2(
    InputStream? inputStream,
    jni$_.JObject? charset,
  ) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return InputStreamReader.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/io/InputStream;Ljava/nio/charset/CharsetDecoder;)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream, java.nio.charset.CharsetDecoder charsetDecoder)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InputStreamReader.new$3(
    InputStream? inputStream,
    jni$_.JObject? charsetDecoder,
  ) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    final _$charsetDecoder = charsetDecoder?.reference ?? jni$_.jNullReference;
    return InputStreamReader.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
        _$charsetDecoder.pointer,
      ).reference,
    );
  }

  static final _id_getEncoding = _class.instanceMethodId(
    r'getEncoding',
    r'()Ljava/lang/String;',
  );

  static final _getEncoding =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getEncoding()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getEncoding() {
    return _getEncoding(
      reference.pointer,
      _id_getEncoding as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_read = _class.instanceMethodId(
    r'read',
    r'(Ljava/nio/CharBuffer;)I',
  );

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(java.nio.CharBuffer charBuffer)`
  int read(jni$_.JObject? charBuffer) {
    final _$charBuffer = charBuffer?.reference ?? jni$_.jNullReference;
    return _read(
      reference.pointer,
      _id_read as jni$_.JMethodIDPtr,
      _$charBuffer.pointer,
    ).integer;
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() {
    return _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() {
    return _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $InputStreamReader$NullableType
    extends jni$_.JObjType<InputStreamReader?> {
  @jni$_.internal
  const $InputStreamReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InputStreamReader;';

  @jni$_.internal
  @core$_.override
  InputStreamReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InputStreamReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InputStreamReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($InputStreamReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InputStreamReader$NullableType) &&
        other is $InputStreamReader$NullableType;
  }
}

final class $InputStreamReader$Type extends jni$_.JObjType<InputStreamReader> {
  @jni$_.internal
  const $InputStreamReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InputStreamReader;';

  @jni$_.internal
  @core$_.override
  InputStreamReader fromReference(jni$_.JReference reference) =>
      InputStreamReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InputStreamReader?> get nullableType =>
      const $InputStreamReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($InputStreamReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InputStreamReader$Type) &&
        other is $InputStreamReader$Type;
  }
}

/// from: `java.io.File`
class File extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<File> $type;

  @jni$_.internal
  File.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/File');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $File$NullableType();
  static const type = $File$Type();
  static final _id_separatorChar = _class.staticFieldId(r'separatorChar', r'C');

  /// from: `static public final char separatorChar`
  static int get separatorChar =>
      _id_separatorChar.get(_class, const jni$_.jcharType());

  static final _id_separator = _class.staticFieldId(
    r'separator',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String separator`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get separator =>
      _id_separator.get(_class, const jni$_.JStringNullableType());

  static final _id_pathSeparatorChar = _class.staticFieldId(
    r'pathSeparatorChar',
    r'C',
  );

  /// from: `static public final char pathSeparatorChar`
  static int get pathSeparatorChar =>
      _id_pathSeparatorChar.get(_class, const jni$_.jcharType());

  static final _id_pathSeparator = _class.staticFieldId(
    r'pathSeparator',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String pathSeparator`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get pathSeparator =>
      _id_pathSeparator.get(_class, const jni$_.JStringNullableType());

  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return File.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$1(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return File.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/io/File;Ljava/lang/String;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$2(File? file, jni$_.JString? string) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return File.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(Ljava/net/URI;)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.URI uRI)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$3(jni$_.JObject? uRI) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    return File.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$uRI.pointer,
      ).reference,
    );
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() {
    return _getName(
      reference.pointer,
      _id_getName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getParent = _class.instanceMethodId(
    r'getParent',
    r'()Ljava/lang/String;',
  );

  static final _getParent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getParent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getParent() {
    return _getParent(
      reference.pointer,
      _id_getParent as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getParentFile = _class.instanceMethodId(
    r'getParentFile',
    r'()Ljava/io/File;',
  );

  static final _getParentFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.File getParentFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getParentFile() {
    return _getParentFile(
      reference.pointer,
      _id_getParentFile as jni$_.JMethodIDPtr,
    ).object<File?>(const $File$NullableType());
  }

  static final _id_getPath = _class.instanceMethodId(
    r'getPath',
    r'()Ljava/lang/String;',
  );

  static final _getPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPath() {
    return _getPath(
      reference.pointer,
      _id_getPath as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isAbsolute = _class.instanceMethodId(r'isAbsolute', r'()Z');

  static final _isAbsolute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isAbsolute()`
  bool isAbsolute() {
    return _isAbsolute(
      reference.pointer,
      _id_isAbsolute as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getAbsolutePath = _class.instanceMethodId(
    r'getAbsolutePath',
    r'()Ljava/lang/String;',
  );

  static final _getAbsolutePath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getAbsolutePath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAbsolutePath() {
    return _getAbsolutePath(
      reference.pointer,
      _id_getAbsolutePath as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getAbsoluteFile = _class.instanceMethodId(
    r'getAbsoluteFile',
    r'()Ljava/io/File;',
  );

  static final _getAbsoluteFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.File getAbsoluteFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getAbsoluteFile() {
    return _getAbsoluteFile(
      reference.pointer,
      _id_getAbsoluteFile as jni$_.JMethodIDPtr,
    ).object<File?>(const $File$NullableType());
  }

  static final _id_getCanonicalPath = _class.instanceMethodId(
    r'getCanonicalPath',
    r'()Ljava/lang/String;',
  );

  static final _getCanonicalPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getCanonicalPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCanonicalPath() {
    return _getCanonicalPath(
      reference.pointer,
      _id_getCanonicalPath as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getCanonicalFile = _class.instanceMethodId(
    r'getCanonicalFile',
    r'()Ljava/io/File;',
  );

  static final _getCanonicalFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.File getCanonicalFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getCanonicalFile() {
    return _getCanonicalFile(
      reference.pointer,
      _id_getCanonicalFile as jni$_.JMethodIDPtr,
    ).object<File?>(const $File$NullableType());
  }

  static final _id_toURL = _class.instanceMethodId(
    r'toURL',
    r'()Ljava/net/URL;',
  );

  static final _toURL =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URL toURL()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toURL() {
    return _toURL(
      reference.pointer,
      _id_toURL as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toURI = _class.instanceMethodId(
    r'toURI',
    r'()Ljava/net/URI;',
  );

  static final _toURI =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URI toURI()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toURI() {
    return _toURI(
      reference.pointer,
      _id_toURI as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_canRead = _class.instanceMethodId(r'canRead', r'()Z');

  static final _canRead =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean canRead()`
  bool canRead() {
    return _canRead(
      reference.pointer,
      _id_canRead as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_canWrite = _class.instanceMethodId(r'canWrite', r'()Z');

  static final _canWrite =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean canWrite()`
  bool canWrite() {
    return _canWrite(
      reference.pointer,
      _id_canWrite as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_exists = _class.instanceMethodId(r'exists', r'()Z');

  static final _exists =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean exists()`
  bool exists() {
    return _exists(reference.pointer, _id_exists as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_isDirectory = _class.instanceMethodId(
    r'isDirectory',
    r'()Z',
  );

  static final _isDirectory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isDirectory()`
  bool isDirectory() {
    return _isDirectory(
      reference.pointer,
      _id_isDirectory as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isFile = _class.instanceMethodId(r'isFile', r'()Z');

  static final _isFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isFile()`
  bool isFile() {
    return _isFile(reference.pointer, _id_isFile as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_isHidden = _class.instanceMethodId(r'isHidden', r'()Z');

  static final _isHidden =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isHidden()`
  bool isHidden() {
    return _isHidden(
      reference.pointer,
      _id_isHidden as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_lastModified = _class.instanceMethodId(
    r'lastModified',
    r'()J',
  );

  static final _lastModified =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long lastModified()`
  int lastModified() {
    return _lastModified(
      reference.pointer,
      _id_lastModified as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_length = _class.instanceMethodId(r'length', r'()J');

  static final _length =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long length()`
  int length() {
    return _length(reference.pointer, _id_length as jni$_.JMethodIDPtr).long;
  }

  static final _id_createNewFile = _class.instanceMethodId(
    r'createNewFile',
    r'()Z',
  );

  static final _createNewFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean createNewFile()`
  bool createNewFile() {
    return _createNewFile(
      reference.pointer,
      _id_createNewFile as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_delete = _class.instanceMethodId(r'delete', r'()Z');

  static final _delete =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean delete()`
  bool delete() {
    return _delete(reference.pointer, _id_delete as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_deleteOnExit = _class.instanceMethodId(
    r'deleteOnExit',
    r'()V',
  );

  static final _deleteOnExit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void deleteOnExit()`
  void deleteOnExit() {
    _deleteOnExit(
      reference.pointer,
      _id_deleteOnExit as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_list = _class.instanceMethodId(
    r'list',
    r'()[Ljava/lang/String;',
  );

  static final _list =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String[] list()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? list() {
    return _list(
      reference.pointer,
      _id_list as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<jni$_.JString?>?>(
      const jni$_.JArrayNullableType<jni$_.JString?>(
        jni$_.JStringNullableType(),
      ),
    );
  }

  static final _id_list$1 = _class.instanceMethodId(
    r'list',
    r'(Ljava/io/FilenameFilter;)[Ljava/lang/String;',
  );

  static final _list$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String[] list(java.io.FilenameFilter filenameFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? list$1(FilenameFilter? filenameFilter) {
    final _$filenameFilter = filenameFilter?.reference ?? jni$_.jNullReference;
    return _list$1(
      reference.pointer,
      _id_list$1 as jni$_.JMethodIDPtr,
      _$filenameFilter.pointer,
    ).object<jni$_.JArray<jni$_.JString?>?>(
      const jni$_.JArrayNullableType<jni$_.JString?>(
        jni$_.JStringNullableType(),
      ),
    );
  }

  static final _id_listFiles = _class.instanceMethodId(
    r'listFiles',
    r'()[Ljava/io/File;',
  );

  static final _listFiles =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.File[] listFiles()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles() {
    return _listFiles(
      reference.pointer,
      _id_listFiles as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<File?>?>(
      const jni$_.JArrayNullableType<File?>($File$NullableType()),
    );
  }

  static final _id_listFiles$1 = _class.instanceMethodId(
    r'listFiles',
    r'(Ljava/io/FilenameFilter;)[Ljava/io/File;',
  );

  static final _listFiles$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.File[] listFiles(java.io.FilenameFilter filenameFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles$1(FilenameFilter? filenameFilter) {
    final _$filenameFilter = filenameFilter?.reference ?? jni$_.jNullReference;
    return _listFiles$1(
      reference.pointer,
      _id_listFiles$1 as jni$_.JMethodIDPtr,
      _$filenameFilter.pointer,
    ).object<jni$_.JArray<File?>?>(
      const jni$_.JArrayNullableType<File?>($File$NullableType()),
    );
  }

  static final _id_listFiles$2 = _class.instanceMethodId(
    r'listFiles',
    r'(Ljava/io/FileFilter;)[Ljava/io/File;',
  );

  static final _listFiles$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.File[] listFiles(java.io.FileFilter fileFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles$2(FileFilter? fileFilter) {
    final _$fileFilter = fileFilter?.reference ?? jni$_.jNullReference;
    return _listFiles$2(
      reference.pointer,
      _id_listFiles$2 as jni$_.JMethodIDPtr,
      _$fileFilter.pointer,
    ).object<jni$_.JArray<File?>?>(
      const jni$_.JArrayNullableType<File?>($File$NullableType()),
    );
  }

  static final _id_mkdir = _class.instanceMethodId(r'mkdir', r'()Z');

  static final _mkdir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean mkdir()`
  bool mkdir() {
    return _mkdir(reference.pointer, _id_mkdir as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_mkdirs = _class.instanceMethodId(r'mkdirs', r'()Z');

  static final _mkdirs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean mkdirs()`
  bool mkdirs() {
    return _mkdirs(reference.pointer, _id_mkdirs as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_renameTo = _class.instanceMethodId(
    r'renameTo',
    r'(Ljava/io/File;)Z',
  );

  static final _renameTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean renameTo(java.io.File file)`
  bool renameTo(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _renameTo(
      reference.pointer,
      _id_renameTo as jni$_.JMethodIDPtr,
      _$file.pointer,
    ).boolean;
  }

  static final _id_setLastModified = _class.instanceMethodId(
    r'setLastModified',
    r'(J)Z',
  );

  static final _setLastModified =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean setLastModified(long j)`
  bool setLastModified(int j) {
    return _setLastModified(
      reference.pointer,
      _id_setLastModified as jni$_.JMethodIDPtr,
      j,
    ).boolean;
  }

  static final _id_setReadOnly = _class.instanceMethodId(
    r'setReadOnly',
    r'()Z',
  );

  static final _setReadOnly =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean setReadOnly()`
  bool setReadOnly() {
    return _setReadOnly(
      reference.pointer,
      _id_setReadOnly as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setWritable = _class.instanceMethodId(
    r'setWritable',
    r'(ZZ)Z',
  );

  static final _setWritable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public boolean setWritable(boolean z, boolean z1)`
  bool setWritable(bool z, bool z1) {
    return _setWritable(
      reference.pointer,
      _id_setWritable as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      z1 ? 1 : 0,
    ).boolean;
  }

  static final _id_setWritable$1 = _class.instanceMethodId(
    r'setWritable',
    r'(Z)Z',
  );

  static final _setWritable$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean setWritable(boolean z)`
  bool setWritable$1(bool z) {
    return _setWritable$1(
      reference.pointer,
      _id_setWritable$1 as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_setReadable = _class.instanceMethodId(
    r'setReadable',
    r'(ZZ)Z',
  );

  static final _setReadable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public boolean setReadable(boolean z, boolean z1)`
  bool setReadable(bool z, bool z1) {
    return _setReadable(
      reference.pointer,
      _id_setReadable as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      z1 ? 1 : 0,
    ).boolean;
  }

  static final _id_setReadable$1 = _class.instanceMethodId(
    r'setReadable',
    r'(Z)Z',
  );

  static final _setReadable$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean setReadable(boolean z)`
  bool setReadable$1(bool z) {
    return _setReadable$1(
      reference.pointer,
      _id_setReadable$1 as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_setExecutable = _class.instanceMethodId(
    r'setExecutable',
    r'(ZZ)Z',
  );

  static final _setExecutable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public boolean setExecutable(boolean z, boolean z1)`
  bool setExecutable(bool z, bool z1) {
    return _setExecutable(
      reference.pointer,
      _id_setExecutable as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      z1 ? 1 : 0,
    ).boolean;
  }

  static final _id_setExecutable$1 = _class.instanceMethodId(
    r'setExecutable',
    r'(Z)Z',
  );

  static final _setExecutable$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean setExecutable(boolean z)`
  bool setExecutable$1(bool z) {
    return _setExecutable$1(
      reference.pointer,
      _id_setExecutable$1 as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_canExecute = _class.instanceMethodId(r'canExecute', r'()Z');

  static final _canExecute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean canExecute()`
  bool canExecute() {
    return _canExecute(
      reference.pointer,
      _id_canExecute as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_listRoots = _class.staticMethodId(
    r'listRoots',
    r'()[Ljava/io/File;',
  );

  static final _listRoots =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.File[] listRoots()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<File?>? listRoots() {
    return _listRoots(
      _class.reference.pointer,
      _id_listRoots as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<File?>?>(
      const jni$_.JArrayNullableType<File?>($File$NullableType()),
    );
  }

  static final _id_getTotalSpace = _class.instanceMethodId(
    r'getTotalSpace',
    r'()J',
  );

  static final _getTotalSpace =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getTotalSpace()`
  int getTotalSpace() {
    return _getTotalSpace(
      reference.pointer,
      _id_getTotalSpace as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getFreeSpace = _class.instanceMethodId(
    r'getFreeSpace',
    r'()J',
  );

  static final _getFreeSpace =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getFreeSpace()`
  int getFreeSpace() {
    return _getFreeSpace(
      reference.pointer,
      _id_getFreeSpace as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getUsableSpace = _class.instanceMethodId(
    r'getUsableSpace',
    r'()J',
  );

  static final _getUsableSpace =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getUsableSpace()`
  int getUsableSpace() {
    return _getUsableSpace(
      reference.pointer,
      _id_getUsableSpace as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_createTempFile = _class.staticMethodId(
    r'createTempFile',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File;',
  );

  static final _createTempFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.File createTempFile(java.lang.String string, java.lang.String string1, java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  static File? createTempFile(
    jni$_.JString? string,
    jni$_.JString? string1,
    File? file,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _createTempFile(
      _class.reference.pointer,
      _id_createTempFile as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
      _$file.pointer,
    ).object<File?>(const $File$NullableType());
  }

  static final _id_createTempFile$1 = _class.staticMethodId(
    r'createTempFile',
    r'(Ljava/lang/String;Ljava/lang/String;)Ljava/io/File;',
  );

  static final _createTempFile$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.File createTempFile(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static File? createTempFile$1(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _createTempFile$1(
      _class.reference.pointer,
      _id_createTempFile$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).object<File?>(const $File$NullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/io/File;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.io.File file)`
  int compareTo(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$file.pointer,
    ).integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toPath = _class.instanceMethodId(
    r'toPath',
    r'()Ljava/nio/file/Path;',
  );

  static final _toPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.file.Path toPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toPath() {
    return _toPath(
      reference.pointer,
      _id_toPath as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  bool operator <(File? file) {
    return compareTo(file) < 0;
  }

  bool operator <=(File? file) {
    return compareTo(file) <= 0;
  }

  bool operator >(File? file) {
    return compareTo(file) > 0;
  }

  bool operator >=(File? file) {
    return compareTo(file) >= 0;
  }
}

final class $File$NullableType extends jni$_.JObjType<File?> {
  @jni$_.internal
  const $File$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/File;';

  @jni$_.internal
  @core$_.override
  File? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : File.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<File?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($File$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($File$NullableType) &&
        other is $File$NullableType;
  }
}

final class $File$Type extends jni$_.JObjType<File> {
  @jni$_.internal
  const $File$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/File;';

  @jni$_.internal
  @core$_.override
  File fromReference(jni$_.JReference reference) =>
      File.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<File?> get nullableType => const $File$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($File$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($File$Type) && other is $File$Type;
  }
}

/// from: `java.io.IOError`
class IOError extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<IOError> $type;

  @jni$_.internal
  IOError.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/IOError');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $IOError$NullableType();
  static const type = $IOError$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/Throwable;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.Throwable throwable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory IOError(jni$_.JObject? throwable) {
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    return IOError.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$throwable.pointer,
      ).reference,
    );
  }
}

final class $IOError$NullableType extends jni$_.JObjType<IOError?> {
  @jni$_.internal
  const $IOError$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/IOError;';

  @jni$_.internal
  @core$_.override
  IOError? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : IOError.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IOError?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IOError$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IOError$NullableType) &&
        other is $IOError$NullableType;
  }
}

final class $IOError$Type extends jni$_.JObjType<IOError> {
  @jni$_.internal
  const $IOError$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/IOError;';

  @jni$_.internal
  @core$_.override
  IOError fromReference(jni$_.JReference reference) =>
      IOError.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<IOError?> get nullableType => const $IOError$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($IOError$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($IOError$Type) && other is $IOError$Type;
  }
}

/// from: `java.io.ObjectStreamException`
class ObjectStreamException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectStreamException> $type;

  @jni$_.internal
  ObjectStreamException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectStreamException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectStreamException$NullableType();
  static const type = $ObjectStreamException$Type();
}

final class $ObjectStreamException$NullableType
    extends jni$_.JObjType<ObjectStreamException?> {
  @jni$_.internal
  const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamException;';

  @jni$_.internal
  @core$_.override
  ObjectStreamException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectStreamException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ObjectStreamException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectStreamException$NullableType) &&
        other is $ObjectStreamException$NullableType;
  }
}

final class $ObjectStreamException$Type
    extends jni$_.JObjType<ObjectStreamException> {
  @jni$_.internal
  const $ObjectStreamException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamException;';

  @jni$_.internal
  @core$_.override
  ObjectStreamException fromReference(jni$_.JReference reference) =>
      ObjectStreamException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamException?> get nullableType =>
      const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ObjectStreamException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectStreamException$Type) &&
        other is $ObjectStreamException$Type;
  }
}

/// from: `java.io.FileFilter`
class FileFilter extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileFilter> $type;

  @jni$_.internal
  FileFilter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FileFilter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileFilter$NullableType();
  static const type = $FileFilter$Type();
  static final _id_accept = _class.instanceMethodId(
    r'accept',
    r'(Ljava/io/File;)Z',
  );

  static final _accept =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract boolean accept(java.io.File file)`
  bool accept(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _accept(
      reference.pointer,
      _id_accept as jni$_.JMethodIDPtr,
      _$file.pointer,
    ).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $FileFilter> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'accept(Ljava/io/File;)Z') {
        final $r = _$impls[$p]!.accept(
          $a![0]?.as(const $File$Type(), releaseOriginal: true),
        );
        return jni$_.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $FileFilter $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.FileFilter', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory FileFilter.implement($FileFilter $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return FileFilter.fromReference($i.implementReference());
  }
}

abstract base mixin class $FileFilter {
  factory $FileFilter({required bool Function(File? file) accept}) =
      _$FileFilter;

  bool accept(File? file);
}

final class _$FileFilter with $FileFilter {
  _$FileFilter({required bool Function(File? file) accept}) : _accept = accept;

  final bool Function(File? file) _accept;

  bool accept(File? file) {
    return _accept(file);
  }
}

final class $FileFilter$NullableType extends jni$_.JObjType<FileFilter?> {
  @jni$_.internal
  const $FileFilter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileFilter;';

  @jni$_.internal
  @core$_.override
  FileFilter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileFilter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileFilter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FileFilter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileFilter$NullableType) &&
        other is $FileFilter$NullableType;
  }
}

final class $FileFilter$Type extends jni$_.JObjType<FileFilter> {
  @jni$_.internal
  const $FileFilter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileFilter;';

  @jni$_.internal
  @core$_.override
  FileFilter fromReference(jni$_.JReference reference) =>
      FileFilter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileFilter?> get nullableType =>
      const $FileFilter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FileFilter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileFilter$Type) && other is $FileFilter$Type;
  }
}

/// from: `java.io.StringReader`
class StringReader extends Reader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StringReader> $type;

  @jni$_.internal
  StringReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/StringReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StringReader$NullableType();
  static const type = $StringReader$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringReader(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return StringReader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() {
    return _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() {
    return _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() {
    return _markSupported(
      reference.pointer,
      _id_markSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $StringReader$NullableType extends jni$_.JObjType<StringReader?> {
  @jni$_.internal
  const $StringReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StringReader;';

  @jni$_.internal
  @core$_.override
  StringReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : StringReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($StringReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringReader$NullableType) &&
        other is $StringReader$NullableType;
  }
}

final class $StringReader$Type extends jni$_.JObjType<StringReader> {
  @jni$_.internal
  const $StringReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StringReader;';

  @jni$_.internal
  @core$_.override
  StringReader fromReference(jni$_.JReference reference) =>
      StringReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringReader?> get nullableType =>
      const $StringReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($StringReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringReader$Type) &&
        other is $StringReader$Type;
  }
}

/// from: `java.io.BufferedReader`
class BufferedReader extends Reader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<BufferedReader> $type;

  @jni$_.internal
  BufferedReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/BufferedReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $BufferedReader$NullableType();
  static const type = $BufferedReader$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/Reader;I)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.Reader reader, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedReader(Reader? reader, int i) {
    final _$reader = reader?.reference ?? jni$_.jNullReference;
    return BufferedReader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$reader.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/Reader;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.Reader reader)`
  /// The returned object must be released after use, by calling the [release] method.
  factory BufferedReader.new$1(Reader? reader) {
    final _$reader = reader?.reference ?? jni$_.jNullReference;
    return BufferedReader.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$reader.pointer,
      ).reference,
    );
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() {
    return _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine() {
    return _readLine(
      reference.pointer,
      _id_readLine as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() {
    return _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() {
    return _markSupported(
      reference.pointer,
      _id_markSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_lines = _class.instanceMethodId(
    r'lines',
    r'()Ljava/util/stream/Stream;',
  );

  static final _lines =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.stream.Stream<java.lang.String> lines()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? lines() {
    return _lines(
      reference.pointer,
      _id_lines as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $BufferedReader$NullableType
    extends jni$_.JObjType<BufferedReader?> {
  @jni$_.internal
  const $BufferedReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedReader;';

  @jni$_.internal
  @core$_.override
  BufferedReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : BufferedReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($BufferedReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BufferedReader$NullableType) &&
        other is $BufferedReader$NullableType;
  }
}

final class $BufferedReader$Type extends jni$_.JObjType<BufferedReader> {
  @jni$_.internal
  const $BufferedReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/BufferedReader;';

  @jni$_.internal
  @core$_.override
  BufferedReader fromReference(jni$_.JReference reference) =>
      BufferedReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Reader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<BufferedReader?> get nullableType =>
      const $BufferedReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($BufferedReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($BufferedReader$Type) &&
        other is $BufferedReader$Type;
  }
}

/// from: `java.io.ObjectOutput`
class ObjectOutput extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectOutput> $type;

  @jni$_.internal
  ObjectOutput.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectOutput');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectOutput$NullableType();
  static const type = $ObjectOutput$Type();
  static final _id_writeObject = _class.instanceMethodId(
    r'writeObject',
    r'(Ljava/lang/Object;)V',
  );

  static final _writeObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeObject(java.lang.Object object)`
  void writeObject(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _writeObject(
      reference.pointer,
      _id_writeObject as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write$1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void write(byte[] bs)`
  void write$1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$1(
      reference.pointer,
      _id_write$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_write$2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract void write(byte[] bs, int i, int i1)`
  void write$2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$2(
      reference.pointer,
      _id_write$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_writeBoolean = _class.instanceMethodId(
    r'writeBoolean',
    r'(Z)V',
  );

  static final _writeBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeBoolean(boolean z)`
  void writeBoolean(bool z) {
    _writeBoolean(
      reference.pointer,
      _id_writeBoolean as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_writeByte = _class.instanceMethodId(r'writeByte', r'(I)V');

  static final _writeByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeByte(int i)`
  void writeByte(int i) {
    _writeByte(
      reference.pointer,
      _id_writeByte as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeShort = _class.instanceMethodId(r'writeShort', r'(I)V');

  static final _writeShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeShort(int i)`
  void writeShort(int i) {
    _writeShort(
      reference.pointer,
      _id_writeShort as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeChar = _class.instanceMethodId(r'writeChar', r'(I)V');

  static final _writeChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeChar(int i)`
  void writeChar(int i) {
    _writeChar(
      reference.pointer,
      _id_writeChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_writeInt = _class.instanceMethodId(r'writeInt', r'(I)V');

  static final _writeInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeInt(int i)`
  void writeInt(int i) {
    _writeInt(reference.pointer, _id_writeInt as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_writeLong = _class.instanceMethodId(r'writeLong', r'(J)V');

  static final _writeLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void writeLong(long j)`
  void writeLong(int j) {
    _writeLong(
      reference.pointer,
      _id_writeLong as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_writeFloat = _class.instanceMethodId(r'writeFloat', r'(F)V');

  static final _writeFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public abstract void writeFloat(float f)`
  void writeFloat(double f) {
    _writeFloat(
      reference.pointer,
      _id_writeFloat as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_writeDouble = _class.instanceMethodId(
    r'writeDouble',
    r'(D)V',
  );

  static final _writeDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public abstract void writeDouble(double d)`
  void writeDouble(double d) {
    _writeDouble(
      reference.pointer,
      _id_writeDouble as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'(Ljava/lang/String;)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeBytes(java.lang.String string)`
  void writeBytes(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeChars = _class.instanceMethodId(
    r'writeChars',
    r'(Ljava/lang/String;)V',
  );

  static final _writeChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeChars(java.lang.String string)`
  void writeChars(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeChars(
      reference.pointer,
      _id_writeChars as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_writeUTF = _class.instanceMethodId(
    r'writeUTF',
    r'(Ljava/lang/String;)V',
  );

  static final _writeUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void writeUTF(java.lang.String string)`
  void writeUTF(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _writeUTF(
      reference.pointer,
      _id_writeUTF as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ObjectOutput> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'writeObject(Ljava/lang/Object;)V') {
        _$impls[$p]!.writeObject(
          $a![0]?.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'write(I)V') {
        _$impls[$p]!.write(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'write([B)V') {
        _$impls[$p]!.write$1(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'write([BII)V') {
        _$impls[$p]!.write$2(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'flush()V') {
        _$impls[$p]!.flush();
        return jni$_.nullptr;
      }
      if ($d == r'close()V') {
        _$impls[$p]!.close();
        return jni$_.nullptr;
      }
      if ($d == r'writeBoolean(Z)V') {
        _$impls[$p]!.writeBoolean(
          $a![0]!
              .as(const jni$_.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeByte(I)V') {
        _$impls[$p]!.writeByte(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeShort(I)V') {
        _$impls[$p]!.writeShort(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeChar(I)V') {
        _$impls[$p]!.writeChar(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeInt(I)V') {
        _$impls[$p]!.writeInt(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeLong(J)V') {
        _$impls[$p]!.writeLong(
          $a![0]!
              .as(const jni$_.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeFloat(F)V') {
        _$impls[$p]!.writeFloat(
          $a![0]!
              .as(const jni$_.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeDouble(D)V') {
        _$impls[$p]!.writeDouble(
          $a![0]!
              .as(const jni$_.JDoubleType(), releaseOriginal: true)
              .doubleValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeBytes(Ljava/lang/String;)V') {
        _$impls[$p]!.writeBytes(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeChars(Ljava/lang/String;)V') {
        _$impls[$p]!.writeChars(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'writeUTF(Ljava/lang/String;)V') {
        _$impls[$p]!.writeUTF(
          $a![0]?.as(const jni$_.JStringType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $ObjectOutput $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.ObjectOutput', $p, _$invokePointer, [
      if ($impl.writeObject$async) r'writeObject(Ljava/lang/Object;)V',
      if ($impl.write$async) r'write(I)V',
      if ($impl.write$1$async) r'write([B)V',
      if ($impl.write$2$async) r'write([BII)V',
      if ($impl.flush$async) r'flush()V',
      if ($impl.close$async) r'close()V',
      if ($impl.writeBoolean$async) r'writeBoolean(Z)V',
      if ($impl.writeByte$async) r'writeByte(I)V',
      if ($impl.writeShort$async) r'writeShort(I)V',
      if ($impl.writeChar$async) r'writeChar(I)V',
      if ($impl.writeInt$async) r'writeInt(I)V',
      if ($impl.writeLong$async) r'writeLong(J)V',
      if ($impl.writeFloat$async) r'writeFloat(F)V',
      if ($impl.writeDouble$async) r'writeDouble(D)V',
      if ($impl.writeBytes$async) r'writeBytes(Ljava/lang/String;)V',
      if ($impl.writeChars$async) r'writeChars(Ljava/lang/String;)V',
      if ($impl.writeUTF$async) r'writeUTF(Ljava/lang/String;)V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ObjectOutput.implement($ObjectOutput $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ObjectOutput.fromReference($i.implementReference());
  }
}

abstract base mixin class $ObjectOutput {
  factory $ObjectOutput({
    required void Function(jni$_.JObject? object) writeObject,
    bool writeObject$async,
    required void Function(int i) write,
    bool write$async,
    required void Function(jni$_.JByteArray? bs) write$1,
    bool write$1$async,
    required void Function(jni$_.JByteArray? bs, int i, int i1) write$2,
    bool write$2$async,
    required void Function() flush,
    bool flush$async,
    required void Function() close,
    bool close$async,
    required void Function(bool z) writeBoolean,
    bool writeBoolean$async,
    required void Function(int i) writeByte,
    bool writeByte$async,
    required void Function(int i) writeShort,
    bool writeShort$async,
    required void Function(int i) writeChar,
    bool writeChar$async,
    required void Function(int i) writeInt,
    bool writeInt$async,
    required void Function(int j) writeLong,
    bool writeLong$async,
    required void Function(double f) writeFloat,
    bool writeFloat$async,
    required void Function(double d) writeDouble,
    bool writeDouble$async,
    required void Function(jni$_.JString? string) writeBytes,
    bool writeBytes$async,
    required void Function(jni$_.JString? string) writeChars,
    bool writeChars$async,
    required void Function(jni$_.JString? string) writeUTF,
    bool writeUTF$async,
  }) = _$ObjectOutput;

  void writeObject(jni$_.JObject? object);
  bool get writeObject$async => false;
  void write(int i);
  bool get write$async => false;
  void write$1(jni$_.JByteArray? bs);
  bool get write$1$async => false;
  void write$2(jni$_.JByteArray? bs, int i, int i1);
  bool get write$2$async => false;
  void flush();
  bool get flush$async => false;
  void close();
  bool get close$async => false;
  void writeBoolean(bool z);
  bool get writeBoolean$async => false;
  void writeByte(int i);
  bool get writeByte$async => false;
  void writeShort(int i);
  bool get writeShort$async => false;
  void writeChar(int i);
  bool get writeChar$async => false;
  void writeInt(int i);
  bool get writeInt$async => false;
  void writeLong(int j);
  bool get writeLong$async => false;
  void writeFloat(double f);
  bool get writeFloat$async => false;
  void writeDouble(double d);
  bool get writeDouble$async => false;
  void writeBytes(jni$_.JString? string);
  bool get writeBytes$async => false;
  void writeChars(jni$_.JString? string);
  bool get writeChars$async => false;
  void writeUTF(jni$_.JString? string);
  bool get writeUTF$async => false;
}

final class _$ObjectOutput with $ObjectOutput {
  _$ObjectOutput({
    required void Function(jni$_.JObject? object) writeObject,
    this.writeObject$async = false,
    required void Function(int i) write,
    this.write$async = false,
    required void Function(jni$_.JByteArray? bs) write$1,
    this.write$1$async = false,
    required void Function(jni$_.JByteArray? bs, int i, int i1) write$2,
    this.write$2$async = false,
    required void Function() flush,
    this.flush$async = false,
    required void Function() close,
    this.close$async = false,
    required void Function(bool z) writeBoolean,
    this.writeBoolean$async = false,
    required void Function(int i) writeByte,
    this.writeByte$async = false,
    required void Function(int i) writeShort,
    this.writeShort$async = false,
    required void Function(int i) writeChar,
    this.writeChar$async = false,
    required void Function(int i) writeInt,
    this.writeInt$async = false,
    required void Function(int j) writeLong,
    this.writeLong$async = false,
    required void Function(double f) writeFloat,
    this.writeFloat$async = false,
    required void Function(double d) writeDouble,
    this.writeDouble$async = false,
    required void Function(jni$_.JString? string) writeBytes,
    this.writeBytes$async = false,
    required void Function(jni$_.JString? string) writeChars,
    this.writeChars$async = false,
    required void Function(jni$_.JString? string) writeUTF,
    this.writeUTF$async = false,
  }) : _writeObject = writeObject,
       _write = write,
       _write$1 = write$1,
       _write$2 = write$2,
       _flush = flush,
       _close = close,
       _writeBoolean = writeBoolean,
       _writeByte = writeByte,
       _writeShort = writeShort,
       _writeChar = writeChar,
       _writeInt = writeInt,
       _writeLong = writeLong,
       _writeFloat = writeFloat,
       _writeDouble = writeDouble,
       _writeBytes = writeBytes,
       _writeChars = writeChars,
       _writeUTF = writeUTF;

  final void Function(jni$_.JObject? object) _writeObject;
  final bool writeObject$async;
  final void Function(int i) _write;
  final bool write$async;
  final void Function(jni$_.JByteArray? bs) _write$1;
  final bool write$1$async;
  final void Function(jni$_.JByteArray? bs, int i, int i1) _write$2;
  final bool write$2$async;
  final void Function() _flush;
  final bool flush$async;
  final void Function() _close;
  final bool close$async;
  final void Function(bool z) _writeBoolean;
  final bool writeBoolean$async;
  final void Function(int i) _writeByte;
  final bool writeByte$async;
  final void Function(int i) _writeShort;
  final bool writeShort$async;
  final void Function(int i) _writeChar;
  final bool writeChar$async;
  final void Function(int i) _writeInt;
  final bool writeInt$async;
  final void Function(int j) _writeLong;
  final bool writeLong$async;
  final void Function(double f) _writeFloat;
  final bool writeFloat$async;
  final void Function(double d) _writeDouble;
  final bool writeDouble$async;
  final void Function(jni$_.JString? string) _writeBytes;
  final bool writeBytes$async;
  final void Function(jni$_.JString? string) _writeChars;
  final bool writeChars$async;
  final void Function(jni$_.JString? string) _writeUTF;
  final bool writeUTF$async;

  void writeObject(jni$_.JObject? object) {
    return _writeObject(object);
  }

  void write(int i) {
    return _write(i);
  }

  void write$1(jni$_.JByteArray? bs) {
    return _write$1(bs);
  }

  void write$2(jni$_.JByteArray? bs, int i, int i1) {
    return _write$2(bs, i, i1);
  }

  void flush() {
    return _flush();
  }

  void close() {
    return _close();
  }

  void writeBoolean(bool z) {
    return _writeBoolean(z);
  }

  void writeByte(int i) {
    return _writeByte(i);
  }

  void writeShort(int i) {
    return _writeShort(i);
  }

  void writeChar(int i) {
    return _writeChar(i);
  }

  void writeInt(int i) {
    return _writeInt(i);
  }

  void writeLong(int j) {
    return _writeLong(j);
  }

  void writeFloat(double f) {
    return _writeFloat(f);
  }

  void writeDouble(double d) {
    return _writeDouble(d);
  }

  void writeBytes(jni$_.JString? string) {
    return _writeBytes(string);
  }

  void writeChars(jni$_.JString? string) {
    return _writeChars(string);
  }

  void writeUTF(jni$_.JString? string) {
    return _writeUTF(string);
  }
}

final class $ObjectOutput$NullableType extends jni$_.JObjType<ObjectOutput?> {
  @jni$_.internal
  const $ObjectOutput$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectOutput;';

  @jni$_.internal
  @core$_.override
  ObjectOutput? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectOutput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectOutput?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectOutput$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectOutput$NullableType) &&
        other is $ObjectOutput$NullableType;
  }
}

final class $ObjectOutput$Type extends jni$_.JObjType<ObjectOutput> {
  @jni$_.internal
  const $ObjectOutput$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectOutput;';

  @jni$_.internal
  @core$_.override
  ObjectOutput fromReference(jni$_.JReference reference) =>
      ObjectOutput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectOutput?> get nullableType =>
      const $ObjectOutput$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectOutput$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectOutput$Type) &&
        other is $ObjectOutput$Type;
  }
}

/// from: `java.io.ObjectInputStream`
class ObjectInputStream extends InputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInputStream> $type;

  @jni$_.internal
  ObjectInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInputStream$NullableType();
  static const type = $ObjectInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/InputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ObjectInputStream(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return ObjectInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
      ).reference,
    );
  }

  static final _id_readObject = _class.instanceMethodId(
    r'readObject',
    r'()Ljava/lang/Object;',
  );

  static final _readObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.Object readObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? readObject() {
    return _readObject(
      reference.pointer,
      _id_readObject as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_readUnshared = _class.instanceMethodId(
    r'readUnshared',
    r'()Ljava/lang/Object;',
  );

  static final _readUnshared =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Object readUnshared()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? readUnshared() {
    return _readUnshared(
      reference.pointer,
      _id_readUnshared as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_defaultReadObject = _class.instanceMethodId(
    r'defaultReadObject',
    r'()V',
  );

  static final _defaultReadObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void defaultReadObject()`
  void defaultReadObject() {
    _defaultReadObject(
      reference.pointer,
      _id_defaultReadObject as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_readFields = _class.instanceMethodId(
    r'readFields',
    r'()Ljava/io/ObjectInputStream$GetField;',
  );

  static final _readFields =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.ObjectInputStream$GetField readFields()`
  /// The returned object must be released after use, by calling the [release] method.
  ObjectInputStream$GetField? readFields() {
    return _readFields(
      reference.pointer,
      _id_readFields as jni$_.JMethodIDPtr,
    ).object<ObjectInputStream$GetField?>(
      const $ObjectInputStream$GetField$NullableType(),
    );
  }

  static final _id_registerValidation = _class.instanceMethodId(
    r'registerValidation',
    r'(Ljava/io/ObjectInputValidation;I)V',
  );

  static final _registerValidation =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void registerValidation(java.io.ObjectInputValidation objectInputValidation, int i)`
  void registerValidation(ObjectInputValidation? objectInputValidation, int i) {
    final _$objectInputValidation =
        objectInputValidation?.reference ?? jni$_.jNullReference;
    _registerValidation(
      reference.pointer,
      _id_registerValidation as jni$_.JMethodIDPtr,
      _$objectInputValidation.pointer,
      i,
    ).check();
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() {
    return _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() {
    return _available(
      reference.pointer,
      _id_available as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_readBoolean = _class.instanceMethodId(
    r'readBoolean',
    r'()Z',
  );

  static final _readBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean readBoolean()`
  bool readBoolean() {
    return _readBoolean(
      reference.pointer,
      _id_readBoolean as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_readByte = _class.instanceMethodId(r'readByte', r'()B');

  static final _readByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte readByte()`
  int readByte() {
    return _readByte(
      reference.pointer,
      _id_readByte as jni$_.JMethodIDPtr,
    ).byte;
  }

  static final _id_readUnsignedByte = _class.instanceMethodId(
    r'readUnsignedByte',
    r'()I',
  );

  static final _readUnsignedByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int readUnsignedByte()`
  int readUnsignedByte() {
    return _readUnsignedByte(
      reference.pointer,
      _id_readUnsignedByte as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readChar = _class.instanceMethodId(r'readChar', r'()C');

  static final _readChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char readChar()`
  int readChar() {
    return _readChar(
      reference.pointer,
      _id_readChar as jni$_.JMethodIDPtr,
    ).char;
  }

  static final _id_readShort = _class.instanceMethodId(r'readShort', r'()S');

  static final _readShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public short readShort()`
  int readShort() {
    return _readShort(
      reference.pointer,
      _id_readShort as jni$_.JMethodIDPtr,
    ).short;
  }

  static final _id_readUnsignedShort = _class.instanceMethodId(
    r'readUnsignedShort',
    r'()I',
  );

  static final _readUnsignedShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int readUnsignedShort()`
  int readUnsignedShort() {
    return _readUnsignedShort(
      reference.pointer,
      _id_readUnsignedShort as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readInt = _class.instanceMethodId(r'readInt', r'()I');

  static final _readInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int readInt()`
  int readInt() {
    return _readInt(
      reference.pointer,
      _id_readInt as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readLong = _class.instanceMethodId(r'readLong', r'()J');

  static final _readLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long readLong()`
  int readLong() {
    return _readLong(
      reference.pointer,
      _id_readLong as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_readFloat = _class.instanceMethodId(r'readFloat', r'()F');

  static final _readFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float readFloat()`
  double readFloat() {
    return _readFloat(
      reference.pointer,
      _id_readFloat as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_readDouble = _class.instanceMethodId(r'readDouble', r'()D');

  static final _readDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double readDouble()`
  double readDouble() {
    return _readDouble(
      reference.pointer,
      _id_readDouble as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_readFully = _class.instanceMethodId(r'readFully', r'([B)V');

  static final _readFully =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void readFully(byte[] bs)`
  void readFully(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully(
      reference.pointer,
      _id_readFully as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_readFully$1 = _class.instanceMethodId(
    r'readFully',
    r'([BII)V',
  );

  static final _readFully$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void readFully(byte[] bs, int i, int i1)`
  void readFully$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully$1(
      reference.pointer,
      _id_readFully$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_skipBytes = _class.instanceMethodId(r'skipBytes', r'(I)I');

  static final _skipBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public int skipBytes(int i)`
  int skipBytes(int i) {
    return _skipBytes(
      reference.pointer,
      _id_skipBytes as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine() {
    return _readLine(
      reference.pointer,
      _id_readLine as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_readUTF = _class.instanceMethodId(
    r'readUTF',
    r'()Ljava/lang/String;',
  );

  static final _readUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String readUTF()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readUTF() {
    return _readUTF(
      reference.pointer,
      _id_readUTF as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getObjectInputFilter = _class.instanceMethodId(
    r'getObjectInputFilter',
    r'()Ljava/io/ObjectInputFilter;',
  );

  static final _getObjectInputFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.io.ObjectInputFilter getObjectInputFilter()`
  /// The returned object must be released after use, by calling the [release] method.
  ObjectInputFilter? getObjectInputFilter() {
    return _getObjectInputFilter(
      reference.pointer,
      _id_getObjectInputFilter as jni$_.JMethodIDPtr,
    ).object<ObjectInputFilter?>(const $ObjectInputFilter$NullableType());
  }

  static final _id_setObjectInputFilter = _class.instanceMethodId(
    r'setObjectInputFilter',
    r'(Ljava/io/ObjectInputFilter;)V',
  );

  static final _setObjectInputFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void setObjectInputFilter(java.io.ObjectInputFilter objectInputFilter)`
  void setObjectInputFilter(ObjectInputFilter? objectInputFilter) {
    final _$objectInputFilter =
        objectInputFilter?.reference ?? jni$_.jNullReference;
    _setObjectInputFilter(
      reference.pointer,
      _id_setObjectInputFilter as jni$_.JMethodIDPtr,
      _$objectInputFilter.pointer,
    ).check();
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'([B)I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract int read(byte[] bs)`
  int read1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read1(
      reference.pointer,
      _id_read1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }
}

final class $ObjectInputStream$NullableType
    extends jni$_.JObjType<ObjectInputStream?> {
  @jni$_.internal
  const $ObjectInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputStream;';

  @jni$_.internal
  @core$_.override
  ObjectInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ObjectInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInputStream$NullableType) &&
        other is $ObjectInputStream$NullableType;
  }
}

final class $ObjectInputStream$Type extends jni$_.JObjType<ObjectInputStream> {
  @jni$_.internal
  const $ObjectInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputStream;';

  @jni$_.internal
  @core$_.override
  ObjectInputStream fromReference(jni$_.JReference reference) =>
      ObjectInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputStream?> get nullableType =>
      const $ObjectInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ObjectInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInputStream$Type) &&
        other is $ObjectInputStream$Type;
  }
}

/// from: `java.io.LineNumberInputStream`
class LineNumberInputStream extends FilterInputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<LineNumberInputStream> $type;

  @jni$_.internal
  LineNumberInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/LineNumberInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $LineNumberInputStream$NullableType();
  static const type = $LineNumberInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/InputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory LineNumberInputStream(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return LineNumberInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
      ).reference,
    );
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() {
    return _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_setLineNumber = _class.instanceMethodId(
    r'setLineNumber',
    r'(I)V',
  );

  static final _setLineNumber =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setLineNumber(int i)`
  void setLineNumber(int i) {
    _setLineNumber(
      reference.pointer,
      _id_setLineNumber as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getLineNumber = _class.instanceMethodId(
    r'getLineNumber',
    r'()I',
  );

  static final _getLineNumber =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLineNumber()`
  int getLineNumber() {
    return _getLineNumber(
      reference.pointer,
      _id_getLineNumber as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() {
    return _available(
      reference.pointer,
      _id_available as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }
}

final class $LineNumberInputStream$NullableType
    extends jni$_.JObjType<LineNumberInputStream?> {
  @jni$_.internal
  const $LineNumberInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/LineNumberInputStream;';

  @jni$_.internal
  @core$_.override
  LineNumberInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : LineNumberInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LineNumberInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($LineNumberInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($LineNumberInputStream$NullableType) &&
        other is $LineNumberInputStream$NullableType;
  }
}

final class $LineNumberInputStream$Type
    extends jni$_.JObjType<LineNumberInputStream> {
  @jni$_.internal
  const $LineNumberInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/LineNumberInputStream;';

  @jni$_.internal
  @core$_.override
  LineNumberInputStream fromReference(jni$_.JReference reference) =>
      LineNumberInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LineNumberInputStream?> get nullableType =>
      const $LineNumberInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($LineNumberInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($LineNumberInputStream$Type) &&
        other is $LineNumberInputStream$Type;
  }
}

/// from: `java.io.ByteArrayInputStream`
class ByteArrayInputStream extends InputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ByteArrayInputStream> $type;

  @jni$_.internal
  ByteArrayInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ByteArrayInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ByteArrayInputStream$NullableType();
  static const type = $ByteArrayInputStream$Type();
  static final _id_new$ = _class.constructorId(r'([B)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ByteArrayInputStream(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return ByteArrayInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$bs.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'([BII)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void <init>(byte[] bs, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ByteArrayInputStream.new$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return ByteArrayInputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$bs.pointer,
        i,
        i1,
      ).reference,
    );
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() {
    return _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_readAllBytes = _class.instanceMethodId(
    r'readAllBytes',
    r'()[B',
  );

  static final _readAllBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] readAllBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? readAllBytes() {
    return _readAllBytes(
      reference.pointer,
      _id_readAllBytes as jni$_.JMethodIDPtr,
    ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_readNBytes1 = _class.instanceMethodId(
    r'readNBytes',
    r'([BII)I',
  );

  static final _readNBytes1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int readNBytes(byte[] bs, int i, int i1)`
  int readNBytes1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _readNBytes1(
      reference.pointer,
      _id_readNBytes1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_transferTo = _class.instanceMethodId(
    r'transferTo',
    r'(Ljava/io/OutputStream;)J',
  );

  static final _transferTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long transferTo(java.io.OutputStream outputStream)`
  int transferTo(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return _transferTo(
      reference.pointer,
      _id_transferTo as jni$_.JMethodIDPtr,
      _$outputStream.pointer,
    ).long;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() {
    return _available(
      reference.pointer,
      _id_available as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() {
    return _markSupported(
      reference.pointer,
      _id_markSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $ByteArrayInputStream$NullableType
    extends jni$_.JObjType<ByteArrayInputStream?> {
  @jni$_.internal
  const $ByteArrayInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ByteArrayInputStream;';

  @jni$_.internal
  @core$_.override
  ByteArrayInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ByteArrayInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ByteArrayInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ByteArrayInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ByteArrayInputStream$NullableType) &&
        other is $ByteArrayInputStream$NullableType;
  }
}

final class $ByteArrayInputStream$Type
    extends jni$_.JObjType<ByteArrayInputStream> {
  @jni$_.internal
  const $ByteArrayInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ByteArrayInputStream;';

  @jni$_.internal
  @core$_.override
  ByteArrayInputStream fromReference(jni$_.JReference reference) =>
      ByteArrayInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ByteArrayInputStream?> get nullableType =>
      const $ByteArrayInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ByteArrayInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ByteArrayInputStream$Type) &&
        other is $ByteArrayInputStream$Type;
  }
}

/// from: `java.io.StreamTokenizer`
class StreamTokenizer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StreamTokenizer> $type;

  @jni$_.internal
  StreamTokenizer.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/StreamTokenizer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StreamTokenizer$NullableType();
  static const type = $StreamTokenizer$Type();
  static final _id_ttype = _class.instanceFieldId(r'ttype', r'I');

  /// from: `public int ttype`
  int get ttype => _id_ttype.get(this, const jni$_.jintType());

  /// from: `public int ttype`
  set ttype(int value) => _id_ttype.set(this, const jni$_.jintType(), value);

  /// from: `static public final int TT_EOF`
  static const TT_EOF = -1;

  /// from: `static public final int TT_EOL`
  static const TT_EOL = 10;

  /// from: `static public final int TT_NUMBER`
  static const TT_NUMBER = -2;

  /// from: `static public final int TT_WORD`
  static const TT_WORD = -3;
  static final _id_sval = _class.instanceFieldId(
    r'sval',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String sval`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get sval =>
      _id_sval.get(this, const jni$_.JStringNullableType());

  /// from: `public java.lang.String sval`
  /// The returned object must be released after use, by calling the [release] method.
  set sval(jni$_.JString? value) =>
      _id_sval.set(this, const jni$_.JStringNullableType(), value);

  static final _id_nval = _class.instanceFieldId(r'nval', r'D');

  /// from: `public double nval`
  double get nval => _id_nval.get(this, const jni$_.jdoubleType());

  /// from: `public double nval`
  set nval(double value) =>
      _id_nval.set(this, const jni$_.jdoubleType(), value);

  static final _id_new$ = _class.constructorId(r'(Ljava/io/InputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StreamTokenizer(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return StreamTokenizer.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/Reader;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.Reader reader)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StreamTokenizer.new$1(Reader? reader) {
    final _$reader = reader?.reference ?? jni$_.jNullReference;
    return StreamTokenizer.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$reader.pointer,
      ).reference,
    );
  }

  static final _id_resetSyntax = _class.instanceMethodId(
    r'resetSyntax',
    r'()V',
  );

  static final _resetSyntax =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void resetSyntax()`
  void resetSyntax() {
    _resetSyntax(
      reference.pointer,
      _id_resetSyntax as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_wordChars = _class.instanceMethodId(r'wordChars', r'(II)V');

  static final _wordChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void wordChars(int i, int i1)`
  void wordChars(int i, int i1) {
    _wordChars(
      reference.pointer,
      _id_wordChars as jni$_.JMethodIDPtr,
      i,
      i1,
    ).check();
  }

  static final _id_whitespaceChars = _class.instanceMethodId(
    r'whitespaceChars',
    r'(II)V',
  );

  static final _whitespaceChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void whitespaceChars(int i, int i1)`
  void whitespaceChars(int i, int i1) {
    _whitespaceChars(
      reference.pointer,
      _id_whitespaceChars as jni$_.JMethodIDPtr,
      i,
      i1,
    ).check();
  }

  static final _id_ordinaryChars = _class.instanceMethodId(
    r'ordinaryChars',
    r'(II)V',
  );

  static final _ordinaryChars =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void ordinaryChars(int i, int i1)`
  void ordinaryChars(int i, int i1) {
    _ordinaryChars(
      reference.pointer,
      _id_ordinaryChars as jni$_.JMethodIDPtr,
      i,
      i1,
    ).check();
  }

  static final _id_ordinaryChar = _class.instanceMethodId(
    r'ordinaryChar',
    r'(I)V',
  );

  static final _ordinaryChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void ordinaryChar(int i)`
  void ordinaryChar(int i) {
    _ordinaryChar(
      reference.pointer,
      _id_ordinaryChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_commentChar = _class.instanceMethodId(
    r'commentChar',
    r'(I)V',
  );

  static final _commentChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void commentChar(int i)`
  void commentChar(int i) {
    _commentChar(
      reference.pointer,
      _id_commentChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_quoteChar = _class.instanceMethodId(r'quoteChar', r'(I)V');

  static final _quoteChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void quoteChar(int i)`
  void quoteChar(int i) {
    _quoteChar(
      reference.pointer,
      _id_quoteChar as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_parseNumbers = _class.instanceMethodId(
    r'parseNumbers',
    r'()V',
  );

  static final _parseNumbers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void parseNumbers()`
  void parseNumbers() {
    _parseNumbers(
      reference.pointer,
      _id_parseNumbers as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_eolIsSignificant = _class.instanceMethodId(
    r'eolIsSignificant',
    r'(Z)V',
  );

  static final _eolIsSignificant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void eolIsSignificant(boolean z)`
  void eolIsSignificant(bool z) {
    _eolIsSignificant(
      reference.pointer,
      _id_eolIsSignificant as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_slashStarComments = _class.instanceMethodId(
    r'slashStarComments',
    r'(Z)V',
  );

  static final _slashStarComments =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void slashStarComments(boolean z)`
  void slashStarComments(bool z) {
    _slashStarComments(
      reference.pointer,
      _id_slashStarComments as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_slashSlashComments = _class.instanceMethodId(
    r'slashSlashComments',
    r'(Z)V',
  );

  static final _slashSlashComments =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void slashSlashComments(boolean z)`
  void slashSlashComments(bool z) {
    _slashSlashComments(
      reference.pointer,
      _id_slashSlashComments as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_lowerCaseMode = _class.instanceMethodId(
    r'lowerCaseMode',
    r'(Z)V',
  );

  static final _lowerCaseMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void lowerCaseMode(boolean z)`
  void lowerCaseMode(bool z) {
    _lowerCaseMode(
      reference.pointer,
      _id_lowerCaseMode as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_nextToken = _class.instanceMethodId(r'nextToken', r'()I');

  static final _nextToken =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int nextToken()`
  int nextToken() {
    return _nextToken(
      reference.pointer,
      _id_nextToken as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_pushBack = _class.instanceMethodId(r'pushBack', r'()V');

  static final _pushBack =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void pushBack()`
  void pushBack() {
    _pushBack(reference.pointer, _id_pushBack as jni$_.JMethodIDPtr).check();
  }

  static final _id_lineno = _class.instanceMethodId(r'lineno', r'()I');

  static final _lineno =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int lineno()`
  int lineno() {
    return _lineno(reference.pointer, _id_lineno as jni$_.JMethodIDPtr).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $StreamTokenizer$NullableType
    extends jni$_.JObjType<StreamTokenizer?> {
  @jni$_.internal
  const $StreamTokenizer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StreamTokenizer;';

  @jni$_.internal
  @core$_.override
  StreamTokenizer? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : StreamTokenizer.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StreamTokenizer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StreamTokenizer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StreamTokenizer$NullableType) &&
        other is $StreamTokenizer$NullableType;
  }
}

final class $StreamTokenizer$Type extends jni$_.JObjType<StreamTokenizer> {
  @jni$_.internal
  const $StreamTokenizer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StreamTokenizer;';

  @jni$_.internal
  @core$_.override
  StreamTokenizer fromReference(jni$_.JReference reference) =>
      StreamTokenizer.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StreamTokenizer?> get nullableType =>
      const $StreamTokenizer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($StreamTokenizer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StreamTokenizer$Type) &&
        other is $StreamTokenizer$Type;
  }
}

/// from: `java.io.Serial`
class Serial extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Serial> $type;

  @jni$_.internal
  Serial.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Serial');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Serial$NullableType();
  static const type = $Serial$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Serial> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $Serial $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.Serial', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Serial.implement($Serial $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Serial.fromReference($i.implementReference());
  }
}

abstract base mixin class $Serial {
  factory $Serial() = _$Serial;
}

final class _$Serial with $Serial {
  _$Serial();
}

final class $Serial$NullableType extends jni$_.JObjType<Serial?> {
  @jni$_.internal
  const $Serial$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Serial;';

  @jni$_.internal
  @core$_.override
  Serial? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Serial.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Serial?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Serial$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Serial$NullableType) &&
        other is $Serial$NullableType;
  }
}

final class $Serial$Type extends jni$_.JObjType<Serial> {
  @jni$_.internal
  const $Serial$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Serial;';

  @jni$_.internal
  @core$_.override
  Serial fromReference(jni$_.JReference reference) =>
      Serial.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Serial?> get nullableType => const $Serial$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Serial$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Serial$Type) && other is $Serial$Type;
  }
}

/// from: `java.io.LineNumberReader`
class LineNumberReader extends BufferedReader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<LineNumberReader> $type;

  @jni$_.internal
  LineNumberReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/LineNumberReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $LineNumberReader$NullableType();
  static const type = $LineNumberReader$Type();
  static final _id_new1 = _class.constructorId(r'(Ljava/io/Reader;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.Reader reader)`
  /// The returned object must be released after use, by calling the [release] method.
  factory LineNumberReader.new1(Reader? reader) {
    final _$reader = reader?.reference ?? jni$_.jNullReference;
    return LineNumberReader.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$reader.pointer,
      ).reference,
    );
  }

  static final _id_new$ = _class.constructorId(r'(Ljava/io/Reader;I)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.Reader reader, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory LineNumberReader(Reader? reader, int i) {
    final _$reader = reader?.reference ?? jni$_.jNullReference;
    return LineNumberReader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$reader.pointer,
        i,
      ).reference,
    );
  }

  static final _id_setLineNumber = _class.instanceMethodId(
    r'setLineNumber',
    r'(I)V',
  );

  static final _setLineNumber =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setLineNumber(int i)`
  void setLineNumber(int i) {
    _setLineNumber(
      reference.pointer,
      _id_setLineNumber as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getLineNumber = _class.instanceMethodId(
    r'getLineNumber',
    r'()I',
  );

  static final _getLineNumber =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getLineNumber()`
  int getLineNumber() {
    return _getLineNumber(
      reference.pointer,
      _id_getLineNumber as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() {
    return _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine() {
    return _readLine(
      reference.pointer,
      _id_readLine as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }
}

final class $LineNumberReader$NullableType
    extends jni$_.JObjType<LineNumberReader?> {
  @jni$_.internal
  const $LineNumberReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/LineNumberReader;';

  @jni$_.internal
  @core$_.override
  LineNumberReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : LineNumberReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $BufferedReader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LineNumberReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($LineNumberReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($LineNumberReader$NullableType) &&
        other is $LineNumberReader$NullableType;
  }
}

final class $LineNumberReader$Type extends jni$_.JObjType<LineNumberReader> {
  @jni$_.internal
  const $LineNumberReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/LineNumberReader;';

  @jni$_.internal
  @core$_.override
  LineNumberReader fromReference(jni$_.JReference reference) =>
      LineNumberReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $BufferedReader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<LineNumberReader?> get nullableType =>
      const $LineNumberReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($LineNumberReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($LineNumberReader$Type) &&
        other is $LineNumberReader$Type;
  }
}

/// from: `java.io.CharArrayWriter`
class CharArrayWriter extends Writer {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CharArrayWriter> $type;

  @jni$_.internal
  CharArrayWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/CharArrayWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CharArrayWriter$NullableType();
  static const type = $CharArrayWriter$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory CharArrayWriter() {
    return CharArrayWriter.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CharArrayWriter.new$1(int i) {
    return CharArrayWriter.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        i,
      ).reference,
    );
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(char[] cs, int i, int i1)`
  void write2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write4 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;II)V',
  );

  static final _write4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(java.lang.String string, int i, int i1)`
  void write4(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write4(
      reference.pointer,
      _id_write4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_writeTo = _class.instanceMethodId(
    r'writeTo',
    r'(Ljava/io/Writer;)V',
  );

  static final _writeTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeTo(java.io.Writer writer)`
  void writeTo(Writer? writer) {
    final _$writer = writer?.reference ?? jni$_.jNullReference;
    _writeTo(
      reference.pointer,
      _id_writeTo as jni$_.JMethodIDPtr,
      _$writer.pointer,
    ).check();
  }

  static final _id_append$3 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;)Ljava/io/CharArrayWriter;',
  );

  static final _append$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.CharArrayWriter append(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  CharArrayWriter? append$3(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$3(
      reference.pointer,
      _id_append$3 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<CharArrayWriter?>(const $CharArrayWriter$NullableType());
  }

  static final _id_append$4 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;II)Ljava/io/CharArrayWriter;',
  );

  static final _append$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public java.io.CharArrayWriter append(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  CharArrayWriter? append$4(jni$_.JObject? charSequence, int i, int i1) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$4(
      reference.pointer,
      _id_append$4 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
    ).object<CharArrayWriter?>(const $CharArrayWriter$NullableType());
  }

  static final _id_append$5 = _class.instanceMethodId(
    r'append',
    r'(C)Ljava/io/CharArrayWriter;',
  );

  static final _append$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.io.CharArrayWriter append(char c)`
  /// The returned object must be released after use, by calling the [release] method.
  CharArrayWriter? append$5(int c) {
    return _append$5(
      reference.pointer,
      _id_append$5 as jni$_.JMethodIDPtr,
      c,
    ).object<CharArrayWriter?>(const $CharArrayWriter$NullableType());
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_toCharArray = _class.instanceMethodId(
    r'toCharArray',
    r'()[C',
  );

  static final _toCharArray =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public char[] toCharArray()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JCharArray? toCharArray() {
    return _toCharArray(
      reference.pointer,
      _id_toCharArray as jni$_.JMethodIDPtr,
    ).object<jni$_.JCharArray?>(const jni$_.JCharArrayNullableType());
  }

  static final _id_size = _class.instanceMethodId(r'size', r'()I');

  static final _size =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int size()`
  int size() {
    return _size(reference.pointer, _id_size as jni$_.JMethodIDPtr).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $CharArrayWriter$NullableType
    extends jni$_.JObjType<CharArrayWriter?> {
  @jni$_.internal
  const $CharArrayWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/CharArrayWriter;';

  @jni$_.internal
  @core$_.override
  CharArrayWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : CharArrayWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CharArrayWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($CharArrayWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CharArrayWriter$NullableType) &&
        other is $CharArrayWriter$NullableType;
  }
}

final class $CharArrayWriter$Type extends jni$_.JObjType<CharArrayWriter> {
  @jni$_.internal
  const $CharArrayWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/CharArrayWriter;';

  @jni$_.internal
  @core$_.override
  CharArrayWriter fromReference(jni$_.JReference reference) =>
      CharArrayWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CharArrayWriter?> get nullableType =>
      const $CharArrayWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($CharArrayWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CharArrayWriter$Type) &&
        other is $CharArrayWriter$Type;
  }
}

/// from: `java.io.EOFException`
class EOFException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<EOFException> $type;

  @jni$_.internal
  EOFException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/EOFException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $EOFException$NullableType();
  static const type = $EOFException$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory EOFException() {
    return EOFException.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory EOFException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return EOFException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $EOFException$NullableType extends jni$_.JObjType<EOFException?> {
  @jni$_.internal
  const $EOFException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/EOFException;';

  @jni$_.internal
  @core$_.override
  EOFException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : EOFException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EOFException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($EOFException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EOFException$NullableType) &&
        other is $EOFException$NullableType;
  }
}

final class $EOFException$Type extends jni$_.JObjType<EOFException> {
  @jni$_.internal
  const $EOFException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/EOFException;';

  @jni$_.internal
  @core$_.override
  EOFException fromReference(jni$_.JReference reference) =>
      EOFException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<EOFException?> get nullableType =>
      const $EOFException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($EOFException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($EOFException$Type) &&
        other is $EOFException$Type;
  }
}

/// from: `java.io.FileNotFoundException`
class FileNotFoundException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileNotFoundException> $type;

  @jni$_.internal
  FileNotFoundException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FileNotFoundException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileNotFoundException$NullableType();
  static const type = $FileNotFoundException$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileNotFoundException() {
    return FileNotFoundException.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileNotFoundException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return FileNotFoundException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $FileNotFoundException$NullableType
    extends jni$_.JObjType<FileNotFoundException?> {
  @jni$_.internal
  const $FileNotFoundException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileNotFoundException;';

  @jni$_.internal
  @core$_.override
  FileNotFoundException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileNotFoundException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileNotFoundException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FileNotFoundException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileNotFoundException$NullableType) &&
        other is $FileNotFoundException$NullableType;
  }
}

final class $FileNotFoundException$Type
    extends jni$_.JObjType<FileNotFoundException> {
  @jni$_.internal
  const $FileNotFoundException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileNotFoundException;';

  @jni$_.internal
  @core$_.override
  FileNotFoundException fromReference(jni$_.JReference reference) =>
      FileNotFoundException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileNotFoundException?> get nullableType =>
      const $FileNotFoundException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FileNotFoundException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileNotFoundException$Type) &&
        other is $FileNotFoundException$Type;
  }
}

/// from: `java.io.CharConversionException`
class CharConversionException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<CharConversionException> $type;

  @jni$_.internal
  CharConversionException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/CharConversionException',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $CharConversionException$NullableType();
  static const type = $CharConversionException$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory CharConversionException() {
    return CharConversionException.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CharConversionException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return CharConversionException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $CharConversionException$NullableType
    extends jni$_.JObjType<CharConversionException?> {
  @jni$_.internal
  const $CharConversionException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/CharConversionException;';

  @jni$_.internal
  @core$_.override
  CharConversionException? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : CharConversionException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CharConversionException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($CharConversionException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CharConversionException$NullableType) &&
        other is $CharConversionException$NullableType;
  }
}

final class $CharConversionException$Type
    extends jni$_.JObjType<CharConversionException> {
  @jni$_.internal
  const $CharConversionException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/CharConversionException;';

  @jni$_.internal
  @core$_.override
  CharConversionException fromReference(jni$_.JReference reference) =>
      CharConversionException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<CharConversionException?> get nullableType =>
      const $CharConversionException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($CharConversionException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CharConversionException$Type) &&
        other is $CharConversionException$Type;
  }
}

/// from: `java.io.ObjectInputFilter$Config`
class ObjectInputFilter$Config extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInputFilter$Config> $type;

  @jni$_.internal
  ObjectInputFilter$Config.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/ObjectInputFilter$Config',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInputFilter$Config$NullableType();
  static const type = $ObjectInputFilter$Config$Type();
  static final _id_getSerialFilter = _class.staticMethodId(
    r'getSerialFilter',
    r'()Ljava/io/ObjectInputFilter;',
  );

  static final _getSerialFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter getSerialFilter()`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter? getSerialFilter() {
    return _getSerialFilter(
      _class.reference.pointer,
      _id_getSerialFilter as jni$_.JMethodIDPtr,
    ).object<ObjectInputFilter?>(const $ObjectInputFilter$NullableType());
  }

  static final _id_setSerialFilter = _class.staticMethodId(
    r'setSerialFilter',
    r'(Ljava/io/ObjectInputFilter;)V',
  );

  static final _setSerialFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setSerialFilter(java.io.ObjectInputFilter objectInputFilter)`
  static void setSerialFilter(ObjectInputFilter? objectInputFilter) {
    final _$objectInputFilter =
        objectInputFilter?.reference ?? jni$_.jNullReference;
    _setSerialFilter(
      _class.reference.pointer,
      _id_setSerialFilter as jni$_.JMethodIDPtr,
      _$objectInputFilter.pointer,
    ).check();
  }

  static final _id_getSerialFilterFactory = _class.staticMethodId(
    r'getSerialFilterFactory',
    r'()Ljava/util/function/BinaryOperator;',
  );

  static final _getSerialFilterFactory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.util.function.BinaryOperator<java.io.ObjectInputFilter> getSerialFilterFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? getSerialFilterFactory() {
    return _getSerialFilterFactory(
      _class.reference.pointer,
      _id_getSerialFilterFactory as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setSerialFilterFactory = _class.staticMethodId(
    r'setSerialFilterFactory',
    r'(Ljava/util/function/BinaryOperator;)V',
  );

  static final _setSerialFilterFactory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public void setSerialFilterFactory(java.util.function.BinaryOperator<java.io.ObjectInputFilter> binaryOperator)`
  static void setSerialFilterFactory(jni$_.JObject? binaryOperator) {
    final _$binaryOperator = binaryOperator?.reference ?? jni$_.jNullReference;
    _setSerialFilterFactory(
      _class.reference.pointer,
      _id_setSerialFilterFactory as jni$_.JMethodIDPtr,
      _$binaryOperator.pointer,
    ).check();
  }

  static final _id_createFilter = _class.staticMethodId(
    r'createFilter',
    r'(Ljava/lang/String;)Ljava/io/ObjectInputFilter;',
  );

  static final _createFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter createFilter(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter? createFilter(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _createFilter(
      _class.reference.pointer,
      _id_createFilter as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<ObjectInputFilter?>(const $ObjectInputFilter$NullableType());
  }
}

final class $ObjectInputFilter$Config$NullableType
    extends jni$_.JObjType<ObjectInputFilter$Config?> {
  @jni$_.internal
  const $ObjectInputFilter$Config$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter$Config;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter$Config? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ObjectInputFilter$Config.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter$Config?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$Config$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInputFilter$Config$NullableType) &&
        other is $ObjectInputFilter$Config$NullableType;
  }
}

final class $ObjectInputFilter$Config$Type
    extends jni$_.JObjType<ObjectInputFilter$Config> {
  @jni$_.internal
  const $ObjectInputFilter$Config$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter$Config;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter$Config fromReference(jni$_.JReference reference) =>
      ObjectInputFilter$Config.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter$Config?> get nullableType =>
      const $ObjectInputFilter$Config$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$Config$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInputFilter$Config$Type) &&
        other is $ObjectInputFilter$Config$Type;
  }
}

/// from: `java.io.PushbackReader`
class PushbackReader extends FilterReader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PushbackReader> $type;

  @jni$_.internal
  PushbackReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PushbackReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PushbackReader$NullableType();
  static const type = $PushbackReader$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/Reader;I)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.Reader reader, int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PushbackReader(Reader? reader, int i) {
    final _$reader = reader?.reference ?? jni$_.jNullReference;
    return PushbackReader.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$reader.pointer,
        i,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/Reader;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.Reader reader)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PushbackReader.new$1(Reader? reader) {
    final _$reader = reader?.reference ?? jni$_.jNullReference;
    return PushbackReader.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$reader.pointer,
      ).reference,
    );
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'()I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read1() {
    return _read1(reference.pointer, _id_read1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read3 = _class.instanceMethodId(r'read', r'([CII)I');

  static final _read3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(char[] cs, int i, int i1)`
  int read3(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _read3(
      reference.pointer,
      _id_read3 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_unread = _class.instanceMethodId(r'unread', r'(I)V');

  static final _unread =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void unread(int i)`
  void unread(int i) {
    _unread(reference.pointer, _id_unread as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_unread$1 = _class.instanceMethodId(r'unread', r'([CII)V');

  static final _unread$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void unread(char[] cs, int i, int i1)`
  void unread$1(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _unread$1(
      reference.pointer,
      _id_unread$1 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_unread$2 = _class.instanceMethodId(r'unread', r'([C)V');

  static final _unread$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void unread(char[] cs)`
  void unread$2(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _unread$2(
      reference.pointer,
      _id_unread$2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).check();
  }

  static final _id_ready = _class.instanceMethodId(r'ready', r'()Z');

  static final _ready =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean ready()`
  bool ready() {
    return _ready(reference.pointer, _id_ready as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() {
    return _markSupported(
      reference.pointer,
      _id_markSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }
}

final class $PushbackReader$NullableType
    extends jni$_.JObjType<PushbackReader?> {
  @jni$_.internal
  const $PushbackReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PushbackReader;';

  @jni$_.internal
  @core$_.override
  PushbackReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PushbackReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterReader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PushbackReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($PushbackReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PushbackReader$NullableType) &&
        other is $PushbackReader$NullableType;
  }
}

final class $PushbackReader$Type extends jni$_.JObjType<PushbackReader> {
  @jni$_.internal
  const $PushbackReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PushbackReader;';

  @jni$_.internal
  @core$_.override
  PushbackReader fromReference(jni$_.JReference reference) =>
      PushbackReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterReader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PushbackReader?> get nullableType =>
      const $PushbackReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($PushbackReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PushbackReader$Type) &&
        other is $PushbackReader$Type;
  }
}

/// from: `java.io.DataInput`
class DataInput extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DataInput> $type;

  @jni$_.internal
  DataInput.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/DataInput');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DataInput$NullableType();
  static const type = $DataInput$Type();
  static final _id_readFully = _class.instanceMethodId(r'readFully', r'([B)V');

  static final _readFully =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void readFully(byte[] bs)`
  void readFully(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully(
      reference.pointer,
      _id_readFully as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_readFully$1 = _class.instanceMethodId(
    r'readFully',
    r'([BII)V',
  );

  static final _readFully$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract void readFully(byte[] bs, int i, int i1)`
  void readFully$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully$1(
      reference.pointer,
      _id_readFully$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_skipBytes = _class.instanceMethodId(r'skipBytes', r'(I)I');

  static final _skipBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract int skipBytes(int i)`
  int skipBytes(int i) {
    return _skipBytes(
      reference.pointer,
      _id_skipBytes as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_readBoolean = _class.instanceMethodId(
    r'readBoolean',
    r'()Z',
  );

  static final _readBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract boolean readBoolean()`
  bool readBoolean() {
    return _readBoolean(
      reference.pointer,
      _id_readBoolean as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_readByte = _class.instanceMethodId(r'readByte', r'()B');

  static final _readByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract byte readByte()`
  int readByte() {
    return _readByte(
      reference.pointer,
      _id_readByte as jni$_.JMethodIDPtr,
    ).byte;
  }

  static final _id_readUnsignedByte = _class.instanceMethodId(
    r'readUnsignedByte',
    r'()I',
  );

  static final _readUnsignedByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int readUnsignedByte()`
  int readUnsignedByte() {
    return _readUnsignedByte(
      reference.pointer,
      _id_readUnsignedByte as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readShort = _class.instanceMethodId(r'readShort', r'()S');

  static final _readShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract short readShort()`
  int readShort() {
    return _readShort(
      reference.pointer,
      _id_readShort as jni$_.JMethodIDPtr,
    ).short;
  }

  static final _id_readUnsignedShort = _class.instanceMethodId(
    r'readUnsignedShort',
    r'()I',
  );

  static final _readUnsignedShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int readUnsignedShort()`
  int readUnsignedShort() {
    return _readUnsignedShort(
      reference.pointer,
      _id_readUnsignedShort as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readChar = _class.instanceMethodId(r'readChar', r'()C');

  static final _readChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract char readChar()`
  int readChar() {
    return _readChar(
      reference.pointer,
      _id_readChar as jni$_.JMethodIDPtr,
    ).char;
  }

  static final _id_readInt = _class.instanceMethodId(r'readInt', r'()I');

  static final _readInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int readInt()`
  int readInt() {
    return _readInt(
      reference.pointer,
      _id_readInt as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readLong = _class.instanceMethodId(r'readLong', r'()J');

  static final _readLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract long readLong()`
  int readLong() {
    return _readLong(
      reference.pointer,
      _id_readLong as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_readFloat = _class.instanceMethodId(r'readFloat', r'()F');

  static final _readFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract float readFloat()`
  double readFloat() {
    return _readFloat(
      reference.pointer,
      _id_readFloat as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_readDouble = _class.instanceMethodId(r'readDouble', r'()D');

  static final _readDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract double readDouble()`
  double readDouble() {
    return _readDouble(
      reference.pointer,
      _id_readDouble as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine() {
    return _readLine(
      reference.pointer,
      _id_readLine as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_readUTF = _class.instanceMethodId(
    r'readUTF',
    r'()Ljava/lang/String;',
  );

  static final _readUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String readUTF()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readUTF() {
    return _readUTF(
      reference.pointer,
      _id_readUTF as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $DataInput> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'readFully([B)V') {
        _$impls[$p]!.readFully(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'readFully([BII)V') {
        _$impls[$p]!.readFully$1(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'skipBytes(I)I') {
        final $r = _$impls[$p]!.skipBytes(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readBoolean()Z') {
        final $r = _$impls[$p]!.readBoolean();
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'readByte()B') {
        final $r = _$impls[$p]!.readByte();
        return jni$_.JByte($r).reference.toPointer();
      }
      if ($d == r'readUnsignedByte()I') {
        final $r = _$impls[$p]!.readUnsignedByte();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readShort()S') {
        final $r = _$impls[$p]!.readShort();
        return jni$_.JShort($r).reference.toPointer();
      }
      if ($d == r'readUnsignedShort()I') {
        final $r = _$impls[$p]!.readUnsignedShort();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readChar()C') {
        final $r = _$impls[$p]!.readChar();
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'readInt()I') {
        final $r = _$impls[$p]!.readInt();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readLong()J') {
        final $r = _$impls[$p]!.readLong();
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'readFloat()F') {
        final $r = _$impls[$p]!.readFloat();
        return jni$_.JFloat($r).reference.toPointer();
      }
      if ($d == r'readDouble()D') {
        final $r = _$impls[$p]!.readDouble();
        return jni$_.JDouble($r).reference.toPointer();
      }
      if ($d == r'readLine()Ljava/lang/String;') {
        final $r = _$impls[$p]!.readLine();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'readUTF()Ljava/lang/String;') {
        final $r = _$impls[$p]!.readUTF();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $DataInput $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.DataInput', $p, _$invokePointer, [
      if ($impl.readFully$async) r'readFully([B)V',
      if ($impl.readFully$1$async) r'readFully([BII)V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory DataInput.implement($DataInput $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return DataInput.fromReference($i.implementReference());
  }
}

abstract base mixin class $DataInput {
  factory $DataInput({
    required void Function(jni$_.JByteArray? bs) readFully,
    bool readFully$async,
    required void Function(jni$_.JByteArray? bs, int i, int i1) readFully$1,
    bool readFully$1$async,
    required int Function(int i) skipBytes,
    required bool Function() readBoolean,
    required int Function() readByte,
    required int Function() readUnsignedByte,
    required int Function() readShort,
    required int Function() readUnsignedShort,
    required int Function() readChar,
    required int Function() readInt,
    required int Function() readLong,
    required double Function() readFloat,
    required double Function() readDouble,
    required jni$_.JString? Function() readLine,
    required jni$_.JString? Function() readUTF,
  }) = _$DataInput;

  void readFully(jni$_.JByteArray? bs);
  bool get readFully$async => false;
  void readFully$1(jni$_.JByteArray? bs, int i, int i1);
  bool get readFully$1$async => false;
  int skipBytes(int i);
  bool readBoolean();
  int readByte();
  int readUnsignedByte();
  int readShort();
  int readUnsignedShort();
  int readChar();
  int readInt();
  int readLong();
  double readFloat();
  double readDouble();
  jni$_.JString? readLine();
  jni$_.JString? readUTF();
}

final class _$DataInput with $DataInput {
  _$DataInput({
    required void Function(jni$_.JByteArray? bs) readFully,
    this.readFully$async = false,
    required void Function(jni$_.JByteArray? bs, int i, int i1) readFully$1,
    this.readFully$1$async = false,
    required int Function(int i) skipBytes,
    required bool Function() readBoolean,
    required int Function() readByte,
    required int Function() readUnsignedByte,
    required int Function() readShort,
    required int Function() readUnsignedShort,
    required int Function() readChar,
    required int Function() readInt,
    required int Function() readLong,
    required double Function() readFloat,
    required double Function() readDouble,
    required jni$_.JString? Function() readLine,
    required jni$_.JString? Function() readUTF,
  }) : _readFully = readFully,
       _readFully$1 = readFully$1,
       _skipBytes = skipBytes,
       _readBoolean = readBoolean,
       _readByte = readByte,
       _readUnsignedByte = readUnsignedByte,
       _readShort = readShort,
       _readUnsignedShort = readUnsignedShort,
       _readChar = readChar,
       _readInt = readInt,
       _readLong = readLong,
       _readFloat = readFloat,
       _readDouble = readDouble,
       _readLine = readLine,
       _readUTF = readUTF;

  final void Function(jni$_.JByteArray? bs) _readFully;
  final bool readFully$async;
  final void Function(jni$_.JByteArray? bs, int i, int i1) _readFully$1;
  final bool readFully$1$async;
  final int Function(int i) _skipBytes;
  final bool Function() _readBoolean;
  final int Function() _readByte;
  final int Function() _readUnsignedByte;
  final int Function() _readShort;
  final int Function() _readUnsignedShort;
  final int Function() _readChar;
  final int Function() _readInt;
  final int Function() _readLong;
  final double Function() _readFloat;
  final double Function() _readDouble;
  final jni$_.JString? Function() _readLine;
  final jni$_.JString? Function() _readUTF;

  void readFully(jni$_.JByteArray? bs) {
    return _readFully(bs);
  }

  void readFully$1(jni$_.JByteArray? bs, int i, int i1) {
    return _readFully$1(bs, i, i1);
  }

  int skipBytes(int i) {
    return _skipBytes(i);
  }

  bool readBoolean() {
    return _readBoolean();
  }

  int readByte() {
    return _readByte();
  }

  int readUnsignedByte() {
    return _readUnsignedByte();
  }

  int readShort() {
    return _readShort();
  }

  int readUnsignedShort() {
    return _readUnsignedShort();
  }

  int readChar() {
    return _readChar();
  }

  int readInt() {
    return _readInt();
  }

  int readLong() {
    return _readLong();
  }

  double readFloat() {
    return _readFloat();
  }

  double readDouble() {
    return _readDouble();
  }

  jni$_.JString? readLine() {
    return _readLine();
  }

  jni$_.JString? readUTF() {
    return _readUTF();
  }
}

final class $DataInput$NullableType extends jni$_.JObjType<DataInput?> {
  @jni$_.internal
  const $DataInput$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataInput;';

  @jni$_.internal
  @core$_.override
  DataInput? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DataInput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataInput?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DataInput$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DataInput$NullableType) &&
        other is $DataInput$NullableType;
  }
}

final class $DataInput$Type extends jni$_.JObjType<DataInput> {
  @jni$_.internal
  const $DataInput$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataInput;';

  @jni$_.internal
  @core$_.override
  DataInput fromReference(jni$_.JReference reference) =>
      DataInput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataInput?> get nullableType =>
      const $DataInput$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DataInput$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DataInput$Type) && other is $DataInput$Type;
  }
}

/// from: `java.io.Writer`
class Writer extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Writer> $type;

  @jni$_.internal
  Writer.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Writer');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Writer$NullableType();
  static const type = $Writer$Type();
  static final _id_nullWriter = _class.staticMethodId(
    r'nullWriter',
    r'()Ljava/io/Writer;',
  );

  static final _nullWriter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.Writer nullWriter()`
  /// The returned object must be released after use, by calling the [release] method.
  static Writer? nullWriter() {
    return _nullWriter(
      _class.reference.pointer,
      _id_nullWriter as jni$_.JMethodIDPtr,
    ).object<Writer?>(const $Writer$NullableType());
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write$1 = _class.instanceMethodId(r'write', r'([C)V');

  static final _write$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(char[] cs)`
  void write$1(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write$1(
      reference.pointer,
      _id_write$1 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).check();
  }

  static final _id_write$2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract void write(char[] cs, int i, int i1)`
  void write$2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write$2(
      reference.pointer,
      _id_write$2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write$3 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;)V',
  );

  static final _write$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(java.lang.String string)`
  void write$3(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write$3(
      reference.pointer,
      _id_write$3 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_write$4 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;II)V',
  );

  static final _write$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(java.lang.String string, int i, int i1)`
  void write$4(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write$4(
      reference.pointer,
      _id_write$4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_append = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;)Ljava/io/Writer;',
  );

  static final _append =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.Writer append(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  Writer? append(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append(
      reference.pointer,
      _id_append as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<Writer?>(const $Writer$NullableType());
  }

  static final _id_append$1 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;II)Ljava/io/Writer;',
  );

  static final _append$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public java.io.Writer append(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  Writer? append$1(jni$_.JObject? charSequence, int i, int i1) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$1(
      reference.pointer,
      _id_append$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
    ).object<Writer?>(const $Writer$NullableType());
  }

  static final _id_append$2 = _class.instanceMethodId(
    r'append',
    r'(C)Ljava/io/Writer;',
  );

  static final _append$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.io.Writer append(char c)`
  /// The returned object must be released after use, by calling the [release] method.
  Writer? append$2(int c) {
    return _append$2(
      reference.pointer,
      _id_append$2 as jni$_.JMethodIDPtr,
      c,
    ).object<Writer?>(const $Writer$NullableType());
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $Writer$NullableType extends jni$_.JObjType<Writer?> {
  @jni$_.internal
  const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Writer;';

  @jni$_.internal
  @core$_.override
  Writer? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Writer.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Writer?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Writer$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Writer$NullableType) &&
        other is $Writer$NullableType;
  }
}

final class $Writer$Type extends jni$_.JObjType<Writer> {
  @jni$_.internal
  const $Writer$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Writer;';

  @jni$_.internal
  @core$_.override
  Writer fromReference(jni$_.JReference reference) =>
      Writer.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Writer?> get nullableType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Writer$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Writer$Type) && other is $Writer$Type;
  }
}

/// from: `java.io.ObjectInput`
class ObjectInput extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInput> $type;

  @jni$_.internal
  ObjectInput.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectInput');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInput$NullableType();
  static const type = $ObjectInput$Type();
  static final _id_readObject = _class.instanceMethodId(
    r'readObject',
    r'()Ljava/lang/Object;',
  );

  static final _readObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.Object readObject()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? readObject() {
    return _readObject(
      reference.pointer,
      _id_readObject as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int read()`
  int read() {
    return _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read$1 = _class.instanceMethodId(r'read', r'([B)I');

  static final _read$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract int read(byte[] bs)`
  int read$1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read$1(
      reference.pointer,
      _id_read$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).integer;
  }

  static final _id_read$2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract int read(byte[] bs, int i, int i1)`
  int read$2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read$2(
      reference.pointer,
      _id_read$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int available()`
  int available() {
    return _available(
      reference.pointer,
      _id_available as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_readFully = _class.instanceMethodId(r'readFully', r'([B)V');

  static final _readFully =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void readFully(byte[] bs)`
  void readFully(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully(
      reference.pointer,
      _id_readFully as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_readFully$1 = _class.instanceMethodId(
    r'readFully',
    r'([BII)V',
  );

  static final _readFully$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public abstract void readFully(byte[] bs, int i, int i1)`
  void readFully$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully$1(
      reference.pointer,
      _id_readFully$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_skipBytes = _class.instanceMethodId(r'skipBytes', r'(I)I');

  static final _skipBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract int skipBytes(int i)`
  int skipBytes(int i) {
    return _skipBytes(
      reference.pointer,
      _id_skipBytes as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_readBoolean = _class.instanceMethodId(
    r'readBoolean',
    r'()Z',
  );

  static final _readBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract boolean readBoolean()`
  bool readBoolean() {
    return _readBoolean(
      reference.pointer,
      _id_readBoolean as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_readByte = _class.instanceMethodId(r'readByte', r'()B');

  static final _readByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract byte readByte()`
  int readByte() {
    return _readByte(
      reference.pointer,
      _id_readByte as jni$_.JMethodIDPtr,
    ).byte;
  }

  static final _id_readUnsignedByte = _class.instanceMethodId(
    r'readUnsignedByte',
    r'()I',
  );

  static final _readUnsignedByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int readUnsignedByte()`
  int readUnsignedByte() {
    return _readUnsignedByte(
      reference.pointer,
      _id_readUnsignedByte as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readShort = _class.instanceMethodId(r'readShort', r'()S');

  static final _readShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract short readShort()`
  int readShort() {
    return _readShort(
      reference.pointer,
      _id_readShort as jni$_.JMethodIDPtr,
    ).short;
  }

  static final _id_readUnsignedShort = _class.instanceMethodId(
    r'readUnsignedShort',
    r'()I',
  );

  static final _readUnsignedShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int readUnsignedShort()`
  int readUnsignedShort() {
    return _readUnsignedShort(
      reference.pointer,
      _id_readUnsignedShort as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readChar = _class.instanceMethodId(r'readChar', r'()C');

  static final _readChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract char readChar()`
  int readChar() {
    return _readChar(
      reference.pointer,
      _id_readChar as jni$_.JMethodIDPtr,
    ).char;
  }

  static final _id_readInt = _class.instanceMethodId(r'readInt', r'()I');

  static final _readInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int readInt()`
  int readInt() {
    return _readInt(
      reference.pointer,
      _id_readInt as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readLong = _class.instanceMethodId(r'readLong', r'()J');

  static final _readLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract long readLong()`
  int readLong() {
    return _readLong(
      reference.pointer,
      _id_readLong as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_readFloat = _class.instanceMethodId(r'readFloat', r'()F');

  static final _readFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract float readFloat()`
  double readFloat() {
    return _readFloat(
      reference.pointer,
      _id_readFloat as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_readDouble = _class.instanceMethodId(r'readDouble', r'()D');

  static final _readDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract double readDouble()`
  double readDouble() {
    return _readDouble(
      reference.pointer,
      _id_readDouble as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine() {
    return _readLine(
      reference.pointer,
      _id_readLine as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_readUTF = _class.instanceMethodId(
    r'readUTF',
    r'()Ljava/lang/String;',
  );

  static final _readUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String readUTF()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readUTF() {
    return _readUTF(
      reference.pointer,
      _id_readUTF as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ObjectInput> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'readObject()Ljava/lang/Object;') {
        final $r = _$impls[$p]!.readObject();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'read()I') {
        final $r = _$impls[$p]!.read();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'read([B)I') {
        final $r = _$impls[$p]!.read$1(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'read([BII)I') {
        final $r = _$impls[$p]!.read$2(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'skip(J)J') {
        final $r = _$impls[$p]!.skip(
          $a![0]!
              .as(const jni$_.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'available()I') {
        final $r = _$impls[$p]!.available();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'close()V') {
        _$impls[$p]!.close();
        return jni$_.nullptr;
      }
      if ($d == r'readFully([B)V') {
        _$impls[$p]!.readFully(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'readFully([BII)V') {
        _$impls[$p]!.readFully$1(
          $a![0]?.as(const jni$_.JByteArrayType(), releaseOriginal: true),
          $a![1]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a![2]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d == r'skipBytes(I)I') {
        final $r = _$impls[$p]!.skipBytes(
          $a![0]!
              .as(const jni$_.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readBoolean()Z') {
        final $r = _$impls[$p]!.readBoolean();
        return jni$_.JBoolean($r).reference.toPointer();
      }
      if ($d == r'readByte()B') {
        final $r = _$impls[$p]!.readByte();
        return jni$_.JByte($r).reference.toPointer();
      }
      if ($d == r'readUnsignedByte()I') {
        final $r = _$impls[$p]!.readUnsignedByte();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readShort()S') {
        final $r = _$impls[$p]!.readShort();
        return jni$_.JShort($r).reference.toPointer();
      }
      if ($d == r'readUnsignedShort()I') {
        final $r = _$impls[$p]!.readUnsignedShort();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readChar()C') {
        final $r = _$impls[$p]!.readChar();
        return jni$_.JCharacter($r).reference.toPointer();
      }
      if ($d == r'readInt()I') {
        final $r = _$impls[$p]!.readInt();
        return jni$_.JInteger($r).reference.toPointer();
      }
      if ($d == r'readLong()J') {
        final $r = _$impls[$p]!.readLong();
        return jni$_.JLong($r).reference.toPointer();
      }
      if ($d == r'readFloat()F') {
        final $r = _$impls[$p]!.readFloat();
        return jni$_.JFloat($r).reference.toPointer();
      }
      if ($d == r'readDouble()D') {
        final $r = _$impls[$p]!.readDouble();
        return jni$_.JDouble($r).reference.toPointer();
      }
      if ($d == r'readLine()Ljava/lang/String;') {
        final $r = _$impls[$p]!.readLine();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d == r'readUTF()Ljava/lang/String;') {
        final $r = _$impls[$p]!.readUTF();
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $ObjectInput $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.ObjectInput', $p, _$invokePointer, [
      if ($impl.close$async) r'close()V',
      if ($impl.readFully$async) r'readFully([B)V',
      if ($impl.readFully$1$async) r'readFully([BII)V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ObjectInput.implement($ObjectInput $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ObjectInput.fromReference($i.implementReference());
  }
}

abstract base mixin class $ObjectInput {
  factory $ObjectInput({
    required jni$_.JObject? Function() readObject,
    required int Function() read,
    required int Function(jni$_.JByteArray? bs) read$1,
    required int Function(jni$_.JByteArray? bs, int i, int i1) read$2,
    required int Function(int j) skip,
    required int Function() available,
    required void Function() close,
    bool close$async,
    required void Function(jni$_.JByteArray? bs) readFully,
    bool readFully$async,
    required void Function(jni$_.JByteArray? bs, int i, int i1) readFully$1,
    bool readFully$1$async,
    required int Function(int i) skipBytes,
    required bool Function() readBoolean,
    required int Function() readByte,
    required int Function() readUnsignedByte,
    required int Function() readShort,
    required int Function() readUnsignedShort,
    required int Function() readChar,
    required int Function() readInt,
    required int Function() readLong,
    required double Function() readFloat,
    required double Function() readDouble,
    required jni$_.JString? Function() readLine,
    required jni$_.JString? Function() readUTF,
  }) = _$ObjectInput;

  jni$_.JObject? readObject();
  int read();
  int read$1(jni$_.JByteArray? bs);
  int read$2(jni$_.JByteArray? bs, int i, int i1);
  int skip(int j);
  int available();
  void close();
  bool get close$async => false;
  void readFully(jni$_.JByteArray? bs);
  bool get readFully$async => false;
  void readFully$1(jni$_.JByteArray? bs, int i, int i1);
  bool get readFully$1$async => false;
  int skipBytes(int i);
  bool readBoolean();
  int readByte();
  int readUnsignedByte();
  int readShort();
  int readUnsignedShort();
  int readChar();
  int readInt();
  int readLong();
  double readFloat();
  double readDouble();
  jni$_.JString? readLine();
  jni$_.JString? readUTF();
}

final class _$ObjectInput with $ObjectInput {
  _$ObjectInput({
    required jni$_.JObject? Function() readObject,
    required int Function() read,
    required int Function(jni$_.JByteArray? bs) read$1,
    required int Function(jni$_.JByteArray? bs, int i, int i1) read$2,
    required int Function(int j) skip,
    required int Function() available,
    required void Function() close,
    this.close$async = false,
    required void Function(jni$_.JByteArray? bs) readFully,
    this.readFully$async = false,
    required void Function(jni$_.JByteArray? bs, int i, int i1) readFully$1,
    this.readFully$1$async = false,
    required int Function(int i) skipBytes,
    required bool Function() readBoolean,
    required int Function() readByte,
    required int Function() readUnsignedByte,
    required int Function() readShort,
    required int Function() readUnsignedShort,
    required int Function() readChar,
    required int Function() readInt,
    required int Function() readLong,
    required double Function() readFloat,
    required double Function() readDouble,
    required jni$_.JString? Function() readLine,
    required jni$_.JString? Function() readUTF,
  }) : _readObject = readObject,
       _read = read,
       _read$1 = read$1,
       _read$2 = read$2,
       _skip = skip,
       _available = available,
       _close = close,
       _readFully = readFully,
       _readFully$1 = readFully$1,
       _skipBytes = skipBytes,
       _readBoolean = readBoolean,
       _readByte = readByte,
       _readUnsignedByte = readUnsignedByte,
       _readShort = readShort,
       _readUnsignedShort = readUnsignedShort,
       _readChar = readChar,
       _readInt = readInt,
       _readLong = readLong,
       _readFloat = readFloat,
       _readDouble = readDouble,
       _readLine = readLine,
       _readUTF = readUTF;

  final jni$_.JObject? Function() _readObject;
  final int Function() _read;
  final int Function(jni$_.JByteArray? bs) _read$1;
  final int Function(jni$_.JByteArray? bs, int i, int i1) _read$2;
  final int Function(int j) _skip;
  final int Function() _available;
  final void Function() _close;
  final bool close$async;
  final void Function(jni$_.JByteArray? bs) _readFully;
  final bool readFully$async;
  final void Function(jni$_.JByteArray? bs, int i, int i1) _readFully$1;
  final bool readFully$1$async;
  final int Function(int i) _skipBytes;
  final bool Function() _readBoolean;
  final int Function() _readByte;
  final int Function() _readUnsignedByte;
  final int Function() _readShort;
  final int Function() _readUnsignedShort;
  final int Function() _readChar;
  final int Function() _readInt;
  final int Function() _readLong;
  final double Function() _readFloat;
  final double Function() _readDouble;
  final jni$_.JString? Function() _readLine;
  final jni$_.JString? Function() _readUTF;

  jni$_.JObject? readObject() {
    return _readObject();
  }

  int read() {
    return _read();
  }

  int read$1(jni$_.JByteArray? bs) {
    return _read$1(bs);
  }

  int read$2(jni$_.JByteArray? bs, int i, int i1) {
    return _read$2(bs, i, i1);
  }

  int skip(int j) {
    return _skip(j);
  }

  int available() {
    return _available();
  }

  void close() {
    return _close();
  }

  void readFully(jni$_.JByteArray? bs) {
    return _readFully(bs);
  }

  void readFully$1(jni$_.JByteArray? bs, int i, int i1) {
    return _readFully$1(bs, i, i1);
  }

  int skipBytes(int i) {
    return _skipBytes(i);
  }

  bool readBoolean() {
    return _readBoolean();
  }

  int readByte() {
    return _readByte();
  }

  int readUnsignedByte() {
    return _readUnsignedByte();
  }

  int readShort() {
    return _readShort();
  }

  int readUnsignedShort() {
    return _readUnsignedShort();
  }

  int readChar() {
    return _readChar();
  }

  int readInt() {
    return _readInt();
  }

  int readLong() {
    return _readLong();
  }

  double readFloat() {
    return _readFloat();
  }

  double readDouble() {
    return _readDouble();
  }

  jni$_.JString? readLine() {
    return _readLine();
  }

  jni$_.JString? readUTF() {
    return _readUTF();
  }
}

final class $ObjectInput$NullableType extends jni$_.JObjType<ObjectInput?> {
  @jni$_.internal
  const $ObjectInput$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInput;';

  @jni$_.internal
  @core$_.override
  ObjectInput? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectInput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInput?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInput$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInput$NullableType) &&
        other is $ObjectInput$NullableType;
  }
}

final class $ObjectInput$Type extends jni$_.JObjType<ObjectInput> {
  @jni$_.internal
  const $ObjectInput$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInput;';

  @jni$_.internal
  @core$_.override
  ObjectInput fromReference(jni$_.JReference reference) =>
      ObjectInput.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInput?> get nullableType =>
      const $ObjectInput$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInput$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInput$Type) &&
        other is $ObjectInput$Type;
  }
}

/// from: `java.io.ObjectInputFilter`
class ObjectInputFilter extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInputFilter> $type;

  @jni$_.internal
  ObjectInputFilter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectInputFilter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInputFilter$NullableType();
  static const type = $ObjectInputFilter$Type();
  static final _id_checkInput = _class.instanceMethodId(
    r'checkInput',
    r'(Ljava/io/ObjectInputFilter$FilterInfo;)Ljava/io/ObjectInputFilter$Status;',
  );

  static final _checkInput =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract java.io.ObjectInputFilter$Status checkInput(java.io.ObjectInputFilter$FilterInfo filterInfo)`
  /// The returned object must be released after use, by calling the [release] method.
  ObjectInputFilter$Status? checkInput(
    ObjectInputFilter$FilterInfo? filterInfo,
  ) {
    final _$filterInfo = filterInfo?.reference ?? jni$_.jNullReference;
    return _checkInput(
      reference.pointer,
      _id_checkInput as jni$_.JMethodIDPtr,
      _$filterInfo.pointer,
    ).object<ObjectInputFilter$Status?>(
      const $ObjectInputFilter$Status$NullableType(),
    );
  }

  static final _id_allowFilter = _class.staticMethodId(
    r'allowFilter',
    r'(Ljava/util/function/Predicate;Ljava/io/ObjectInputFilter$Status;)Ljava/io/ObjectInputFilter;',
  );

  static final _allowFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter allowFilter(java.util.function.Predicate<java.lang.Class<?>> predicate, java.io.ObjectInputFilter$Status status)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter? allowFilter(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  ) {
    final _$predicate = predicate?.reference ?? jni$_.jNullReference;
    final _$status = status?.reference ?? jni$_.jNullReference;
    return _allowFilter(
      _class.reference.pointer,
      _id_allowFilter as jni$_.JMethodIDPtr,
      _$predicate.pointer,
      _$status.pointer,
    ).object<ObjectInputFilter?>(const $ObjectInputFilter$NullableType());
  }

  static final _id_rejectFilter = _class.staticMethodId(
    r'rejectFilter',
    r'(Ljava/util/function/Predicate;Ljava/io/ObjectInputFilter$Status;)Ljava/io/ObjectInputFilter;',
  );

  static final _rejectFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter rejectFilter(java.util.function.Predicate<java.lang.Class<?>> predicate, java.io.ObjectInputFilter$Status status)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter? rejectFilter(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  ) {
    final _$predicate = predicate?.reference ?? jni$_.jNullReference;
    final _$status = status?.reference ?? jni$_.jNullReference;
    return _rejectFilter(
      _class.reference.pointer,
      _id_rejectFilter as jni$_.JMethodIDPtr,
      _$predicate.pointer,
      _$status.pointer,
    ).object<ObjectInputFilter?>(const $ObjectInputFilter$NullableType());
  }

  static final _id_merge = _class.staticMethodId(
    r'merge',
    r'(Ljava/io/ObjectInputFilter;Ljava/io/ObjectInputFilter;)Ljava/io/ObjectInputFilter;',
  );

  static final _merge =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter merge(java.io.ObjectInputFilter objectInputFilter, java.io.ObjectInputFilter objectInputFilter1)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter? merge(
    ObjectInputFilter? objectInputFilter,
    ObjectInputFilter? objectInputFilter1,
  ) {
    final _$objectInputFilter =
        objectInputFilter?.reference ?? jni$_.jNullReference;
    final _$objectInputFilter1 =
        objectInputFilter1?.reference ?? jni$_.jNullReference;
    return _merge(
      _class.reference.pointer,
      _id_merge as jni$_.JMethodIDPtr,
      _$objectInputFilter.pointer,
      _$objectInputFilter1.pointer,
    ).object<ObjectInputFilter?>(const $ObjectInputFilter$NullableType());
  }

  static final _id_rejectUndecidedClass = _class.staticMethodId(
    r'rejectUndecidedClass',
    r'(Ljava/io/ObjectInputFilter;)Ljava/io/ObjectInputFilter;',
  );

  static final _rejectUndecidedClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter rejectUndecidedClass(java.io.ObjectInputFilter objectInputFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter? rejectUndecidedClass(
    ObjectInputFilter? objectInputFilter,
  ) {
    final _$objectInputFilter =
        objectInputFilter?.reference ?? jni$_.jNullReference;
    return _rejectUndecidedClass(
      _class.reference.pointer,
      _id_rejectUndecidedClass as jni$_.JMethodIDPtr,
      _$objectInputFilter.pointer,
    ).object<ObjectInputFilter?>(const $ObjectInputFilter$NullableType());
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ObjectInputFilter> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'checkInput(Ljava/io/ObjectInputFilter$FilterInfo;)Ljava/io/ObjectInputFilter$Status;') {
        final $r = _$impls[$p]!.checkInput(
          $a![0]?.as(
            const $ObjectInputFilter$FilterInfo$Type(),
            releaseOriginal: true,
          ),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'allowFilter(Ljava/util/function/Predicate;Ljava/io/ObjectInputFilter$Status;)Ljava/io/ObjectInputFilter;') {
        final $r = _$impls[$p]!.allowFilter(
          $a![0]?.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]?.as(
            const $ObjectInputFilter$Status$Type(),
            releaseOriginal: true,
          ),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'rejectFilter(Ljava/util/function/Predicate;Ljava/io/ObjectInputFilter$Status;)Ljava/io/ObjectInputFilter;') {
        final $r = _$impls[$p]!.rejectFilter(
          $a![0]?.as(const jni$_.JObjectType(), releaseOriginal: true),
          $a![1]?.as(
            const $ObjectInputFilter$Status$Type(),
            releaseOriginal: true,
          ),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'merge(Ljava/io/ObjectInputFilter;Ljava/io/ObjectInputFilter;)Ljava/io/ObjectInputFilter;') {
        final $r = _$impls[$p]!.merge(
          $a![0]?.as(const $ObjectInputFilter$Type(), releaseOriginal: true),
          $a![1]?.as(const $ObjectInputFilter$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
      if ($d ==
          r'rejectUndecidedClass(Ljava/io/ObjectInputFilter;)Ljava/io/ObjectInputFilter;') {
        final $r = _$impls[$p]!.rejectUndecidedClass(
          $a![0]?.as(const $ObjectInputFilter$Type(), releaseOriginal: true),
        );
        return ($r as jni$_.JObject?)
                ?.as(const jni$_.JObjectType())
                .reference
                .toPointer() ??
            jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ObjectInputFilter $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.ObjectInputFilter', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ObjectInputFilter.implement($ObjectInputFilter $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ObjectInputFilter.fromReference($i.implementReference());
  }
}

abstract base mixin class $ObjectInputFilter {
  factory $ObjectInputFilter({
    required ObjectInputFilter$Status? Function(
      ObjectInputFilter$FilterInfo? filterInfo,
    )
    checkInput,
    required ObjectInputFilter? Function(
      jni$_.JObject? predicate,
      ObjectInputFilter$Status? status,
    )
    allowFilter,
    required ObjectInputFilter? Function(
      jni$_.JObject? predicate,
      ObjectInputFilter$Status? status,
    )
    rejectFilter,
    required ObjectInputFilter? Function(
      ObjectInputFilter? objectInputFilter,
      ObjectInputFilter? objectInputFilter1,
    )
    merge,
    required ObjectInputFilter? Function(ObjectInputFilter? objectInputFilter)
    rejectUndecidedClass,
  }) = _$ObjectInputFilter;

  ObjectInputFilter$Status? checkInput(
    ObjectInputFilter$FilterInfo? filterInfo,
  );
  ObjectInputFilter? allowFilter(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  );
  ObjectInputFilter? rejectFilter(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  );
  ObjectInputFilter? merge(
    ObjectInputFilter? objectInputFilter,
    ObjectInputFilter? objectInputFilter1,
  );
  ObjectInputFilter? rejectUndecidedClass(ObjectInputFilter? objectInputFilter);
}

final class _$ObjectInputFilter with $ObjectInputFilter {
  _$ObjectInputFilter({
    required ObjectInputFilter$Status? Function(
      ObjectInputFilter$FilterInfo? filterInfo,
    )
    checkInput,
    required ObjectInputFilter? Function(
      jni$_.JObject? predicate,
      ObjectInputFilter$Status? status,
    )
    allowFilter,
    required ObjectInputFilter? Function(
      jni$_.JObject? predicate,
      ObjectInputFilter$Status? status,
    )
    rejectFilter,
    required ObjectInputFilter? Function(
      ObjectInputFilter? objectInputFilter,
      ObjectInputFilter? objectInputFilter1,
    )
    merge,
    required ObjectInputFilter? Function(ObjectInputFilter? objectInputFilter)
    rejectUndecidedClass,
  }) : _checkInput = checkInput,
       _allowFilter = allowFilter,
       _rejectFilter = rejectFilter,
       _merge = merge,
       _rejectUndecidedClass = rejectUndecidedClass;

  final ObjectInputFilter$Status? Function(
    ObjectInputFilter$FilterInfo? filterInfo,
  )
  _checkInput;
  final ObjectInputFilter? Function(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  )
  _allowFilter;
  final ObjectInputFilter? Function(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  )
  _rejectFilter;
  final ObjectInputFilter? Function(
    ObjectInputFilter? objectInputFilter,
    ObjectInputFilter? objectInputFilter1,
  )
  _merge;
  final ObjectInputFilter? Function(ObjectInputFilter? objectInputFilter)
  _rejectUndecidedClass;

  ObjectInputFilter$Status? checkInput(
    ObjectInputFilter$FilterInfo? filterInfo,
  ) {
    return _checkInput(filterInfo);
  }

  ObjectInputFilter? allowFilter(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  ) {
    return _allowFilter(predicate, status);
  }

  ObjectInputFilter? rejectFilter(
    jni$_.JObject? predicate,
    ObjectInputFilter$Status? status,
  ) {
    return _rejectFilter(predicate, status);
  }

  ObjectInputFilter? merge(
    ObjectInputFilter? objectInputFilter,
    ObjectInputFilter? objectInputFilter1,
  ) {
    return _merge(objectInputFilter, objectInputFilter1);
  }

  ObjectInputFilter? rejectUndecidedClass(
    ObjectInputFilter? objectInputFilter,
  ) {
    return _rejectUndecidedClass(objectInputFilter);
  }
}

final class $ObjectInputFilter$NullableType
    extends jni$_.JObjType<ObjectInputFilter?> {
  @jni$_.internal
  const $ObjectInputFilter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectInputFilter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInputFilter$NullableType) &&
        other is $ObjectInputFilter$NullableType;
  }
}

final class $ObjectInputFilter$Type extends jni$_.JObjType<ObjectInputFilter> {
  @jni$_.internal
  const $ObjectInputFilter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter fromReference(jni$_.JReference reference) =>
      ObjectInputFilter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter?> get nullableType =>
      const $ObjectInputFilter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInputFilter$Type) &&
        other is $ObjectInputFilter$Type;
  }
}

/// from: `java.io.UnsupportedEncodingException`
class UnsupportedEncodingException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<UnsupportedEncodingException> $type;

  @jni$_.internal
  UnsupportedEncodingException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/UnsupportedEncodingException',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $UnsupportedEncodingException$NullableType();
  static const type = $UnsupportedEncodingException$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory UnsupportedEncodingException() {
    return UnsupportedEncodingException.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory UnsupportedEncodingException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return UnsupportedEncodingException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $UnsupportedEncodingException$NullableType
    extends jni$_.JObjType<UnsupportedEncodingException?> {
  @jni$_.internal
  const $UnsupportedEncodingException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/UnsupportedEncodingException;';

  @jni$_.internal
  @core$_.override
  UnsupportedEncodingException? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : UnsupportedEncodingException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UnsupportedEncodingException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UnsupportedEncodingException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UnsupportedEncodingException$NullableType) &&
        other is $UnsupportedEncodingException$NullableType;
  }
}

final class $UnsupportedEncodingException$Type
    extends jni$_.JObjType<UnsupportedEncodingException> {
  @jni$_.internal
  const $UnsupportedEncodingException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/UnsupportedEncodingException;';

  @jni$_.internal
  @core$_.override
  UnsupportedEncodingException fromReference(jni$_.JReference reference) =>
      UnsupportedEncodingException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UnsupportedEncodingException?> get nullableType =>
      const $UnsupportedEncodingException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UnsupportedEncodingException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UnsupportedEncodingException$Type) &&
        other is $UnsupportedEncodingException$Type;
  }
}

/// from: `java.io.UTFDataFormatException`
class UTFDataFormatException extends IOException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<UTFDataFormatException> $type;

  @jni$_.internal
  UTFDataFormatException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/UTFDataFormatException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $UTFDataFormatException$NullableType();
  static const type = $UTFDataFormatException$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory UTFDataFormatException() {
    return UTFDataFormatException.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new1 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory UTFDataFormatException.new1(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return UTFDataFormatException.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }
}

final class $UTFDataFormatException$NullableType
    extends jni$_.JObjType<UTFDataFormatException?> {
  @jni$_.internal
  const $UTFDataFormatException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/UTFDataFormatException;';

  @jni$_.internal
  @core$_.override
  UTFDataFormatException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : UTFDataFormatException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UTFDataFormatException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UTFDataFormatException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UTFDataFormatException$NullableType) &&
        other is $UTFDataFormatException$NullableType;
  }
}

final class $UTFDataFormatException$Type
    extends jni$_.JObjType<UTFDataFormatException> {
  @jni$_.internal
  const $UTFDataFormatException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/UTFDataFormatException;';

  @jni$_.internal
  @core$_.override
  UTFDataFormatException fromReference(jni$_.JReference reference) =>
      UTFDataFormatException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $IOException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<UTFDataFormatException?> get nullableType =>
      const $UTFDataFormatException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UTFDataFormatException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UTFDataFormatException$Type) &&
        other is $UTFDataFormatException$Type;
  }
}

/// from: `java.io.DataInputStream`
class DataInputStream extends FilterInputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DataInputStream> $type;

  @jni$_.internal
  DataInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/DataInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DataInputStream$NullableType();
  static const type = $DataInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/InputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory DataInputStream(InputStream? inputStream) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    return DataInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
      ).reference,
    );
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'([B)I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final int read(byte[] bs)`
  int read1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read1(
      reference.pointer,
      _id_read1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).integer;
  }

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public final int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_readFully = _class.instanceMethodId(r'readFully', r'([B)V');

  static final _readFully =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public final void readFully(byte[] bs)`
  void readFully(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully(
      reference.pointer,
      _id_readFully as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_readFully$1 = _class.instanceMethodId(
    r'readFully',
    r'([BII)V',
  );

  static final _readFully$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public final void readFully(byte[] bs, int i, int i1)`
  void readFully$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _readFully$1(
      reference.pointer,
      _id_readFully$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_skipBytes = _class.instanceMethodId(r'skipBytes', r'(I)I');

  static final _skipBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public final int skipBytes(int i)`
  int skipBytes(int i) {
    return _skipBytes(
      reference.pointer,
      _id_skipBytes as jni$_.JMethodIDPtr,
      i,
    ).integer;
  }

  static final _id_readBoolean = _class.instanceMethodId(
    r'readBoolean',
    r'()Z',
  );

  static final _readBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean readBoolean()`
  bool readBoolean() {
    return _readBoolean(
      reference.pointer,
      _id_readBoolean as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_readByte = _class.instanceMethodId(r'readByte', r'()B');

  static final _readByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final byte readByte()`
  int readByte() {
    return _readByte(
      reference.pointer,
      _id_readByte as jni$_.JMethodIDPtr,
    ).byte;
  }

  static final _id_readUnsignedByte = _class.instanceMethodId(
    r'readUnsignedByte',
    r'()I',
  );

  static final _readUnsignedByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int readUnsignedByte()`
  int readUnsignedByte() {
    return _readUnsignedByte(
      reference.pointer,
      _id_readUnsignedByte as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readShort = _class.instanceMethodId(r'readShort', r'()S');

  static final _readShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final short readShort()`
  int readShort() {
    return _readShort(
      reference.pointer,
      _id_readShort as jni$_.JMethodIDPtr,
    ).short;
  }

  static final _id_readUnsignedShort = _class.instanceMethodId(
    r'readUnsignedShort',
    r'()I',
  );

  static final _readUnsignedShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int readUnsignedShort()`
  int readUnsignedShort() {
    return _readUnsignedShort(
      reference.pointer,
      _id_readUnsignedShort as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readChar = _class.instanceMethodId(r'readChar', r'()C');

  static final _readChar =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallCharMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final char readChar()`
  int readChar() {
    return _readChar(
      reference.pointer,
      _id_readChar as jni$_.JMethodIDPtr,
    ).char;
  }

  static final _id_readInt = _class.instanceMethodId(r'readInt', r'()I');

  static final _readInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final int readInt()`
  int readInt() {
    return _readInt(
      reference.pointer,
      _id_readInt as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_readLong = _class.instanceMethodId(r'readLong', r'()J');

  static final _readLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final long readLong()`
  int readLong() {
    return _readLong(
      reference.pointer,
      _id_readLong as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_readFloat = _class.instanceMethodId(r'readFloat', r'()F');

  static final _readFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final float readFloat()`
  double readFloat() {
    return _readFloat(
      reference.pointer,
      _id_readFloat as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_readDouble = _class.instanceMethodId(r'readDouble', r'()D');

  static final _readDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final double readDouble()`
  double readDouble() {
    return _readDouble(
      reference.pointer,
      _id_readDouble as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_readLine = _class.instanceMethodId(
    r'readLine',
    r'()Ljava/lang/String;',
  );

  static final _readLine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String readLine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readLine() {
    return _readLine(
      reference.pointer,
      _id_readLine as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_readUTF = _class.instanceMethodId(
    r'readUTF',
    r'()Ljava/lang/String;',
  );

  static final _readUTF =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.lang.String readUTF()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? readUTF() {
    return _readUTF(
      reference.pointer,
      _id_readUTF as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_readUTF$1 = _class.staticMethodId(
    r'readUTF',
    r'(Ljava/io/DataInput;)Ljava/lang/String;',
  );

  static final _readUTF$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public final java.lang.String readUTF(java.io.DataInput dataInput)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? readUTF$1(DataInput? dataInput) {
    final _$dataInput = dataInput?.reference ?? jni$_.jNullReference;
    return _readUTF$1(
      _class.reference.pointer,
      _id_readUTF$1 as jni$_.JMethodIDPtr,
      _$dataInput.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $DataInputStream$NullableType
    extends jni$_.JObjType<DataInputStream?> {
  @jni$_.internal
  const $DataInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataInputStream;';

  @jni$_.internal
  @core$_.override
  DataInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DataInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($DataInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DataInputStream$NullableType) &&
        other is $DataInputStream$NullableType;
  }
}

final class $DataInputStream$Type extends jni$_.JObjType<DataInputStream> {
  @jni$_.internal
  const $DataInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/DataInputStream;';

  @jni$_.internal
  @core$_.override
  DataInputStream fromReference(jni$_.JReference reference) =>
      DataInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DataInputStream?> get nullableType =>
      const $DataInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($DataInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DataInputStream$Type) &&
        other is $DataInputStream$Type;
  }
}

/// from: `java.io.ObjectStreamClass`
class ObjectStreamClass extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectStreamClass> $type;

  @jni$_.internal
  ObjectStreamClass.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectStreamClass');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectStreamClass$NullableType();
  static const type = $ObjectStreamClass$Type();
  static final _id_NO_FIELDS = _class.staticFieldId(
    r'NO_FIELDS',
    r'[Ljava/io/ObjectStreamField;',
  );

  /// from: `static public final java.io.ObjectStreamField[] NO_FIELDS`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<ObjectStreamField?>? get NO_FIELDS => _id_NO_FIELDS.get(
    _class,
    const jni$_.JArrayNullableType<ObjectStreamField?>(
      $ObjectStreamField$NullableType(),
    ),
  );

  static final _id_lookup = _class.staticMethodId(
    r'lookup',
    r'(Ljava/lang/Class;)Ljava/io/ObjectStreamClass;',
  );

  static final _lookup =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectStreamClass lookup(java.lang.Class<?> class)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectStreamClass? lookup(jni$_.JObject? class$) {
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    return _lookup(
      _class.reference.pointer,
      _id_lookup as jni$_.JMethodIDPtr,
      _$class$.pointer,
    ).object<ObjectStreamClass?>(const $ObjectStreamClass$NullableType());
  }

  static final _id_lookupAny = _class.staticMethodId(
    r'lookupAny',
    r'(Ljava/lang/Class;)Ljava/io/ObjectStreamClass;',
  );

  static final _lookupAny =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectStreamClass lookupAny(java.lang.Class<?> class)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectStreamClass? lookupAny(jni$_.JObject? class$) {
    final _$class$ = class$?.reference ?? jni$_.jNullReference;
    return _lookupAny(
      _class.reference.pointer,
      _id_lookupAny as jni$_.JMethodIDPtr,
      _$class$.pointer,
    ).object<ObjectStreamClass?>(const $ObjectStreamClass$NullableType());
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() {
    return _getName(
      reference.pointer,
      _id_getName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getSerialVersionUID = _class.instanceMethodId(
    r'getSerialVersionUID',
    r'()J',
  );

  static final _getSerialVersionUID =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getSerialVersionUID()`
  int getSerialVersionUID() {
    return _getSerialVersionUID(
      reference.pointer,
      _id_getSerialVersionUID as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_forClass = _class.instanceMethodId(
    r'forClass',
    r'()Ljava/lang/Class;',
  );

  static final _forClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.Class<?> forClass()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? forClass() {
    return _forClass(
      reference.pointer,
      _id_forClass as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getFields = _class.instanceMethodId(
    r'getFields',
    r'()[Ljava/io/ObjectStreamField;',
  );

  static final _getFields =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.ObjectStreamField[] getFields()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<ObjectStreamField?>? getFields() {
    return _getFields(
      reference.pointer,
      _id_getFields as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<ObjectStreamField?>?>(
      const jni$_.JArrayNullableType<ObjectStreamField?>(
        $ObjectStreamField$NullableType(),
      ),
    );
  }

  static final _id_getField = _class.instanceMethodId(
    r'getField',
    r'(Ljava/lang/String;)Ljava/io/ObjectStreamField;',
  );

  static final _getField =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.ObjectStreamField getField(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  ObjectStreamField? getField(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _getField(
      reference.pointer,
      _id_getField as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<ObjectStreamField?>(const $ObjectStreamField$NullableType());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $ObjectStreamClass$NullableType
    extends jni$_.JObjType<ObjectStreamClass?> {
  @jni$_.internal
  const $ObjectStreamClass$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamClass;';

  @jni$_.internal
  @core$_.override
  ObjectStreamClass? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectStreamClass.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamClass?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectStreamClass$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectStreamClass$NullableType) &&
        other is $ObjectStreamClass$NullableType;
  }
}

final class $ObjectStreamClass$Type extends jni$_.JObjType<ObjectStreamClass> {
  @jni$_.internal
  const $ObjectStreamClass$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamClass;';

  @jni$_.internal
  @core$_.override
  ObjectStreamClass fromReference(jni$_.JReference reference) =>
      ObjectStreamClass.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamClass?> get nullableType =>
      const $ObjectStreamClass$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectStreamClass$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectStreamClass$Type) &&
        other is $ObjectStreamClass$Type;
  }
}

/// from: `java.io.StringBufferInputStream`
class StringBufferInputStream extends InputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<StringBufferInputStream> $type;

  @jni$_.internal
  StringBufferInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/StringBufferInputStream',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $StringBufferInputStream$NullableType();
  static const type = $StringBufferInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory StringBufferInputStream(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return StringBufferInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() {
    return _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() {
    return _available(
      reference.pointer,
      _id_available as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }
}

final class $StringBufferInputStream$NullableType
    extends jni$_.JObjType<StringBufferInputStream?> {
  @jni$_.internal
  const $StringBufferInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StringBufferInputStream;';

  @jni$_.internal
  @core$_.override
  StringBufferInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : StringBufferInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringBufferInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($StringBufferInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringBufferInputStream$NullableType) &&
        other is $StringBufferInputStream$NullableType;
  }
}

final class $StringBufferInputStream$Type
    extends jni$_.JObjType<StringBufferInputStream> {
  @jni$_.internal
  const $StringBufferInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/StringBufferInputStream;';

  @jni$_.internal
  @core$_.override
  StringBufferInputStream fromReference(jni$_.JReference reference) =>
      StringBufferInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<StringBufferInputStream?> get nullableType =>
      const $StringBufferInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($StringBufferInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($StringBufferInputStream$Type) &&
        other is $StringBufferInputStream$Type;
  }
}

/// from: `java.io.InvalidClassException`
class InvalidClassException extends ObjectStreamException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InvalidClassException> $type;

  @jni$_.internal
  InvalidClassException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/InvalidClassException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InvalidClassException$NullableType();
  static const type = $InvalidClassException$Type();
  static final _id_classname = _class.instanceFieldId(
    r'classname',
    r'Ljava/lang/String;',
  );

  /// from: `public java.lang.String classname`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? get classname =>
      _id_classname.get(this, const jni$_.JStringNullableType());

  /// from: `public java.lang.String classname`
  /// The returned object must be released after use, by calling the [release] method.
  set classname(jni$_.JString? value) =>
      _id_classname.set(this, const jni$_.JStringNullableType(), value);

  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InvalidClassException.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return InvalidClassException.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory InvalidClassException.new$5(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return InvalidClassException.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_getMessage = _class.instanceMethodId(
    r'getMessage',
    r'()Ljava/lang/String;',
  );

  static final _getMessage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getMessage()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getMessage() {
    return _getMessage(
      reference.pointer,
      _id_getMessage as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $InvalidClassException$NullableType
    extends jni$_.JObjType<InvalidClassException?> {
  @jni$_.internal
  const $InvalidClassException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InvalidClassException;';

  @jni$_.internal
  @core$_.override
  InvalidClassException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InvalidClassException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InvalidClassException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($InvalidClassException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InvalidClassException$NullableType) &&
        other is $InvalidClassException$NullableType;
  }
}

final class $InvalidClassException$Type
    extends jni$_.JObjType<InvalidClassException> {
  @jni$_.internal
  const $InvalidClassException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InvalidClassException;';

  @jni$_.internal
  @core$_.override
  InvalidClassException fromReference(jni$_.JReference reference) =>
      InvalidClassException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InvalidClassException?> get nullableType =>
      const $InvalidClassException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($InvalidClassException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InvalidClassException$Type) &&
        other is $InvalidClassException$Type;
  }
}

/// from: `java.io.SerializablePermission`
class SerializablePermission extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SerializablePermission> $type;

  @jni$_.internal
  SerializablePermission.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/SerializablePermission');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SerializablePermission$NullableType();
  static const type = $SerializablePermission$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SerializablePermission(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return SerializablePermission.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SerializablePermission.new$1(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return SerializablePermission.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }
}

final class $SerializablePermission$NullableType
    extends jni$_.JObjType<SerializablePermission?> {
  @jni$_.internal
  const $SerializablePermission$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/SerializablePermission;';

  @jni$_.internal
  @core$_.override
  SerializablePermission? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SerializablePermission.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SerializablePermission?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SerializablePermission$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SerializablePermission$NullableType) &&
        other is $SerializablePermission$NullableType;
  }
}

final class $SerializablePermission$Type
    extends jni$_.JObjType<SerializablePermission> {
  @jni$_.internal
  const $SerializablePermission$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/SerializablePermission;';

  @jni$_.internal
  @core$_.override
  SerializablePermission fromReference(jni$_.JReference reference) =>
      SerializablePermission.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SerializablePermission?> get nullableType =>
      const $SerializablePermission$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($SerializablePermission$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SerializablePermission$Type) &&
        other is $SerializablePermission$Type;
  }
}

/// from: `java.io.FilterInputStream`
class FilterInputStream extends InputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FilterInputStream> $type;

  @jni$_.internal
  FilterInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FilterInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FilterInputStream$NullableType();
  static const type = $FilterInputStream$Type();
  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() {
    return _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'([B)I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(byte[] bs)`
  int read1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read1(
      reference.pointer,
      _id_read1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).integer;
  }

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() {
    return _available(
      reference.pointer,
      _id_available as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() {
    return _markSupported(
      reference.pointer,
      _id_markSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }
}

final class $FilterInputStream$NullableType
    extends jni$_.JObjType<FilterInputStream?> {
  @jni$_.internal
  const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterInputStream;';

  @jni$_.internal
  @core$_.override
  FilterInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FilterInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FilterInputStream$NullableType) &&
        other is $FilterInputStream$NullableType;
  }
}

final class $FilterInputStream$Type extends jni$_.JObjType<FilterInputStream> {
  @jni$_.internal
  const $FilterInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterInputStream;';

  @jni$_.internal
  @core$_.override
  FilterInputStream fromReference(jni$_.JReference reference) =>
      FilterInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterInputStream?> get nullableType =>
      const $FilterInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FilterInputStream$Type) &&
        other is $FilterInputStream$Type;
  }
}

/// from: `java.io.OutputStreamWriter`
class OutputStreamWriter extends Writer {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OutputStreamWriter> $type;

  @jni$_.internal
  OutputStreamWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/OutputStreamWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OutputStreamWriter$NullableType();
  static const type = $OutputStreamWriter$Type();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/io/OutputStream;Ljava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory OutputStreamWriter(
    OutputStream? outputStream,
    jni$_.JString? string,
  ) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return OutputStreamWriter.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory OutputStreamWriter.new$1(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return OutputStreamWriter.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/io/OutputStream;Ljava/nio/charset/Charset;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory OutputStreamWriter.new$2(
    OutputStream? outputStream,
    jni$_.JObject? charset,
  ) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return OutputStreamWriter.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/io/OutputStream;Ljava/nio/charset/CharsetEncoder;)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, java.nio.charset.CharsetEncoder charsetEncoder)`
  /// The returned object must be released after use, by calling the [release] method.
  factory OutputStreamWriter.new$3(
    OutputStream? outputStream,
    jni$_.JObject? charsetEncoder,
  ) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    final _$charsetEncoder = charsetEncoder?.reference ?? jni$_.jNullReference;
    return OutputStreamWriter.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        _$charsetEncoder.pointer,
      ).reference,
    );
  }

  static final _id_getEncoding = _class.instanceMethodId(
    r'getEncoding',
    r'()Ljava/lang/String;',
  );

  static final _getEncoding =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getEncoding()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getEncoding() {
    return _getEncoding(
      reference.pointer,
      _id_getEncoding as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(char[] cs, int i, int i1)`
  void write2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write4 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;II)V',
  );

  static final _write4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(java.lang.String string, int i, int i1)`
  void write4(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write4(
      reference.pointer,
      _id_write4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_append1 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;II)Ljava/io/Writer;',
  );

  static final _append1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public java.io.Writer append(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  Writer? append1(jni$_.JObject? charSequence, int i, int i1) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append1(
      reference.pointer,
      _id_append1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
    ).object<Writer?>(const $Writer$NullableType());
  }

  static final _id_append = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;)Ljava/io/Writer;',
  );

  static final _append =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.Writer append(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  Writer? append(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append(
      reference.pointer,
      _id_append as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<Writer?>(const $Writer$NullableType());
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $OutputStreamWriter$NullableType
    extends jni$_.JObjType<OutputStreamWriter?> {
  @jni$_.internal
  const $OutputStreamWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/OutputStreamWriter;';

  @jni$_.internal
  @core$_.override
  OutputStreamWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : OutputStreamWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OutputStreamWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($OutputStreamWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OutputStreamWriter$NullableType) &&
        other is $OutputStreamWriter$NullableType;
  }
}

final class $OutputStreamWriter$Type
    extends jni$_.JObjType<OutputStreamWriter> {
  @jni$_.internal
  const $OutputStreamWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/OutputStreamWriter;';

  @jni$_.internal
  @core$_.override
  OutputStreamWriter fromReference(jni$_.JReference reference) =>
      OutputStreamWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OutputStreamWriter?> get nullableType =>
      const $OutputStreamWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($OutputStreamWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OutputStreamWriter$Type) &&
        other is $OutputStreamWriter$Type;
  }
}

/// from: `java.io.NotActiveException`
class NotActiveException extends ObjectStreamException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NotActiveException> $type;

  @jni$_.internal
  NotActiveException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/NotActiveException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NotActiveException$NullableType();
  static const type = $NotActiveException$Type();
  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NotActiveException.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return NotActiveException.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'()V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NotActiveException.new$5() {
    return NotActiveException.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }
}

final class $NotActiveException$NullableType
    extends jni$_.JObjType<NotActiveException?> {
  @jni$_.internal
  const $NotActiveException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/NotActiveException;';

  @jni$_.internal
  @core$_.override
  NotActiveException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : NotActiveException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NotActiveException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($NotActiveException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NotActiveException$NullableType) &&
        other is $NotActiveException$NullableType;
  }
}

final class $NotActiveException$Type
    extends jni$_.JObjType<NotActiveException> {
  @jni$_.internal
  const $NotActiveException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/NotActiveException;';

  @jni$_.internal
  @core$_.override
  NotActiveException fromReference(jni$_.JReference reference) =>
      NotActiveException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NotActiveException?> get nullableType =>
      const $NotActiveException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($NotActiveException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NotActiveException$Type) &&
        other is $NotActiveException$Type;
  }
}

/// from: `java.io.OutputStream`
class OutputStream extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OutputStream> $type;

  @jni$_.internal
  OutputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/OutputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OutputStream$NullableType();
  static const type = $OutputStream$Type();
  static final _id_nullOutputStream = _class.staticMethodId(
    r'nullOutputStream',
    r'()Ljava/io/OutputStream;',
  );

  static final _nullOutputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.OutputStream nullOutputStream()`
  /// The returned object must be released after use, by calling the [release] method.
  static OutputStream? nullOutputStream() {
    return _nullOutputStream(
      _class.reference.pointer,
      _id_nullOutputStream as jni$_.JMethodIDPtr,
    ).object<OutputStream?>(const $OutputStream$NullableType());
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public abstract void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write$1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(byte[] bs)`
  void write$1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$1(
      reference.pointer,
      _id_write$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_write$2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write$2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write$2(
      reference.pointer,
      _id_write$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $OutputStream$NullableType extends jni$_.JObjType<OutputStream?> {
  @jni$_.internal
  const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/OutputStream;';

  @jni$_.internal
  @core$_.override
  OutputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : OutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OutputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OutputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OutputStream$NullableType) &&
        other is $OutputStream$NullableType;
  }
}

final class $OutputStream$Type extends jni$_.JObjType<OutputStream> {
  @jni$_.internal
  const $OutputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/OutputStream;';

  @jni$_.internal
  @core$_.override
  OutputStream fromReference(jni$_.JReference reference) =>
      OutputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OutputStream?> get nullableType =>
      const $OutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($OutputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OutputStream$Type) &&
        other is $OutputStream$Type;
  }
}

/// from: `java.io.PrintStream`
class PrintStream extends FilterOutputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<PrintStream> $type;

  @jni$_.internal
  PrintStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/PrintStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $PrintStream$NullableType();
  static const type = $PrintStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/OutputStream;Z)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$1(OutputStream? outputStream, bool z) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/io/OutputStream;ZLjava/lang/String;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, boolean z, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$2(
    OutputStream? outputStream,
    bool z,
    jni$_.JString? string,
  ) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        z ? 1 : 0,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/io/OutputStream;ZLjava/nio/charset/Charset;)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream, boolean z, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$3(
    OutputStream? outputStream,
    bool z,
    jni$_.JObject? charset,
  ) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
        z ? 1 : 0,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$5(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_new$6 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;)V',
  );

  static final _new$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$6(jni$_.JString? string, jni$_.JObject? charset) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$6(
        _class.reference.pointer,
        _id_new$6 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$7 = _class.constructorId(r'(Ljava/io/File;)V');

  static final _new$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$7(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$7(
        _class.reference.pointer,
        _id_new$7 as jni$_.JMethodIDPtr,
        _$file.pointer,
      ).reference,
    );
  }

  static final _id_new$8 = _class.constructorId(
    r'(Ljava/io/File;Ljava/lang/String;)V',
  );

  static final _new$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$8(File? file, jni$_.JString? string) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$8(
        _class.reference.pointer,
        _id_new$8 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$9 = _class.constructorId(
    r'(Ljava/io/File;Ljava/nio/charset/Charset;)V',
  );

  static final _new$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PrintStream.new$9(File? file, jni$_.JObject? charset) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return PrintStream.fromReference(
      _new$9(
        _class.reference.pointer,
        _id_new$9 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_checkError = _class.instanceMethodId(r'checkError', r'()Z');

  static final _checkError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean checkError()`
  bool checkError() {
    return _checkError(
      reference.pointer,
      _id_checkError as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([BII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(byte[] bs, int i, int i1)`
  void write2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write1 = _class.instanceMethodId(r'write', r'([B)V');

  static final _write1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void write(byte[] bs)`
  void write1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _write1(
      reference.pointer,
      _id_write1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_writeBytes = _class.instanceMethodId(
    r'writeBytes',
    r'([B)V',
  );

  static final _writeBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeBytes(byte[] bs)`
  void writeBytes(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    _writeBytes(
      reference.pointer,
      _id_writeBytes as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).check();
  }

  static final _id_print = _class.instanceMethodId(r'print', r'(Z)V');

  static final _print =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(boolean z)`
  void print(bool z) {
    _print(
      reference.pointer,
      _id_print as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_print$1 = _class.instanceMethodId(r'print', r'(C)V');

  static final _print$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(char c)`
  void print$1(int c) {
    _print$1(reference.pointer, _id_print$1 as jni$_.JMethodIDPtr, c).check();
  }

  static final _id_print$2 = _class.instanceMethodId(r'print', r'(I)V');

  static final _print$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(int i)`
  void print$2(int i) {
    _print$2(reference.pointer, _id_print$2 as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_print$3 = _class.instanceMethodId(r'print', r'(J)V');

  static final _print$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void print(long j)`
  void print$3(int j) {
    _print$3(reference.pointer, _id_print$3 as jni$_.JMethodIDPtr, j).check();
  }

  static final _id_print$4 = _class.instanceMethodId(r'print', r'(F)V');

  static final _print$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void print(float f)`
  void print$4(double f) {
    _print$4(reference.pointer, _id_print$4 as jni$_.JMethodIDPtr, f).check();
  }

  static final _id_print$5 = _class.instanceMethodId(r'print', r'(D)V');

  static final _print$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void print(double d)`
  void print$5(double d) {
    _print$5(reference.pointer, _id_print$5 as jni$_.JMethodIDPtr, d).check();
  }

  static final _id_print$6 = _class.instanceMethodId(r'print', r'([C)V');

  static final _print$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void print(char[] cs)`
  void print$6(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _print$6(
      reference.pointer,
      _id_print$6 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).check();
  }

  static final _id_print$7 = _class.instanceMethodId(
    r'print',
    r'(Ljava/lang/String;)V',
  );

  static final _print$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void print(java.lang.String string)`
  void print$7(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _print$7(
      reference.pointer,
      _id_print$7 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_print$8 = _class.instanceMethodId(
    r'print',
    r'(Ljava/lang/Object;)V',
  );

  static final _print$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void print(java.lang.Object object)`
  void print$8(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _print$8(
      reference.pointer,
      _id_print$8 as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_println = _class.instanceMethodId(r'println', r'()V');

  static final _println =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void println()`
  void println() {
    _println(reference.pointer, _id_println as jni$_.JMethodIDPtr).check();
  }

  static final _id_println$1 = _class.instanceMethodId(r'println', r'(Z)V');

  static final _println$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(boolean z)`
  void println$1(bool z) {
    _println$1(
      reference.pointer,
      _id_println$1 as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_println$2 = _class.instanceMethodId(r'println', r'(C)V');

  static final _println$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(char c)`
  void println$2(int c) {
    _println$2(
      reference.pointer,
      _id_println$2 as jni$_.JMethodIDPtr,
      c,
    ).check();
  }

  static final _id_println$3 = _class.instanceMethodId(r'println', r'(I)V');

  static final _println$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(int i)`
  void println$3(int i) {
    _println$3(
      reference.pointer,
      _id_println$3 as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_println$4 = _class.instanceMethodId(r'println', r'(J)V');

  static final _println$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void println(long j)`
  void println$4(int j) {
    _println$4(
      reference.pointer,
      _id_println$4 as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_println$5 = _class.instanceMethodId(r'println', r'(F)V');

  static final _println$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void println(float f)`
  void println$5(double f) {
    _println$5(
      reference.pointer,
      _id_println$5 as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_println$6 = _class.instanceMethodId(r'println', r'(D)V');

  static final _println$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void println(double d)`
  void println$6(double d) {
    _println$6(
      reference.pointer,
      _id_println$6 as jni$_.JMethodIDPtr,
      d,
    ).check();
  }

  static final _id_println$7 = _class.instanceMethodId(r'println', r'([C)V');

  static final _println$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void println(char[] cs)`
  void println$7(jni$_.JCharArray? cs) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _println$7(
      reference.pointer,
      _id_println$7 as jni$_.JMethodIDPtr,
      _$cs.pointer,
    ).check();
  }

  static final _id_println$8 = _class.instanceMethodId(
    r'println',
    r'(Ljava/lang/String;)V',
  );

  static final _println$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void println(java.lang.String string)`
  void println$8(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _println$8(
      reference.pointer,
      _id_println$8 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_println$9 = _class.instanceMethodId(
    r'println',
    r'(Ljava/lang/Object;)V',
  );

  static final _println$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void println(java.lang.Object object)`
  void println$9(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    _println$9(
      reference.pointer,
      _id_println$9 as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).check();
  }

  static final _id_printf = _class.instanceMethodId(
    r'printf',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;',
  );

  static final _printf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintStream printf(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintStream? printf(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _printf(
      reference.pointer,
      _id_printf as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintStream?>(const $PrintStream$NullableType());
  }

  static final _id_printf$1 = _class.instanceMethodId(
    r'printf',
    r'(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;',
  );

  static final _printf$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintStream printf(java.util.Locale locale, java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintStream? printf$1(
    jni$_.JObject? locale,
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _printf$1(
      reference.pointer,
      _id_printf$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintStream?>(const $PrintStream$NullableType());
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintStream format(java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintStream? format(
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintStream?>(const $PrintStream$NullableType());
  }

  static final _id_format$1 = _class.instanceMethodId(
    r'format',
    r'(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;',
  );

  static final _format$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintStream format(java.util.Locale locale, java.lang.String string, java.lang.Object[] objects)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintStream? format$1(
    jni$_.JObject? locale,
    jni$_.JString? string,
    jni$_.JArray<jni$_.JObject?>? objects,
  ) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$objects = objects?.reference ?? jni$_.jNullReference;
    return _format$1(
      reference.pointer,
      _id_format$1 as jni$_.JMethodIDPtr,
      _$locale.pointer,
      _$string.pointer,
      _$objects.pointer,
    ).object<PrintStream?>(const $PrintStream$NullableType());
  }

  static final _id_append = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;)Ljava/io/PrintStream;',
  );

  static final _append =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.PrintStream append(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintStream? append(jni$_.JObject? charSequence) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append(
      reference.pointer,
      _id_append as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
    ).object<PrintStream?>(const $PrintStream$NullableType());
  }

  static final _id_append$1 = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/CharSequence;II)Ljava/io/PrintStream;',
  );

  static final _append$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public java.io.PrintStream append(java.lang.CharSequence charSequence, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintStream? append$1(jni$_.JObject? charSequence, int i, int i1) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _append$1(
      reference.pointer,
      _id_append$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
    ).object<PrintStream?>(const $PrintStream$NullableType());
  }

  static final _id_append$2 = _class.instanceMethodId(
    r'append',
    r'(C)Ljava/io/PrintStream;',
  );

  static final _append$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public java.io.PrintStream append(char c)`
  /// The returned object must be released after use, by calling the [release] method.
  PrintStream? append$2(int c) {
    return _append$2(
      reference.pointer,
      _id_append$2 as jni$_.JMethodIDPtr,
      c,
    ).object<PrintStream?>(const $PrintStream$NullableType());
  }
}

final class $PrintStream$NullableType extends jni$_.JObjType<PrintStream?> {
  @jni$_.internal
  const $PrintStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PrintStream;';

  @jni$_.internal
  @core$_.override
  PrintStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PrintStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PrintStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($PrintStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PrintStream$NullableType) &&
        other is $PrintStream$NullableType;
  }
}

final class $PrintStream$Type extends jni$_.JObjType<PrintStream> {
  @jni$_.internal
  const $PrintStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/PrintStream;';

  @jni$_.internal
  @core$_.override
  PrintStream fromReference(jni$_.JReference reference) =>
      PrintStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $FilterOutputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<PrintStream?> get nullableType =>
      const $PrintStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($PrintStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PrintStream$Type) &&
        other is $PrintStream$Type;
  }
}

/// from: `java.io.SequenceInputStream`
class SequenceInputStream extends InputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<SequenceInputStream> $type;

  @jni$_.internal
  SequenceInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/SequenceInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $SequenceInputStream$NullableType();
  static const type = $SequenceInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/util/Enumeration;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.util.Enumeration<? extends java.io.InputStream> enumeration)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SequenceInputStream(jni$_.JObject? enumeration) {
    final _$enumeration = enumeration?.reference ?? jni$_.jNullReference;
    return SequenceInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$enumeration.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/io/InputStream;Ljava/io/InputStream;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.InputStream inputStream, java.io.InputStream inputStream1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory SequenceInputStream.new$1(
    InputStream? inputStream,
    InputStream? inputStream1,
  ) {
    final _$inputStream = inputStream?.reference ?? jni$_.jNullReference;
    final _$inputStream1 = inputStream1?.reference ?? jni$_.jNullReference;
    return SequenceInputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$inputStream.pointer,
        _$inputStream1.pointer,
      ).reference,
    );
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() {
    return _available(
      reference.pointer,
      _id_available as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() {
    return _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $SequenceInputStream$NullableType
    extends jni$_.JObjType<SequenceInputStream?> {
  @jni$_.internal
  const $SequenceInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/SequenceInputStream;';

  @jni$_.internal
  @core$_.override
  SequenceInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : SequenceInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SequenceInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SequenceInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SequenceInputStream$NullableType) &&
        other is $SequenceInputStream$NullableType;
  }
}

final class $SequenceInputStream$Type
    extends jni$_.JObjType<SequenceInputStream> {
  @jni$_.internal
  const $SequenceInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/SequenceInputStream;';

  @jni$_.internal
  @core$_.override
  SequenceInputStream fromReference(jni$_.JReference reference) =>
      SequenceInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<SequenceInputStream?> get nullableType =>
      const $SequenceInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($SequenceInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($SequenceInputStream$Type) &&
        other is $SequenceInputStream$Type;
  }
}

/// from: `java.io.FilterWriter`
class FilterWriter extends Writer {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FilterWriter> $type;

  @jni$_.internal
  FilterWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FilterWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FilterWriter$NullableType();
  static const type = $FilterWriter$Type();
  static final _id_write = _class.instanceMethodId(r'write', r'(I)V');

  static final _write =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void write(int i)`
  void write(int i) {
    _write(reference.pointer, _id_write as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_write2 = _class.instanceMethodId(r'write', r'([CII)V');

  static final _write2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(char[] cs, int i, int i1)`
  void write2(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    _write2(
      reference.pointer,
      _id_write2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_write4 = _class.instanceMethodId(
    r'write',
    r'(Ljava/lang/String;II)V',
  );

  static final _write4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void write(java.lang.String string, int i, int i1)`
  void write4(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _write4(
      reference.pointer,
      _id_write4 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).check();
  }

  static final _id_flush = _class.instanceMethodId(r'flush', r'()V');

  static final _flush =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void flush()`
  void flush() {
    _flush(reference.pointer, _id_flush as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }
}

final class $FilterWriter$NullableType extends jni$_.JObjType<FilterWriter?> {
  @jni$_.internal
  const $FilterWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterWriter;';

  @jni$_.internal
  @core$_.override
  FilterWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FilterWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FilterWriter$NullableType) &&
        other is $FilterWriter$NullableType;
  }
}

final class $FilterWriter$Type extends jni$_.JObjType<FilterWriter> {
  @jni$_.internal
  const $FilterWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FilterWriter;';

  @jni$_.internal
  @core$_.override
  FilterWriter fromReference(jni$_.JReference reference) =>
      FilterWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $Writer$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FilterWriter?> get nullableType =>
      const $FilterWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FilterWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FilterWriter$Type) &&
        other is $FilterWriter$Type;
  }
}

/// from: `java.io.FileWriter`
class FileWriter extends OutputStreamWriter {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileWriter> $type;

  @jni$_.internal
  FileWriter.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FileWriter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileWriter$NullableType();
  static const type = $FileWriter$Type();
  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'(Ljava/lang/String;Z)V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$5(jni$_.JString? string, bool z) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$string.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$6 = _class.constructorId(r'(Ljava/io/File;)V');

  static final _new$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$6(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$6(
        _class.reference.pointer,
        _id_new$6 as jni$_.JMethodIDPtr,
        _$file.pointer,
      ).reference,
    );
  }

  static final _id_new$7 = _class.constructorId(r'(Ljava/io/File;Z)V');

  static final _new$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.File file, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$7(File? file, bool z) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$7(
        _class.reference.pointer,
        _id_new$7 as jni$_.JMethodIDPtr,
        _$file.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$8 = _class.constructorId(r'(Ljava/io/FileDescriptor;)V');

  static final _new$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.FileDescriptor fileDescriptor)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$8(FileDescriptor? fileDescriptor) {
    final _$fileDescriptor = fileDescriptor?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$8(
        _class.reference.pointer,
        _id_new$8 as jni$_.JMethodIDPtr,
        _$fileDescriptor.pointer,
      ).reference,
    );
  }

  static final _id_new$9 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;)V',
  );

  static final _new$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$9(jni$_.JString? string, jni$_.JObject? charset) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$9(
        _class.reference.pointer,
        _id_new$9 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$10 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;Z)V',
  );

  static final _new$10 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.nio.charset.Charset charset, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$10(
    jni$_.JString? string,
    jni$_.JObject? charset,
    bool z,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$10(
        _class.reference.pointer,
        _id_new$10 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$charset.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }

  static final _id_new$11 = _class.constructorId(
    r'(Ljava/io/File;Ljava/nio/charset/Charset;)V',
  );

  static final _new$11 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$11(File? file, jni$_.JObject? charset) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$11(
        _class.reference.pointer,
        _id_new$11 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$12 = _class.constructorId(
    r'(Ljava/io/File;Ljava/nio/charset/Charset;Z)V',
  );

  static final _new$12 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.nio.charset.Charset charset, boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileWriter.new$12(File? file, jni$_.JObject? charset, bool z) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return FileWriter.fromReference(
      _new$12(
        _class.reference.pointer,
        _id_new$12 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$charset.pointer,
        z ? 1 : 0,
      ).reference,
    );
  }
}

final class $FileWriter$NullableType extends jni$_.JObjType<FileWriter?> {
  @jni$_.internal
  const $FileWriter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileWriter;';

  @jni$_.internal
  @core$_.override
  FileWriter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStreamWriter$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileWriter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($FileWriter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileWriter$NullableType) &&
        other is $FileWriter$NullableType;
  }
}

final class $FileWriter$Type extends jni$_.JObjType<FileWriter> {
  @jni$_.internal
  const $FileWriter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileWriter;';

  @jni$_.internal
  @core$_.override
  FileWriter fromReference(jni$_.JReference reference) =>
      FileWriter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $OutputStreamWriter$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileWriter?> get nullableType =>
      const $FileWriter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($FileWriter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileWriter$Type) && other is $FileWriter$Type;
  }
}

/// from: `java.io.OptionalDataException`
class OptionalDataException extends ObjectStreamException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<OptionalDataException> $type;

  @jni$_.internal
  OptionalDataException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/OptionalDataException');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $OptionalDataException$NullableType();
  static const type = $OptionalDataException$Type();
  static final _id_length = _class.instanceFieldId(r'length', r'I');

  /// from: `public int length`
  int get length => _id_length.get(this, const jni$_.jintType());

  /// from: `public int length`
  set length(int value) => _id_length.set(this, const jni$_.jintType(), value);

  static final _id_eof = _class.instanceFieldId(r'eof', r'Z');

  /// from: `public boolean eof`
  bool get eof => _id_eof.get(this, const jni$_.jbooleanType());

  /// from: `public boolean eof`
  set eof(bool value) => _id_eof.set(this, const jni$_.jbooleanType(), value);
}

final class $OptionalDataException$NullableType
    extends jni$_.JObjType<OptionalDataException?> {
  @jni$_.internal
  const $OptionalDataException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/OptionalDataException;';

  @jni$_.internal
  @core$_.override
  OptionalDataException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : OptionalDataException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OptionalDataException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($OptionalDataException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OptionalDataException$NullableType) &&
        other is $OptionalDataException$NullableType;
  }
}

final class $OptionalDataException$Type
    extends jni$_.JObjType<OptionalDataException> {
  @jni$_.internal
  const $OptionalDataException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/OptionalDataException;';

  @jni$_.internal
  @core$_.override
  OptionalDataException fromReference(jni$_.JReference reference) =>
      OptionalDataException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<OptionalDataException?> get nullableType =>
      const $OptionalDataException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($OptionalDataException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($OptionalDataException$Type) &&
        other is $OptionalDataException$Type;
  }
}

/// from: `java.io.FileInputStream`
class FileInputStream extends InputStream {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileInputStream> $type;

  @jni$_.internal
  FileInputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FileInputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileInputStream$NullableType();
  static const type = $FileInputStream$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileInputStream(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return FileInputStream.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Ljava/io/File;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileInputStream.new$1(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return FileInputStream.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$file.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Ljava/io/FileDescriptor;)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.FileDescriptor fileDescriptor)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileInputStream.new$2(FileDescriptor? fileDescriptor) {
    final _$fileDescriptor = fileDescriptor?.reference ?? jni$_.jNullReference;
    return FileInputStream.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$fileDescriptor.pointer,
      ).reference,
    );
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int read()`
  int read() {
    return _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read1 = _class.instanceMethodId(r'read', r'([B)I');

  static final _read1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(byte[] bs)`
  int read1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read1(
      reference.pointer,
      _id_read1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).integer;
  }

  static final _id_read2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read2(
      reference.pointer,
      _id_read2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_readAllBytes = _class.instanceMethodId(
    r'readAllBytes',
    r'()[B',
  );

  static final _readAllBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] readAllBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? readAllBytes() {
    return _readAllBytes(
      reference.pointer,
      _id_readAllBytes as jni$_.JMethodIDPtr,
    ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_readNBytes = _class.instanceMethodId(
    r'readNBytes',
    r'(I)[B',
  );

  static final _readNBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public byte[] readNBytes(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? readNBytes(int i) {
    return _readNBytes(
      reference.pointer,
      _id_readNBytes as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() {
    return _available(
      reference.pointer,
      _id_available as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_getFD = _class.instanceMethodId(
    r'getFD',
    r'()Ljava/io/FileDescriptor;',
  );

  static final _getFD =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final java.io.FileDescriptor getFD()`
  /// The returned object must be released after use, by calling the [release] method.
  FileDescriptor? getFD() {
    return _getFD(
      reference.pointer,
      _id_getFD as jni$_.JMethodIDPtr,
    ).object<FileDescriptor?>(const $FileDescriptor$NullableType());
  }

  static final _id_getChannel = _class.instanceMethodId(
    r'getChannel',
    r'()Ljava/nio/channels/FileChannel;',
  );

  static final _getChannel =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.channels.FileChannel getChannel()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getChannel() {
    return _getChannel(
      reference.pointer,
      _id_getChannel as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $FileInputStream$NullableType
    extends jni$_.JObjType<FileInputStream?> {
  @jni$_.internal
  const $FileInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileInputStream;';

  @jni$_.internal
  @core$_.override
  FileInputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileInputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FileInputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileInputStream$NullableType) &&
        other is $FileInputStream$NullableType;
  }
}

final class $FileInputStream$Type extends jni$_.JObjType<FileInputStream> {
  @jni$_.internal
  const $FileInputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileInputStream;';

  @jni$_.internal
  @core$_.override
  FileInputStream fromReference(jni$_.JReference reference) =>
      FileInputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileInputStream?> get nullableType =>
      const $FileInputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($FileInputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileInputStream$Type) &&
        other is $FileInputStream$Type;
  }
}

/// from: `java.io.NotSerializableException`
class NotSerializableException extends ObjectStreamException {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<NotSerializableException> $type;

  @jni$_.internal
  NotSerializableException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/NotSerializableException',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $NotSerializableException$NullableType();
  static const type = $NotSerializableException$Type();
  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory NotSerializableException.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return NotSerializableException.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'()V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory NotSerializableException.new$5() {
    return NotSerializableException.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
      ).reference,
    );
  }
}

final class $NotSerializableException$NullableType
    extends jni$_.JObjType<NotSerializableException?> {
  @jni$_.internal
  const $NotSerializableException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/NotSerializableException;';

  @jni$_.internal
  @core$_.override
  NotSerializableException? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : NotSerializableException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NotSerializableException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($NotSerializableException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NotSerializableException$NullableType) &&
        other is $NotSerializableException$NullableType;
  }
}

final class $NotSerializableException$Type
    extends jni$_.JObjType<NotSerializableException> {
  @jni$_.internal
  const $NotSerializableException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/NotSerializableException;';

  @jni$_.internal
  @core$_.override
  NotSerializableException fromReference(jni$_.JReference reference) =>
      NotSerializableException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ObjectStreamException$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<NotSerializableException?> get nullableType =>
      const $NotSerializableException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($NotSerializableException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($NotSerializableException$Type) &&
        other is $NotSerializableException$Type;
  }
}

/// from: `java.io.Closeable`
class Closeable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Closeable> $type;

  @jni$_.internal
  Closeable.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/Closeable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Closeable$NullableType();
  static const type = $Closeable$Type();
  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Closeable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'close()V') {
        _$impls[$p]!.close();
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $Closeable $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.Closeable', $p, _$invokePointer, [
      if ($impl.close$async) r'close()V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Closeable.implement($Closeable $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Closeable.fromReference($i.implementReference());
  }
}

abstract base mixin class $Closeable {
  factory $Closeable({required void Function() close, bool close$async}) =
      _$Closeable;

  void close();
  bool get close$async => false;
}

final class _$Closeable with $Closeable {
  _$Closeable({required void Function() close, this.close$async = false})
    : _close = close;

  final void Function() _close;
  final bool close$async;

  void close() {
    return _close();
  }
}

final class $Closeable$NullableType extends jni$_.JObjType<Closeable?> {
  @jni$_.internal
  const $Closeable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Closeable;';

  @jni$_.internal
  @core$_.override
  Closeable? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Closeable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Closeable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Closeable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Closeable$NullableType) &&
        other is $Closeable$NullableType;
  }
}

final class $Closeable$Type extends jni$_.JObjType<Closeable> {
  @jni$_.internal
  const $Closeable$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/Closeable;';

  @jni$_.internal
  @core$_.override
  Closeable fromReference(jni$_.JReference reference) =>
      Closeable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Closeable?> get nullableType =>
      const $Closeable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Closeable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Closeable$Type) && other is $Closeable$Type;
  }
}

/// from: `java.io.FileDescriptor`
class FileDescriptor extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileDescriptor> $type;

  @jni$_.internal
  FileDescriptor.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FileDescriptor');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileDescriptor$NullableType();
  static const type = $FileDescriptor$Type();
  static final _id_in$ = _class.staticFieldId(
    r'in',
    r'Ljava/io/FileDescriptor;',
  );

  /// from: `static public final java.io.FileDescriptor in`
  /// The returned object must be released after use, by calling the [release] method.
  static FileDescriptor? get in$ =>
      _id_in$.get(_class, const $FileDescriptor$NullableType());

  static final _id_out = _class.staticFieldId(
    r'out',
    r'Ljava/io/FileDescriptor;',
  );

  /// from: `static public final java.io.FileDescriptor out`
  /// The returned object must be released after use, by calling the [release] method.
  static FileDescriptor? get out =>
      _id_out.get(_class, const $FileDescriptor$NullableType());

  static final _id_err = _class.staticFieldId(
    r'err',
    r'Ljava/io/FileDescriptor;',
  );

  /// from: `static public final java.io.FileDescriptor err`
  /// The returned object must be released after use, by calling the [release] method.
  static FileDescriptor? get err =>
      _id_err.get(_class, const $FileDescriptor$NullableType());

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileDescriptor() {
    return FileDescriptor.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_valid = _class.instanceMethodId(r'valid', r'()Z');

  static final _valid =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean valid()`
  bool valid() {
    return _valid(reference.pointer, _id_valid as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_sync = _class.instanceMethodId(r'sync', r'()V');

  static final _sync =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public native void sync()`
  void sync() {
    _sync(reference.pointer, _id_sync as jni$_.JMethodIDPtr).check();
  }
}

final class $FileDescriptor$NullableType
    extends jni$_.JObjType<FileDescriptor?> {
  @jni$_.internal
  const $FileDescriptor$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileDescriptor;';

  @jni$_.internal
  @core$_.override
  FileDescriptor? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileDescriptor.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileDescriptor?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FileDescriptor$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileDescriptor$NullableType) &&
        other is $FileDescriptor$NullableType;
  }
}

final class $FileDescriptor$Type extends jni$_.JObjType<FileDescriptor> {
  @jni$_.internal
  const $FileDescriptor$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileDescriptor;';

  @jni$_.internal
  @core$_.override
  FileDescriptor fromReference(jni$_.JReference reference) =>
      FileDescriptor.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileDescriptor?> get nullableType =>
      const $FileDescriptor$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($FileDescriptor$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileDescriptor$Type) &&
        other is $FileDescriptor$Type;
  }
}

/// from: `java.io.ObjectInputFilter$Status`
class ObjectInputFilter$Status extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectInputFilter$Status> $type;

  @jni$_.internal
  ObjectInputFilter$Status.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'java/io/ObjectInputFilter$Status',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectInputFilter$Status$NullableType();
  static const type = $ObjectInputFilter$Status$Type();
  static final _id_UNDECIDED = _class.staticFieldId(
    r'UNDECIDED',
    r'Ljava/io/ObjectInputFilter$Status;',
  );

  /// from: `static public final java.io.ObjectInputFilter$Status UNDECIDED`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter$Status get UNDECIDED =>
      _id_UNDECIDED.get(_class, const $ObjectInputFilter$Status$Type());

  static final _id_ALLOWED = _class.staticFieldId(
    r'ALLOWED',
    r'Ljava/io/ObjectInputFilter$Status;',
  );

  /// from: `static public final java.io.ObjectInputFilter$Status ALLOWED`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter$Status get ALLOWED =>
      _id_ALLOWED.get(_class, const $ObjectInputFilter$Status$Type());

  static final _id_REJECTED = _class.staticFieldId(
    r'REJECTED',
    r'Ljava/io/ObjectInputFilter$Status;',
  );

  /// from: `static public final java.io.ObjectInputFilter$Status REJECTED`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter$Status get REJECTED =>
      _id_REJECTED.get(_class, const $ObjectInputFilter$Status$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/io/ObjectInputFilter$Status;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter$Status[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<ObjectInputFilter$Status?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<ObjectInputFilter$Status?>?>(
      const jni$_.JArrayNullableType<ObjectInputFilter$Status?>(
        $ObjectInputFilter$Status$NullableType(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/io/ObjectInputFilter$Status;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.ObjectInputFilter$Status valueOf(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static ObjectInputFilter$Status? valueOf(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<ObjectInputFilter$Status?>(
      const $ObjectInputFilter$Status$NullableType(),
    );
  }
}

final class $ObjectInputFilter$Status$NullableType
    extends jni$_.JObjType<ObjectInputFilter$Status?> {
  @jni$_.internal
  const $ObjectInputFilter$Status$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter$Status;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter$Status? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : ObjectInputFilter$Status.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter$Status?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$Status$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInputFilter$Status$NullableType) &&
        other is $ObjectInputFilter$Status$NullableType;
  }
}

final class $ObjectInputFilter$Status$Type
    extends jni$_.JObjType<ObjectInputFilter$Status> {
  @jni$_.internal
  const $ObjectInputFilter$Status$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectInputFilter$Status;';

  @jni$_.internal
  @core$_.override
  ObjectInputFilter$Status fromReference(jni$_.JReference reference) =>
      ObjectInputFilter$Status.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectInputFilter$Status?> get nullableType =>
      const $ObjectInputFilter$Status$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectInputFilter$Status$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectInputFilter$Status$Type) &&
        other is $ObjectInputFilter$Status$Type;
  }
}

/// from: `java.io.FileReader`
class FileReader extends InputStreamReader {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<FileReader> $type;

  @jni$_.internal
  FileReader.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/FileReader');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $FileReader$NullableType();
  static const type = $FileReader$Type();
  static final _id_new$4 = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileReader.new$4(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return FileReader.fromReference(
      _new$4(
        _class.reference.pointer,
        _id_new$4 as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$5 = _class.constructorId(r'(Ljava/io/File;)V');

  static final _new$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileReader.new$5(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return FileReader.fromReference(
      _new$5(
        _class.reference.pointer,
        _id_new$5 as jni$_.JMethodIDPtr,
        _$file.pointer,
      ).reference,
    );
  }

  static final _id_new$6 = _class.constructorId(r'(Ljava/io/FileDescriptor;)V');

  static final _new$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.FileDescriptor fileDescriptor)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileReader.new$6(FileDescriptor? fileDescriptor) {
    final _$fileDescriptor = fileDescriptor?.reference ?? jni$_.jNullReference;
    return FileReader.fromReference(
      _new$6(
        _class.reference.pointer,
        _id_new$6 as jni$_.JMethodIDPtr,
        _$fileDescriptor.pointer,
      ).reference,
    );
  }

  static final _id_new$7 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;)V',
  );

  static final _new$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileReader.new$7(jni$_.JString? string, jni$_.JObject? charset) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return FileReader.fromReference(
      _new$7(
        _class.reference.pointer,
        _id_new$7 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$charset.pointer,
      ).reference,
    );
  }

  static final _id_new$8 = _class.constructorId(
    r'(Ljava/io/File;Ljava/nio/charset/Charset;)V',
  );

  static final _new$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  factory FileReader.new$8(File? file, jni$_.JObject? charset) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return FileReader.fromReference(
      _new$8(
        _class.reference.pointer,
        _id_new$8 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$charset.pointer,
      ).reference,
    );
  }
}

final class $FileReader$NullableType extends jni$_.JObjType<FileReader?> {
  @jni$_.internal
  const $FileReader$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileReader;';

  @jni$_.internal
  @core$_.override
  FileReader? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : FileReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStreamReader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileReader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($FileReader$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileReader$NullableType) &&
        other is $FileReader$NullableType;
  }
}

final class $FileReader$Type extends jni$_.JObjType<FileReader> {
  @jni$_.internal
  const $FileReader$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/FileReader;';

  @jni$_.internal
  @core$_.override
  FileReader fromReference(jni$_.JReference reference) =>
      FileReader.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $InputStreamReader$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<FileReader?> get nullableType =>
      const $FileReader$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($FileReader$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($FileReader$Type) && other is $FileReader$Type;
  }
}

/// from: `java.io.ObjectStreamConstants`
class ObjectStreamConstants extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ObjectStreamConstants> $type;

  @jni$_.internal
  ObjectStreamConstants.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/ObjectStreamConstants');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ObjectStreamConstants$NullableType();
  static const type = $ObjectStreamConstants$Type();

  /// from: `static public final short STREAM_MAGIC`
  static const STREAM_MAGIC = -21267;

  /// from: `static public final short STREAM_VERSION`
  static const STREAM_VERSION = 5;

  /// from: `static public final byte TC_BASE`
  static const TC_BASE = 112;

  /// from: `static public final byte TC_NULL`
  static const TC_NULL = 112;

  /// from: `static public final byte TC_REFERENCE`
  static const TC_REFERENCE = 113;

  /// from: `static public final byte TC_CLASSDESC`
  static const TC_CLASSDESC = 114;

  /// from: `static public final byte TC_OBJECT`
  static const TC_OBJECT = 115;

  /// from: `static public final byte TC_STRING`
  static const TC_STRING = 116;

  /// from: `static public final byte TC_ARRAY`
  static const TC_ARRAY = 117;

  /// from: `static public final byte TC_CLASS`
  static const TC_CLASS = 118;

  /// from: `static public final byte TC_BLOCKDATA`
  static const TC_BLOCKDATA = 119;

  /// from: `static public final byte TC_ENDBLOCKDATA`
  static const TC_ENDBLOCKDATA = 120;

  /// from: `static public final byte TC_RESET`
  static const TC_RESET = 121;

  /// from: `static public final byte TC_BLOCKDATALONG`
  static const TC_BLOCKDATALONG = 122;

  /// from: `static public final byte TC_EXCEPTION`
  static const TC_EXCEPTION = 123;

  /// from: `static public final byte TC_LONGSTRING`
  static const TC_LONGSTRING = 124;

  /// from: `static public final byte TC_PROXYCLASSDESC`
  static const TC_PROXYCLASSDESC = 125;

  /// from: `static public final byte TC_ENUM`
  static const TC_ENUM = 126;

  /// from: `static public final byte TC_MAX`
  static const TC_MAX = 126;

  /// from: `static public final int baseWireHandle`
  static const baseWireHandle = 8257536;

  /// from: `static public final byte SC_WRITE_METHOD`
  static const SC_WRITE_METHOD = 1;

  /// from: `static public final byte SC_BLOCK_DATA`
  static const SC_BLOCK_DATA = 8;

  /// from: `static public final byte SC_SERIALIZABLE`
  static const SC_SERIALIZABLE = 2;

  /// from: `static public final byte SC_EXTERNALIZABLE`
  static const SC_EXTERNALIZABLE = 4;

  /// from: `static public final byte SC_ENUM`
  static const SC_ENUM = 16;
  static final _id_SUBSTITUTION_PERMISSION = _class.staticFieldId(
    r'SUBSTITUTION_PERMISSION',
    r'Ljava/io/SerializablePermission;',
  );

  /// from: `static public final java.io.SerializablePermission SUBSTITUTION_PERMISSION`
  /// The returned object must be released after use, by calling the [release] method.
  static SerializablePermission? get SUBSTITUTION_PERMISSION =>
      _id_SUBSTITUTION_PERMISSION.get(
        _class,
        const $SerializablePermission$NullableType(),
      );

  static final _id_SUBCLASS_IMPLEMENTATION_PERMISSION = _class.staticFieldId(
    r'SUBCLASS_IMPLEMENTATION_PERMISSION',
    r'Ljava/io/SerializablePermission;',
  );

  /// from: `static public final java.io.SerializablePermission SUBCLASS_IMPLEMENTATION_PERMISSION`
  /// The returned object must be released after use, by calling the [release] method.
  static SerializablePermission? get SUBCLASS_IMPLEMENTATION_PERMISSION =>
      _id_SUBCLASS_IMPLEMENTATION_PERMISSION.get(
        _class,
        const $SerializablePermission$NullableType(),
      );

  static final _id_SERIAL_FILTER_PERMISSION = _class.staticFieldId(
    r'SERIAL_FILTER_PERMISSION',
    r'Ljava/io/SerializablePermission;',
  );

  /// from: `static public final java.io.SerializablePermission SERIAL_FILTER_PERMISSION`
  /// The returned object must be released after use, by calling the [release] method.
  static SerializablePermission? get SERIAL_FILTER_PERMISSION =>
      _id_SERIAL_FILTER_PERMISSION.get(
        _class,
        const $SerializablePermission$NullableType(),
      );

  /// from: `static public final int PROTOCOL_VERSION_1`
  static const PROTOCOL_VERSION_1 = 1;

  /// from: `static public final int PROTOCOL_VERSION_2`
  static const PROTOCOL_VERSION_2 = 2;

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ObjectStreamConstants> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ObjectStreamConstants $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.io.ObjectStreamConstants', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ObjectStreamConstants.implement($ObjectStreamConstants $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ObjectStreamConstants.fromReference($i.implementReference());
  }
}

abstract base mixin class $ObjectStreamConstants {
  factory $ObjectStreamConstants() = _$ObjectStreamConstants;
}

final class _$ObjectStreamConstants with $ObjectStreamConstants {
  _$ObjectStreamConstants();
}

final class $ObjectStreamConstants$NullableType
    extends jni$_.JObjType<ObjectStreamConstants?> {
  @jni$_.internal
  const $ObjectStreamConstants$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamConstants;';

  @jni$_.internal
  @core$_.override
  ObjectStreamConstants? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ObjectStreamConstants.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamConstants?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectStreamConstants$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectStreamConstants$NullableType) &&
        other is $ObjectStreamConstants$NullableType;
  }
}

final class $ObjectStreamConstants$Type
    extends jni$_.JObjType<ObjectStreamConstants> {
  @jni$_.internal
  const $ObjectStreamConstants$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/ObjectStreamConstants;';

  @jni$_.internal
  @core$_.override
  ObjectStreamConstants fromReference(jni$_.JReference reference) =>
      ObjectStreamConstants.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ObjectStreamConstants?> get nullableType =>
      const $ObjectStreamConstants$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ObjectStreamConstants$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ObjectStreamConstants$Type) &&
        other is $ObjectStreamConstants$Type;
  }
}

/// from: `java.io.InputStream`
class InputStream extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<InputStream> $type;

  @jni$_.internal
  InputStream.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/InputStream');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $InputStream$NullableType();
  static const type = $InputStream$Type();
  static final _id_nullInputStream = _class.staticMethodId(
    r'nullInputStream',
    r'()Ljava/io/InputStream;',
  );

  static final _nullInputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.InputStream nullInputStream()`
  /// The returned object must be released after use, by calling the [release] method.
  static InputStream? nullInputStream() {
    return _nullInputStream(
      _class.reference.pointer,
      _id_nullInputStream as jni$_.JMethodIDPtr,
    ).object<InputStream?>(const $InputStream$NullableType());
  }

  static final _id_read = _class.instanceMethodId(r'read', r'()I');

  static final _read =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int read()`
  int read() {
    return _read(reference.pointer, _id_read as jni$_.JMethodIDPtr).integer;
  }

  static final _id_read$1 = _class.instanceMethodId(r'read', r'([B)I');

  static final _read$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int read(byte[] bs)`
  int read$1(jni$_.JByteArray? bs) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read$1(
      reference.pointer,
      _id_read$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
    ).integer;
  }

  static final _id_read$2 = _class.instanceMethodId(r'read', r'([BII)I');

  static final _read$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int read(byte[] bs, int i, int i1)`
  int read$2(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _read$2(
      reference.pointer,
      _id_read$2 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_readAllBytes = _class.instanceMethodId(
    r'readAllBytes',
    r'()[B',
  );

  static final _readAllBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte[] readAllBytes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? readAllBytes() {
    return _readAllBytes(
      reference.pointer,
      _id_readAllBytes as jni$_.JMethodIDPtr,
    ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_readNBytes = _class.instanceMethodId(
    r'readNBytes',
    r'(I)[B',
  );

  static final _readNBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public byte[] readNBytes(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? readNBytes(int i) {
    return _readNBytes(
      reference.pointer,
      _id_readNBytes as jni$_.JMethodIDPtr,
      i,
    ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_readNBytes$1 = _class.instanceMethodId(
    r'readNBytes',
    r'([BII)I',
  );

  static final _readNBytes$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public int readNBytes(byte[] bs, int i, int i1)`
  int readNBytes$1(jni$_.JByteArray? bs, int i, int i1) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _readNBytes$1(
      reference.pointer,
      _id_readNBytes$1 as jni$_.JMethodIDPtr,
      _$bs.pointer,
      i,
      i1,
    ).integer;
  }

  static final _id_skip = _class.instanceMethodId(r'skip', r'(J)J');

  static final _skip =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public long skip(long j)`
  int skip(int j) {
    return _skip(reference.pointer, _id_skip as jni$_.JMethodIDPtr, j).long;
  }

  static final _id_skipNBytes = _class.instanceMethodId(r'skipNBytes', r'(J)V');

  static final _skipNBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void skipNBytes(long j)`
  void skipNBytes(int j) {
    _skipNBytes(
      reference.pointer,
      _id_skipNBytes as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_available = _class.instanceMethodId(r'available', r'()I');

  static final _available =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int available()`
  int available() {
    return _available(
      reference.pointer,
      _id_available as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_mark = _class.instanceMethodId(r'mark', r'(I)V');

  static final _mark =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void mark(int i)`
  void mark(int i) {
    _mark(reference.pointer, _id_mark as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_markSupported = _class.instanceMethodId(
    r'markSupported',
    r'()Z',
  );

  static final _markSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean markSupported()`
  bool markSupported() {
    return _markSupported(
      reference.pointer,
      _id_markSupported as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_transferTo = _class.instanceMethodId(
    r'transferTo',
    r'(Ljava/io/OutputStream;)J',
  );

  static final _transferTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long transferTo(java.io.OutputStream outputStream)`
  int transferTo(OutputStream? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    return _transferTo(
      reference.pointer,
      _id_transferTo as jni$_.JMethodIDPtr,
      _$outputStream.pointer,
    ).long;
  }
}

final class $InputStream$NullableType extends jni$_.JObjType<InputStream?> {
  @jni$_.internal
  const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InputStream;';

  @jni$_.internal
  @core$_.override
  InputStream? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : InputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InputStream?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InputStream$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InputStream$NullableType) &&
        other is $InputStream$NullableType;
  }
}

final class $InputStream$Type extends jni$_.JObjType<InputStream> {
  @jni$_.internal
  const $InputStream$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/InputStream;';

  @jni$_.internal
  @core$_.override
  InputStream fromReference(jni$_.JReference reference) =>
      InputStream.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<InputStream?> get nullableType =>
      const $InputStream$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($InputStream$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($InputStream$Type) &&
        other is $InputStream$Type;
  }
}

/// from: `com.Accumulator`
class Accumulator extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Accumulator> $type;

  @jni$_.internal
  Accumulator.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/Accumulator');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Accumulator$NullableType();
  static const type = $Accumulator$Type();
  static final _id_accumulator = _class.instanceFieldId(r'accumulator', r'I');

  /// from: `public int accumulator`
  int get accumulator => _id_accumulator.get(this, const jni$_.jintType());

  /// from: `public int accumulator`
  set accumulator(int value) =>
      _id_accumulator.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Accumulator() {
    return Accumulator.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(I)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int initialValue)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Accumulator.new$1(int initialValue) {
    return Accumulator.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        initialValue,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Lcom/Accumulator;)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(com.Accumulator other)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Accumulator.new$2(Accumulator? other) {
    final _$other = other?.reference ?? jni$_.jNullReference;
    return Accumulator.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$other.pointer,
      ).reference,
    );
  }

  static final _id_add = _class.instanceMethodId(r'add', r'(I)V');

  static final _add =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void add(int value)`
  void add(int value) {
    _add(reference.pointer, _id_add as jni$_.JMethodIDPtr, value).check();
  }

  static final _id_add$1 = _class.instanceMethodId(r'add', r'(II)V');

  static final _add$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void add(int value1, int value2)`
  void add$1(int value1, int value2) {
    _add$1(
      reference.pointer,
      _id_add$1 as jni$_.JMethodIDPtr,
      value1,
      value2,
    ).check();
  }

  static final _id_add$2 = _class.instanceMethodId(r'add', r'(III)V');

  static final _add$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public void add(int value1, int value2, int value3)`
  void add$2(int value1, int value2, int value3) {
    _add$2(
      reference.pointer,
      _id_add$2 as jni$_.JMethodIDPtr,
      value1,
      value2,
      value3,
    ).check();
  }

  static final _id_add$3 = _class.instanceMethodId(
    r'add',
    r'(Lcom/Accumulator;)V',
  );

  static final _add$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void add(com.Accumulator other)`
  void add$3(Accumulator? other) {
    final _$other = other?.reference ?? jni$_.jNullReference;
    _add$3(
      reference.pointer,
      _id_add$3 as jni$_.JMethodIDPtr,
      _$other.pointer,
    ).check();
  }
}

final class $Accumulator$NullableType extends jni$_.JObjType<Accumulator?> {
  @jni$_.internal
  const $Accumulator$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Accumulator;';

  @jni$_.internal
  @core$_.override
  Accumulator? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Accumulator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Accumulator?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Accumulator$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Accumulator$NullableType) &&
        other is $Accumulator$NullableType;
  }
}

final class $Accumulator$Type extends jni$_.JObjType<Accumulator> {
  @jni$_.internal
  const $Accumulator$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Accumulator;';

  @jni$_.internal
  @core$_.override
  Accumulator fromReference(jni$_.JReference reference) =>
      Accumulator.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Accumulator?> get nullableType =>
      const $Accumulator$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Accumulator$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Accumulator$Type) &&
        other is $Accumulator$Type;
  }
}

/// from: `com.Example`
class Example extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Example> $type;

  @jni$_.internal
  Example.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/Example');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Example$NullableType();
  static const type = $Example$Type();
  static final _id_has$$dollar$$sign = _class.staticFieldId(
    r'has$dollar$sign',
    r'I',
  );

  /// from: `static public int has$dollar$sign`
  static int get has$$dollar$$sign =>
      _id_has$$dollar$$sign.get(_class, const jni$_.jintType());

  /// from: `static public int has$dollar$sign`
  static set has$$dollar$$sign(int value) =>
      _id_has$$dollar$$sign.set(_class, const jni$_.jintType(), value);

  static final _id_$_startsWithUnderscore = _class.staticFieldId(
    r'_startsWithUnderscore',
    r'I',
  );

  /// from: `static public int _startsWithUnderscore`
  static int get $_startsWithUnderscore =>
      _id_$_startsWithUnderscore.get(_class, const jni$_.jintType());

  /// from: `static public int _startsWithUnderscore`
  static set $_startsWithUnderscore(int value) =>
      _id_$_startsWithUnderscore.set(_class, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Example() {
    return Example.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_greet = _class.instanceMethodId(
    r'greet',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _greet =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String greet(java.lang.String name)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? greet(jni$_.JString? name) {
    final _$name = name?.reference ?? jni$_.jNullReference;
    return _greet(
      reference.pointer,
      _id_greet as jni$_.JMethodIDPtr,
      _$name.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_enumValueToString = _class.instanceMethodId(
    r'enumValueToString',
    r'(Lcom/Example$Operation;)Ljava/lang/String;',
  );

  static final _enumValueToString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String enumValueToString(com.Example$Operation operation)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? enumValueToString(Example$Operation? operation) {
    final _$operation = operation?.reference ?? jni$_.jNullReference;
    return _enumValueToString(
      reference.pointer,
      _id_enumValueToString as jni$_.JMethodIDPtr,
      _$operation.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $Example$NullableType extends jni$_.JObjType<Example?> {
  @jni$_.internal
  const $Example$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Example;';

  @jni$_.internal
  @core$_.override
  Example? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Example.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$NullableType) &&
        other is $Example$NullableType;
  }
}

final class $Example$Type extends jni$_.JObjType<Example> {
  @jni$_.internal
  const $Example$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Example;';

  @jni$_.internal
  @core$_.override
  Example fromReference(jni$_.JReference reference) =>
      Example.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example?> get nullableType => const $Example$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Type) && other is $Example$Type;
  }
}

/// from: `com.Example$Operation`
class Example$Operation extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Example$Operation> $type;

  @jni$_.internal
  Example$Operation.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/Example$Operation');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Example$Operation$NullableType();
  static const type = $Example$Operation$Type();
  static final _id_ADD = _class.staticFieldId(
    r'ADD',
    r'Lcom/Example$Operation;',
  );

  /// from: `static public final com.Example$Operation ADD`
  /// The returned object must be released after use, by calling the [release] method.
  static Example$Operation get ADD =>
      _id_ADD.get(_class, const $Example$Operation$Type());

  static final _id_SUBTRACT = _class.staticFieldId(
    r'SUBTRACT',
    r'Lcom/Example$Operation;',
  );

  /// from: `static public final com.Example$Operation SUBTRACT`
  /// The returned object must be released after use, by calling the [release] method.
  static Example$Operation get SUBTRACT =>
      _id_SUBTRACT.get(_class, const $Example$Operation$Type());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lcom/Example$Operation;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public com.Example$Operation[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Example$Operation?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Example$Operation?>?>(
      const jni$_.JArrayNullableType<Example$Operation?>(
        $Example$Operation$NullableType(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lcom/Example$Operation;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public com.Example$Operation valueOf(java.lang.String name)`
  /// The returned object must be released after use, by calling the [release] method.
  static Example$Operation? valueOf(jni$_.JString? name) {
    final _$name = name?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$name.pointer,
    ).object<Example$Operation?>(const $Example$Operation$NullableType());
  }
}

final class $Example$Operation$NullableType
    extends jni$_.JObjType<Example$Operation?> {
  @jni$_.internal
  const $Example$Operation$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Example$Operation;';

  @jni$_.internal
  @core$_.override
  Example$Operation? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Example$Operation.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$Operation?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Operation$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Operation$NullableType) &&
        other is $Example$Operation$NullableType;
  }
}

final class $Example$Operation$Type extends jni$_.JObjType<Example$Operation> {
  @jni$_.internal
  const $Example$Operation$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Example$Operation;';

  @jni$_.internal
  @core$_.override
  Example$Operation fromReference(jni$_.JReference reference) =>
      Example$Operation.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Example$Operation?> get nullableType =>
      const $Example$Operation$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Example$Operation$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Example$Operation$Type) &&
        other is $Example$Operation$Type;
  }
}

/// from: `com.Runnable`
class Runnable extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Runnable> $type;

  @jni$_.internal
  Runnable.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'com/Runnable');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Runnable$NullableType();
  static const type = $Runnable$Type();
  static final _id_run = _class.instanceMethodId(r'run', r'()I');

  static final _run =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int run()`
  int run() {
    return _run(reference.pointer, _id_run as jni$_.JMethodIDPtr).integer;
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Runnable> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'run()I') {
        final $r = _$impls[$p]!.run();
        return jni$_.JInteger($r).reference.toPointer();
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $Runnable $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'com.Runnable', $p, _$invokePointer, []);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Runnable.implement($Runnable $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Runnable.fromReference($i.implementReference());
  }
}

abstract base mixin class $Runnable {
  factory $Runnable({required int Function() run}) = _$Runnable;

  int run();
}

final class _$Runnable with $Runnable {
  _$Runnable({required int Function() run}) : _run = run;

  final int Function() _run;

  int run() {
    return _run();
  }
}

final class $Runnable$NullableType extends jni$_.JObjType<Runnable?> {
  @jni$_.internal
  const $Runnable$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Runnable;';

  @jni$_.internal
  @core$_.override
  Runnable? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Runnable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Runnable?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Runnable$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Runnable$NullableType) &&
        other is $Runnable$NullableType;
  }
}

final class $Runnable$Type extends jni$_.JObjType<Runnable> {
  @jni$_.internal
  const $Runnable$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lcom/Runnable;';

  @jni$_.internal
  @core$_.override
  Runnable fromReference(jni$_.JReference reference) =>
      Runnable.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Runnable?> get nullableType => const $Runnable$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Runnable$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Runnable$Type) && other is $Runnable$Type;
  }
}
