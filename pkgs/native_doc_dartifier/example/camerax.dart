// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters
// ignore_for_file: prefer_expression_function_bodies

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `java.io.File`
class File extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<File> $type;

  @jni$_.internal
  File.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/io/File');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $File$NullableType();
  static const type = $File$Type();
  static final _id_pathSeparator = _class.staticFieldId(
    r'pathSeparator',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String pathSeparator`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get pathSeparator =>
      _id_pathSeparator.get(_class, const jni$_.JStringNullableType());

  static final _id_pathSeparatorChar = _class.staticFieldId(
    r'pathSeparatorChar',
    r'C',
  );

  /// from: `static public final char pathSeparatorChar`
  static int get pathSeparatorChar =>
      _id_pathSeparatorChar.get(_class, const jni$_.jcharType());

  static final _id_separator = _class.staticFieldId(
    r'separator',
    r'Ljava/lang/String;',
  );

  /// from: `static public final java.lang.String separator`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JString? get separator =>
      _id_separator.get(_class, const jni$_.JStringNullableType());

  static final _id_separatorChar = _class.staticFieldId(r'separatorChar', r'C');

  /// from: `static public final char separatorChar`
  static int get separatorChar =>
      _id_separatorChar.get(_class, const jni$_.jcharType());

  static final _id_new$ = _class.constructorId(r'(Ljava/lang/String;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return File.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$1(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return File.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$string.pointer,
        _$string1.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/io/File;Ljava/lang/String;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$2(File? file, jni$_.JString? string) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return File.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$file.pointer,
        _$string.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(r'(Ljava/net/URI;)V');

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.net.URI uRI)`
  /// The returned object must be released after use, by calling the [release] method.
  factory File.new$3(jni$_.JObject? uRI) {
    final _$uRI = uRI?.reference ?? jni$_.jNullReference;
    return File.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$uRI.pointer,
      ).reference,
    );
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getName() {
    return _getName(
      reference.pointer,
      _id_getName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getParent = _class.instanceMethodId(
    r'getParent',
    r'()Ljava/lang/String;',
  );

  static final _getParent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getParent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getParent() {
    return _getParent(
      reference.pointer,
      _id_getParent as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getParentFile = _class.instanceMethodId(
    r'getParentFile',
    r'()Ljava/io/File;',
  );

  static final _getParentFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.File getParentFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getParentFile() {
    return _getParentFile(
      reference.pointer,
      _id_getParentFile as jni$_.JMethodIDPtr,
    ).object<File?>(const $File$NullableType());
  }

  static final _id_getPath = _class.instanceMethodId(
    r'getPath',
    r'()Ljava/lang/String;',
  );

  static final _getPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPath() {
    return _getPath(
      reference.pointer,
      _id_getPath as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isAbsolute = _class.instanceMethodId(r'isAbsolute', r'()Z');

  static final _isAbsolute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isAbsolute()`
  bool isAbsolute() {
    return _isAbsolute(
      reference.pointer,
      _id_isAbsolute as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getAbsolutePath = _class.instanceMethodId(
    r'getAbsolutePath',
    r'()Ljava/lang/String;',
  );

  static final _getAbsolutePath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getAbsolutePath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAbsolutePath() {
    return _getAbsolutePath(
      reference.pointer,
      _id_getAbsolutePath as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getAbsoluteFile = _class.instanceMethodId(
    r'getAbsoluteFile',
    r'()Ljava/io/File;',
  );

  static final _getAbsoluteFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.File getAbsoluteFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getAbsoluteFile() {
    return _getAbsoluteFile(
      reference.pointer,
      _id_getAbsoluteFile as jni$_.JMethodIDPtr,
    ).object<File?>(const $File$NullableType());
  }

  static final _id_getCanonicalPath = _class.instanceMethodId(
    r'getCanonicalPath',
    r'()Ljava/lang/String;',
  );

  static final _getCanonicalPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getCanonicalPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getCanonicalPath() {
    return _getCanonicalPath(
      reference.pointer,
      _id_getCanonicalPath as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getCanonicalFile = _class.instanceMethodId(
    r'getCanonicalFile',
    r'()Ljava/io/File;',
  );

  static final _getCanonicalFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.File getCanonicalFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getCanonicalFile() {
    return _getCanonicalFile(
      reference.pointer,
      _id_getCanonicalFile as jni$_.JMethodIDPtr,
    ).object<File?>(const $File$NullableType());
  }

  static final _id_toURL = _class.instanceMethodId(
    r'toURL',
    r'()Ljava/net/URL;',
  );

  static final _toURL =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URL toURL()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toURL() {
    return _toURL(
      reference.pointer,
      _id_toURL as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toURI = _class.instanceMethodId(
    r'toURI',
    r'()Ljava/net/URI;',
  );

  static final _toURI =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.net.URI toURI()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toURI() {
    return _toURI(
      reference.pointer,
      _id_toURI as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_canRead = _class.instanceMethodId(r'canRead', r'()Z');

  static final _canRead =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean canRead()`
  bool canRead() {
    return _canRead(
      reference.pointer,
      _id_canRead as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_canWrite = _class.instanceMethodId(r'canWrite', r'()Z');

  static final _canWrite =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean canWrite()`
  bool canWrite() {
    return _canWrite(
      reference.pointer,
      _id_canWrite as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_exists = _class.instanceMethodId(r'exists', r'()Z');

  static final _exists =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean exists()`
  bool exists() {
    return _exists(reference.pointer, _id_exists as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_isDirectory = _class.instanceMethodId(
    r'isDirectory',
    r'()Z',
  );

  static final _isDirectory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isDirectory()`
  bool isDirectory() {
    return _isDirectory(
      reference.pointer,
      _id_isDirectory as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isFile = _class.instanceMethodId(r'isFile', r'()Z');

  static final _isFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isFile()`
  bool isFile() {
    return _isFile(reference.pointer, _id_isFile as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_isHidden = _class.instanceMethodId(r'isHidden', r'()Z');

  static final _isHidden =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isHidden()`
  bool isHidden() {
    return _isHidden(
      reference.pointer,
      _id_isHidden as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_lastModified = _class.instanceMethodId(
    r'lastModified',
    r'()J',
  );

  static final _lastModified =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long lastModified()`
  int lastModified() {
    return _lastModified(
      reference.pointer,
      _id_lastModified as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_length = _class.instanceMethodId(r'length', r'()J');

  static final _length =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long length()`
  int length() {
    return _length(reference.pointer, _id_length as jni$_.JMethodIDPtr).long;
  }

  static final _id_createNewFile = _class.instanceMethodId(
    r'createNewFile',
    r'()Z',
  );

  static final _createNewFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean createNewFile()`
  bool createNewFile() {
    return _createNewFile(
      reference.pointer,
      _id_createNewFile as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_delete = _class.instanceMethodId(r'delete', r'()Z');

  static final _delete =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean delete()`
  bool delete() {
    return _delete(reference.pointer, _id_delete as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_deleteOnExit = _class.instanceMethodId(
    r'deleteOnExit',
    r'()V',
  );

  static final _deleteOnExit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void deleteOnExit()`
  void deleteOnExit() {
    _deleteOnExit(
      reference.pointer,
      _id_deleteOnExit as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_list = _class.instanceMethodId(
    r'list',
    r'()[Ljava/lang/String;',
  );

  static final _list =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String[] list()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? list() {
    return _list(
      reference.pointer,
      _id_list as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<jni$_.JString?>?>(
      const jni$_.JArrayNullableType<jni$_.JString?>(
        jni$_.JStringNullableType(),
      ),
    );
  }

  static final _id_list$1 = _class.instanceMethodId(
    r'list',
    r'(Ljava/io/FilenameFilter;)[Ljava/lang/String;',
  );

  static final _list$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String[] list(java.io.FilenameFilter filenameFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<jni$_.JString?>? list$1(jni$_.JObject? filenameFilter) {
    final _$filenameFilter = filenameFilter?.reference ?? jni$_.jNullReference;
    return _list$1(
      reference.pointer,
      _id_list$1 as jni$_.JMethodIDPtr,
      _$filenameFilter.pointer,
    ).object<jni$_.JArray<jni$_.JString?>?>(
      const jni$_.JArrayNullableType<jni$_.JString?>(
        jni$_.JStringNullableType(),
      ),
    );
  }

  static final _id_listFiles = _class.instanceMethodId(
    r'listFiles',
    r'()[Ljava/io/File;',
  );

  static final _listFiles =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.File[] listFiles()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles() {
    return _listFiles(
      reference.pointer,
      _id_listFiles as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<File?>?>(
      const jni$_.JArrayNullableType<File?>($File$NullableType()),
    );
  }

  static final _id_listFiles$1 = _class.instanceMethodId(
    r'listFiles',
    r'(Ljava/io/FilenameFilter;)[Ljava/io/File;',
  );

  static final _listFiles$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.File[] listFiles(java.io.FilenameFilter filenameFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles$1(jni$_.JObject? filenameFilter) {
    final _$filenameFilter = filenameFilter?.reference ?? jni$_.jNullReference;
    return _listFiles$1(
      reference.pointer,
      _id_listFiles$1 as jni$_.JMethodIDPtr,
      _$filenameFilter.pointer,
    ).object<jni$_.JArray<File?>?>(
      const jni$_.JArrayNullableType<File?>($File$NullableType()),
    );
  }

  static final _id_listFiles$2 = _class.instanceMethodId(
    r'listFiles',
    r'(Ljava/io/FileFilter;)[Ljava/io/File;',
  );

  static final _listFiles$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.io.File[] listFiles(java.io.FileFilter fileFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JArray<File?>? listFiles$2(jni$_.JObject? fileFilter) {
    final _$fileFilter = fileFilter?.reference ?? jni$_.jNullReference;
    return _listFiles$2(
      reference.pointer,
      _id_listFiles$2 as jni$_.JMethodIDPtr,
      _$fileFilter.pointer,
    ).object<jni$_.JArray<File?>?>(
      const jni$_.JArrayNullableType<File?>($File$NullableType()),
    );
  }

  static final _id_mkdir = _class.instanceMethodId(r'mkdir', r'()Z');

  static final _mkdir =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean mkdir()`
  bool mkdir() {
    return _mkdir(reference.pointer, _id_mkdir as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_mkdirs = _class.instanceMethodId(r'mkdirs', r'()Z');

  static final _mkdirs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean mkdirs()`
  bool mkdirs() {
    return _mkdirs(reference.pointer, _id_mkdirs as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_renameTo = _class.instanceMethodId(
    r'renameTo',
    r'(Ljava/io/File;)Z',
  );

  static final _renameTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean renameTo(java.io.File file)`
  bool renameTo(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _renameTo(
      reference.pointer,
      _id_renameTo as jni$_.JMethodIDPtr,
      _$file.pointer,
    ).boolean;
  }

  static final _id_setLastModified = _class.instanceMethodId(
    r'setLastModified',
    r'(J)Z',
  );

  static final _setLastModified =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean setLastModified(long j)`
  bool setLastModified(int j) {
    return _setLastModified(
      reference.pointer,
      _id_setLastModified as jni$_.JMethodIDPtr,
      j,
    ).boolean;
  }

  static final _id_setReadOnly = _class.instanceMethodId(
    r'setReadOnly',
    r'()Z',
  );

  static final _setReadOnly =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean setReadOnly()`
  bool setReadOnly() {
    return _setReadOnly(
      reference.pointer,
      _id_setReadOnly as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setWritable = _class.instanceMethodId(
    r'setWritable',
    r'(ZZ)Z',
  );

  static final _setWritable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public boolean setWritable(boolean z, boolean z1)`
  bool setWritable(bool z, bool z1) {
    return _setWritable(
      reference.pointer,
      _id_setWritable as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      z1 ? 1 : 0,
    ).boolean;
  }

  static final _id_setWritable$1 = _class.instanceMethodId(
    r'setWritable',
    r'(Z)Z',
  );

  static final _setWritable$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean setWritable(boolean z)`
  bool setWritable$1(bool z) {
    return _setWritable$1(
      reference.pointer,
      _id_setWritable$1 as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_setReadable = _class.instanceMethodId(
    r'setReadable',
    r'(ZZ)Z',
  );

  static final _setReadable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public boolean setReadable(boolean z, boolean z1)`
  bool setReadable(bool z, bool z1) {
    return _setReadable(
      reference.pointer,
      _id_setReadable as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      z1 ? 1 : 0,
    ).boolean;
  }

  static final _id_setReadable$1 = _class.instanceMethodId(
    r'setReadable',
    r'(Z)Z',
  );

  static final _setReadable$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean setReadable(boolean z)`
  bool setReadable$1(bool z) {
    return _setReadable$1(
      reference.pointer,
      _id_setReadable$1 as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_setExecutable = _class.instanceMethodId(
    r'setExecutable',
    r'(ZZ)Z',
  );

  static final _setExecutable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public boolean setExecutable(boolean z, boolean z1)`
  bool setExecutable(bool z, bool z1) {
    return _setExecutable(
      reference.pointer,
      _id_setExecutable as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      z1 ? 1 : 0,
    ).boolean;
  }

  static final _id_setExecutable$1 = _class.instanceMethodId(
    r'setExecutable',
    r'(Z)Z',
  );

  static final _setExecutable$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean setExecutable(boolean z)`
  bool setExecutable$1(bool z) {
    return _setExecutable$1(
      reference.pointer,
      _id_setExecutable$1 as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).boolean;
  }

  static final _id_canExecute = _class.instanceMethodId(r'canExecute', r'()Z');

  static final _canExecute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean canExecute()`
  bool canExecute() {
    return _canExecute(
      reference.pointer,
      _id_canExecute as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_listRoots = _class.staticMethodId(
    r'listRoots',
    r'()[Ljava/io/File;',
  );

  static final _listRoots =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public java.io.File[] listRoots()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<File?>? listRoots() {
    return _listRoots(
      _class.reference.pointer,
      _id_listRoots as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<File?>?>(
      const jni$_.JArrayNullableType<File?>($File$NullableType()),
    );
  }

  static final _id_getTotalSpace = _class.instanceMethodId(
    r'getTotalSpace',
    r'()J',
  );

  static final _getTotalSpace =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getTotalSpace()`
  int getTotalSpace() {
    return _getTotalSpace(
      reference.pointer,
      _id_getTotalSpace as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getFreeSpace = _class.instanceMethodId(
    r'getFreeSpace',
    r'()J',
  );

  static final _getFreeSpace =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getFreeSpace()`
  int getFreeSpace() {
    return _getFreeSpace(
      reference.pointer,
      _id_getFreeSpace as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getUsableSpace = _class.instanceMethodId(
    r'getUsableSpace',
    r'()J',
  );

  static final _getUsableSpace =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getUsableSpace()`
  int getUsableSpace() {
    return _getUsableSpace(
      reference.pointer,
      _id_getUsableSpace as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_createTempFile = _class.staticMethodId(
    r'createTempFile',
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File;',
  );

  static final _createTempFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.File createTempFile(java.lang.String string, java.lang.String string1, java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  static File? createTempFile(
    jni$_.JString? string,
    jni$_.JString? string1,
    File? file,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _createTempFile(
      _class.reference.pointer,
      _id_createTempFile as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
      _$file.pointer,
    ).object<File?>(const $File$NullableType());
  }

  static final _id_createTempFile$1 = _class.staticMethodId(
    r'createTempFile',
    r'(Ljava/lang/String;Ljava/lang/String;)Ljava/io/File;',
  );

  static final _createTempFile$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.io.File createTempFile(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  static File? createTempFile$1(jni$_.JString? string, jni$_.JString? string1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _createTempFile$1(
      _class.reference.pointer,
      _id_createTempFile$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$string1.pointer,
    ).object<File?>(const $File$NullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/io/File;)I',
  );

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int compareTo(java.io.File file)`
  int compareTo(File? file) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _compareTo(
      reference.pointer,
      _id_compareTo as jni$_.JMethodIDPtr,
      _$file.pointer,
    ).integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toPath = _class.instanceMethodId(
    r'toPath',
    r'()Ljava/nio/file/Path;',
  );

  static final _toPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.file.Path toPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toPath() {
    return _toPath(
      reference.pointer,
      _id_toPath as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  bool operator <(File? file) {
    return compareTo(file) < 0;
  }

  bool operator <=(File? file) {
    return compareTo(file) <= 0;
  }

  bool operator >(File? file) {
    return compareTo(file) > 0;
  }

  bool operator >=(File? file) {
    return compareTo(file) >= 0;
  }
}

final class $File$NullableType extends jni$_.JObjType<File?> {
  @jni$_.internal
  const $File$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/File;';

  @jni$_.internal
  @core$_.override
  File? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : File.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<File?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($File$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($File$NullableType) &&
        other is $File$NullableType;
  }
}

final class $File$Type extends jni$_.JObjType<File> {
  @jni$_.internal
  const $File$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/io/File;';

  @jni$_.internal
  @core$_.override
  File fromReference(jni$_.JReference reference) =>
      File.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<File?> get nullableType => const $File$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($File$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($File$Type) && other is $File$Type;
  }
}

/// from: `androidx.camera.core.ImageCapture$Builder`
class ImageCapture$Builder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$Builder> $type;

  @jni$_.internal
  ImageCapture$Builder.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/core/ImageCapture$Builder',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$Builder$NullableType();
  static const type = $ImageCapture$Builder$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$Builder() {
    return ImageCapture$Builder.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_fromConfig = _class.staticMethodId(
    r'fromConfig',
    r'(Landroidx/camera/core/impl/Config;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _fromConfig =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public androidx.camera.core.ImageCapture$Builder fromConfig(androidx.camera.core.impl.Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  static ImageCapture$Builder fromConfig(jni$_.JObject config) {
    final _$config = config.reference;
    return _fromConfig(
      _class.reference.pointer,
      _id_fromConfig as jni$_.JMethodIDPtr,
      _$config.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_getMutableConfig = _class.instanceMethodId(
    r'getMutableConfig',
    r'()Landroidx/camera/core/impl/MutableConfig;',
  );

  static final _getMutableConfig =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.impl.MutableConfig getMutableConfig()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getMutableConfig() {
    return _getMutableConfig(
      reference.pointer,
      _id_getMutableConfig as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_getUseCaseConfig = _class.instanceMethodId(
    r'getUseCaseConfig',
    r'()Landroidx/camera/core/impl/ImageCaptureConfig;',
  );

  static final _getUseCaseConfig =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.impl.ImageCaptureConfig getUseCaseConfig()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getUseCaseConfig() {
    return _getUseCaseConfig(
      reference.pointer,
      _id_getUseCaseConfig as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Landroidx/camera/core/ImageCapture;',
  );

  static final _build =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture build()`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture build() {
    return _build(
      reference.pointer,
      _id_build as jni$_.JMethodIDPtr,
    ).object<ImageCapture>(const $ImageCapture$Type());
  }

  static final _id_setCaptureMode = _class.instanceMethodId(
    r'setCaptureMode',
    r'(I)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setCaptureMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setCaptureMode(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setCaptureMode(int i) {
    return _setCaptureMode(
      reference.pointer,
      _id_setCaptureMode as jni$_.JMethodIDPtr,
      i,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setFlashMode = _class.instanceMethodId(
    r'setFlashMode',
    r'(I)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setFlashMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setFlashMode(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setFlashMode(int i) {
    return _setFlashMode(
      reference.pointer,
      _id_setFlashMode as jni$_.JMethodIDPtr,
      i,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setBufferFormat = _class.instanceMethodId(
    r'setBufferFormat',
    r'(I)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setBufferFormat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setBufferFormat(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setBufferFormat(int i) {
    return _setBufferFormat(
      reference.pointer,
      _id_setBufferFormat as jni$_.JMethodIDPtr,
      i,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setSupportedResolutions = _class.instanceMethodId(
    r'setSupportedResolutions',
    r'(Ljava/util/List;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setSupportedResolutions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setSupportedResolutions(java.util.List<android.util.Pair<java.lang.Integer, android.util.Size[]>> list)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setSupportedResolutions(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _setSupportedResolutions(
      reference.pointer,
      _id_setSupportedResolutions as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setCustomOrderedResolutions = _class.instanceMethodId(
    r'setCustomOrderedResolutions',
    r'(Ljava/util/List;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setCustomOrderedResolutions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setCustomOrderedResolutions(java.util.List<android.util.Size> list)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setCustomOrderedResolutions(
    jni$_.JList<jni$_.JObject?> list,
  ) {
    final _$list = list.reference;
    return _setCustomOrderedResolutions(
      reference.pointer,
      _id_setCustomOrderedResolutions as jni$_.JMethodIDPtr,
      _$list.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setTargetClass = _class.instanceMethodId(
    r'setTargetClass',
    r'(Ljava/lang/Class;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setTargetClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setTargetClass(java.lang.Class<androidx.camera.core.ImageCapture> class)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setTargetClass(jni$_.JObject class$) {
    final _$class$ = class$.reference;
    return _setTargetClass(
      reference.pointer,
      _id_setTargetClass as jni$_.JMethodIDPtr,
      _$class$.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setTargetName = _class.instanceMethodId(
    r'setTargetName',
    r'(Ljava/lang/String;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setTargetName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setTargetName(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setTargetName(jni$_.JString string) {
    final _$string = string.reference;
    return _setTargetName(
      reference.pointer,
      _id_setTargetName as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setTargetAspectRatio = _class.instanceMethodId(
    r'setTargetAspectRatio',
    r'(I)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setTargetAspectRatio =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setTargetAspectRatio(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setTargetAspectRatio(int i) {
    return _setTargetAspectRatio(
      reference.pointer,
      _id_setTargetAspectRatio as jni$_.JMethodIDPtr,
      i,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setTargetRotation = _class.instanceMethodId(
    r'setTargetRotation',
    r'(I)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setTargetRotation =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setTargetRotation(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setTargetRotation(int i) {
    return _setTargetRotation(
      reference.pointer,
      _id_setTargetRotation as jni$_.JMethodIDPtr,
      i,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setMirrorMode = _class.instanceMethodId(
    r'setMirrorMode',
    r'(I)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setMirrorMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setMirrorMode(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setMirrorMode(int i) {
    return _setMirrorMode(
      reference.pointer,
      _id_setMirrorMode as jni$_.JMethodIDPtr,
      i,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setTargetResolution = _class.instanceMethodId(
    r'setTargetResolution',
    r'(Landroid/util/Size;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setTargetResolution =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setTargetResolution(android.util.Size size)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setTargetResolution(jni$_.JObject size) {
    final _$size = size.reference;
    return _setTargetResolution(
      reference.pointer,
      _id_setTargetResolution as jni$_.JMethodIDPtr,
      _$size.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setDefaultResolution = _class.instanceMethodId(
    r'setDefaultResolution',
    r'(Landroid/util/Size;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setDefaultResolution =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setDefaultResolution(android.util.Size size)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setDefaultResolution(jni$_.JObject size) {
    final _$size = size.reference;
    return _setDefaultResolution(
      reference.pointer,
      _id_setDefaultResolution as jni$_.JMethodIDPtr,
      _$size.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setMaxResolution = _class.instanceMethodId(
    r'setMaxResolution',
    r'(Landroid/util/Size;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setMaxResolution =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setMaxResolution(android.util.Size size)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setMaxResolution(jni$_.JObject size) {
    final _$size = size.reference;
    return _setMaxResolution(
      reference.pointer,
      _id_setMaxResolution as jni$_.JMethodIDPtr,
      _$size.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setResolutionSelector = _class.instanceMethodId(
    r'setResolutionSelector',
    r'(Landroidx/camera/core/resolutionselector/ResolutionSelector;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setResolutionSelector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setResolutionSelector(androidx.camera.core.resolutionselector.ResolutionSelector resolutionSelector)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setResolutionSelector(jni$_.JObject resolutionSelector) {
    final _$resolutionSelector = resolutionSelector.reference;
    return _setResolutionSelector(
      reference.pointer,
      _id_setResolutionSelector as jni$_.JMethodIDPtr,
      _$resolutionSelector.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setImageReaderProxyProvider = _class.instanceMethodId(
    r'setImageReaderProxyProvider',
    r'(Landroidx/camera/core/ImageReaderProxyProvider;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setImageReaderProxyProvider =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setImageReaderProxyProvider(androidx.camera.core.ImageReaderProxyProvider imageReaderProxyProvider)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setImageReaderProxyProvider(
    jni$_.JObject imageReaderProxyProvider,
  ) {
    final _$imageReaderProxyProvider = imageReaderProxyProvider.reference;
    return _setImageReaderProxyProvider(
      reference.pointer,
      _id_setImageReaderProxyProvider as jni$_.JMethodIDPtr,
      _$imageReaderProxyProvider.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setSoftwareJpegEncoderRequested = _class.instanceMethodId(
    r'setSoftwareJpegEncoderRequested',
    r'(Z)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setSoftwareJpegEncoderRequested =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setSoftwareJpegEncoderRequested(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setSoftwareJpegEncoderRequested(bool z) {
    return _setSoftwareJpegEncoderRequested(
      reference.pointer,
      _id_setSoftwareJpegEncoderRequested as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setFlashType = _class.instanceMethodId(
    r'setFlashType',
    r'(I)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setFlashType =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setFlashType(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setFlashType(int i) {
    return _setFlashType(
      reference.pointer,
      _id_setFlashType as jni$_.JMethodIDPtr,
      i,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setJpegQuality = _class.instanceMethodId(
    r'setJpegQuality',
    r'(I)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setJpegQuality =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setJpegQuality(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setJpegQuality(int i) {
    return _setJpegQuality(
      reference.pointer,
      _id_setJpegQuality as jni$_.JMethodIDPtr,
      i,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setIoExecutor = _class.instanceMethodId(
    r'setIoExecutor',
    r'(Ljava/util/concurrent/Executor;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setIoExecutor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setIoExecutor(java.util.concurrent.Executor executor)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setIoExecutor(Executor executor) {
    final _$executor = executor.reference;
    return _setIoExecutor(
      reference.pointer,
      _id_setIoExecutor as jni$_.JMethodIDPtr,
      _$executor.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setDefaultSessionConfig = _class.instanceMethodId(
    r'setDefaultSessionConfig',
    r'(Landroidx/camera/core/impl/SessionConfig;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setDefaultSessionConfig =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setDefaultSessionConfig(androidx.camera.core.impl.SessionConfig sessionConfig)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setDefaultSessionConfig(jni$_.JObject sessionConfig) {
    final _$sessionConfig = sessionConfig.reference;
    return _setDefaultSessionConfig(
      reference.pointer,
      _id_setDefaultSessionConfig as jni$_.JMethodIDPtr,
      _$sessionConfig.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setDefaultCaptureConfig = _class.instanceMethodId(
    r'setDefaultCaptureConfig',
    r'(Landroidx/camera/core/impl/CaptureConfig;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setDefaultCaptureConfig =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setDefaultCaptureConfig(androidx.camera.core.impl.CaptureConfig captureConfig)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setDefaultCaptureConfig(jni$_.JObject captureConfig) {
    final _$captureConfig = captureConfig.reference;
    return _setDefaultCaptureConfig(
      reference.pointer,
      _id_setDefaultCaptureConfig as jni$_.JMethodIDPtr,
      _$captureConfig.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setSessionOptionUnpacker = _class.instanceMethodId(
    r'setSessionOptionUnpacker',
    r'(Landroidx/camera/core/impl/SessionConfig$OptionUnpacker;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setSessionOptionUnpacker =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setSessionOptionUnpacker(androidx.camera.core.impl.SessionConfig$OptionUnpacker optionUnpacker)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setSessionOptionUnpacker(jni$_.JObject optionUnpacker) {
    final _$optionUnpacker = optionUnpacker.reference;
    return _setSessionOptionUnpacker(
      reference.pointer,
      _id_setSessionOptionUnpacker as jni$_.JMethodIDPtr,
      _$optionUnpacker.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setCaptureOptionUnpacker = _class.instanceMethodId(
    r'setCaptureOptionUnpacker',
    r'(Landroidx/camera/core/impl/CaptureConfig$OptionUnpacker;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setCaptureOptionUnpacker =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setCaptureOptionUnpacker(androidx.camera.core.impl.CaptureConfig$OptionUnpacker optionUnpacker)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setCaptureOptionUnpacker(jni$_.JObject optionUnpacker) {
    final _$optionUnpacker = optionUnpacker.reference;
    return _setCaptureOptionUnpacker(
      reference.pointer,
      _id_setCaptureOptionUnpacker as jni$_.JMethodIDPtr,
      _$optionUnpacker.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setCameraSelector = _class.instanceMethodId(
    r'setCameraSelector',
    r'(Landroidx/camera/core/CameraSelector;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setCameraSelector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setCameraSelector(androidx.camera.core.CameraSelector cameraSelector)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setCameraSelector(jni$_.JObject cameraSelector) {
    final _$cameraSelector = cameraSelector.reference;
    return _setCameraSelector(
      reference.pointer,
      _id_setCameraSelector as jni$_.JMethodIDPtr,
      _$cameraSelector.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setSurfaceOccupancyPriority = _class.instanceMethodId(
    r'setSurfaceOccupancyPriority',
    r'(I)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setSurfaceOccupancyPriority =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setSurfaceOccupancyPriority(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setSurfaceOccupancyPriority(int i) {
    return _setSurfaceOccupancyPriority(
      reference.pointer,
      _id_setSurfaceOccupancyPriority as jni$_.JMethodIDPtr,
      i,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setUseCaseEventCallback = _class.instanceMethodId(
    r'setUseCaseEventCallback',
    r'(Landroidx/camera/core/UseCase$EventCallback;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setUseCaseEventCallback =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setUseCaseEventCallback(androidx.camera.core.UseCase$EventCallback eventCallback)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setUseCaseEventCallback(jni$_.JObject eventCallback) {
    final _$eventCallback = eventCallback.reference;
    return _setUseCaseEventCallback(
      reference.pointer,
      _id_setUseCaseEventCallback as jni$_.JMethodIDPtr,
      _$eventCallback.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setZslDisabled = _class.instanceMethodId(
    r'setZslDisabled',
    r'(Z)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setZslDisabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setZslDisabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setZslDisabled(bool z) {
    return _setZslDisabled(
      reference.pointer,
      _id_setZslDisabled as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setHighResolutionDisabled = _class.instanceMethodId(
    r'setHighResolutionDisabled',
    r'(Z)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setHighResolutionDisabled =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setHighResolutionDisabled(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setHighResolutionDisabled(bool z) {
    return _setHighResolutionDisabled(
      reference.pointer,
      _id_setHighResolutionDisabled as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setCaptureType = _class.instanceMethodId(
    r'setCaptureType',
    r'(Landroidx/camera/core/impl/UseCaseConfigFactory$CaptureType;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setCaptureType =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setCaptureType(androidx.camera.core.impl.UseCaseConfigFactory$CaptureType captureType)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setCaptureType(jni$_.JObject captureType) {
    final _$captureType = captureType.reference;
    return _setCaptureType(
      reference.pointer,
      _id_setCaptureType as jni$_.JMethodIDPtr,
      _$captureType.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }

  static final _id_setDynamicRange = _class.instanceMethodId(
    r'setDynamicRange',
    r'(Landroidx/camera/core/DynamicRange;)Landroidx/camera/core/ImageCapture$Builder;',
  );

  static final _setDynamicRange =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Builder setDynamicRange(androidx.camera.core.DynamicRange dynamicRange)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Builder setDynamicRange(jni$_.JObject dynamicRange) {
    final _$dynamicRange = dynamicRange.reference;
    return _setDynamicRange(
      reference.pointer,
      _id_setDynamicRange as jni$_.JMethodIDPtr,
      _$dynamicRange.pointer,
    ).object<ImageCapture$Builder>(const $ImageCapture$Builder$Type());
  }
}

final class $ImageCapture$Builder$NullableType
    extends jni$_.JObjType<ImageCapture$Builder?> {
  @jni$_.internal
  const $ImageCapture$Builder$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCapture$Builder;';

  @jni$_.internal
  @core$_.override
  ImageCapture$Builder? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ImageCapture$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$Builder?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$Builder$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$Builder$NullableType) &&
        other is $ImageCapture$Builder$NullableType;
  }
}

final class $ImageCapture$Builder$Type
    extends jni$_.JObjType<ImageCapture$Builder> {
  @jni$_.internal
  const $ImageCapture$Builder$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCapture$Builder;';

  @jni$_.internal
  @core$_.override
  ImageCapture$Builder fromReference(jni$_.JReference reference) =>
      ImageCapture$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$Builder?> get nullableType =>
      const $ImageCapture$Builder$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$Builder$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$Builder$Type) &&
        other is $ImageCapture$Builder$Type;
  }
}

/// from: `androidx.camera.core.ImageCapture$CaptureMode`
class ImageCapture$CaptureMode extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$CaptureMode> $type;

  @jni$_.internal
  ImageCapture$CaptureMode.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/core/ImageCapture$CaptureMode',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$CaptureMode$NullableType();
  static const type = $ImageCapture$CaptureMode$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ImageCapture$CaptureMode> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ImageCapture$CaptureMode $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.camera.core.ImageCapture$CaptureMode',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ImageCapture$CaptureMode.implement($ImageCapture$CaptureMode $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ImageCapture$CaptureMode.fromReference($i.implementReference());
  }
}

abstract base mixin class $ImageCapture$CaptureMode {
  factory $ImageCapture$CaptureMode() = _$ImageCapture$CaptureMode;
}

final class _$ImageCapture$CaptureMode with $ImageCapture$CaptureMode {
  _$ImageCapture$CaptureMode();
}

final class $ImageCapture$CaptureMode$NullableType
    extends jni$_.JObjType<ImageCapture$CaptureMode?> {
  @jni$_.internal
  const $ImageCapture$CaptureMode$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCapture$CaptureMode;';

  @jni$_.internal
  @core$_.override
  ImageCapture$CaptureMode? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : ImageCapture$CaptureMode.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$CaptureMode?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$CaptureMode$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$CaptureMode$NullableType) &&
        other is $ImageCapture$CaptureMode$NullableType;
  }
}

final class $ImageCapture$CaptureMode$Type
    extends jni$_.JObjType<ImageCapture$CaptureMode> {
  @jni$_.internal
  const $ImageCapture$CaptureMode$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCapture$CaptureMode;';

  @jni$_.internal
  @core$_.override
  ImageCapture$CaptureMode fromReference(jni$_.JReference reference) =>
      ImageCapture$CaptureMode.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$CaptureMode?> get nullableType =>
      const $ImageCapture$CaptureMode$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$CaptureMode$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$CaptureMode$Type) &&
        other is $ImageCapture$CaptureMode$Type;
  }
}

/// from: `androidx.camera.core.ImageCapture$Defaults`
class ImageCapture$Defaults extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$Defaults> $type;

  @jni$_.internal
  ImageCapture$Defaults.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/core/ImageCapture$Defaults',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$Defaults$NullableType();
  static const type = $ImageCapture$Defaults$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$Defaults() {
    return ImageCapture$Defaults.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_getConfig = _class.instanceMethodId(
    r'getConfig',
    r'()Landroidx/camera/core/impl/ImageCaptureConfig;',
  );

  static final _getConfig =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.impl.ImageCaptureConfig getConfig()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getConfig() {
    return _getConfig(
      reference.pointer,
      _id_getConfig as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $ImageCapture$Defaults$NullableType
    extends jni$_.JObjType<ImageCapture$Defaults?> {
  @jni$_.internal
  const $ImageCapture$Defaults$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCapture$Defaults;';

  @jni$_.internal
  @core$_.override
  ImageCapture$Defaults? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ImageCapture$Defaults.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$Defaults?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$Defaults$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$Defaults$NullableType) &&
        other is $ImageCapture$Defaults$NullableType;
  }
}

final class $ImageCapture$Defaults$Type
    extends jni$_.JObjType<ImageCapture$Defaults> {
  @jni$_.internal
  const $ImageCapture$Defaults$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCapture$Defaults;';

  @jni$_.internal
  @core$_.override
  ImageCapture$Defaults fromReference(jni$_.JReference reference) =>
      ImageCapture$Defaults.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$Defaults?> get nullableType =>
      const $ImageCapture$Defaults$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$Defaults$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$Defaults$Type) &&
        other is $ImageCapture$Defaults$Type;
  }
}

/// from: `androidx.camera.core.ImageCapture$FlashMode`
class ImageCapture$FlashMode extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$FlashMode> $type;

  @jni$_.internal
  ImageCapture$FlashMode.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/core/ImageCapture$FlashMode',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$FlashMode$NullableType();
  static const type = $ImageCapture$FlashMode$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ImageCapture$FlashMode> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ImageCapture$FlashMode $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.camera.core.ImageCapture$FlashMode',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ImageCapture$FlashMode.implement($ImageCapture$FlashMode $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ImageCapture$FlashMode.fromReference($i.implementReference());
  }
}

abstract base mixin class $ImageCapture$FlashMode {
  factory $ImageCapture$FlashMode() = _$ImageCapture$FlashMode;
}

final class _$ImageCapture$FlashMode with $ImageCapture$FlashMode {
  _$ImageCapture$FlashMode();
}

final class $ImageCapture$FlashMode$NullableType
    extends jni$_.JObjType<ImageCapture$FlashMode?> {
  @jni$_.internal
  const $ImageCapture$FlashMode$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCapture$FlashMode;';

  @jni$_.internal
  @core$_.override
  ImageCapture$FlashMode? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ImageCapture$FlashMode.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$FlashMode?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$FlashMode$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$FlashMode$NullableType) &&
        other is $ImageCapture$FlashMode$NullableType;
  }
}

final class $ImageCapture$FlashMode$Type
    extends jni$_.JObjType<ImageCapture$FlashMode> {
  @jni$_.internal
  const $ImageCapture$FlashMode$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCapture$FlashMode;';

  @jni$_.internal
  @core$_.override
  ImageCapture$FlashMode fromReference(jni$_.JReference reference) =>
      ImageCapture$FlashMode.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$FlashMode?> get nullableType =>
      const $ImageCapture$FlashMode$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$FlashMode$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$FlashMode$Type) &&
        other is $ImageCapture$FlashMode$Type;
  }
}

/// from: `androidx.camera.core.ImageCapture$FlashType`
class ImageCapture$FlashType extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$FlashType> $type;

  @jni$_.internal
  ImageCapture$FlashType.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/core/ImageCapture$FlashType',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$FlashType$NullableType();
  static const type = $ImageCapture$FlashType$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ImageCapture$FlashType> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ImageCapture$FlashType $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.camera.core.ImageCapture$FlashType',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ImageCapture$FlashType.implement($ImageCapture$FlashType $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ImageCapture$FlashType.fromReference($i.implementReference());
  }
}

abstract base mixin class $ImageCapture$FlashType {
  factory $ImageCapture$FlashType() = _$ImageCapture$FlashType;
}

final class _$ImageCapture$FlashType with $ImageCapture$FlashType {
  _$ImageCapture$FlashType();
}

final class $ImageCapture$FlashType$NullableType
    extends jni$_.JObjType<ImageCapture$FlashType?> {
  @jni$_.internal
  const $ImageCapture$FlashType$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCapture$FlashType;';

  @jni$_.internal
  @core$_.override
  ImageCapture$FlashType? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ImageCapture$FlashType.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$FlashType?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$FlashType$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$FlashType$NullableType) &&
        other is $ImageCapture$FlashType$NullableType;
  }
}

final class $ImageCapture$FlashType$Type
    extends jni$_.JObjType<ImageCapture$FlashType> {
  @jni$_.internal
  const $ImageCapture$FlashType$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCapture$FlashType;';

  @jni$_.internal
  @core$_.override
  ImageCapture$FlashType fromReference(jni$_.JReference reference) =>
      ImageCapture$FlashType.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$FlashType?> get nullableType =>
      const $ImageCapture$FlashType$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$FlashType$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$FlashType$Type) &&
        other is $ImageCapture$FlashType$Type;
  }
}

/// from: `androidx.camera.core.ImageCapture$ImageCaptureError`
class ImageCapture$ImageCaptureError extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$ImageCaptureError> $type;

  @jni$_.internal
  ImageCapture$ImageCaptureError.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/core/ImageCapture$ImageCaptureError',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$ImageCaptureError$NullableType();
  static const type = $ImageCapture$ImageCaptureError$Type();

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ImageCapture$ImageCaptureError> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ImageCapture$ImageCaptureError $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.camera.core.ImageCapture$ImageCaptureError',
      $p,
      _$invokePointer,
      [],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ImageCapture$ImageCaptureError.implement(
    $ImageCapture$ImageCaptureError $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ImageCapture$ImageCaptureError.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $ImageCapture$ImageCaptureError {
  factory $ImageCapture$ImageCaptureError() = _$ImageCapture$ImageCaptureError;
}

final class _$ImageCapture$ImageCaptureError
    with $ImageCapture$ImageCaptureError {
  _$ImageCapture$ImageCaptureError();
}

final class $ImageCapture$ImageCaptureError$NullableType
    extends jni$_.JObjType<ImageCapture$ImageCaptureError?> {
  @jni$_.internal
  const $ImageCapture$ImageCaptureError$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/camera/core/ImageCapture$ImageCaptureError;';

  @jni$_.internal
  @core$_.override
  ImageCapture$ImageCaptureError? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : ImageCapture$ImageCaptureError.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$ImageCaptureError?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$ImageCaptureError$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$ImageCaptureError$NullableType) &&
        other is $ImageCapture$ImageCaptureError$NullableType;
  }
}

final class $ImageCapture$ImageCaptureError$Type
    extends jni$_.JObjType<ImageCapture$ImageCaptureError> {
  @jni$_.internal
  const $ImageCapture$ImageCaptureError$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/camera/core/ImageCapture$ImageCaptureError;';

  @jni$_.internal
  @core$_.override
  ImageCapture$ImageCaptureError fromReference(jni$_.JReference reference) =>
      ImageCapture$ImageCaptureError.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$ImageCaptureError?> get nullableType =>
      const $ImageCapture$ImageCaptureError$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$ImageCaptureError$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$ImageCaptureError$Type) &&
        other is $ImageCapture$ImageCaptureError$Type;
  }
}

/// from: `androidx.camera.core.ImageCapture$Metadata`
class ImageCapture$Metadata extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$Metadata> $type;

  @jni$_.internal
  ImageCapture$Metadata.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/core/ImageCapture$Metadata',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$Metadata$NullableType();
  static const type = $ImageCapture$Metadata$Type();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$Metadata() {
    return ImageCapture$Metadata.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_isReversedHorizontal = _class.instanceMethodId(
    r'isReversedHorizontal',
    r'()Z',
  );

  static final _isReversedHorizontal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isReversedHorizontal()`
  bool isReversedHorizontal() {
    return _isReversedHorizontal(
      reference.pointer,
      _id_isReversedHorizontal as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isReversedHorizontalSet = _class.instanceMethodId(
    r'isReversedHorizontalSet',
    r'()Z',
  );

  static final _isReversedHorizontalSet =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isReversedHorizontalSet()`
  bool isReversedHorizontalSet() {
    return _isReversedHorizontalSet(
      reference.pointer,
      _id_isReversedHorizontalSet as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setReversedHorizontal = _class.instanceMethodId(
    r'setReversedHorizontal',
    r'(Z)V',
  );

  static final _setReversedHorizontal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReversedHorizontal(boolean z)`
  void setReversedHorizontal(bool z) {
    _setReversedHorizontal(
      reference.pointer,
      _id_setReversedHorizontal as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_isReversedVertical = _class.instanceMethodId(
    r'isReversedVertical',
    r'()Z',
  );

  static final _isReversedVertical =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isReversedVertical()`
  bool isReversedVertical() {
    return _isReversedVertical(
      reference.pointer,
      _id_isReversedVertical as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_setReversedVertical = _class.instanceMethodId(
    r'setReversedVertical',
    r'(Z)V',
  );

  static final _setReversedVertical =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setReversedVertical(boolean z)`
  void setReversedVertical(bool z) {
    _setReversedVertical(
      reference.pointer,
      _id_setReversedVertical as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_getLocation = _class.instanceMethodId(
    r'getLocation',
    r'()Landroid/location/Location;',
  );

  static final _getLocation =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.location.Location getLocation()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getLocation() {
    return _getLocation(
      reference.pointer,
      _id_getLocation as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_setLocation = _class.instanceMethodId(
    r'setLocation',
    r'(Landroid/location/Location;)V',
  );

  static final _setLocation =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setLocation(android.location.Location location)`
  void setLocation(jni$_.JObject? location) {
    final _$location = location?.reference ?? jni$_.jNullReference;
    _setLocation(
      reference.pointer,
      _id_setLocation as jni$_.JMethodIDPtr,
      _$location.pointer,
    ).check();
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $ImageCapture$Metadata$NullableType
    extends jni$_.JObjType<ImageCapture$Metadata?> {
  @jni$_.internal
  const $ImageCapture$Metadata$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCapture$Metadata;';

  @jni$_.internal
  @core$_.override
  ImageCapture$Metadata? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ImageCapture$Metadata.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$Metadata?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$Metadata$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$Metadata$NullableType) &&
        other is $ImageCapture$Metadata$NullableType;
  }
}

final class $ImageCapture$Metadata$Type
    extends jni$_.JObjType<ImageCapture$Metadata> {
  @jni$_.internal
  const $ImageCapture$Metadata$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCapture$Metadata;';

  @jni$_.internal
  @core$_.override
  ImageCapture$Metadata fromReference(jni$_.JReference reference) =>
      ImageCapture$Metadata.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$Metadata?> get nullableType =>
      const $ImageCapture$Metadata$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$Metadata$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$Metadata$Type) &&
        other is $ImageCapture$Metadata$Type;
  }
}

/// from: `androidx.camera.core.ImageCapture$OnImageCapturedCallback`
class ImageCapture$OnImageCapturedCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$OnImageCapturedCallback> $type;

  @jni$_.internal
  ImageCapture$OnImageCapturedCallback.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/core/ImageCapture$OnImageCapturedCallback',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $ImageCapture$OnImageCapturedCallback$NullableType();
  static const type = $ImageCapture$OnImageCapturedCallback$Type();
  static final _id_onCaptureSuccess = _class.instanceMethodId(
    r'onCaptureSuccess',
    r'(Landroidx/camera/core/ImageProxy;)V',
  );

  static final _onCaptureSuccess =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void onCaptureSuccess(androidx.camera.core.ImageProxy imageProxy)`
  void onCaptureSuccess(jni$_.JObject imageProxy) {
    final _$imageProxy = imageProxy.reference;
    _onCaptureSuccess(
      reference.pointer,
      _id_onCaptureSuccess as jni$_.JMethodIDPtr,
      _$imageProxy.pointer,
    ).check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Landroidx/camera/core/ImageCaptureException;)V',
  );

  static final _onError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void onError(androidx.camera.core.ImageCaptureException imageCaptureException)`
  void onError(ImageCaptureException imageCaptureException) {
    final _$imageCaptureException = imageCaptureException.reference;
    _onError(
      reference.pointer,
      _id_onError as jni$_.JMethodIDPtr,
      _$imageCaptureException.pointer,
    ).check();
  }
}

final class $ImageCapture$OnImageCapturedCallback$NullableType
    extends jni$_.JObjType<ImageCapture$OnImageCapturedCallback?> {
  @jni$_.internal
  const $ImageCapture$OnImageCapturedCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/camera/core/ImageCapture$OnImageCapturedCallback;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OnImageCapturedCallback? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : ImageCapture$OnImageCapturedCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OnImageCapturedCallback?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ImageCapture$OnImageCapturedCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OnImageCapturedCallback$NullableType) &&
        other is $ImageCapture$OnImageCapturedCallback$NullableType;
  }
}

final class $ImageCapture$OnImageCapturedCallback$Type
    extends jni$_.JObjType<ImageCapture$OnImageCapturedCallback> {
  @jni$_.internal
  const $ImageCapture$OnImageCapturedCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/camera/core/ImageCapture$OnImageCapturedCallback;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OnImageCapturedCallback fromReference(
    jni$_.JReference reference,
  ) => ImageCapture$OnImageCapturedCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OnImageCapturedCallback?> get nullableType =>
      const $ImageCapture$OnImageCapturedCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OnImageCapturedCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$OnImageCapturedCallback$Type) &&
        other is $ImageCapture$OnImageCapturedCallback$Type;
  }
}

/// from: `androidx.camera.core.ImageCapture$OnImageSavedCallback`
class ImageCapture$OnImageSavedCallback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$OnImageSavedCallback> $type;

  @jni$_.internal
  ImageCapture$OnImageSavedCallback.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/core/ImageCapture$OnImageSavedCallback',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$OnImageSavedCallback$NullableType();
  static const type = $ImageCapture$OnImageSavedCallback$Type();
  static final _id_onImageSaved = _class.instanceMethodId(
    r'onImageSaved',
    r'(Landroidx/camera/core/ImageCapture$OutputFileResults;)V',
  );

  static final _onImageSaved =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onImageSaved(androidx.camera.core.ImageCapture$OutputFileResults outputFileResults)`
  void onImageSaved(ImageCapture$OutputFileResults outputFileResults) {
    final _$outputFileResults = outputFileResults.reference;
    _onImageSaved(
      reference.pointer,
      _id_onImageSaved as jni$_.JMethodIDPtr,
      _$outputFileResults.pointer,
    ).check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Landroidx/camera/core/ImageCaptureException;)V',
  );

  static final _onError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void onError(androidx.camera.core.ImageCaptureException imageCaptureException)`
  void onError(ImageCaptureException imageCaptureException) {
    final _$imageCaptureException = imageCaptureException.reference;
    _onError(
      reference.pointer,
      _id_onError as jni$_.JMethodIDPtr,
      _$imageCaptureException.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $ImageCapture$OnImageSavedCallback> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onImageSaved(Landroidx/camera/core/ImageCapture$OutputFileResults;)V') {
        _$impls[$p]!.onImageSaved(
          $a![0]!.as(
            const $ImageCapture$OutputFileResults$Type(),
            releaseOriginal: true,
          ),
        );
        return jni$_.nullptr;
      }
      if ($d == r'onError(Landroidx/camera/core/ImageCaptureException;)V') {
        _$impls[$p]!.onError(
          $a![0]!.as(
            const $ImageCaptureException$Type(),
            releaseOriginal: true,
          ),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $ImageCapture$OnImageSavedCallback $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'androidx.camera.core.ImageCapture$OnImageSavedCallback',
      $p,
      _$invokePointer,
      [
        if ($impl.onImageSaved$async)
          r'onImageSaved(Landroidx/camera/core/ImageCapture$OutputFileResults;)V',
        if ($impl.onError$async)
          r'onError(Landroidx/camera/core/ImageCaptureException;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory ImageCapture$OnImageSavedCallback.implement(
    $ImageCapture$OnImageSavedCallback $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return ImageCapture$OnImageSavedCallback.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $ImageCapture$OnImageSavedCallback {
  factory $ImageCapture$OnImageSavedCallback({
    required void Function(ImageCapture$OutputFileResults outputFileResults)
    onImageSaved,
    bool onImageSaved$async,
    required void Function(ImageCaptureException imageCaptureException) onError,
    bool onError$async,
  }) = _$ImageCapture$OnImageSavedCallback;

  void onImageSaved(ImageCapture$OutputFileResults outputFileResults);
  bool get onImageSaved$async => false;
  void onError(ImageCaptureException imageCaptureException);
  bool get onError$async => false;
}

final class _$ImageCapture$OnImageSavedCallback
    with $ImageCapture$OnImageSavedCallback {
  _$ImageCapture$OnImageSavedCallback({
    required void Function(ImageCapture$OutputFileResults outputFileResults)
    onImageSaved,
    this.onImageSaved$async = false,
    required void Function(ImageCaptureException imageCaptureException) onError,
    this.onError$async = false,
  }) : _onImageSaved = onImageSaved,
       _onError = onError;

  final void Function(ImageCapture$OutputFileResults outputFileResults)
  _onImageSaved;
  final bool onImageSaved$async;
  final void Function(ImageCaptureException imageCaptureException) _onError;
  final bool onError$async;

  void onImageSaved(ImageCapture$OutputFileResults outputFileResults) {
    return _onImageSaved(outputFileResults);
  }

  void onError(ImageCaptureException imageCaptureException) {
    return _onError(imageCaptureException);
  }
}

final class $ImageCapture$OnImageSavedCallback$NullableType
    extends jni$_.JObjType<ImageCapture$OnImageSavedCallback?> {
  @jni$_.internal
  const $ImageCapture$OnImageSavedCallback$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/camera/core/ImageCapture$OnImageSavedCallback;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OnImageSavedCallback? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : ImageCapture$OnImageSavedCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OnImageSavedCallback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ImageCapture$OnImageSavedCallback$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OnImageSavedCallback$NullableType) &&
        other is $ImageCapture$OnImageSavedCallback$NullableType;
  }
}

final class $ImageCapture$OnImageSavedCallback$Type
    extends jni$_.JObjType<ImageCapture$OnImageSavedCallback> {
  @jni$_.internal
  const $ImageCapture$OnImageSavedCallback$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/camera/core/ImageCapture$OnImageSavedCallback;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OnImageSavedCallback fromReference(jni$_.JReference reference) =>
      ImageCapture$OnImageSavedCallback.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OnImageSavedCallback?> get nullableType =>
      const $ImageCapture$OnImageSavedCallback$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OnImageSavedCallback$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$OnImageSavedCallback$Type) &&
        other is $ImageCapture$OnImageSavedCallback$Type;
  }
}

/// from: `androidx.camera.core.ImageCapture$OutputFileOptions$Builder`
class ImageCapture$OutputFileOptions$Builder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$OutputFileOptions$Builder> $type;

  @jni$_.internal
  ImageCapture$OutputFileOptions$Builder.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/core/ImageCapture$OutputFileOptions$Builder',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType =
      $ImageCapture$OutputFileOptions$Builder$NullableType();
  static const type = $ImageCapture$OutputFileOptions$Builder$Type();
  static final _id_new$ = _class.constructorId(r'(Ljava/io/File;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$OutputFileOptions$Builder(File file) {
    final _$file = file.reference;
    return ImageCapture$OutputFileOptions$Builder.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$file.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Landroid/content/ContentResolver;Landroid/net/Uri;Landroid/content/ContentValues;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(android.content.ContentResolver contentResolver, android.net.Uri uri, android.content.ContentValues contentValues)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$OutputFileOptions$Builder.new$1(
    jni$_.JObject contentResolver,
    jni$_.JObject uri,
    jni$_.JObject contentValues,
  ) {
    final _$contentResolver = contentResolver.reference;
    final _$uri = uri.reference;
    final _$contentValues = contentValues.reference;
    return ImageCapture$OutputFileOptions$Builder.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$contentResolver.pointer,
        _$uri.pointer,
        _$contentValues.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(Ljava/io/OutputStream;)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.io.OutputStream outputStream)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$OutputFileOptions$Builder.new$2(
    jni$_.JObject outputStream,
  ) {
    final _$outputStream = outputStream.reference;
    return ImageCapture$OutputFileOptions$Builder.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$outputStream.pointer,
      ).reference,
    );
  }

  static final _id_setMetadata = _class.instanceMethodId(
    r'setMetadata',
    r'(Landroidx/camera/core/ImageCapture$Metadata;)Landroidx/camera/core/ImageCapture$OutputFileOptions$Builder;',
  );

  static final _setMetadata =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$OutputFileOptions$Builder setMetadata(androidx.camera.core.ImageCapture$Metadata metadata)`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$OutputFileOptions$Builder setMetadata(
    ImageCapture$Metadata metadata,
  ) {
    final _$metadata = metadata.reference;
    return _setMetadata(
      reference.pointer,
      _id_setMetadata as jni$_.JMethodIDPtr,
      _$metadata.pointer,
    ).object<ImageCapture$OutputFileOptions$Builder>(
      const $ImageCapture$OutputFileOptions$Builder$Type(),
    );
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Landroidx/camera/core/ImageCapture$OutputFileOptions;',
  );

  static final _build =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$OutputFileOptions build()`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$OutputFileOptions build() {
    return _build(
      reference.pointer,
      _id_build as jni$_.JMethodIDPtr,
    ).object<ImageCapture$OutputFileOptions>(
      const $ImageCapture$OutputFileOptions$Type(),
    );
  }
}

final class $ImageCapture$OutputFileOptions$Builder$NullableType
    extends jni$_.JObjType<ImageCapture$OutputFileOptions$Builder?> {
  @jni$_.internal
  const $ImageCapture$OutputFileOptions$Builder$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/camera/core/ImageCapture$OutputFileOptions$Builder;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OutputFileOptions$Builder? fromReference(
    jni$_.JReference reference,
  ) => reference.isNull
      ? null
      : ImageCapture$OutputFileOptions$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OutputFileOptions$Builder?> get nullableType =>
      this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($ImageCapture$OutputFileOptions$Builder$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OutputFileOptions$Builder$NullableType) &&
        other is $ImageCapture$OutputFileOptions$Builder$NullableType;
  }
}

final class $ImageCapture$OutputFileOptions$Builder$Type
    extends jni$_.JObjType<ImageCapture$OutputFileOptions$Builder> {
  @jni$_.internal
  const $ImageCapture$OutputFileOptions$Builder$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/camera/core/ImageCapture$OutputFileOptions$Builder;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OutputFileOptions$Builder fromReference(
    jni$_.JReference reference,
  ) => ImageCapture$OutputFileOptions$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OutputFileOptions$Builder?> get nullableType =>
      const $ImageCapture$OutputFileOptions$Builder$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OutputFileOptions$Builder$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OutputFileOptions$Builder$Type) &&
        other is $ImageCapture$OutputFileOptions$Builder$Type;
  }
}

/// from: `androidx.camera.core.ImageCapture$OutputFileOptions`
class ImageCapture$OutputFileOptions extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$OutputFileOptions> $type;

  @jni$_.internal
  ImageCapture$OutputFileOptions.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/core/ImageCapture$OutputFileOptions',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$OutputFileOptions$NullableType();
  static const type = $ImageCapture$OutputFileOptions$Type();
  static final _id_getFile = _class.instanceMethodId(
    r'getFile',
    r'()Ljava/io/File;',
  );

  static final _getFile =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.File getFile()`
  /// The returned object must be released after use, by calling the [release] method.
  File? getFile() {
    return _getFile(
      reference.pointer,
      _id_getFile as jni$_.JMethodIDPtr,
    ).object<File?>(const $File$NullableType());
  }

  static final _id_getContentResolver = _class.instanceMethodId(
    r'getContentResolver',
    r'()Landroid/content/ContentResolver;',
  );

  static final _getContentResolver =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.content.ContentResolver getContentResolver()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContentResolver() {
    return _getContentResolver(
      reference.pointer,
      _id_getContentResolver as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getSaveCollection = _class.instanceMethodId(
    r'getSaveCollection',
    r'()Landroid/net/Uri;',
  );

  static final _getSaveCollection =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.net.Uri getSaveCollection()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSaveCollection() {
    return _getSaveCollection(
      reference.pointer,
      _id_getSaveCollection as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getContentValues = _class.instanceMethodId(
    r'getContentValues',
    r'()Landroid/content/ContentValues;',
  );

  static final _getContentValues =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.content.ContentValues getContentValues()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContentValues() {
    return _getContentValues(
      reference.pointer,
      _id_getContentValues as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getOutputStream = _class.instanceMethodId(
    r'getOutputStream',
    r'()Ljava/io/OutputStream;',
  );

  static final _getOutputStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.io.OutputStream getOutputStream()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getOutputStream() {
    return _getOutputStream(
      reference.pointer,
      _id_getOutputStream as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getMetadata = _class.instanceMethodId(
    r'getMetadata',
    r'()Landroidx/camera/core/ImageCapture$Metadata;',
  );

  static final _getMetadata =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.ImageCapture$Metadata getMetadata()`
  /// The returned object must be released after use, by calling the [release] method.
  ImageCapture$Metadata getMetadata() {
    return _getMetadata(
      reference.pointer,
      _id_getMetadata as jni$_.JMethodIDPtr,
    ).object<ImageCapture$Metadata>(const $ImageCapture$Metadata$Type());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.JStringType());
  }
}

final class $ImageCapture$OutputFileOptions$NullableType
    extends jni$_.JObjType<ImageCapture$OutputFileOptions?> {
  @jni$_.internal
  const $ImageCapture$OutputFileOptions$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/camera/core/ImageCapture$OutputFileOptions;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OutputFileOptions? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : ImageCapture$OutputFileOptions.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OutputFileOptions?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OutputFileOptions$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OutputFileOptions$NullableType) &&
        other is $ImageCapture$OutputFileOptions$NullableType;
  }
}

final class $ImageCapture$OutputFileOptions$Type
    extends jni$_.JObjType<ImageCapture$OutputFileOptions> {
  @jni$_.internal
  const $ImageCapture$OutputFileOptions$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/camera/core/ImageCapture$OutputFileOptions;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OutputFileOptions fromReference(jni$_.JReference reference) =>
      ImageCapture$OutputFileOptions.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OutputFileOptions?> get nullableType =>
      const $ImageCapture$OutputFileOptions$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OutputFileOptions$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$OutputFileOptions$Type) &&
        other is $ImageCapture$OutputFileOptions$Type;
  }
}

/// from: `androidx.camera.core.ImageCapture$OutputFileResults`
class ImageCapture$OutputFileResults extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture$OutputFileResults> $type;

  @jni$_.internal
  ImageCapture$OutputFileResults.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/core/ImageCapture$OutputFileResults',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$OutputFileResults$NullableType();
  static const type = $ImageCapture$OutputFileResults$Type();
  static final _id_new$ = _class.constructorId(r'(Landroid/net/Uri;)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(android.net.Uri uri)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCapture$OutputFileResults(jni$_.JObject? uri) {
    final _$uri = uri?.reference ?? jni$_.jNullReference;
    return ImageCapture$OutputFileResults.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$uri.pointer,
      ).reference,
    );
  }

  static final _id_getSavedUri = _class.instanceMethodId(
    r'getSavedUri',
    r'()Landroid/net/Uri;',
  );

  static final _getSavedUri =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.net.Uri getSavedUri()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSavedUri() {
    return _getSavedUri(
      reference.pointer,
      _id_getSavedUri as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }
}

final class $ImageCapture$OutputFileResults$NullableType
    extends jni$_.JObjType<ImageCapture$OutputFileResults?> {
  @jni$_.internal
  const $ImageCapture$OutputFileResults$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/camera/core/ImageCapture$OutputFileResults;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OutputFileResults? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : ImageCapture$OutputFileResults.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OutputFileResults?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OutputFileResults$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($ImageCapture$OutputFileResults$NullableType) &&
        other is $ImageCapture$OutputFileResults$NullableType;
  }
}

final class $ImageCapture$OutputFileResults$Type
    extends jni$_.JObjType<ImageCapture$OutputFileResults> {
  @jni$_.internal
  const $ImageCapture$OutputFileResults$Type();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroidx/camera/core/ImageCapture$OutputFileResults;';

  @jni$_.internal
  @core$_.override
  ImageCapture$OutputFileResults fromReference(jni$_.JReference reference) =>
      ImageCapture$OutputFileResults.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture$OutputFileResults?> get nullableType =>
      const $ImageCapture$OutputFileResults$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$OutputFileResults$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$OutputFileResults$Type) &&
        other is $ImageCapture$OutputFileResults$Type;
  }
}

/// from: `androidx.camera.core.ImageCapture`
class ImageCapture extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCapture> $type;

  @jni$_.internal
  ImageCapture.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/core/ImageCapture',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCapture$NullableType();
  static const type = $ImageCapture$Type();

  /// from: `static public final int ERROR_UNKNOWN`
  static const ERROR_UNKNOWN = 0;

  /// from: `static public final int ERROR_FILE_IO`
  static const ERROR_FILE_IO = 1;

  /// from: `static public final int ERROR_CAPTURE_FAILED`
  static const ERROR_CAPTURE_FAILED = 2;

  /// from: `static public final int ERROR_CAMERA_CLOSED`
  static const ERROR_CAMERA_CLOSED = 3;

  /// from: `static public final int ERROR_INVALID_CAMERA`
  static const ERROR_INVALID_CAMERA = 4;

  /// from: `static public final int CAPTURE_MODE_MAXIMIZE_QUALITY`
  static const CAPTURE_MODE_MAXIMIZE_QUALITY = 0;

  /// from: `static public final int CAPTURE_MODE_MINIMIZE_LATENCY`
  static const CAPTURE_MODE_MINIMIZE_LATENCY = 1;

  /// from: `static public final int CAPTURE_MODE_ZERO_SHUTTER_LAG`
  static const CAPTURE_MODE_ZERO_SHUTTER_LAG = 2;

  /// from: `static public final int FLASH_MODE_AUTO`
  static const FLASH_MODE_AUTO = 0;

  /// from: `static public final int FLASH_MODE_ON`
  static const FLASH_MODE_ON = 1;

  /// from: `static public final int FLASH_MODE_OFF`
  static const FLASH_MODE_OFF = 2;

  /// from: `static public final int FLASH_TYPE_ONE_SHOT_FLASH`
  static const FLASH_TYPE_ONE_SHOT_FLASH = 0;

  /// from: `static public final int FLASH_TYPE_USE_TORCH_AS_FLASH`
  static const FLASH_TYPE_USE_TORCH_AS_FLASH = 1;
  static final _id_DEFAULT_CONFIG = _class.staticFieldId(
    r'DEFAULT_CONFIG',
    r'Landroidx/camera/core/ImageCapture$Defaults;',
  );

  /// from: `static public final androidx.camera.core.ImageCapture$Defaults DEFAULT_CONFIG`
  /// The returned object must be released after use, by calling the [release] method.
  static ImageCapture$Defaults? get DEFAULT_CONFIG => _id_DEFAULT_CONFIG.get(
    _class,
    const $ImageCapture$Defaults$NullableType(),
  );

  static final _id_getDefaultConfig = _class.instanceMethodId(
    r'getDefaultConfig',
    r'(ZLandroidx/camera/core/impl/UseCaseConfigFactory;)Landroidx/camera/core/impl/UseCaseConfig;',
  );

  static final _getDefaultConfig =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.impl.UseCaseConfig<?> getDefaultConfig(boolean z, androidx.camera.core.impl.UseCaseConfigFactory useCaseConfigFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getDefaultConfig(bool z, jni$_.JObject useCaseConfigFactory) {
    final _$useCaseConfigFactory = useCaseConfigFactory.reference;
    return _getDefaultConfig(
      reference.pointer,
      _id_getDefaultConfig as jni$_.JMethodIDPtr,
      z ? 1 : 0,
      _$useCaseConfigFactory.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getUseCaseConfigBuilder = _class.instanceMethodId(
    r'getUseCaseConfigBuilder',
    r'(Landroidx/camera/core/impl/Config;)Landroidx/camera/core/impl/UseCaseConfig$Builder;',
  );

  static final _getUseCaseConfigBuilder =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public androidx.camera.core.impl.UseCaseConfig$Builder<?, ?, ?> getUseCaseConfigBuilder(androidx.camera.core.impl.Config config)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getUseCaseConfigBuilder(jni$_.JObject config) {
    final _$config = config.reference;
    return _getUseCaseConfigBuilder(
      reference.pointer,
      _id_getUseCaseConfigBuilder as jni$_.JMethodIDPtr,
      _$config.pointer,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }

  static final _id_onCameraControlReady = _class.instanceMethodId(
    r'onCameraControlReady',
    r'()V',
  );

  static final _onCameraControlReady =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void onCameraControlReady()`
  void onCameraControlReady() {
    _onCameraControlReady(
      reference.pointer,
      _id_onCameraControlReady as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_getFlashMode = _class.instanceMethodId(
    r'getFlashMode',
    r'()I',
  );

  static final _getFlashMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getFlashMode()`
  int getFlashMode() {
    return _getFlashMode(
      reference.pointer,
      _id_getFlashMode as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_setFlashMode = _class.instanceMethodId(
    r'setFlashMode',
    r'(I)V',
  );

  static final _setFlashMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setFlashMode(int i)`
  void setFlashMode(int i) {
    _setFlashMode(
      reference.pointer,
      _id_setFlashMode as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setCropAspectRatio = _class.instanceMethodId(
    r'setCropAspectRatio',
    r'(Landroid/util/Rational;)V',
  );

  static final _setCropAspectRatio =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setCropAspectRatio(android.util.Rational rational)`
  void setCropAspectRatio(jni$_.JObject rational) {
    final _$rational = rational.reference;
    _setCropAspectRatio(
      reference.pointer,
      _id_setCropAspectRatio as jni$_.JMethodIDPtr,
      _$rational.pointer,
    ).check();
  }

  static final _id_getTargetRotation = _class.instanceMethodId(
    r'getTargetRotation',
    r'()I',
  );

  static final _getTargetRotation =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getTargetRotation()`
  int getTargetRotation() {
    return _getTargetRotation(
      reference.pointer,
      _id_getTargetRotation as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_setTargetRotation = _class.instanceMethodId(
    r'setTargetRotation',
    r'(I)V',
  );

  static final _setTargetRotation =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setTargetRotation(int i)`
  void setTargetRotation(int i) {
    _setTargetRotation(
      reference.pointer,
      _id_setTargetRotation as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_getCaptureMode = _class.instanceMethodId(
    r'getCaptureMode',
    r'()I',
  );

  static final _getCaptureMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getCaptureMode()`
  int getCaptureMode() {
    return _getCaptureMode(
      reference.pointer,
      _id_getCaptureMode as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getJpegQuality = _class.instanceMethodId(
    r'getJpegQuality',
    r'()I',
  );

  static final _getJpegQuality =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getJpegQuality()`
  int getJpegQuality() {
    return _getJpegQuality(
      reference.pointer,
      _id_getJpegQuality as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getResolutionInfo = _class.instanceMethodId(
    r'getResolutionInfo',
    r'()Landroidx/camera/core/ResolutionInfo;',
  );

  static final _getResolutionInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.ResolutionInfo getResolutionInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getResolutionInfo() {
    return _getResolutionInfo(
      reference.pointer,
      _id_getResolutionInfo as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getResolutionSelector = _class.instanceMethodId(
    r'getResolutionSelector',
    r'()Landroidx/camera/core/resolutionselector/ResolutionSelector;',
  );

  static final _getResolutionSelector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.resolutionselector.ResolutionSelector getResolutionSelector()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getResolutionSelector() {
    return _getResolutionSelector(
      reference.pointer,
      _id_getResolutionSelector as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_takePicture = _class.instanceMethodId(
    r'takePicture',
    r'(Ljava/util/concurrent/Executor;Landroidx/camera/core/ImageCapture$OnImageCapturedCallback;)V',
  );

  static final _takePicture =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void takePicture(java.util.concurrent.Executor executor, androidx.camera.core.ImageCapture$OnImageCapturedCallback onImageCapturedCallback)`
  void takePicture(
    Executor executor,
    ImageCapture$OnImageCapturedCallback onImageCapturedCallback,
  ) {
    final _$executor = executor.reference;
    final _$onImageCapturedCallback = onImageCapturedCallback.reference;
    _takePicture(
      reference.pointer,
      _id_takePicture as jni$_.JMethodIDPtr,
      _$executor.pointer,
      _$onImageCapturedCallback.pointer,
    ).check();
  }

  static final _id_takePicture$1 = _class.instanceMethodId(
    r'takePicture',
    r'(Landroidx/camera/core/ImageCapture$OutputFileOptions;Ljava/util/concurrent/Executor;Landroidx/camera/core/ImageCapture$OnImageSavedCallback;)V',
  );

  static final _takePicture$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void takePicture(androidx.camera.core.ImageCapture$OutputFileOptions outputFileOptions, java.util.concurrent.Executor executor, androidx.camera.core.ImageCapture$OnImageSavedCallback onImageSavedCallback)`
  void takePicture$1(
    ImageCapture$OutputFileOptions outputFileOptions,
    Executor executor,
    ImageCapture$OnImageSavedCallback onImageSavedCallback,
  ) {
    final _$outputFileOptions = outputFileOptions.reference;
    final _$executor = executor.reference;
    final _$onImageSavedCallback = onImageSavedCallback.reference;
    _takePicture$1(
      reference.pointer,
      _id_takePicture$1 as jni$_.JMethodIDPtr,
      _$outputFileOptions.pointer,
      _$executor.pointer,
      _$onImageSavedCallback.pointer,
    ).check();
  }

  static final _id_onStateDetached = _class.instanceMethodId(
    r'onStateDetached',
    r'()V',
  );

  static final _onStateDetached =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void onStateDetached()`
  void onStateDetached() {
    _onStateDetached(
      reference.pointer,
      _id_onStateDetached as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString>(const jni$_.JStringType());
  }

  static final _id_onUnbind = _class.instanceMethodId(r'onUnbind', r'()V');

  static final _onUnbind =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void onUnbind()`
  void onUnbind() {
    _onUnbind(reference.pointer, _id_onUnbind as jni$_.JMethodIDPtr).check();
  }

  static final _id_onBind = _class.instanceMethodId(r'onBind', r'()V');

  static final _onBind =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void onBind()`
  void onBind() {
    _onBind(reference.pointer, _id_onBind as jni$_.JMethodIDPtr).check();
  }

  static final _id_getSupportedEffectTargets = _class.instanceMethodId(
    r'getSupportedEffectTargets',
    r'()Ljava/util/Set;',
  );

  static final _getSupportedEffectTargets =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<java.lang.Integer> getSupportedEffectTargets()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JInteger?> getSupportedEffectTargets() {
    return _getSupportedEffectTargets(
      reference.pointer,
      _id_getSupportedEffectTargets as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JInteger?>>(
      const jni$_.JSetType<jni$_.JInteger?>(jni$_.JIntegerNullableType()),
    );
  }

  static final _id_getRealtimeCaptureLatencyEstimate = _class.instanceMethodId(
    r'getRealtimeCaptureLatencyEstimate',
    r'()Landroidx/camera/core/ImageCaptureLatencyEstimate;',
  );

  static final _getRealtimeCaptureLatencyEstimate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public androidx.camera.core.ImageCaptureLatencyEstimate getRealtimeCaptureLatencyEstimate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject getRealtimeCaptureLatencyEstimate() {
    return _getRealtimeCaptureLatencyEstimate(
      reference.pointer,
      _id_getRealtimeCaptureLatencyEstimate as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject>(const jni$_.JObjectType());
  }
}

final class $ImageCapture$NullableType extends jni$_.JObjType<ImageCapture?> {
  @jni$_.internal
  const $ImageCapture$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCapture;';

  @jni$_.internal
  @core$_.override
  ImageCapture? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ImageCapture.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$NullableType) &&
        other is $ImageCapture$NullableType;
  }
}

final class $ImageCapture$Type extends jni$_.JObjType<ImageCapture> {
  @jni$_.internal
  const $ImageCapture$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCapture;';

  @jni$_.internal
  @core$_.override
  ImageCapture fromReference(jni$_.JReference reference) =>
      ImageCapture.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCapture?> get nullableType =>
      const $ImageCapture$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCapture$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCapture$Type) &&
        other is $ImageCapture$Type;
  }
}

/// from: `androidx.camera.core.ImageCaptureException`
class ImageCaptureException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ImageCaptureException> $type;

  @jni$_.internal
  ImageCaptureException.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'androidx/camera/core/ImageCaptureException',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ImageCaptureException$NullableType();
  static const type = $ImageCaptureException$Type();
  static final _id_new$ = _class.constructorId(
    r'(ILjava/lang/String;Ljava/lang/Throwable;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(int i, java.lang.String string, java.lang.Throwable throwable)`
  /// The returned object must be released after use, by calling the [release] method.
  factory ImageCaptureException(
    int i,
    jni$_.JString string,
    jni$_.JObject? throwable,
  ) {
    final _$string = string.reference;
    final _$throwable = throwable?.reference ?? jni$_.jNullReference;
    return ImageCaptureException.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        i,
        _$string.pointer,
        _$throwable.pointer,
      ).reference,
    );
  }

  static final _id_getImageCaptureError = _class.instanceMethodId(
    r'getImageCaptureError',
    r'()I',
  );

  static final _getImageCaptureError =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getImageCaptureError()`
  int getImageCaptureError() {
    return _getImageCaptureError(
      reference.pointer,
      _id_getImageCaptureError as jni$_.JMethodIDPtr,
    ).integer;
  }
}

final class $ImageCaptureException$NullableType
    extends jni$_.JObjType<ImageCaptureException?> {
  @jni$_.internal
  const $ImageCaptureException$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCaptureException;';

  @jni$_.internal
  @core$_.override
  ImageCaptureException? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ImageCaptureException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCaptureException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCaptureException$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCaptureException$NullableType) &&
        other is $ImageCaptureException$NullableType;
  }
}

final class $ImageCaptureException$Type
    extends jni$_.JObjType<ImageCaptureException> {
  @jni$_.internal
  const $ImageCaptureException$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroidx/camera/core/ImageCaptureException;';

  @jni$_.internal
  @core$_.override
  ImageCaptureException fromReference(jni$_.JReference reference) =>
      ImageCaptureException.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ImageCaptureException?> get nullableType =>
      const $ImageCaptureException$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ImageCaptureException$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ImageCaptureException$Type) &&
        other is $ImageCaptureException$Type;
  }
}

/// from: `java.util.concurrent.Executor`
class Executor extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Executor> $type;

  @jni$_.internal
  Executor.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/util/concurrent/Executor');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Executor$NullableType();
  static const type = $Executor$Type();
  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'(Ljava/lang/Runnable;)V',
  );

  static final _execute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public abstract void execute(java.lang.Runnable runnable)`
  void execute(jni$_.JObject? runnable) {
    final _$runnable = runnable?.reference ?? jni$_.jNullReference;
    _execute(
      reference.pointer,
      _id_execute as jni$_.JMethodIDPtr,
      _$runnable.pointer,
    ).check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_.Map<int, $Executor> _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(0, descriptor.address, args.address),
    );
  }

  static final jni$_.Pointer<
    jni$_.NativeFunction<
      jni$_.JObjectPtr Function(jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)
    >
  >
  _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'execute(Ljava/lang/Runnable;)V') {
        _$impls[$p]!.execute(
          $a![0]?.as(const jni$_.JObjectType(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(jni$_.JImplementer implementer, $Executor $impl) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(r'java.util.concurrent.Executor', $p, _$invokePointer, [
      if ($impl.execute$async) r'execute(Ljava/lang/Runnable;)V',
    ]);
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory Executor.implement($Executor $impl) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return Executor.fromReference($i.implementReference());
  }
}

abstract base mixin class $Executor {
  factory $Executor({
    required void Function(jni$_.JObject? runnable) execute,
    bool execute$async,
  }) = _$Executor;

  void execute(jni$_.JObject? runnable);
  bool get execute$async => false;
}

final class _$Executor with $Executor {
  _$Executor({
    required void Function(jni$_.JObject? runnable) execute,
    this.execute$async = false,
  }) : _execute = execute;

  final void Function(jni$_.JObject? runnable) _execute;
  final bool execute$async;

  void execute(jni$_.JObject? runnable) {
    return _execute(runnable);
  }
}

final class $Executor$NullableType extends jni$_.JObjType<Executor?> {
  @jni$_.internal
  const $Executor$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/concurrent/Executor;';

  @jni$_.internal
  @core$_.override
  Executor? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Executor.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Executor?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Executor$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Executor$NullableType) &&
        other is $Executor$NullableType;
  }
}

final class $Executor$Type extends jni$_.JObjType<Executor> {
  @jni$_.internal
  const $Executor$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/concurrent/Executor;';

  @jni$_.internal
  @core$_.override
  Executor fromReference(jni$_.JReference reference) =>
      Executor.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Executor?> get nullableType => const $Executor$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Executor$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Executor$Type) && other is $Executor$Type;
  }
}
